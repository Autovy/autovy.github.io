<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/gear48.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gear32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="true"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"autovy.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Java|渐进式本地缓存开发总结">
<meta property="og:url" content="https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Autovy&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202205211137136.png">
<meta property="article:published_time" content="2022-04-20T15:45:00.000Z">
<meta property="article:modified_time" content="2022-10-27T07:56:48.928Z">
<meta property="article:author" content="Autovy">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="项目实战">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202205211137136.png">

<link rel="canonical" href="https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Java|渐进式本地缓存开发总结 | Autovy's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Autovy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Autovy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Just For Interest</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">72</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">54</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2.png">
      <meta itemprop="name" content="Autovy">
      <meta itemprop="description" content="新时代农民工的数字农田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Autovy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java|渐进式本地缓存开发总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022/04/20 23:45:00" itemprop="dateCreated datePublished" datetime="2022-04-20T23:45:00+08:00">2022/04/20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv_test" style="display: inline;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>65k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205211137136.png" alt="img"></p>
<span id="more"></span>

<h3 id="一-固定大小缓存实现"><a href="#一-固定大小缓存实现" class="headerlink" title="一.固定大小缓存实现"></a>一.固定大小缓存实现</h3><h4 id="缓存接口定义"><a href="#缓存接口定义" class="headerlink" title="缓存接口定义"></a>缓存接口定义</h4><p>为了兼容 Map，我们定义缓存接口继承自 Map 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><p>我们主要看一下 put 时的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 尝试驱除</span></span><br><span class="line">    CacheEvictContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheEvictContext&lt;&gt;();</span><br><span class="line">    context.key(key).size(sizeLimit).cache(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// context包含新的键和旧的缓存，放入驱除类中按规则淘汰</span></span><br><span class="line">    cacheEvict.evict(context);</span><br><span class="line">    <span class="comment">//2. 判断驱除后的信息</span></span><br><span class="line">    <span class="keyword">if</span>(isSizeLimit()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 执行添加</span></span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以让用户动态指定大小，但是指定大小肯就要有对应的淘汰策略。</p>
<p>否则，固定大小的 map 肯定无法放入元素。</p>
<h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>淘汰策略可以有多种，比如 LRU/LFU/FIFO 等等，我们此处实现一个最基本的 FIFO。</p>
<p>所有实现以接口的方式实现，便于后期灵活替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictFIFO</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * queue 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;K&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，执行移除</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            K evictKey = queue.remove();</span><br><span class="line">            <span class="comment">// 移除最开始的元素</span></span><br><span class="line">            cache.remove(evictKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新加的元素放入队尾</span></span><br><span class="line">        <span class="keyword">final</span> K key = context.key();</span><br><span class="line">        queue.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FIFO 比较简单，我们使用一个队列，存储每一次放入的元素，当队列超过最大限制时，删除最早的元素。</p>
<h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>为了便于用户使用，我们实现类似于 guava 的引导类。</p>
<p>所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存引导类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBs</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CacheBs</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建对象实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">CacheBs&lt;K,V&gt; <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheBs&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K,V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驱除策略默认设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">map</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">        ArgUtil.notNull(map, <span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 size 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">size</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArgUtil.notNegative(size, <span class="string">&quot;size&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置驱除策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict 驱除策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 0.0.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">evict</span><span class="params">(ICacheEvict&lt;K, V&gt; evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.evict = evict;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICache&lt;K,V&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheContext&lt;&gt;();</span><br><span class="line">        context.cacheEvict(evict);</span><br><span class="line">        context.map(map);</span><br><span class="line">        context.size(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cache&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">2</span>)</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>

<p>默认为先进先出的策略，此时输出 keys，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<h3 id="二-LRU缓存淘汰策略"><a href="#二-LRU缓存淘汰策略" class="headerlink" title="二.LRU缓存淘汰策略"></a>二.LRU缓存淘汰策略</h3><p>上面默认使用FIFO淘汰策略即先进先淘汰，下我们来开发LRU缓存淘汰策略即淘汰最近最少使用</p>
<h4 id="LRU基本原理"><a href="#LRU基本原理" class="headerlink" title="LRU基本原理"></a>LRU基本原理</h4><h5 id="1-LRU-是什么"><a href="#1-LRU-是什么" class="headerlink" title="1.LRU 是什么"></a>1.LRU 是什么</h5><p>LRU 是由 Least Recently Used 的首字母组成，表示最近最少使用的含义，一般使用在对象淘汰算法上。</p>
<p>也是比较常见的一种淘汰算法。</p>
<p>其核心思想是<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>。</p>
<h5 id="2-连续性"><a href="#2-连续性" class="headerlink" title="2.连续性"></a>2.连续性</h5><p>在计算机科学中，有一个指导准则：连续性准则。</p>
<p>时间连续性：对于信息的访问，最近被访问过，被再次访问的可能性会很高。缓存就是基于这个理念进行数据淘汰的。</p>
<p>空间连续性：对于磁盘信息的访问，将很有可能访问连续的空间信息。所以会有 page 预取来提升性能。</p>
<h5 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h5><ol>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<p>其实比较简单，比起 FIFO 的队列，我们引入一个链表实现即可。</p>
<h5 id="5-LRU实现步骤疑点"><a href="#5-LRU实现步骤疑点" class="headerlink" title="5.LRU实现步骤疑点"></a>5.LRU实现步骤疑点</h5><p>我们针对上面的 3 句话，逐句考虑一下，看看有没有值得优化点或者一些坑。</p>
<p><strong>如何判断是新数据？</strong></p>
<p><strong>新数据插入到链表头部；</strong></p>
<p>我们使用的是链表。</p>
<p>判断新数据最简单的方法就是遍历是否存在，对于链表，这是一个 O(n) 的时间复杂度。</p>
<p>其实性能还是比较差的。</p>
<p>当然也可以考虑空间换时间，比如引入一个 set 之类的，不过这样对空间的压力会加倍。</p>
<p><strong>什么是缓存命中</strong></p>
<p><strong>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</strong></p>
<p>put(key,value) 的情况，就是新元素。如果已有这个元素，可以先删除，再加入，参考上面的处理。</p>
<p>get(key) 的情况，对于元素访问，删除已有的元素，将新元素放在头部。</p>
<p>remove(key) 移除一个元素，直接删除已有元素。</p>
<p>keySet() valueSet() entrySet() 这些属于无差别访问，我们不对队列做调整。</p>
<p><strong>移除</strong></p>
<p><strong>当链表满的时候，将链表尾部的数据丢弃。</strong></p>
<p>链表满只有一种场景，那就是添加元素的时候，也就是执行 put(key, value) 的时候。</p>
<p>直接删除对应的 key 即可。</p>
<h4 id="Java-代码实现"><a href="#Java-代码实现" class="headerlink" title="Java 代码实现"></a>Java 代码实现</h4><h5 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1.接口定义"></a>1.接口定义</h5><p>和 FIFO 的接口保持一致，调用地方也不变</p>
<p>为了后续 LRU/LFU 实现，新增 remove/update 两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驱除策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否执行驱除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> ICacheEvictContext&lt;K, V&gt; context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-LRU-实现"><a href="#2-LRU-实现" class="headerlink" title="2.LRU 实现"></a>2.LRU 实现</h5><p>直接基于 LinkedList 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 丢弃策略-LRU 最近最少使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLRU</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLRU.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;K&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            K evictKey = list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 移除对应的元素</span></span><br><span class="line">            cache.remove(evictKey);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(key);</span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="number">0</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现比较简单，相对 FIFO 多了三个方法：</p>
<p>update()：我们做一点简化，认为只要是访问，就是删除，然后插入到队首。</p>
<p>remove()：删除就是直接删除。</p>
<p>这三个方法是用来更新最近使用情况的。</p>
<p>那什么时候调用呢？</p>
<h5 id="3-注解属性"><a href="#3-注解属性" class="headerlink" title="3.注解属性"></a>3.注解属性</h5><p>为了保证核心流程，我们基于注解实现。</p>
<p>添加属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否执行驱除更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 主要用于 LRU/LFU 等驱除策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">evict</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="4-注解使用"><a href="#4-注解使用" class="headerlink" title="4.注解使用"></a>4.注解使用</h5><p>有哪些方法需要使用？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(refresh = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(evict = true)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 刷新所有过期信息</span></span><br><span class="line">    K genericKey = (K) key;</span><br><span class="line">    <span class="keyword">this</span>.expire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-注解驱除拦截器实现"><a href="#5-注解驱除拦截器实现" class="headerlink" title="5.注解驱除拦截器实现"></a>5.注解驱除拦截器实现</h5><p>执行顺序：放在方法之后更新，不然每次当前操作的 key 都会被放在最前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 驱除策略拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptorEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheInterceptorEvict.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">        ICacheEvict&lt;K,V&gt; evict = context.cache().evict();</span><br><span class="line"></span><br><span class="line">        Method method = context.method();</span><br><span class="line">        <span class="keyword">final</span> K key = (K) context.params()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;remove&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            evict.remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            evict.update(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只对 remove 方法做下特判，其他方法都使用 update 更新信息。</p>
<p>参数直接取第一个参数。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line"></span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>

<ul>
<li>日志信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure>

<p>通过 removeListener 日志也可以看到 B 被移除了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">21</span>:<span class="number">33</span>:<span class="number">44.578</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key:</span><br></pre></td></tr></table></figure>



<h3 id="三-LRU缓存策略的优化"><a href="#三-LRU缓存策略的优化" class="headerlink" title="三.LRU缓存策略的优化"></a>三.LRU缓存策略的优化</h3><h4 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h4><h5 id="1-基于数组"><a href="#1-基于数组" class="headerlink" title="1.基于数组"></a>1.基于数组</h5><p>方案：为每一个数据附加一个额外的属性——时间戳，当每一次访问数据时，更新该数据的时间戳至当前时间。</p>
<p>当数据空间已满后，则扫描整个数组，淘汰时间戳最小的数据。</p>
<p>不足：维护时间戳需要耗费额外的空间，淘汰数据时需要扫描整个数组。</p>
<p>这个时间复杂度太差，空间复杂度也不好。</p>
<h5 id="2-基于长度有限的双向链表"><a href="#2-基于长度有限的双向链表" class="headerlink" title="2.基于长度有限的双向链表"></a>2.基于长度有限的双向链表</h5><p>方案：访问一个数据时，当数据不在链表中，则将数据插入至链表头部，如果在链表中，则将该数据移至链表头部。当数据空间已满后，则淘汰链表最末尾的数据。</p>
<p>不足：插入数据或取数据时，需要扫描整个链表。</p>
<p>这个就是我们上一节实现的方式，缺点还是很明显，每次确认元素是否存在，都要消耗 O(n) 的时间复杂度去查询。</p>
<h5 id="3-基于双向链表和哈希表"><a href="#3-基于双向链表和哈希表" class="headerlink" title="3.基于双向链表和哈希表"></a>3.基于双向链表和哈希表</h5><p>方案：为了改进上面需要扫描链表的缺陷，配合哈希表，将数据和链表中的节点形成映射，将插入操作和读取操作的时间复杂度从O(N)降至O(1)</p>
<p>缺点：这个使我们上一节提到的优化思路，不过还是有缺点的，那就是空间复杂度翻倍。</p>
<h5 id="4-数据结构的选择总结"><a href="#4-数据结构的选择总结" class="headerlink" title="4.数据结构的选择总结"></a>4.数据结构的选择总结</h5><p>（1）基于数组的实现</p>
<p>这里不建议选择 array 或者 ArrayList，因为读取的时间复杂度为 O(1)，但是更新相对是比较慢的，虽然 jdk 使用的是 System.arrayCopy。</p>
<p>（2）基于双向链表的实现</p>
<p>如果我们选择链表，HashMap 中还是不能简单的存储 key, 和对应的下标。</p>
<p>因为链表的遍历，实际上还是 O(n) 的，双向链表理论上可以优化一半，但是这并不是我们想要的 O(1) 效果。</p>
<p>（3）基于双向链表 + Map实现</p>
<p>双向链表我们保持不变。</p>
<p>Map 中 key 对应的值我们放双向链表的节点信息。</p>
<p>那实现方式就变成了实现一个双向链表。</p>
<h4 id="基于自定义双向链表实现"><a href="#基于自定义双向链表实现" class="headerlink" title="基于自定义双向链表实现"></a>基于自定义双向链表实现</h4><h5 id="1-节点定义"><a href="#1-节点定义" class="headerlink" title="1.节点定义"></a>1.节点定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fluent get &amp; set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-核心代码实现"><a href="#2-核心代码实现" class="headerlink" title="2.核心代码实现"></a>2.核心代码实现</h5><p>我们保持和原来的接口不变，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLruDoubleListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLruDoubleListMap.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLruDoubleListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">            DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">            <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            K evictKey = tailPre.key();</span><br><span class="line">            V evictValue = cache.remove(evictKey);</span><br><span class="line">            result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行删除</span></span><br><span class="line">        <span class="keyword">this</span>.remove(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 新元素插入到头部</span></span><br><span class="line">        <span class="comment">//head&lt;-&gt;next</span></span><br><span class="line">        <span class="comment">//变成：head&lt;-&gt;new&lt;-&gt;next</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; newNode = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        newNode.key(key);</span><br><span class="line"></span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = <span class="keyword">this</span>.head.next();</span><br><span class="line">        <span class="keyword">this</span>.head.next(newNode);</span><br><span class="line">        newNode.pre(<span class="keyword">this</span>.head);</span><br><span class="line">        next.pre(newNode);</span><br><span class="line">        newNode.next(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 插入到 map 中</span></span><br><span class="line">        indexMap.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment">     * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment">     * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment">     * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        DoubleListNode&lt;K,V&gt; node = indexMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 list node</span></span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line"></span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.indexMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现起来不难，就是一个简易版本的双向列表。</p>
<p>只是获取节点的时候，借助了一下 map，让时间复杂度降低为 O(1)。</p>
<h5 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p>我们验证一下自己的实现：</p>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lruDoubleListMap())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>



<p><strong>日志</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> 09:<span class="number">37</span>:<span class="number">41.007</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure>

<p>因为我们访问过一次 A，所以 B 已经变成最少被访问的元素。</p>
<h4 id="基于-LinkedHashMap-实现"><a href="#基于-LinkedHashMap-实现" class="headerlink" title="基于 LinkedHashMap 实现"></a>基于 LinkedHashMap 实现</h4><p>实际上，LinkedHashMap 本身就是对于 list 和 hashMap 的一种结合的数据结构，我们可以直接使用 jdk 中 LinkedHashMap 去实现。</p>
<h5 id="1-直接实现"><a href="#1-直接实现" class="headerlink" title="1.直接实现"></a>1.直接实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里将LinkedHashMap的accessOrder设为true</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt;= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认LinkedHashMap并不会淘汰数据，所以我们重写了它的removeEldestEntry()方法，当数据数量达到预设上限后，淘汰数据，accessOrder设为true意为按照访问的顺序排序。</p>
<p>整个实现的代码量并不大，主要都是应用LinkedHashMap的特性。</p>
<h5 id="2-简单改造"><a href="#2-简单改造" class="headerlink" title="2.简单改造"></a>2.简单改造</h5><p>我们对这个方法简单改造下，让其适应我们定义的接口。</p>
<h5 id="3-测试结果-1"><a href="#3-测试结果-1" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lruLinkedHashMap())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>



<p><strong>日志</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">57.842</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure>



<h4 id="LRU扩展算法"><a href="#LRU扩展算法" class="headerlink" title="LRU扩展算法"></a>LRU扩展算法</h4><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p>
<h5 id="1-LRU-K"><a href="#1-LRU-K" class="headerlink" title="1. LRU-K"></a>1. LRU-K</h5><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。</p>
<p>当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>数据第一次被访问时，加入到历史访问列表，如果数据在访问历史列表中没有达到K次访问，则按照一定的规则（FIFO,LRU）淘汰；</p>
<p>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列中删除，将数据移到缓存队列中，并缓存数据，缓存队列重新按照时间排序；</p>
<p>缓存数据队列中被再次访问后，重新排序，需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即“淘汰倒数K次访问离现在最久的数据”。</p>
<p>LRU-K具有LRU的优点，同时还能避免LRU的缺点，实际应用中LRU-2是综合最优的选择。</p>
<p>由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多。</p>
<h5 id="2-two-queue"><a href="#2-two-queue" class="headerlink" title="2. two queue"></a>2. two queue</h5><p>Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p>
<p>当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。</p>
<p>新访问的数据插入到FIFO队列中，如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>如果数据在FIFO队列中再次被访问到，则将数据移到LRU队列头部，如果数据在LRU队列中再次被访问，则将数据移动LRU队列头部，LRU队列淘汰末尾的数据。</p>
<h5 id="3-Multi-Queue-MQ"><a href="#3-Multi-Queue-MQ" class="headerlink" title="3. Multi Queue(MQ)"></a>3. Multi Queue(MQ)</h5><p>MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：<strong>优先缓存访问次数多的数据</strong>。</p>
<p>详细的算法结构图如下，Q0，Q1….Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列：</p>
<p>新插入的数据放入Q0，每个队列按照LRU进行管理，当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列中删除，加入到高一级队列的头部；为了防止高优先级数据永远不会被淘汰，当数据在指定的时间里没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；需要淘汰数据时，从最低一级队列开始按照LRU淘汰，每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部。</p>
<p>如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列头部。</p>
<p>Q-history按照LRU淘汰数据的索引。</p>
<p>MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。</p>
<h5 id="4-LRU算法对比"><a href="#4-LRU算法对比" class="headerlink" title="4.LRU算法对比"></a>4.LRU算法对比</h5><table>
<thead>
<tr>
<th align="left">对比点</th>
<th align="left">对比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">命中率</td>
<td align="left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td align="left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td>
</tr>
<tr>
<td align="left">代价</td>
<td align="left">LRU-2  &gt; MQ(2) &gt; 2Q &gt; LRU</td>
</tr>
</tbody></table>
<p>实际上上面的几个算法，思想上大同小异。</p>
<p>核心目的：解决批量操作导致热点数据失效，缓存被污染的问题。</p>
<p>实现方式：增加一个队列，用来保存只访问一次的数据，然后根据次数不同，放入到 LRU 中。</p>
<p>只访问一次的队列，可以是 FIFO 队列，可以是 LRU，我们来实现一下 2Q 和 LRU-2 两种实现。</p>
<h4 id="2Q算法实现"><a href="#2Q算法实现" class="headerlink" title="2Q算法实现"></a>2Q算法实现</h4><h5 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h5><p>实际上就是我们以前的 FIFO + LRU 二者的结合。</p>
<h5 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2.基本属性"></a>2.基本属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLru2Q</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLru2Q.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小限制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 降低 O(n) 的消耗，避免耗时过长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT_QUEUE_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次访问的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;K&gt; firstQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; lruIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLru2Q</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.lruIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-数据淘汰"><a href="#3-数据淘汰" class="headerlink" title="3.数据淘汰"></a>3.数据淘汰</h5><p>数据淘汰的逻辑：</p>
<p>当缓存大小，已经达到最大限制时执行：</p>
<p>（1）优先淘汰 firstQueue 中的数据</p>
<p>（2）如果 firstQueue 中数据为空，则淘汰 lruMap 中的数据信息。</p>
<p>这里有一个假设：我们认为被多次访问的数据，重要性高于被只访问了一次的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">    ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">    <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">        K evictKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. firstQueue 不为空，优先移除队列中元素</span></span><br><span class="line">        <span class="keyword">if</span>(!firstQueue.isEmpty()) &#123;</span><br><span class="line">            evictKey = firstQueue.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">            DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">            <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            evictKey = tailPre.key();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行移除操作</span></span><br><span class="line">        V evictValue = cache.remove(evictKey);</span><br><span class="line">        result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-数据删除"><a href="#4-数据删除" class="headerlink" title="4.数据删除"></a>4.数据删除</h5><p>当数据被删除时调用：</p>
<p>这个逻辑和以前类似，只是多了一个 FIFO 队列的移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment"> * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment"> * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment"> * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    DoubleListNode&lt;K,V&gt; node = lruIndexMap.get(key);</span><br><span class="line">    <span class="comment">//1. LRU 删除逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isNotNull(node)) &#123;</span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.lruIndexMap.remove(node.key());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. FIFO 删除逻辑（O(n) 时间复杂度）</span></span><br><span class="line">        firstQueue.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-数据的更新"><a href="#5-数据的更新" class="headerlink" title="5.数据的更新"></a>5.数据的更新</h5><p>当数据被访问时，提升数据的优先级。</p>
<p>（1）如果在 lruMap 中，则首先移除，然后放入到头部</p>
<p>（2）如果不在 lruMap 中，但是在 FIFO 队列，则从 FIFO 队列中移除，添加到 LRU map 中。</p>
<p>（3）如果都不在，直接加入到 FIFO 队列中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放入元素</span></span><br><span class="line"><span class="comment"> * 1. 如果 lruIndexMap 已经存在，则处理 lru 队列，先删除，再插入。</span></span><br><span class="line"><span class="comment"> * 2. 如果 firstQueue 中已经存在，则处理 first 队列，先删除 firstQueue，然后插入 Lru。</span></span><br><span class="line"><span class="comment"> * 1 和 2 是不同的场景，但是代码实际上是一样的，删除逻辑中做了二种场景的兼容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 如果不在1、2中，说明是新元素，直接插入到 firstQueue 的开始即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 是否在 LRU MAP 中</span></span><br><span class="line">    <span class="comment">//1.2 是否在 firstQueue 中</span></span><br><span class="line">    DoubleListNode&lt;K,V&gt; node = lruIndexMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isNotNull(node)</span><br><span class="line">        || firstQueue.contains(key)) &#123;</span><br><span class="line">        <span class="comment">//1.3 删除信息</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line">        <span class="comment">//1.4 加入到 LRU 中</span></span><br><span class="line">        <span class="keyword">this</span>.addToLruMapHead(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 直接加入到 firstQueue 队尾</span></span><br><span class="line">    <span class="comment">//        if(firstQueue.size() &gt;= LIMIT_QUEUE_SIZE) &#123;</span></span><br><span class="line"><span class="comment">//            // 避免第一次访问的列表一直增长，移除队头的元素</span></span><br><span class="line"><span class="comment">//            firstQueue.remove();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    firstQueue.add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我想到了一个优化点，限制 firstQueue 的一直增长，因为遍历的时间复杂度为 O(n)，所以限制最大的大小为 1024。</p>
<p>如果超过了，则把 FIFO 中的元素先移除掉。</p>
<p>不过只移除 FIFO，不移除 cache，会导致二者的活跃程度不一致；</p>
<p>如果同时移除，但是 cache 的大小还没有满足，可能会导致超出用户的预期，这个可以作为一个优化点，暂时注释掉。</p>
<h5 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h5><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru2Q())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>



<p><strong>效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">13</span>:<span class="number">15</span>:<span class="number">50.670</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure>



<h4 id="LRU-2算法实现"><a href="#LRU-2算法实现" class="headerlink" title="LRU-2算法实现"></a>LRU-2算法实现</h4><h5 id="1-实现LRU简介"><a href="#1-实现LRU简介" class="headerlink" title="1.实现LRU简介"></a>1.实现LRU简介</h5><p>FIFO 中的缺点还是比较明显的，需要 O(n) 的时间复杂度做遍历。</p>
<p>而且命中率和 LRU-2 比起来还是会差一点。</p>
<p>这里 LRU map 出现了多次，我们为了方便，将 LRU map 简单的封装为一个数据结构。</p>
<p>我们使用双向链表+HashMap 实现一个简单版本的。</p>
<h5 id="2-节点"><a href="#2-节点" class="headerlink" title="2.节点"></a>2.节点</h5><p>node 节点和以前一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fluent getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h5><p>我们根据自己的需要，暂时定义 3 个最重要的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU map 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILruMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除最老的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的明细</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICacheEntry&lt;K, V&gt; <span class="title">removeEldest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 key 的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除对应的 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h5><p>我们基于 DoubleLinkedList + HashMap 实现。</p>
<p>就是把上一节中的实现整理一下即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于双向列表的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMapDoubleList</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ILruMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(LruMapDoubleList.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruMapDoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICacheEntry&lt;K, V&gt; <span class="title">removeEldest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">        <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        K evictKey = tailPre.key();</span><br><span class="line">        V evictValue = tailPre.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CacheEntry.of(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行删除</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 新元素插入到头部</span></span><br><span class="line">        <span class="comment">//head&lt;-&gt;next</span></span><br><span class="line">        <span class="comment">//变成：head&lt;-&gt;new&lt;-&gt;next</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; newNode = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        newNode.key(key);</span><br><span class="line"></span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = <span class="keyword">this</span>.head.next();</span><br><span class="line">        <span class="keyword">this</span>.head.next(newNode);</span><br><span class="line">        newNode.pre(<span class="keyword">this</span>.head);</span><br><span class="line">        next.pre(newNode);</span><br><span class="line">        newNode.next(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 插入到 map 中</span></span><br><span class="line">        indexMap.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment">     * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment">     * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment">     * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        DoubleListNode&lt;K,V&gt; node = indexMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 list node</span></span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line"></span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.indexMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexMap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-基本属性"><a href="#5-基本属性" class="headerlink" title="5.基本属性"></a>5.基本属性</h5><p>LRU 的实现保持不变。我们直接将 FIFO 替换为 LRU map 即可。</p>
<p>为了便于理解，我们将 FIFO 对应为 firstLruMap，用来存放用户只访问了一次的元素。</p>
<p>将原来的 LRU 中存入访问了 2 次及其以上的元素。</p>
<p>其他逻辑和 2Q 保持一致。</p>
<p>定义两个 LRU，用来分别存储访问的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLru2</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLru2.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次访问的 lru</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILruMap&lt;K,V&gt; firstLruMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2次及其以上的 lru</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILruMap&lt;K,V&gt; moreLruMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLru2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstLruMap = <span class="keyword">new</span> LruMapDoubleList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.moreLruMap = <span class="keyword">new</span> LruMapDoubleList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-淘汰实现"><a href="#6-淘汰实现" class="headerlink" title="6.淘汰实现"></a>6.淘汰实现</h5><p>和 lru 2Q 模式类似，这里我们优先淘汰 firstLruMap 中的数据信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">    ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">    <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">        ICacheEntry&lt;K,V&gt;  evictEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. firstLruMap 不为空，优先移除队列中元素</span></span><br><span class="line">        <span class="keyword">if</span>(!firstLruMap.isEmpty()) &#123;</span><br><span class="line">            evictEntry = firstLruMap.removeEldest();</span><br><span class="line">            log.debug(<span class="string">&quot;从 firstLruMap 中淘汰数据：&#123;&#125;&quot;</span>, evictEntry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 否则从 moreLruMap 中淘汰数据</span></span><br><span class="line">            evictEntry = moreLruMap.removeEldest();</span><br><span class="line">            log.debug(<span class="string">&quot;从 moreLruMap 中淘汰数据：&#123;&#125;&quot;</span>, evictEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行缓存移除操作</span></span><br><span class="line">        <span class="keyword">final</span> K evictKey = evictEntry.key();</span><br><span class="line">        V evictValue = cache.remove(evictKey);</span><br><span class="line">        result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-删除"><a href="#7-删除" class="headerlink" title="7.删除"></a>7.删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 多次 lru 中存在，删除</span></span><br><span class="line"><span class="comment"> * 2. 初次 lru 中存在，删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 多次LRU 删除逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(moreLruMap.contains(key)) &#123;</span><br><span class="line">        moreLruMap.removeKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 从 moreLruMap 中移除&quot;</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLruMap.removeKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 从 firstLruMap 中移除&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-更新"><a href="#8-更新" class="headerlink" title="8.更新"></a>8.更新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新信息</span></span><br><span class="line"><span class="comment"> * 1. 如果 moreLruMap 已经存在，则处理 more 队列，先删除，再插入。</span></span><br><span class="line"><span class="comment"> * 2. 如果 firstLruMap 中已经存在，则处理 first 队列，先删除 firstLruMap，然后插入 Lru。</span></span><br><span class="line"><span class="comment"> * 1 和 2 是不同的场景，但是代码实际上是一样的，删除逻辑中做了二种场景的兼容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 如果不在1、2中，说明是新元素，直接插入到 firstLruMap 的开始即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 元素已经在多次访问，或者第一次访问的 lru 中</span></span><br><span class="line">    <span class="keyword">if</span>(moreLruMap.contains(key)</span><br><span class="line">        || firstLruMap.contains(key)) &#123;</span><br><span class="line">        <span class="comment">//1.1 删除信息</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line">        <span class="comment">//1.2 加入到多次 LRU 中</span></span><br><span class="line">        moreLruMap.updateKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 多次访问，加入到 moreLruMap 中&quot;</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 加入到第一次访问 LRU 中</span></span><br><span class="line">        firstLruMap.updateKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 为第一次访问，加入到 firstLruMap 中&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上使用 LRU-2 的代码逻辑反而变得清晰了一些，主要是因为我们把 lruMap 作为独立的数据结构抽离了出去</p>
<h5 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h5><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru2Q())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>



<p><strong>日志</strong></p>
<p>为了便于定位分析，源代码实现的时候，加了一点日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.966</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: A 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.967</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: B 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.968</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: C 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.970</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.removeKey] - key: A 从 firstLruMap 中移除</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.970</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: A 多次访问，加入到 moreLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.972</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.doEvict] - 从 firstLruMap 中淘汰数据：EvictEntry&#123;key=B, value=<span class="keyword">null</span>&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.974</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.974</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: D 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure>



<h5 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h5><p>对于 LRU 算法的改进我们主要做了两点：</p>
<p>（1）性能的改进，从 O(N) 优化到 O(1)</p>
<p>（2）批量操作的改进，避免缓存污染</p>
<h3 id="四-过期功能的实现"><a href="#四-过期功能的实现" class="headerlink" title="四.过期功能的实现"></a>四.过期功能的实现</h3><h4 id="缓存接口定义-1"><a href="#缓存接口定义-1" class="headerlink" title="缓存接口定义"></a>缓存接口定义</h4><p>我们首先来定义一下接口。</p>
<p>主要有两个：一个是多久之后过期，一个是在什么时候过期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> timeInMills)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的时间过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeInMills 时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> timeInMills)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="缓存接口实现"><a href="#缓存接口实现" class="headerlink" title="缓存接口实现"></a>缓存接口实现</h4><p>为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。</p>
<p>核心的代码，主要还是看 cacheExpire 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireTime = System.currentTimeMillis() + timeInMills;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.expireAt(key, expireTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheExpire.expire(key, timeInMills);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="缓存过期接口"><a href="#缓存过期接口" class="headerlink" title="缓存过期接口"></a>缓存过期接口</h4><p>这里为了便于后期拓展，对于过期的处理定义为接口，便于后期灵活替换</p>
<p>其中 <code>expire(final K key, final long expireAt);</code> 就是我们方法中调用的地方。</p>
<p>refershExpire 属于惰性删除，需要进行刷新时才考虑，我们后面讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheExpire</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定过期信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireAt 什么时候过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expire</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> expireAt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 惰性删除中需要处理的 keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyList keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(<span class="keyword">final</span> Collection&lt;K&gt; keyList)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="expire-实现原理"><a href="#expire-实现原理" class="headerlink" title="expire 实现原理"></a>expire 实现原理</h4><p>其实过期的实思路也比较简单：我们可以开启一个定时任务，比如 1 秒钟做一次轮训，将过期的信息清空。</p>
<h5 id="1-过期信息的存储"><a href="#1-过期信息的存储" class="headerlink" title="1.过期信息的存储"></a>1.过期信息的存储</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过期 map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 空间换时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Long&gt; expireMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> expireAt)</span> </span>&#123;</span><br><span class="line">    expireMap.put(key, expireAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个 map，key 是对应的要过期的信息，value 存储的是过期时间。</p>
<h5 id="2-轮询清理"><a href="#2-轮询清理" class="headerlink" title="2.轮询清理"></a>2.轮询清理</h5><p>我们固定 100ms 清理一次，每次最多清理 100 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单次清空的数量限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheExpire</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> ExpireThread(), <span class="number">100</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个单线程，用于执行清空任务。</p>
<h5 id="3-清空任务"><a href="#3-清空任务" class="headerlink" title="3.清空任务"></a>3.清空任务</h5><p>这个非常简单，遍历过期数据，判断对应的时间，如果已经到期了，则执行清空操作。</p>
<p>为了避免单次执行时间过长，最多只处理 100 条</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(MapUtil.isEmpty(expireMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取 key 进行处理</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= LIMIT) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expireKey(entry);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行过期操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entry 明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expireKey</span><span class="params">(Map.Entry&lt;K, Long&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key = entry.getKey();</span><br><span class="line">    <span class="keyword">final</span> Long expireAt = entry.getValue();</span><br><span class="line">    <span class="comment">// 删除的逻辑处理</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class="line">        expireMap.remove(key);</span><br><span class="line">        <span class="comment">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><h5 id="1-出现的原因"><a href="#1-出现的原因" class="headerlink" title="1.出现的原因"></a>1.出现的原因</h5><p>类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。</p>
<p>那当我们查询时，可能获取到到是脏数据。</p>
<p>于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。</p>
<p>算是一种折中方案。</p>
<h5 id="2-需要惰性删除的方法"><a href="#2-需要惰性删除的方法" class="headerlink" title="2.需要惰性删除的方法"></a>2.需要惰性删除的方法</h5><p>一般就是各种查询方法，比如我们获取 key 对应的值时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 刷新所有过期信息</span></span><br><span class="line">    K genericKey = (K) key;</span><br><span class="line">    <span class="keyword">this</span>.cacheExpire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在获取之前，先做一次数据的刷新。</p>
<h5 id="3-刷新的实现"><a href="#3-刷新的实现" class="headerlink" title="3.刷新的实现"></a>3.刷新的实现</h5><p>实现原理也非常简单，就是一个循环，然后作删除即可。</p>
<p>这里加了一个小的优化：选择数量少的作为外循环。</p>
<p>循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(Collection&lt;K&gt; keyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断大小，小的作为外循环。一般都是过期的 keys 比较小。</span></span><br><span class="line">    <span class="keyword">if</span>(keyList.size() &lt;= expireMap.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : keyList) &#123;</span><br><span class="line">            expireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.expireKey(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>上面的代码写完之后，我们就可以验证一下了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.expire(<span class="string">&quot;1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line"></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, cache.size());</span><br><span class="line"></span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>

<p>结果也符合我们的预期</p>
<h3 id="五-过期功能的优化"><a href="#五-过期功能的优化" class="headerlink" title="五.过期功能的优化"></a>五.过期功能的优化</h3><p>上面的过期功能的实现中存在两个问题：</p>
<p>（1）keys 的选择不够随机，可能会导致每次循环 100 个结束时，真正需要过期的没有被遍历到</p>
<p>（2）keys 的遍历可能大部分都是无效的</p>
<p>所以下面以过期时间为维度对过期功能进行优化</p>
<h4 id="基于时间的遍历"><a href="#基于时间的遍历" class="headerlink" title="基于时间的遍历"></a>基于时间的遍历</h4><h5 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h5><p>我们换一种思路，让过期的时间做 key，相同时间的需要过期的信息放在一个列表中，作为 value</p>
<p>然后对过期时间排序，轮询的时候就可以快速判断出是否有过期的信息了。</p>
<p>我们每次 put 放入过期元素时，根据过期时间对元素进行排序，相同的过期时间的 Keys 放在一起。</p>
<p>优点：定时遍历的时候，如果时间不到当前时间，就可以直接返回了，大大降低无效遍历。</p>
<p>缺点：考虑到惰性删除问题，还是需要存储以删除信息作为 key 的 map 关系，这样内存基本翻倍。</p>
<h5 id="2-基本属性定义"><a href="#2-基本属性定义" class="headerlink" title="2.基本属性定义"></a>2.基本属性定义</h5><p>我们这里使用 <code>TreeMap</code> 帮助我们进行过期时间的排序，这个集合后续有时间可以详细讲解了，我大概看了下 jdk1.8 的源码，主要是通过红黑树实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheExpireSort</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheExpire</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单次清空的数量限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序缓存存储</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用按照时间排序的缓存处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, List&lt;K&gt;&gt; sortMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (o1 - o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期 map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间换时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Long&gt; expireMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-放入元素时"><a href="#3-放入元素时" class="headerlink" title="3.放入元素时"></a>3.放入元素时</h5><p>每次存入新元素时，同时放入 sortMap 和 expireMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> expireAt)</span> </span>&#123;</span><br><span class="line">    List&lt;K&gt; keys = sortMap.get(expireAt);</span><br><span class="line">    <span class="keyword">if</span>(keys == <span class="keyword">null</span>) &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    keys.add(key);</span><br><span class="line">    <span class="comment">// 设置对应的信息</span></span><br><span class="line">    sortMap.put(expireAt, keys);</span><br><span class="line">    expireMap.put(key, expireAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定时任务的执行"><a href="#定时任务的执行" class="headerlink" title="定时任务的执行"></a>定时任务的执行</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><p>我们定义一个定时任务，100ms 执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheExpireSort</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> ExpireThread(), <span class="number">100</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-执行任务"><a href="#2-执行任务" class="headerlink" title="2.执行任务"></a>2.执行任务</h5><p>实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(MapUtil.isEmpty(sortMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取 key 进行处理</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Long, List&lt;K&gt;&gt; entry : sortMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Long expireAt = entry.getKey();</span><br><span class="line">            List&lt;K&gt; expireKeys = entry.getValue();</span><br><span class="line">            <span class="comment">// 判断队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(CollectionUtil.isEmpty(expireKeys)) &#123;</span><br><span class="line">                sortMap.remove(expireAt);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= LIMIT) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除的逻辑处理</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class="line">                Iterator&lt;K&gt; iterator = expireKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    K key = iterator.next();</span><br><span class="line">                    <span class="comment">// 先移除本身</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    expireMap.remove(key);</span><br><span class="line">                    <span class="comment">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class="line">                    cache.remove(key);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接跳过，没有过期的信息</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接遍历 sortMap，对应的 key 就是过期时间，然后和当前时间对比即可。</p>
<p>删除的时候，需要删除 expireMap/sortMap/cache。</p>
<h4 id="惰性删除刷新"><a href="#惰性删除刷新" class="headerlink" title="惰性删除刷新"></a>惰性删除刷新</h4><p>惰性删除刷新时，就会用到 expireMap。</p>
<p>因为有时候刷新的 key 就一个，如果没有 expireMap 映射关系，可能要把 sortMap 全部遍历一遍才能找到对应的过期时间。</p>
<p>就是一个时间复杂度与空间复杂度衡量的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(Collection&lt;K&gt; keyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历判断过期信息</span></span><br><span class="line">    <span class="comment">// 这样维护两套的代价太大，后续优化，暂时不用。</span></span><br><span class="line">    <span class="comment">// 判断大小，小的作为外循环</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expireSize = expireMap.size();</span><br><span class="line">    <span class="keyword">if</span>(expireSize &lt;= keyList.size()) &#123;</span><br><span class="line">        <span class="comment">// 一般过期的数量都是较少的</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            <span class="comment">// 这里直接执行过期处理，不再判断是否存在于集合中。</span></span><br><span class="line">            <span class="comment">// 因为基于集合的判断，时间复杂度为 O(n)</span></span><br><span class="line">            <span class="keyword">this</span>.removeExpireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : keyList) &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeExpireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除过期信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeExpireKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    Long expireTime = expireMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(expireTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(currentTime &gt;= expireTime) &#123;</span><br><span class="line">            expireMap.remove(key);</span><br><span class="line">            List&lt;K&gt; expireKeys = sortMap.get(expireTime);</span><br><span class="line">            expireKeys.remove(key);</span><br><span class="line">            sortMap.put(expireTime, expireKeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六-RBD持久化功能的实现"><a href="#六-RBD持久化功能的实现" class="headerlink" title="六.RBD持久化功能的实现"></a>六.RBD持久化功能的实现</h3><p>缓存的持久化功能分为以下两个部分：</p>
<ul>
<li>Cache 的内容持久化到文件或者数据库</li>
<li>初始化的时候加载持久化数据</li>
</ul>
<h4 id="持久化操作"><a href="#持久化操作" class="headerlink" title="持久化操作"></a>持久化操作</h4><h5 id="1-持久化操作接口"><a href="#1-持久化操作接口" class="headerlink" title="1.持久化操作接口"></a>1.持久化操作接口</h5><p>为了便于灵活替换，我们定义一个持久化的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-持久化操作接口实现"><a href="#2-持久化操作接口实现" class="headerlink" title="2.持久化操作接口实现"></a>2.持久化操作接口实现</h5><p>我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePersistDbJson</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachePersistDbJson</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化</span></span><br><span class="line"><span class="comment">     * key长度 key+value</span></span><br><span class="line"><span class="comment">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = cache.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        FileUtil.createFile(dbPath);</span><br><span class="line">        <span class="comment">// 清空文件</span></span><br><span class="line">        FileUtil.truncate(dbPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry : entrySet) &#123;</span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            Long expireTime = cache.expire().expireTime(key);</span><br><span class="line">            <span class="comment">// 填充持久化数据</span></span><br><span class="line">            PersistEntry&lt;K,V&gt; persistEntry = <span class="keyword">new</span> PersistEntry&lt;&gt;();</span><br><span class="line">            persistEntry.setKey(key);</span><br><span class="line">            persistEntry.setValue(entry.getValue());</span><br><span class="line">            persistEntry.setExpire(expireTime);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 持久化数据转换为JSON数据</span></span><br><span class="line">            String line = JSON.toJSONString(persistEntry);</span><br><span class="line">            <span class="comment">// JSON数据追加到文件中</span></span><br><span class="line">            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-持久化操作的触发"><a href="#3-持久化操作的触发" class="headerlink" title="3.持久化操作的触发"></a>3.持久化操作的触发</h5><p>上面定义好了一种持久化的策略，但是没有提供对应的触发方式。</p>
<p>我们就采用对用户透明的设计方式：定时执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerCachePersist</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(InnerCachePersist.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存持久化策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICachePersist&lt;K,V&gt; persist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程执行类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerCachePersist</span><span class="params">(ICache&lt;K, V&gt; cache, ICachePersist&lt;K, V&gt; persist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">        <span class="keyword">this</span>.persist = persist;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;开始持久化缓存信息&quot;</span>);</span><br><span class="line">                    persist.persist(cache);</span><br><span class="line">                    log.info(<span class="string">&quot;完成持久化缓存信息&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;文件持久化异常&quot;</span>, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时执行的时间间隔为 10min。</p>
<h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h5><p>我们只需要在创建 Cache 时，指定我们的持久化策略即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .load(<span class="keyword">new</span> MyCacheLoad())</span><br><span class="line">        .persist(CachePersists.&lt;String, String&gt;dbJson(<span class="string">&quot;1.rdb&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>为了确保文件持久化完成，我们沉睡了一会儿。</p>
<p>测试结果如下</p>
<p>生成1.rdb文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;key&quot;</span>:<span class="string">&quot;2&quot;</span>,<span class="attr">&quot;value&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;key&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;value&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<h4 id="缓存数据的加载"><a href="#缓存数据的加载" class="headerlink" title="缓存数据的加载"></a>缓存数据的加载</h4><h5 id="1-缓存初始化接口"><a href="#1-缓存初始化接口" class="headerlink" title="1.缓存初始化接口"></a>1.缓存初始化接口</h5><p>缓存初始化即从持久化中提取数据到缓存内存中</p>
<p>为了便于后期拓展，定义 ICacheLoad 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheLoad</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> ICache&lt;K,V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="2-缓存初始化接口实现"><a href="#2-缓存初始化接口实现" class="headerlink" title="2.缓存初始化接口实现"></a>2.缓存初始化接口实现</h5><p>我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载策略-文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLoadDbJson</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheLoad</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheLoadDbJson.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheLoadDbJson</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class="line">        log.info(<span class="string">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String line : lines) &#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="comment">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class="line">            PersistEntry&lt;K,V&gt; entry = JSON.parseObject(line, PersistEntry.class);</span><br><span class="line"></span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            V value = entry.getValue();</span><br><span class="line">            Long expire = entry.getExpire();</span><br><span class="line"></span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            <span class="keyword">if</span>(ObjectUtil.isNotNull(expire)) &#123;</span><br><span class="line">                cache.expireAt(key, expire);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在初始化时使用即可。</p>
<h3 id="七-AOF持久化功能的实现"><a href="#七-AOF持久化功能的实现" class="headerlink" title="七.AOF持久化功能的实现"></a>七.AOF持久化功能的实现</h3><h4 id="Redis-AOF-解析"><a href="#Redis-AOF-解析" class="headerlink" title="Redis AOF 解析"></a>Redis AOF 解析</h4><h5 id="1-为什么选择-AOF？"><a href="#1-为什么选择-AOF？" class="headerlink" title="1.为什么选择 AOF？"></a>1.为什么选择 AOF？</h5><p>AOF 模式的<strong>性能特别好</strong>：</p>
<p>用过 kafka 的同学肯定知道，kafka 也用到了顺序写这个特性。</p>
<p>顺序写添加文件内容，避免了文件 IO 的随机写问题，性能基本可以和内存媲美。</p>
<p>AOF 的<strong>实时性更好</strong>，这个是相对于 RDB 模式而言的：</p>
<p>我们原来使用 RDB 模式，将缓存内容全部持久化，这个是比较耗时的动作，一般是几分钟持久化一次。</p>
<p>AOF 模式主要是针对修改内容的指令，然后将所有的指令顺序添加到文件中。这样的话，实时性会好很多，可以提升到秒级别，甚至秒级别。可以将AOF模式理解为一个操作流水表</p>
<h5 id="2-AOF-的吞吐量"><a href="#2-AOF-的吞吐量" class="headerlink" title="2.AOF 的吞吐量"></a>2.AOF 的吞吐量</h5><p>AOF 模式可以每次操作都进行持久化，但是这样会导致吞吐量大大下降。</p>
<p>提升吞吐量最常用的方式就是<strong>批量</strong>，这个 kafka 中也是类似的，比如我们可以 1s 持久化一次，将 1s 内的操作全部放入 buffer 中。</p>
<p>这里其实就是一个 trade-off 问题，实时性与吞吐量的平衡艺术。</p>
<p>实际业务中，1s 的误差一般都是可以接受的，所以这个也是业界比较认可的方式。</p>
<h5 id="3-AOF-的异步-多线程"><a href="#3-AOF-的异步-多线程" class="headerlink" title="3.AOF 的异步+多线程"></a>3.AOF 的异步+多线程</h5><p>kafka 中所有的操作实际上都是异步+回调的方式实现的。</p>
<p>异步+多线程，确实可以提升操作的性能。</p>
<p>当然 redis 6 以前，其实一直是单线程的。那为什么性能依然这么好呢？</p>
<p>其实多线程也有代价，那就是线程上下文的切换是需要耗时的，保持并发的安全问题，也需要加锁，从而降低性能。</p>
<p>所以这里要考虑异步的收益，与付出的耗时是否成正比的问题。</p>
<h5 id="4-AOF-的落盘"><a href="#4-AOF-的落盘" class="headerlink" title="4.AOF 的落盘"></a>4.AOF 的落盘</h5><p>我们 AOF 与 RDB 模式，归根结底都是基于操作系统的文件系统做持久化的。</p>
<p>对于开发者而言，可能就是调用一个 api 就实现了，但是实际持久化落盘的动作并不见得就是一步完成的。</p>
<p>文件系统为了提升吞吐量，也会采用类似 buffer 的方式。这忽然有一点俄罗斯套娃的味道。</p>
<p>但是优秀的设计总是相似的，比如说缓存从 cpu 的设计中就有 L1/L2 等等，思路是一致的。</p>
<p>阿里的很多开源技术，都会针对操作系统的落盘做进一步的优化，这个我们后续做深入学习</p>
<h5 id="5-AOF-的缺陷"><a href="#5-AOF-的缺陷" class="headerlink" title="5.AOF 的缺陷"></a>5.AOF 的缺陷</h5><p>大道缺一，没有银弹。</p>
<p>AOF 千好万好，和 RDB 对比也存在一个缺陷，那就是指令</p>
<h4 id="AOF注解实现"><a href="#AOF注解实现" class="headerlink" title="AOF注解实现"></a>AOF注解实现</h4><h5 id="1-接口"><a href="#1-接口" class="headerlink" title="1.接口"></a>1.接口</h5><p>接口和 rdb 的保持一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化缓存接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-注解定义"><a href="#2-注解定义" class="headerlink" title="2.注解定义"></a>2.注解定义</h5><p>为了和耗时统计，刷新等特性保持一致，对于操作类的动作才添加到文件中（append to file）我们也基于注解属性来指定，而不是固定写死在代码中，便于后期拓展调整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作是否需要 append to file，默认为 false</span></span><br><span class="line"><span class="comment">     * 主要针对 cache 内容有变更的操作，不包括查询操作。</span></span><br><span class="line"><span class="comment">     * 包括删除，添加，过期等操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">aof</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在原来的 <code>@CacheInterceptor</code> 注解中添加 aof 属性，用于指定是否对操作开启 aof 模式</p>
<h5 id="3-过期操作中启用AOF"><a href="#3-过期操作中启用AOF" class="headerlink" title="3.过期操作中启用AOF"></a>3.过期操作中启用AOF</h5><p>类似于 spring 的事务拦截器，我们使用代理类调用 expireAt。</p>
<p>expire 方法就不需要添加 aof 拦截了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key         key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireTime = System.currentTimeMillis() + timeInMills;</span><br><span class="line">    <span class="comment">// 使用代理调用</span></span><br><span class="line">    Cache&lt;K,V&gt; cachePoxy = (Cache&lt;K, V&gt;) CacheProxy.getProxy(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cachePoxy.expireAt(key, expireTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定过期信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeInMills 时间戳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expire.expire(key, timeInMills);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-变更操作中启用AOF"><a href="#4-变更操作中启用AOF" class="headerlink" title="4.变更操作中启用AOF"></a>4.变更操作中启用AOF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 尝试驱除</span></span><br><span class="line">    CacheEvictContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheEvictContext&lt;&gt;();</span><br><span class="line">    context.key(key).size(sizeLimit).cache(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> evictResult = evict.evict(context);</span><br><span class="line">    <span class="keyword">if</span>(evictResult) &#123;</span><br><span class="line">        <span class="comment">// 执行淘汰监听器</span></span><br><span class="line">        ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(value).type(CacheRemoveType.EVICT.code());</span><br><span class="line">        <span class="keyword">for</span>(ICacheRemoveListener&lt;K,V&gt; listener : <span class="keyword">this</span>.removeListeners) &#123;</span><br><span class="line">            listener.listen(removeListenerContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断驱除后的信息</span></span><br><span class="line">    <span class="keyword">if</span>(isSizeLimit()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 执行添加</span></span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    map.putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(refresh = true, aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AOF-持久化拦截实现"><a href="#AOF-持久化拦截实现" class="headerlink" title="AOF 持久化拦截实现"></a>AOF 持久化拦截实现</h4><h5 id="1-持久化对象定义"><a href="#1-持久化对象定义" class="headerlink" title="1.持久化对象定义"></a>1.持久化对象定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AOF 持久化明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistAofEntry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;（</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter &amp; setter &amp;toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只需要方法名，和参数对象。</p>
<p>暂时实现的简单一些即可</p>
<h5 id="2-持久化拦截器"><a href="#2-持久化拦截器" class="headerlink" title="2.持久化拦截器"></a>2.持久化拦截器</h5><p>我们定义拦截器，当 cache 中定义的持久化类为 <code>CachePersistAof</code> 时，将操作的信息放入到 CachePersistAof 的 buffer 列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptorAof</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheInterceptorAof.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 持久化类</span></span><br><span class="line">        ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        ICachePersist&lt;K,V&gt; persist = cache.persist();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(persist <span class="keyword">instanceof</span> CachePersistAof) &#123;</span><br><span class="line">            CachePersistAof&lt;K,V&gt; cachePersistAof = (CachePersistAof&lt;K,V&gt;) persist;</span><br><span class="line"></span><br><span class="line">            String methodName = context.method().getName();</span><br><span class="line">            PersistAofEntry aofEntry = PersistAofEntry.newInstance();</span><br><span class="line">            aofEntry.setMethodName(methodName);</span><br><span class="line">            aofEntry.setParams(context.params());</span><br><span class="line"></span><br><span class="line">            String json = JSON.toJSONString(aofEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接持久化</span></span><br><span class="line">            log.debug(<span class="string">&quot;AOF 开始追加文件内容：&#123;&#125;&quot;</span>, json);</span><br><span class="line">            cachePersistAof.append(json);</span><br><span class="line">            log.debug(<span class="string">&quot;AOF 完成追加文件内容：&#123;&#125;&quot;</span>, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-拦截器调用"><a href="#3-拦截器调用" class="headerlink" title="3.拦截器调用"></a>3.拦截器调用</h5><p>当 AOF 的注解属性为 true 时，调用上述拦截器即可。</p>
<p>这里为了避免浪费，只有当持久化类为 AOF 模式时，才进行调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. AOF 追加</span></span><br><span class="line"><span class="keyword">final</span> ICachePersist cachePersist = cache.persist();</span><br><span class="line"><span class="keyword">if</span>(cacheInterceptor.aof() &amp;&amp; (cachePersist <span class="keyword">instanceof</span> CachePersistAof)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(before) &#123;</span><br><span class="line">        persistInterceptors.before(interceptorContext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        persistInterceptors.after(interceptorContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h4><p>这里的 AOF 模式和以前的 RDB 持久化类只是不同的模式，实际上二者是相同的接口。</p>
<h5 id="1-接口-1"><a href="#1-接口-1" class="headerlink" title="1.接口"></a>1.接口</h5><p>这里我们统一定义了不同的持久化类的时间，便于 RDB 与 AOF 不同任务的不同时间间隔触发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间间隔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">period</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeUnit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-持久化类实现"><a href="#2-持久化类实现" class="headerlink" title="2.持久化类实现"></a>2.持久化类实现</h5><p>实现一个 Buffer 列表，用于每次拦截器直接顺序添加</p>
<p>持久化的实现也比较简单，追加到文件之后，直接清空 buffer 列表即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存持久化-AOF 持久化模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePersistAof</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">CachePersistAdaptor</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CachePersistAof.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; bufferList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据持久化路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachePersistAof</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化</span></span><br><span class="line"><span class="comment">     * key长度 key+value</span></span><br><span class="line"><span class="comment">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始 AOF 持久化到文件&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建文件</span></span><br><span class="line">        <span class="keyword">if</span>(!FileUtil.exists(dbPath)) &#123;</span><br><span class="line">            FileUtil.createFile(dbPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 持久化追加到文件中</span></span><br><span class="line">        FileUtil.append(dbPath, bufferList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 清空 buffer 列表</span></span><br><span class="line">        bufferList.clear();</span><br><span class="line">        log.info(<span class="string">&quot;完成 AOF 持久化到文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">period</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimeUnit <span class="title">timeUnit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TimeUnit.SECONDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文件内容到 buffer 列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json json 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> String json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(json)) &#123;</span><br><span class="line">            bufferList.add(json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="持久化测试"><a href="#持久化测试" class="headerlink" title="持久化测试"></a>持久化测试</h4><h5 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1.测试代码"></a>1.测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .persist(CachePersists.&lt;String, String&gt;aof(<span class="string">&quot;1.aof&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.expire(<span class="string">&quot;1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">cache.remove(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h5 id="2-测试日志"><a href="#2-测试日志" class="headerlink" title="2.测试日志"></a>2.测试日志</h5><p>expire 实际上调用的是 expireAt。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.979</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.980</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.982</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.982</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.984</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.984</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.088</span>] [pool-<span class="number">1</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: <span class="number">1</span>, value: <span class="number">1</span>, type: expire</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.789</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.InnerCachePersist.run] - 开始持久化缓存信息</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.789</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.CachePersistAof.persist] - 开始 AOF 持久化到文件</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.798</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.CachePersistAof.persist] - 完成 AOF 持久化到文件</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.799</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.InnerCachePersist.run] - 完成持久化缓存信息</span><br></pre></td></tr></table></figure>



<h5 id="3-文件内容"><a href="#3-文件内容" class="headerlink" title="3.文件内容"></a>3.文件内容</h5><p><code>1.aof</code> 的文件内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>将每一次的操作，简单的存储到文件中</p>
<h4 id="AOF-加载实现"><a href="#AOF-加载实现" class="headerlink" title="AOF 加载实现"></a>AOF 加载实现</h4><h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h5><p>类似于 RDB 的加载模式，aof 的加载模式也是类似的。</p>
<p>我们需要根据文件的内容，还原以前的缓存的内容。</p>
<p>实现思路：遍历文件内容，反射调用原来的方法。</p>
<h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><p><strong>解析文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class="line">    log.info(<span class="string">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        <span class="comment">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class="line">        PersistAofEntry entry = JSON.parseObject(line, PersistAofEntry.class);</span><br><span class="line">        <span class="keyword">final</span> String methodName = entry.getMethodName();</span><br><span class="line">        <span class="keyword">final</span> Object[] objects = entry.getParams();</span><br><span class="line">        <span class="keyword">final</span> Method method = METHOD_MAP.get(methodName);</span><br><span class="line">        <span class="comment">// 反射调用</span></span><br><span class="line">        ReflectMethodUtil.invoke(cache, method, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法映射的预加载</strong></p>
<p>Method 反射是固定的，为了提升性能，我们做一下预处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法缓存</span></span><br><span class="line"><span class="comment"> * 暂时比较简单，直接通过方法判断即可，不必引入参数类型增加复杂度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Method&gt; METHOD_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Method[] methods = Cache.class.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        CacheInterceptor cacheInterceptor = method.getAnnotation(CacheInterceptor.class);</span><br><span class="line">        <span class="keyword">if</span>(cacheInterceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 暂时</span></span><br><span class="line">            <span class="keyword">if</span>(cacheInterceptor.aof()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                METHOD_MAP.put(methodName, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="持久化加载测试"><a href="#持久化加载测试" class="headerlink" title="持久化加载测试"></a>持久化加载测试</h4><h5 id="1-文件内容"><a href="#1-文件内容" class="headerlink" title="1.文件内容"></a>1.文件内容</h5><ul>
<li>default.aof</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .load(CacheLoads.&lt;String, String&gt;aof(<span class="string">&quot;default.aof&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure>

<p>直接将 default.aof 文件加载到 cache 缓存中</p>
<h3 id="八-监听器的开发"><a href="#八-监听器的开发" class="headerlink" title="八.监听器的开发"></a>八.监听器的开发</h3><p>下面我们将一起学习一下如何实现类似 guava-cache 中的 removeListener 删除监听器，和类似 redis 中的慢日志监控的 slowListener</p>
<p><strong>删除监听器</strong>：将数据驱除或过期时删除的数据记录打印到删除日志中</p>
<p><strong>慢操作监听器</strong>：当操作变慢时，将警告信息或报警信息打印到慢日志中</p>
<h4 id="删除监听器的开发"><a href="#删除监听器的开发" class="headerlink" title="删除监听器的开发"></a>删除监听器的开发</h4><h5 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h5><p>我们在两种场景下删除数据是对用户透明的：</p>
<p>（1）size 满了之后，进行数据淘汰。</p>
<p>（2）expire 过期时，清除数据。</p>
<p>这两个特性对用户本来应该是无感的，不过用户如果关心的话，也可以通过添加删除监听器来获取到相关的变更信息</p>
<h5 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h5><p>为了实现删除的监听，我们需要找到删除的位置，然后调用监听器即可</p>
<ul>
<li>evict 驱除的场景</li>
</ul>
<p>​    每次 put 数据时，都会校验 size 是否达到最大的限制，如果达到，则进行 evict 淘汰</p>
<ul>
<li>expire 过期的场景</li>
</ul>
<p>​    用户指定 expire 时间之后，回后台异步执行刷新</p>
<p>​    也存在惰性删除的场景</p>
<h5 id="3-接口定义"><a href="#3-接口定义" class="headerlink" title="3.接口定义"></a>3.接口定义</h5><p>为了统一，我们将所有的删除都定义统一的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除监听器接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> ICacheRemoveListenerContext&lt;K,V&gt; context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-内置实现"><a href="#4-内置实现" class="headerlink" title="4.内置实现"></a>4.内置实现</h5><p>系统内置的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheRemoveListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheRemoveListenerContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Remove key: &#123;&#125;, value: &#123;&#125;, type: &#123;&#125;&quot;</span>,</span><br><span class="line">                context.key(), context.value(), context.type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个监听器是默认开启的，暂时无法关闭</p>
<h5 id="5-自定义"><a href="#5-自定义" class="headerlink" title="5.自定义"></a>5.自定义</h5><p>用户可以自己的需要，进行自定义实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheRemoveListenerContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【删除提示】可恶，我竟然被删除了！&quot;</span> + context.key());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-使用测试"><a href="#6-使用测试" class="headerlink" title="6.使用测试"></a>6.使用测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">1</span>)</span><br><span class="line">        .addRemoveListener(<span class="keyword">new</span> MyRemoveListener&lt;String, String&gt;())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们指定 cache 的大小为1，设置我们自定义的删除监听器</p>
<p>这里的删除监听器可以添加多个</p>
<h5 id="7-测试结果"><a href="#7-测试结果" class="headerlink" title="7.测试结果"></a>7.测试结果</h5><p>测试日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">19</span>:<span class="number">32</span>:<span class="number">54.617</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: <span class="number">2</span>, value: <span class="number">2</span>, type: evict</span><br><span class="line">【删除提示】可恶，我竟然被删除了！<span class="number">2</span></span><br></pre></td></tr></table></figure>



<h4 id="慢操作监听器开发"><a href="#慢操作监听器开发" class="headerlink" title="慢操作监听器开发"></a>慢操作监听器开发</h4><h5 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h5><p>redis 中会存储慢操作的相关日志信息，主要是由两个参数构成：</p>
<p>（1）slowlog-log-slower-than 预设阈值,它的单位是毫秒(1秒=1000000微秒)默认值是10000</p>
<p>（2）slowlog-max-len 最多存储多少条的慢日志记录</p>
<p>不过 redis 是直接存储到内存中，而且有长度限制。</p>
<p>根据实际工作体验，如果我们可以添加慢日志的监听，然后有对应的存储或者报警，这样更加方便问题的分析和快速反馈。</p>
<p>所以我们引入类似于删除的监听器。</p>
<h5 id="2-实现思路-1"><a href="#2-实现思路-1" class="headerlink" title="2.实现思路"></a>2.实现思路</h5><p>我们处理所有的 cache 操作，并且记录对应的操作耗时。</p>
<p>如果耗时操作用户设置的时间阈值，则调用慢操作监听器。</p>
<h5 id="3-接口定义-1"><a href="#3-接口定义-1" class="headerlink" title="3.接口定义"></a>3.接口定义</h5><p>为了保证接口的灵活性，每一个实现都可以定义自己的慢操作阈值，这样便于分级处理。</p>
<p>比如超过 100ms，用户可以选择输出 warn 日志；超过 1s，可能影响到业务了，可以直接接入报警系统。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheSlowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> ICacheSlowListenerContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 慢日志的阈值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 慢日志的阙值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">slowerThanMills</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-自定义监听器"><a href="#4-自定义监听器" class="headerlink" title="4.自定义监听器"></a>4.自定义监听器</h5><p>实现接口 <code>ICacheSlowListener</code></p>
<p>这里每一个监听器都可以指定自己的慢日志阈值，便于分级处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySlowListener</span> <span class="keyword">implements</span> <span class="title">ICacheSlowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheSlowListenerContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【慢日志】name: &quot;</span> + context.methodName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">slowerThanMills</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-使用测试"><a href="#5-使用测试" class="headerlink" title="5.使用测试"></a>5.使用测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .addSlowListener(<span class="keyword">new</span> MySlowListener())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="6-测试结果"><a href="#6-测试结果" class="headerlink" title="6.测试结果"></a>6.测试结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.547</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: put</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.551</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: put, cost: 10ms</span><br><span class="line">【慢日志】name: put</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.554</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: get</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.554</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: get, cost: 1ms</span><br><span class="line">【慢日志】name: get</span><br></pre></td></tr></table></figure>

<p>实际工作中，我们可以针对慢日志数据存储，便于后期分析。</p>
<p>也可以直接接入报警系统，及时反馈问题</p>
<h3 id="九-Redis-渐进式-Rehash详解"><a href="#九-Redis-渐进式-Rehash详解" class="headerlink" title="九.Redis 渐进式 Rehash详解"></a>九.Redis 渐进式 Rehash详解</h3><h4 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h4><h5 id="1-HashMap-的-rehash"><a href="#1-HashMap-的-rehash" class="headerlink" title="1.HashMap 的 rehash"></a>1.HashMap 的 rehash</h5><p>读过 HashMap 源码的同学，应该都知道 map 在扩容的时候，有一个 rehash 的过程</p>
<h5 id="2-HashMap-的扩容简介"><a href="#2-HashMap-的扩容简介" class="headerlink" title="2.HashMap 的扩容简介"></a>2.HashMap 的扩容简介</h5><p>这里简单介绍下：</p>
<p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素</p>
<p>当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶</p>
<h4 id="Redis-中的扩容设计"><a href="#Redis-中的扩容设计" class="headerlink" title="Redis 中的扩容设计"></a>Redis 中的扩容设计</h4><p>HashMap 的扩容需要对集合中大部分的元素进行重新计算，但是对于 redis 这种企业级应用，特别是单线程的应用，如果像传统的 rehash 一样把所有元素来一遍的话，估计要十几秒的时间。</p>
<p>十几秒对于常见的金融、电商等相对高并发的业务场景，是无法忍受的。</p>
<p>那么 redis 的 rehash 是如何实现的呢？</p>
<p>实际上 redis 的 rehash 动作并不是一次性、集中式地完成的， 而是<strong>分多次、渐进式地完成的</strong>。</p>
<p>这里补充一点，不单单是扩容，缩容也是一样的道理，二者都需要进行 rehash。</p>
<p>只增不降就是对内存的浪费，浪费就是犯罪，特别是内存还这么贵。</p>
<p>ps: 这种思想和 key 淘汰有异曲同工之妙，一口吃不了一个大胖子，一次搞不定，那就 1024 次，慢慢来总能解决问题</p>
<h4 id="Redis-的渐进式-rehash"><a href="#Redis-的渐进式-rehash" class="headerlink" title="Redis 的渐进式 rehash"></a>Redis 的渐进式 rehash</h4><p>这部分直接选自经典入门书籍《Redis 设计与实现》</p>
<h5 id="1-为什么要渐进式处理？"><a href="#1-为什么要渐进式处理？" class="headerlink" title="1.为什么要渐进式处理？"></a>1.为什么要渐进式处理？</h5><p>实际上 redis 内部有两个 hashtable，我们称之为 ht[0] 和 ht[1]。传统的 HashMap 中只有一个。</p>
<p>为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<h5 id="2-详细步骤"><a href="#2-详细步骤" class="headerlink" title="2.详细步骤"></a>2.详细步骤</h5><p>哈希表渐进式 rehash 的详细步骤：</p>
<p>（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</p>
<p>（2）在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</p>
<p>（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增1。</p>
<p>（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</p>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<h5 id="3-rehash-间的操作怎么兼容呢？"><a href="#3-rehash-间的操作怎么兼容呢？" class="headerlink" title="3.rehash 间的操作怎么兼容呢？"></a>3.rehash 间的操作怎么兼容呢？</h5><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 那这期间的操作如何保证正常进行呢？</p>
<p>（1）查询一个信息</p>
<p>这个类似于我们的数据库信息等迁移，先查询一个库，没有的话，再去查询另一个库。</p>
<p>ht[0] 中没找到，我们去 ht[1] 中查询即可。</p>
<p>（2）新数据怎么办？</p>
<p>这个和数据迁移一样的道理。</p>
<p>当我们有新旧的两个系统时，新来的用户等信息直接落在新系统即可，</p>
<p>这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h5 id="1-什么时候判断？"><a href="#1-什么时候判断？" class="headerlink" title="1.什么时候判断？"></a>1.什么时候判断？</h5><p>redis 在每次执行 put 操作的时候，就可以检查是否需要扩容。</p>
<p>其实也很好理解，put 插入元素的时候，判断是否需要扩容，然后开始扩容，是直接的一种思路。</p>
<p>留一个思考题：我们可以在其他的时候判断吗？</p>
<h5 id="2-redis-判断是否需要扩容的源码"><a href="#2-redis-判断是否需要扩容的源码" class="headerlink" title="2.redis 判断是否需要扩容的源码"></a>2.redis 判断是否需要扩容的源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictExpandIfNeeded</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">// 如果正在进行渐进式扩容，则返回OK</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="comment">// 如果哈希表ht[0]的大小为0，则初始化字典</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果哈希表ht[0]中保存的key个数与哈希表大小的比例已经达到1:1，即保存的节点数已经大于哈希表大小</span></span><br><span class="line"><span class="comment">     * 且redis服务当前允许执行rehash，或者保存的节点数与哈希表大小的比例超过了安全阈值（默认值为5）</span></span><br><span class="line"><span class="comment">     * 则将哈希表大小扩容为原来的两倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>扩容的条件总结下来就是两句话：</p>
<p>（1）服务器目前没有在执行 BGSAVE/BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1；</p>
<p>（2）服务器目前正在执行 BGSAVE/BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5；</p>
<p>这里其实体现了作者的一种设计思想：如果负载因子超过5，说明信息已经很多了，管你在不在保存，都要执行扩容，优先保证服务可用性。如果没那么高，那就等持久化完成再做 rehash。</p>
<p>我们自己在实现的时候可以简化一下，比如只考虑情况2。</p>
<h5 id="3-扩容到原来的多少？"><a href="#3-扩容到原来的多少？" class="headerlink" title="3.扩容到原来的多少？"></a>3.扩容到原来的多少？</h5><p>知道了什么时候应该开始扩容，但是要扩容到多大也是值得思考的一个问题。</p>
<p>扩容的太小，会导致频繁扩容，浪费性能。</p>
<p>扩容的太大，会导致资源的浪费。</p>
<p>其实这个最好的方案是结合我们实际的业务，不过这部分对用户是透明的。</p>
<p>一般是扩容为原来的两倍。</p>
<h5 id="4-为什么需要扩容？"><a href="#4-为什么需要扩容？" class="headerlink" title="4.为什么需要扩容？"></a>4.为什么需要扩容？</h5><p>我们在实现 ArrayList 的时候需要扩容，因为数据放不下了。</p>
<p>我们知道 HashMap 的底层是数组 + 链表（红黑树）的数据结构。</p>
<p>那么会存在放不下的情况吗？</p>
<p>个人理解实际上不会。因为链表可以一直加下去。</p>
<p>那为什么需要扩容呢？</p>
<p>实际上更多的是处于性能的考虑。我们使用 HashMap 就是为了提升性能，如果一直不扩容，可以理解为元素都 hash 到相同的 bucket 上，这时就退化成了一个链表。</p>
<p>这会导致查询等操作性能大大降低。</p>
<h4 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h4><h5 id="1-什么时候判断？-1"><a href="#1-什么时候判断？-1" class="headerlink" title="1.什么时候判断？"></a>1.什么时候判断？</h5><p>看了前面的扩容，我们比较直观地方式是在用户 remove 元素的时候执行是否需要缩容。</p>
<p>不过 redis 并不完全等同于传统的 HashMap，还有数据的淘汰和过期，这些是对用户透明的。</p>
<p>redis 采用的方式实际上是一个定时任务。</p>
<p>个人理解内存缩容很重要，但是没有那么紧急，我们可以 1min 扫描一次，这样可以节省机器资源。</p>
<p>实际工作中，一般 redis 的内存都是逐步上升的，或者稳定在一个范围内，很少去大批量删除数据。（除非数据搞错了，我就遇到过一次，数据同步错地方了）。</p>
<p>所以数据删除，一般几分钟内给用户一个反馈就行。</p>
<p>知其然，知其所以然。</p>
<p>我们懂得了这个道理也就懂得了为什么有时候删除 redis 的几百万 keys，内存也不是直接降下来的原因。</p>
<h5 id="2-缩容的条件"><a href="#2-缩容的条件" class="headerlink" title="2.缩容的条件"></a>2.缩容的条件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL</span></span><br><span class="line"><span class="comment"> * we resize the hash table to save memory */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryResizeHashTables</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].dict))</span><br><span class="line">        dictResize(server.db[dbid].dict);</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].expires))</span><br><span class="line">        dictResize(server.db[dbid].expires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table parameters */</span></span><br><span class="line">#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和扩容类似，不过这里的缩容比例不是 5 倍，而是当哈希表保存的key数量与哈希表的大小的比例小于 10% 时需要缩容。</p>
<h5 id="3-缩容到多少？"><a href="#3-缩容到多少？" class="headerlink" title="3.缩容到多少？"></a>3.缩容到多少？</h5><p>最简单的方式是直接变为原来的一半，不过这么做有时候也不是那么好用。</p>
<p>redis 是<strong>缩容后的大小为第一个大于等于当前key数量的2的n次方。</strong></p>
<p>这个可能不太好理解，举几个数字就懂了：</p>
<table>
<thead>
<tr>
<th align="left">keys数量</th>
<th align="left">缩容大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">16</td>
</tr>
</tbody></table>
<p>主要保障以下3点：</p>
<p>（1）缩容之后，要大于等于 key 的数量</p>
<p>（2）尽可能的小，节约内存</p>
<p>（3）2 的倍数。</p>
<p>第三个看过 HashMap 源码讲解的小伙伴应该深有体会。</p>
<p>当然也不能太小，redis 限制的最小为 4。</p>
<p>实际上如果 redis 中只放 4 个 key，实在是杀鸡用牛刀，一般不会这么小。</p>
<p>我们在实现的时候，直接参考 jdk 好了，给个最小值限制 8。</p>
<h5 id="4-为什么需要缩容？"><a href="#4-为什么需要缩容？" class="headerlink" title="4.为什么需要缩容？"></a>4.为什么需要缩容？</h5><p>最核心的目的就是为了节约内存，其实还有一个原因，叫 small means fast（小即是快——老马）。</p>
<h4 id="渐进式-ReHash-实现的思考"><a href="#渐进式-ReHash-实现的思考" class="headerlink" title="渐进式 ReHash 实现的思考"></a>渐进式 ReHash 实现的思考</h4><p>好了，扩容和缩容就聊到这里，那么这个渐进式 rehash 到底怎么一个渐进法？</p>
<h5 id="1-扩容前"><a href="#1-扩容前" class="headerlink" title="1.扩容前"></a>1.扩容前</h5><p>不需要扩容时应该有至少需要初始化两个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = <span class="keyword">new</span> HashTable(size);</span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>hashtable 中存储着当前的元素信息，hashIndex=-1 标识当前没有在进行扩容。</p>
<h5 id="2-扩容准备"><a href="#2-扩容准备" class="headerlink" title="2.扩容准备"></a>2.扩容准备</h5><p>当需要扩容的时候，我们再去创建一个 hashtable[1]，并且 size 是原来的 2倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = <span class="keyword">new</span> HashTable(size);</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">new</span> HashTable(<span class="number">2</span> * size);</span><br><span class="line"></span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>主要是为了节约内存，使用惰性初始化的方式创建 hashtable。</p>
<h5 id="3-扩容时"><a href="#3-扩容时" class="headerlink" title="3.扩容时"></a>3.扩容时</h5><p>调整 hashIndex=0…size，逐步去 rehash 到新的 hashtable[1]</p>
<p>新的插入全部放入到 hashtable[1]</p>
<h5 id="4-扩容后"><a href="#4-扩容后" class="headerlink" title="4.扩容后"></a>4.扩容后</h5><p>扩容后我们应该把 hashtable[0] 的值更新为 hashtable[1]，并且释放掉 hashtable[1] 的资源。</p>
<p>并且设置 hashIndex=-1，标识已经 rehash 完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = hashtable[<span class="number">1</span>];</span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这样整体的实现思路就已经差不多了，光说不练假把式，我们下一节就来自己实现一个渐进式 rehash 的 HashMap</p>
<h3 id="十-实现渐进式ReHash-Map类定义"><a href="#十-实现渐进式ReHash-Map类定义" class="headerlink" title="十.实现渐进式ReHash Map类定义"></a>十.实现渐进式ReHash Map类定义</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己实现的渐进式 rehash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProgressiveReHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和简易版本类似。</p>
<h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(MyProgressiveReHashMap.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rehash 的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 rehashIndex != -1，说明正在进行 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rehashIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量</span></span><br><span class="line"><span class="comment"> * 默认为 8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处于 rehash 状态的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rehashCapacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计大小的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阈值</span></span><br><span class="line"><span class="comment"> * 阈值=容量*factor</span></span><br><span class="line"><span class="comment"> * 暂时不考虑最大值的问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当达到这个阈值的时候，直接进行两倍的容量扩充+rehash。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存放信息的 table 数组。</span></span><br><span class="line"><span class="comment"> * 数组：数组的下标是一个桶，桶对应的元素 hash 值相同。</span></span><br><span class="line"><span class="comment"> * 桶里放置的是一个链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以理解为 table 是一个 ArrayList</span></span><br><span class="line"><span class="comment"> * arrayList 中每一个元素，都是一个 DoubleLinkedList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Entry&lt;K, V&gt;&gt;&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渐进式 rehash 时，用来存储元素信息使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Entry&lt;K, V&gt;&gt;&gt; rehashTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否开启 debug 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> debugMode = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>rehashIndex/rehashCapacity/rehashTable 这三个值都是我们在进行渐进式实现的时候需要使用的值。</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>主要是一些值的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> debugMode 是否开启 debug 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> debugMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 初始化最大为容量的个数，如果 hash 的非常完美的话。</span></span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">    <span class="comment">// 初始化为空列表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.table.add(i, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.debugMode = debugMode;</span><br><span class="line">    <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashCapacity = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashTable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h4><p>这个方法相对难度比较大：</p>
<p>put() 的过程可以见方法的注释。</p>
<p>需要考虑是否为 rehash 阶段，还需要考虑是否为更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put 一个值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果不处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.1 判断是否为 table 更新，如果是，则进行更新</span></span><br><span class="line"><span class="comment"> * 1.2 如果不是更新，则进行插入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 插入的时候可能触发 rehash</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （2）如果处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.0 执行一次渐进式 rehash 的动作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1 判断是否为更新，需要遍历 table 和 rehashTable</span></span><br><span class="line"><span class="comment"> * 如果是，执行更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.2 如果不是，则执行插入</span></span><br><span class="line"><span class="comment"> * 插入到 rehashTable 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInRehash = isInReHash();</span><br><span class="line">    <span class="keyword">if</span>(!isInRehash) &#123;</span><br><span class="line">        <span class="comment">//1. 是否为更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair = updateTableInfo(key, value, <span class="keyword">this</span>.table, <span class="keyword">this</span>.capacity);</span><br><span class="line">        <span class="keyword">if</span>(pair.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;不处于渐进式 rehash，此次为更新操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createNewEntry(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2.0 执行一个附加操作，进行渐进式 rehash 处理</span></span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 阶段，额外执行一次渐进式 rehash 的动作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rehashToNew();</span><br><span class="line">        <span class="comment">//2.1 是否为 table 更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair = updateTableInfo(key, value, <span class="keyword">this</span>.table, <span class="keyword">this</span>.capacity);</span><br><span class="line">        <span class="keyword">if</span>(pair.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;此次为更新 table 操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 是否为 rehashTable 更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair2 = updateTableInfo(key, value, <span class="keyword">this</span>.rehashTable, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        <span class="keyword">if</span>(pair2.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair2.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;此次为更新 rehashTable 操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.3 插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createNewEntry(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-是否为-rehash-阶段"><a href="#1-是否为-rehash-阶段" class="headerlink" title="1.是否为 rehash 阶段"></a>1.是否为 rehash 阶段</h5><p>这个实现比较简单，就是判断 rehashIndex 是否为 -1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInReHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rehashIndex != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-更新列表信息"><a href="#2-更新列表信息" class="headerlink" title="2.更新列表信息"></a>2.更新列表信息</h5><p>这里为了复用，对方法进行了抽象。可以同时使用到 table 和 rehashTable 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为更新信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> table table 信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableCapacity table 的容量（使用 size 也可以，因为都默认初始化了。）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 更新结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Pair&lt;Boolean, V&gt; <span class="title">updateTableInfo</span><span class="params">(K key, V value, <span class="keyword">final</span> List&lt;List&lt;Entry&lt;K,V&gt;&gt;&gt; table,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> <span class="keyword">int</span> tableCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 index 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = HashUtil.hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = HashUtil.indexFor(hash, tableCapacity);</span><br><span class="line">    <span class="comment">// 判断是否为替换</span></span><br><span class="line">    List&lt;Entry&lt;K,V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(index &lt; table.size()) &#123;</span><br><span class="line">        entryList = table.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; entry : entryList) &#123;</span><br><span class="line">        <span class="comment">// 二者的 key 都为 null，或者二者的 key equals()</span></span><br><span class="line">        <span class="keyword">final</span> K entryKey = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(key, entryKey)</span><br><span class="line">                || key.equals(entryKey)) &#123;</span><br><span class="line">            <span class="keyword">final</span> V oldValue = entry.getValue();</span><br><span class="line">            <span class="comment">// 更新新的 value</span></span><br><span class="line">            entry.setValue(value);</span><br><span class="line">            <span class="keyword">return</span> Pair.of(<span class="keyword">true</span>, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pair.of(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个和以前基本是类似的。</p>
<p>返回结果时，为了同时保存是否为更新，以及更新的 value 值。所以使用了 Pair 工具类。</p>
<h5 id="3-插入新的元素"><a href="#3-插入新的元素" class="headerlink" title="3.插入新的元素"></a>3.插入新的元素</h5><p>插入方法也比较麻烦，需要区分是否处于渐进式 rehash 阶段。还要考虑是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的明细</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果处于渐进式 rehash 中，则设置到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （2）如果不是，则判断是否需要扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1 如果扩容，则直接放到 rehashTable 中。</span></span><br><span class="line"><span class="comment"> * 因为我们每次扩容内存翻倍，一次只处理一个 index 的信息，所以不会直接 rehash 结束，直接放到新的 rehashTable 中即可</span></span><br><span class="line"><span class="comment"> * 2.2 如果不扩容，则放入 table 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">createNewEntry</span><span class="params">(<span class="keyword">final</span> K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; entry = <span class="keyword">new</span> DefaultMapEntry&lt;&gt;(key, value);</span><br><span class="line">    <span class="comment">// 重新计算 tableIndex</span></span><br><span class="line">    <span class="keyword">int</span> hash = HashUtil.hash(key);</span><br><span class="line">    <span class="comment">//是否处于 rehash 中？</span></span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.rehashTable.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前处于 rehash 中，元素直接插入到 rehashTable 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.rehashTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要扩容 &amp;&amp; 不处于渐进式 rehash</span></span><br><span class="line">    <span class="comment">// rehash 一定是扩容 rehashTable</span></span><br><span class="line">    <span class="comment">// 如果发生了 rehash，元素是直接放到 rehashTable 中的</span></span><br><span class="line">    <span class="keyword">if</span>(isNeedExpand()) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">        <span class="comment">// 放入到 rehashTable 中</span></span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.rehashTable.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前处于 rehash 中，元素直接插入到 rehashTable 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.rehashTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.capacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.table.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前不处于 rehash 中，元素直接插入到 table 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.table);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否需要扩容的方法也比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比例满足，且不处于渐进式 rehash 中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNeedExpand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证比例</span></span><br><span class="line">    <span class="keyword">double</span> rate = size*<span class="number">1.0</span> / capacity*<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> rate &gt;= factor &amp;&amp; !isInReHash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过我们这次添加了一个不要处于渐进式 rehash 过程中。</p>
<p>其中 rehash 的实现也发生了很大的变化，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接 rehash 的流程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果处于 rehash 中，直接返回</span></span><br><span class="line"><span class="comment"> * （2）初始化 rehashTable，并且更新 rehashIndex=0;</span></span><br><span class="line"><span class="comment"> * （3）获取 table[0]，rehash 到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （4）设置 table[0] = new ArrayList();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 阶段，不重复进行 rehash!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 rehashTable</span></span><br><span class="line">    <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashCapacity = <span class="number">2</span>*capacity;</span><br><span class="line">    <span class="keyword">this</span>.rehashTable = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rehashCapacity; i++) &#123;</span><br><span class="line">        rehashTable.add(i, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素第一个元素，其他的进行渐进式更新。</span></span><br><span class="line">    rehashToNew();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渐进式更新的方法，可以在 get/put/remove 等操作时，执行附加操作时使用。</p>
<p>所以单独抽成了一个方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将信息从旧的 table 迁移到新的 table 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）table[rehashIndex] 重新 rehash 到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （2）设置 table[rehashIndex] = new ArrayList();</span></span><br><span class="line"><span class="comment"> * （3）判断是否完成渐进式 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehashToNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rehashIndex++;</span><br><span class="line"></span><br><span class="line">    List&lt;Entry&lt;K, V&gt;&gt; list = table.get(rehashIndex);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; entry : list) &#123;</span><br><span class="line">        <span class="keyword">int</span> hash = HashUtil.hash(entry);</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, rehashCapacity);</span><br><span class="line">        <span class="comment">//  添加元素</span></span><br><span class="line">        <span class="comment">// 获取列表，避免数组越界</span></span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; newList = rehashTable.get(index);</span><br><span class="line">        <span class="comment">// 添加元素到列表</span></span><br><span class="line">        <span class="comment">// 元素不存在重复，所以不需要考虑更新</span></span><br><span class="line">        newList.add(entry);</span><br><span class="line">        rehashTable.set(index, newList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 index 处的信息</span></span><br><span class="line">    table.set(rehashIndex, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断大小是否完成 rehash</span></span><br><span class="line">    <span class="comment">// 验证是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span>(rehashIndex == (table.size()-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="keyword">this</span>.rehashCapacity;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">this</span>.rehashTable;</span><br><span class="line">        <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rehashCapacity = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rehashTable = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;渐进式 rehash 已经完成。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.table);</span><br><span class="line">        &#125;p</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;渐进式 rehash 处理中, 目前 index：&#123;&#125; 已完成&quot;</span>, rehashIndex);</span><br><span class="line">            printAllTable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="get-操作"><a href="#get-操作" class="headerlink" title="get() 操作"></a>get() 操作</h4><p>渐进式 rehash 将动作分散到每一个操作中，我们对 get 方法进行重写，当做一个例子。其他的方法如果实现也是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询方法</span></span><br><span class="line"><span class="comment"> * （1）如果处于渐进式 rehash 状态，额外执行一次 rehashToNew()</span></span><br><span class="line"><span class="comment"> * （2）判断 table 中是否存在元素</span></span><br><span class="line"><span class="comment"> * （3）判断 rehashTable 中是否存在元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 状态，额外执行一次操作&quot;</span>);</span><br><span class="line">            rehashToNew();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断 table 中是否存在</span></span><br><span class="line">    V result = getValue(key, <span class="keyword">this</span>.table);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 是否处于渐进式 rehash</span></span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getValue(key, <span class="keyword">this</span>.rehashTable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>我们历经千辛万苦，终于实现了一个简单版本的渐进式 hash map。</p>
<p>下面来测试一下功能是否符合我们的预期。</p>
<h5 id="1-put-操作"><a href="#1-put-操作" class="headerlink" title="1.put 操作"></a>1.put 操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> MyProgressiveReHashMap&lt;&gt;(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">30</span>:<span class="number">15.072</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">30</span>:<span class="number">15.076</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.put] - 不处于渐进式 rehash，此次为更新操作。key: <span class="number">1</span>, value: <span class="number">2</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>&#125; </span><br></pre></td></tr></table></figure>

<p>第一次是插入，第二次是更新。</p>
<p>这里都没有触发扩容，下面我们看一下触发扩容的情况。</p>
<h5 id="2-扩容测试"><a href="#2-扩容测试" class="headerlink" title="2.扩容测试"></a>2.扩容测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> MyProgressiveReHashMap&lt;&gt;(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;1&quot;</span>, map.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;2&quot;</span>, map.get(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;3&quot;</span>, map.get(<span class="string">&quot;3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.559</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.560</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.563</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.rehashToNew] - 渐进式 rehash 处理中, 目前 index：<span class="number">0</span> 已完成</span><br><span class="line">原始 table 信息: </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">新的 table 信息: </span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.563</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前处于 rehash 中，元素直接插入到 rehashTable 中。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">3</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.564</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.get] - 当前处于渐进式 rehash 状态，额外执行一次操作</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.564</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.rehashToNew] - 渐进式 rehash 已经完成。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">3</span>&#125; </span><br></pre></td></tr></table></figure>

<p>当放入元素【3】的时候，已经触发了 rehash。</p>
<p>（1）第一次渐进式 rehash 将 table[0] 的元素 rehash 到了新的节点。</p>
<p>（2）插入的元素直接插入到 rehashTable 中</p>
<p>（3）get 操作时，额外触发一次 rehash，然后所有的 rehash 已经完成。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4ffc613d6eaf">Fluent Interface 流式接口</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Autovy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" title="Java|渐进式本地缓存开发总结">https://autovy.github.io/2022/04/20/Java/Java-渐进式本地缓存框架开发总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" rel="tag"><i class="fa fa-tag"></i> 项目实战</a>
              <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/25/DevPrinciple/MySQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="prev" title="开发原理|MySQL最佳实践">
      <i class="fa fa-chevron-left"></i> 开发原理|MySQL最佳实践
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/13/BookNote/%E3%80%8A%E7%BB%8F%E6%B5%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9A%E9%B1%BC%E3%80%81%E7%BE%8E%E5%85%83%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%95%85%E4%BA%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="next" title="读书笔记|经济为什么会崩溃：鱼、美元与经济学的故事">
      读书笔记|经济为什么会崩溃：鱼、美元与经济学的故事 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>



  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="nav-text">一.固定大小缓存实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-text">缓存接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="nav-text">核心实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-text">淘汰策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB"><span class="nav-text">引导类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8"><span class="nav-text">测试使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-text">二.LRU缓存淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">LRU基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-LRU-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">1.LRU 是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="nav-text">2.连续性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-text">3.实现步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-LRU%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%E7%96%91%E7%82%B9"><span class="nav-text">5.LRU实现步骤疑点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">Java 代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-text">1.接口定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-LRU-%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.LRU 实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7"><span class="nav-text">3.注解属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8"><span class="nav-text">4.注解使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E9%99%A4%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.注解驱除拦截器实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-LRU%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">三.LRU缓存策略的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9"><span class="nav-text">数据结构选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="nav-text">1.基于数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">2.基于长度有限的双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">3.基于双向链表和哈希表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%BB%E7%BB%93"><span class="nav-text">4.数据结构的选择总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">基于自定义双向链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">1.节点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.核心代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-text">3.测试结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-LinkedHashMap-%E5%AE%9E%E7%8E%B0"><span class="nav-text">基于 LinkedHashMap 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%9B%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.直接实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%AE%80%E5%8D%95%E6%94%B9%E9%80%A0"><span class="nav-text">2.简单改造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C-1"><span class="nav-text">3.测试结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95"><span class="nav-text">LRU扩展算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-LRU-K"><span class="nav-text">1. LRU-K</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-two-queue"><span class="nav-text">2. two queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Multi-Queue-MQ"><span class="nav-text">3. Multi Queue(MQ)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-LRU%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-text">4.LRU算法对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2Q%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">2Q算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-text">1.实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="nav-text">2.基本属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0"><span class="nav-text">3.数据淘汰</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="nav-text">4.数据删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-text">5.数据的更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%B5%8B%E8%AF%95"><span class="nav-text">6.测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU-2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">LRU-2算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0LRU%E7%AE%80%E4%BB%8B"><span class="nav-text">1.实现LRU简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%8A%82%E7%82%B9"><span class="nav-text">2.节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="nav-text">5.基本属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%B7%98%E6%B1%B0%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.淘汰实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%88%A0%E9%99%A4"><span class="nav-text">7.删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E6%9B%B4%E6%96%B0"><span class="nav-text">8.更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E6%B5%8B%E8%AF%95"><span class="nav-text">9.测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-%E5%B0%8F%E7%BB%93"><span class="nav-text">10.小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E8%BF%87%E6%9C%9F%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">四.过期功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-1"><span class="nav-text">缓存接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">缓存接口实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%8E%A5%E5%8F%A3"><span class="nav-text">缓存过期接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#expire-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">expire 实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%BF%87%E6%9C%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">1.过期信息的存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%BD%AE%E8%AF%A2%E6%B8%85%E7%90%86"><span class="nav-text">2.轮询清理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B8%85%E7%A9%BA%E4%BB%BB%E5%8A%A1"><span class="nav-text">3.清空任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-text">惰性删除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">1.出现的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9C%80%E8%A6%81%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">2.需要惰性删除的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%B7%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.刷新的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E8%BF%87%E6%9C%9F%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">五.过期功能的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">基于时间的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%80%9D%E8%B7%AF"><span class="nav-text">1.思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="nav-text">2.基本属性定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%94%BE%E5%85%A5%E5%85%83%E7%B4%A0%E6%97%B6"><span class="nav-text">3.放入元素时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-text">定时任务的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="nav-text">2.执行任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E5%88%B7%E6%96%B0"><span class="nav-text">惰性删除刷新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-RBD%E6%8C%81%E4%B9%85%E5%8C%96%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">六.RBD持久化功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-text">持久化操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.持久化操作接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.持久化操作接口实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="nav-text">3.持久化操作的触发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B5%8B%E8%AF%95"><span class="nav-text">4.测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-text">缓存数据的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.缓存初始化接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.缓存初始化接口实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">七.AOF持久化功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-AOF-%E8%A7%A3%E6%9E%90"><span class="nav-text">Redis AOF 解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-AOF%EF%BC%9F"><span class="nav-text">1.为什么选择 AOF？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-AOF-%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">2.AOF 的吞吐量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-AOF-%E7%9A%84%E5%BC%82%E6%AD%A5-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.AOF 的异步+多线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-AOF-%E7%9A%84%E8%90%BD%E7%9B%98"><span class="nav-text">4.AOF 的落盘</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-AOF-%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-text">5.AOF 的缺陷</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">AOF注解实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89"><span class="nav-text">2.注解定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C%E4%B8%AD%E5%90%AF%E7%94%A8AOF"><span class="nav-text">3.过期操作中启用AOF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%8F%98%E6%9B%B4%E6%93%8D%E4%BD%9C%E4%B8%AD%E5%90%AF%E7%94%A8AOF"><span class="nav-text">4.变更操作中启用AOF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E6%8B%A6%E6%88%AA%E5%AE%9E%E7%8E%B0"><span class="nav-text">AOF 持久化拦截实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89"><span class="nav-text">1.持久化对象定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8C%81%E4%B9%85%E5%8C%96%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">2.持久化拦截器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B0%83%E7%94%A8"><span class="nav-text">3.拦截器调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="nav-text">AOF持久化实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8E%A5%E5%8F%A3-1"><span class="nav-text">1.接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8C%81%E4%B9%85%E5%8C%96%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.持久化类实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-text">持久化测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">1.测试代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97"><span class="nav-text">2.测试日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-text">3.文件内容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0"><span class="nav-text">AOF 加载实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8A%A0%E8%BD%BD"><span class="nav-text">1.加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%95"><span class="nav-text">持久化加载测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-text">1.文件内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95"><span class="nav-text">2.测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91"><span class="nav-text">八.监听器的开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91"><span class="nav-text">删除监听器的开发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-text">2.实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-text">3.接口定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%86%85%E7%BD%AE%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.内置实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="nav-text">5.自定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="nav-text">6.使用测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-text">7.测试结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%85%A2%E6%93%8D%E4%BD%9C%E7%9B%91%E5%90%AC%E5%99%A8%E5%BC%80%E5%8F%91"><span class="nav-text">慢操作监听器开发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="nav-text">1.说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1"><span class="nav-text">2.实现思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-1"><span class="nav-text">3.接口定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">4.自定义监听器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="nav-text">5.使用测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-text">6.测试结果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D-Redis-%E6%B8%90%E8%BF%9B%E5%BC%8F-Rehash%E8%AF%A6%E8%A7%A3"><span class="nav-text">九.Redis 渐进式 Rehash详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%AE%80%E4%BB%8B"><span class="nav-text">HashMap 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-HashMap-%E7%9A%84-rehash"><span class="nav-text">1.HashMap 的 rehash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E7%AE%80%E4%BB%8B"><span class="nav-text">2.HashMap 的扩容简介</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9%E8%AE%BE%E8%AE%A1"><span class="nav-text">Redis 中的扩容设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="nav-text">Redis 的渐进式 rehash</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">1.为什么要渐进式处理？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.详细步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-rehash-%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C%E6%80%8E%E4%B9%88%E5%85%BC%E5%AE%B9%E5%91%A2%EF%BC%9F"><span class="nav-text">3.rehash 间的操作怎么兼容呢？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9"><span class="nav-text">扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="nav-text">1.什么时候判断？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-redis-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%E7%9A%84%E6%BA%90%E7%A0%81"><span class="nav-text">2.redis 判断是否需要扩容的源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%89%A9%E5%AE%B9%E5%88%B0%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-text">3.扩容到原来的多少？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-text">4.为什么需要扩容？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%A9%E5%AE%B9"><span class="nav-text">缩容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%A4%E6%96%AD%EF%BC%9F-1"><span class="nav-text">1.什么时候判断？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%A9%E5%AE%B9%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">2.缩容的条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BC%A9%E5%AE%B9%E5%88%B0%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-text">3.缩容到多少？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BC%A9%E5%AE%B9%EF%BC%9F"><span class="nav-text">4.为什么需要缩容？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-ReHash-%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-text">渐进式 ReHash 实现的思考</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%89%A9%E5%AE%B9%E5%89%8D"><span class="nav-text">1.扩容前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%89%A9%E5%AE%B9%E5%87%86%E5%A4%87"><span class="nav-text">2.扩容准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%89%A9%E5%AE%B9%E6%97%B6"><span class="nav-text">3.扩容时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A9%E5%AE%B9%E5%90%8E"><span class="nav-text">4.扩容后</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81-%E5%AE%9E%E7%8E%B0%E6%B8%90%E8%BF%9B%E5%BC%8FReHash-Map%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-text">十.实现渐进式ReHash Map类定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="nav-text">私有变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-%E6%96%B9%E6%B3%95"><span class="nav-text">put() 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%98%AF%E5%90%A6%E4%B8%BA-rehash-%E9%98%B6%E6%AE%B5"><span class="nav-text">1.是否为 rehash 阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF"><span class="nav-text">2.更新列表信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">3.插入新的元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-%E6%93%8D%E4%BD%9C"><span class="nav-text">get() 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-put-%E6%93%8D%E4%BD%9C"><span class="nav-text">1.put 操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%89%A9%E5%AE%B9%E6%B5%8B%E8%AF%95"><span class="nav-text">2.扩容测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a href="/">  <img class="site-author-image" itemprop="image" alt="Autovy"
      src="/images/2.png">  </a>
  <p class="site-author-name" itemprop="name">Autovy</p>
  <div class="site-description" itemprop="description">新时代农民工的数字农田</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Autovy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">738k</span>
</div>

<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
    本站已有
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    位访客
    <i class="fa fa-user"></i>
    </span>
  
<span> | </span>

  
    <span class="site-pv" title="总访问量">
   
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    次阅读
    <i class="fa fa-eye"></i>
    </span>
  
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RVJRabsBhxWXvhMcG8CH5wbc-gzGzoHsz',
      appKey     : 'JSGLk7guOagDPMFN9wbASkEh',
      placeholder: "说点什么吧",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
  <script src="/js/bloom.js" type="text/javascript"></script>