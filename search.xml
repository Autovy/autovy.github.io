<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开发工具|学点docker</title>
    <url>/2021/05/28/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040845042.jpeg" alt="git"></p>
<span id="more"></span>

<h3 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h3><h4 id="Docker应用"><a href="#Docker应用" class="headerlink" title="Docker应用"></a>Docker应用</h4><ul>
<li>部署环境复杂，非常费时费力</li>
<li>环境不能跨平台</li>
<li>docker可以把环境打包成镜像，直接运行即可</li>
<li>docker通过隔离机制，可以将服务器利用到极致</li>
</ul>
<h4 id="Docker的功能"><a href="#Docker的功能" class="headerlink" title="Docker的功能"></a>Docker的功能</h4><ul>
<li><p>虚拟机技术</p>
</li>
<li><p>容器化技术</p>
</li>
<li><p>DevOps（开发 + 运维）</p>
</li>
<li><p>应用更加快速的交付和部署</p>
</li>
<li><p>更便捷的升级和扩缩容</p>
</li>
<li><p>更加简单的系统运维</p>
</li>
<li><p>更加高效的计算资源利用</p>
</li>
</ul>
<h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><h4 id="1-Docker基本组成"><a href="#1-Docker基本组成" class="headerlink" title="1.Docker基本组成"></a>1.Docker基本组成</h4><ul>
<li><p>仓库：仓库就是存放镜像的地方</p>
</li>
<li><p>镜像：docker镜像就像一个模板，通过镜像可以创建多个容器</p>
</li>
<li><p>容器：容器可以独立运行一个或者多组应用（启动，停止，删除）</p>
</li>
</ul>
<h4 id="2-run工作流程"><a href="#2-run工作流程" class="headerlink" title="2.run工作流程"></a>2.run工作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846845.png" alt="在这里插入图片描述"></p>
<h4 id="3-Docker工作原理"><a href="#3-Docker工作原理" class="headerlink" title="3.Docker工作原理"></a>3.Docker工作原理</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846904.png" alt="Docker 工作原理"></p>
<h4 id="4-Docker与VM的区别"><a href="#4-Docker与VM的区别" class="headerlink" title="4.Docker与VM的区别"></a>4.Docker与VM的区别</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846873.jpeg" alt="containers-vs-virtual-machines.jpg"></p>
<ul>
<li>Docker的抽象层比虚拟机少</li>
<li>docker利用的是宿主机的内核，vm需要的是Guest OS（vm每次都要加载操作系统的内核）</li>
</ul>
<h3 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846335.jpeg" alt="img"></p>
<h4 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>



<h4 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2.镜像命令"></a>2.镜像命令</h4><p>（1）docker images查看本地主机上的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>REPOSITORY :镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像的id</li>
<li>CREATED：镜像的创建时间    </li>
<li>SIZE：镜像大小</li>
</ul>
<p>可选项：</p>
<ul>
<li>-a : 列出所有镜像</li>
<li>-q：只显示镜像id</li>
</ul>
<p>（2）docker search 搜索镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME  DESCRIPTION   STARS  OFFICIAL   AUTOMATED</span><br></pre></td></tr></table></figure>

<p>可选项，可以过滤搜索结果：</p>
<p>–filter=STARS=3000 ：搜索stars大于3000的镜像</p>
<p>（3）docker pull 拉取镜像:tag ，默认拉取最新版</p>
<p>（4）docker rmi 删除镜像名称/id   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除mysql镜像</span></span><br><span class="line">docker rmi -f mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归删除所有镜像</span></span><br><span class="line">docker -f $(docker images -aq)</span><br></pre></td></tr></table></figure>



<h4 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3.容器命令"></a>3.容器命令</h4><p>有了镜像我们才能创建容器</p>
<p>（1）新建镜像并启动：dokcer run [可选参数] image</p>
<p>容器内相当于一个新的虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>相关参数：</p>
<ul>
<li>–name = “Name” ：容器名字，用于区分容器</li>
<li>-d ：后台方式运行</li>
<li>-it : 使用交互方式运行，可进入容器查看内容（开启容器终端）</li>
<li>-p：指定容器端口</li>
</ul>
<p>（2）查看容器：docker ps</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps  	  #查看运行中的容器</span><br></pre></td></tr></table></figure>

<p>相关参数：</p>
<ul>
<li>-a  ：查看所有容器（包括已终止的容器）</li>
<li>-n = ? :显示最近创建的容器</li>
<li>-q ： 只显示容器的编号</li>
</ul>
<p>（3）退出容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit # 容器停止并退出</span><br><span class="line">ctrl + P + Q # 容器不停止退出(按P,Q这个设计多少有点反人类)</span><br></pre></td></tr></table></figure>



<p>（4）删除容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id	# 删除指定的容器(不能删除运行中的容器，加-f强制删除)</span><br><span class="line">docker rm -f $(docker ps -aq) 	 # 删除所有容器</span><br></pre></td></tr></table></figure>



<p>（5）启动和停止容器的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id # 启动容器</span><br><span class="line">docker restart 容器id # 重启容器</span><br><span class="line">docker stop 容器id # 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id # 强制停止当前容器</span><br></pre></td></tr></table></figure>



<h4 id="4-操作命令"><a href="#4-操作命令" class="headerlink" title="4.操作命令"></a>4.操作命令</h4><p>（1）后台启动命令</p>
<p>docker容器使用后台运行时（<code>docker run -d centos</code>），必须要有一个前台进程，如果docker发现自己没有应用了，就会自动停止</p>
<p>（2）查看日志命令</p>
<p>查看容器运行的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 容器</span><br></pre></td></tr></table></figure>



<p>（3）查看容器进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>



<p>（4）查看镜像元数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>



<p>（5）进入当前正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令1:进入容器后开启一个新的终端（相当于开启了另一个进程）</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令2：进入容器正在执行的终端中，不会启动新的进程</span></span><br><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure>



<p>（6）从容器中拷贝文件到主机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 2e18c3e0375a:/home/test.py /home/autovy/桌面</span><br></pre></td></tr></table></figure>

<p>拷贝是一个手动过程，从封闭的容器中拿到需要留存的数据，而使用数据卷</p>
<p>则可以实现自动同步</p>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>推荐文章：<a href="http://linyishui.top/2019101101.html">docker镜像讲解</a></p>
<h4 id="1-Portainer可视化工具"><a href="#1-Portainer可视化工具" class="headerlink" title="1.Portainer可视化工具"></a>1.Portainer可视化工具</h4><h4 id="2-镜像简介"><a href="#2-镜像简介" class="headerlink" title="2.镜像简介"></a>2.镜像简介</h4><ul>
<li>镜像就是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于环境开会的软件（包括代码，运行时，库，环境变量，配置文件）</li>
<li>镜像来源：<ul>
<li>从远程仓库下载</li>
<li>自己制作的镜像DockerFile</li>
</ul>
</li>
</ul>
<h4 id="3-镜像加载原理"><a href="#3-镜像加载原理" class="headerlink" title="3.镜像加载原理"></a>3.镜像加载原理</h4><p>（1）联合文件系统（UnionFS）</p>
<p>镜像和容器不同，容器是彼此独立的，而容器是分层叠加的，可以共享相同的底层文件和目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846837.webp" alt="img"></p>
<p>（2）镜像加载原理</p>
<p>共享底层资源</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846524.png" alt="docker文件系统分层存储原理"></p>
<h4 id="4-分层理解"><a href="#4-分层理解" class="headerlink" title="4.分层理解"></a>4.分层理解</h4><p>基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846403.png" alt="基于Ubuntu Linux 16.04创建镜像"></p>
<p>docker镜像默认只读，当容器启动时，一个新的可写层被加载到镜像顶部</p>
<p>这一层即为容器层，容器之下称为镜像层</p>
<h4 id="5-commit镜像"><a href="#5-commit镜像" class="headerlink" title="5.commit镜像"></a>5.commit镜像</h4><p>提交一个新的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和git原理相似</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]</span><br></pre></td></tr></table></figure>



<h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><h4 id="1-数据卷原理"><a href="#1-数据卷原理" class="headerlink" title="1.数据卷原理"></a>1.数据卷原理</h4><p>容器之间有一个数据共享技术，Docker容器中产生的数据，同步到本地（从而实现数据可持久化，数据同步操作，数据存储在本地不会随着容器删除而丢失）</p>
<p>其本质是将容器内的目录挂载到主机上</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846330.png" alt="数据卷容器实践_heima201907的博客-CSDN博客"></p>
<h4 id="2-数据卷使用"><a href="#2-数据卷使用" class="headerlink" title="2.数据卷使用"></a>2.数据卷使用</h4><p>（1）使用命令挂载 -v</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录地址:容器目录地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试：将容器的目录挂载到主机目录</span></span><br><span class="line">docker run -it -v /home/test:/home centos /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>主机和容器没有对应目录时会自动创建目录</li>
<li>通过docker inspect 可以查看到挂载信息</li>
<li>挂载双方是双向同步关系，他们的文件内容无论哪一方更改，都会保持同步</li>
<li>修改文件时，只需要在本地修改即可，不需要进入容器</li>
</ul>
<p>（2）具名挂载和匿名挂载</p>
<p>除了上文中的指定路径挂载，我们也可以使用具名挂载和匿名挂载</p>
<p>匿名挂载：<code>-v :容器目录地址</code></p>
<p>具名挂载：<code>-v 卷名:容器目录地址</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">docker run -d -P --name test1 -v /home/new centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">docker run -d -P --name test1 -v mycentos:/home/new centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有卷(可以看到存在匿名卷)</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>

<p>所有的docker容器内的卷默认放在本地主机的<code>/var/lib/docker/volumes下</code></p>
<p>（3）挂载权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以通过 -v 容器路径：ro,rw改变读写权限</span></span><br><span class="line">ro # 只读，只能通过宿主机来操作，容器内部无法进行操作</span><br><span class="line">rw # 可读可写，默认为可读可写</span><br></pre></td></tr></table></figure>





<h4 id="3-数据卷容器"><a href="#3-数据卷容器" class="headerlink" title="3.数据卷容器"></a>3.数据卷容器</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846812.png" alt="Docker学习过程（5-数据卷）_gengli2017的博客-CSDN博客"></p>
<p>容器间也可以进行挂载从而实现数据同步，多个子容器的数据可以挂载到一个父容器中，这个父容器就是数据卷容器</p>
<p>–volumes-from即可以让docker3挂载到docker1上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name docker3 --volumes-from docker1 5ce91af318b3 /bin/bash</span><br></pre></td></tr></table></figure>

<p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</p>
<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>参考文章：<a href="https://blog.52itstyle.vip/archives/2839/">DokcerFile命令详解</a></p>
<h4 id="1-DockerFile简介"><a href="#1-DockerFile简介" class="headerlink" title="1.DockerFile简介"></a>1.DockerFile简介</h4><p>DockerFile是构建docker镜像的构建文件，即命令脚本。通过这个脚本我们可以生成一个镜像。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846366.png" alt="在这里插入图片描述"></p>
<h4 id="2-DockerFile构建流程"><a href="#2-DockerFile构建流程" class="headerlink" title="2.DockerFile构建流程"></a>2.DockerFile构建流程</h4><p>（1）DockerFile内容示例</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构建镜像形成两个数据卷，因为没有指定的挂载卷会自动进行匿名挂载</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;-----end------&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>



<p>（2）通过DockerFile文件构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f dockerfile -t test/centos .</span><br></pre></td></tr></table></figure>

<p>build命令， -f  打开dockerfile文件的路径，-t  test/centos命名容器，.即为生成路径</p>
<p>（3）用自己的镜像创建容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it 5ce91af318b3 /bin/bash</span><br></pre></td></tr></table></figure>



<p>（4）docker push 发布镜像（开源进行）</p>
<h4 id="3-DockerFile指令详解"><a href="#3-DockerFile指令详解" class="headerlink" title="3.DockerFile指令详解"></a>3.DockerFile指令详解</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040846106.png" alt="img"></p>
<p>（图中最后一项应为CMD指令此处更正）</p>
<p>补充项：</p>
<ul>
<li><p>CMD：指定这个容器启动时要运行的命令，只有最后一个会生效，可被替代</p>
</li>
<li><p>ENTRYPOINT：指定这个容器启动时要运行的命令，可以追加命令</p>
</li>
<li><p>COPY：类似于ADD，将我们文件拷贝到镜像中</p>
</li>
<li><p>ENV：构建的时候设置环境变量</p>
</li>
</ul>
<h4 id="4-创建自己的DockerFile"><a href="#4-创建自己的DockerFile" class="headerlink" title="4.创建自己的DockerFile"></a>4.创建自己的DockerFile</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> Autovy&lt;autovys@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录为/usr/local</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装相关依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开放端口80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;-----end------&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>

<p> 通过<code>docker history mycentos:0.1</code>  命令可以查看构建镜像的过程</p>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>docker</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>入门教程</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>开发笔记：自动化脚本实战手册</title>
    <url>/2021/03/28/python%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040841155.jpg" alt="python"></p>
<span id="more"></span>

<h2 id="Python-自动化实战手册"><a href="#Python-自动化实战手册" class="headerlink" title="Python 自动化实战手册"></a>Python 自动化实战手册</h2><h4 id="调用系统终端（cmd）"><a href="#调用系统终端（cmd）" class="headerlink" title="调用系统终端（cmd）"></a>调用系统终端（cmd）</h4><h5 id="1-运用场景"><a href="#1-运用场景" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>有一些工具是使用命令行来执行的，这时可以调用系统终端来实现自动化</p>
<p>如：</p>
<p>swftool：<a href="http://www.swftools.org/">http://www.swftools.org/</a>     （swf转换工具）</p>
<p>ffmpeg：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a>    （视频转码工具）</p>
<h5 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pdf转swf</span></span><br><span class="line">os.system(<span class="string">&#x27;E:\swftools\pdf2swf.exe -b E:\swftools\pdf\%s.pdf -o E:\swftools\swf\%s.swf&#x27;</span> % (name, name))</span><br></pre></td></tr></table></figure>



<h5 id="3-语法解释"><a href="#3-语法解释" class="headerlink" title="3.语法解释"></a>3.语法解释</h5><ul>
<li><p><code>import os</code>引入os模块，该模块主要提供与操作系统相关的功能的便捷式途径</p>
</li>
<li><p><code>os.system</code>可以在系统的子shell中执行命令，在windows上即相当于在cmd运行命令行，其返回值为命令退出的状态</p>
</li>
<li><p><code>os.system</code>运行命令行时无法实时显示运行过程，只能最终返回运行结果，这是和在cmd运行时的差别</p>
</li>
<li><p>使用<code>system</code>函数，会创建一个子进程，但是子进程无法影响父进程中的环境变量。简单来说，就是使用第一个<code>system</code>函数用cd切换目录，第二个<code>system</code>函数的环境变量仍然继承父进程的环境变量。所以第二个子进程的目录位置没有被第一条语句改变</p>
</li>
<li><p>关于新进程的生成和跟踪执行结果，往往用<code>subprocess</code>模块代替<code>system</code></p>
</li>
<li><p>在<code>system</code>函数执行多条语句的方法，可以使用复合语句，如：<code>os.system(&#39;cd path-to-repo &amp;&amp; svn ci&#39;)</code>，即都在一个子进程中运行命令</p>
</li>
<li><p>或者使用<code>os.chdir</code>切换父进程的目录，再执行子进程</p>
</li>
</ul>
<h4 id="文件遍历筛选"><a href="#文件遍历筛选" class="headerlink" title="文件遍历筛选"></a>文件遍历筛选</h4><h5 id="1-运用场景-1"><a href="#1-运用场景-1" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>在自动化批量操作文件时，一定少不了文件遍历，并且可以筛选出需要的文件</p>
<h5 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="2.实例"></a>2.实例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入python的标准库os库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 遍历文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="comment"># 初始化一个空列表存储文件</span></span><br><span class="line">    list_all = []</span><br><span class="line">    <span class="comment"># 搜索一个目录下的所有文件夹和所有文件内的指定类型文件</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">&#x27;E:\swftools\%s&#x27;</span> % name):</span><br><span class="line">        <span class="comment"># 获得文件名</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># 加上文件路径</span></span><br><span class="line">            dir_path = os.path.join(root, name)</span><br><span class="line">            <span class="comment"># 切割出文件名</span></span><br><span class="line">            dir_name = os.path.split(dir_path)[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 筛选文件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;.pdf&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;.swf&#x27;</span> <span class="keyword">in</span> name:</span><br><span class="line">                list_all.append(dir_name)</span><br><span class="line">        <span class="keyword">return</span> list_all</span><br></pre></td></tr></table></figure>



<h5 id="3-语法解释-1"><a href="#3-语法解释-1" class="headerlink" title="3.语法解释"></a>3.语法解释</h5><ul>
<li><code>os.walk(根目录)</code>可返回3元组 (dirpath, dirnames, filenames)【文件夹相对路径, 文件夹名字, 文件名】</li>
<li><code>os.path.join</code>拼接路径</li>
<li><code>os.path.split(path)</code>拆分路径为<code>(head, tail)</code></li>
</ul>
<h4 id="服务器操作"><a href="#服务器操作" class="headerlink" title="服务器操作"></a>服务器操作</h4><h5 id="1-运用场景-2"><a href="#1-运用场景-2" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>可以运用在将本地文件上传到服务器或者操作服务器上的文件，还可以调用服务器的终端（可用于在服务器上制作视频流）</p>
<h5 id="2-实例-2"><a href="#2-实例-2" class="headerlink" title="2.实例"></a>2.实例</h5><p>参考博客：</p>
<p><a href="https://www.jianshu.com/p/486dd9993125">https://www.jianshu.com/p/486dd9993125</a></p>
<p><a href="https://juejin.cn/post/6844904078057668615">https://juejin.cn/post/6844904078057668615</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="comment"># 建立ssh连接的同时，建立一个加密的文件传输通道</span></span><br><span class="line"><span class="comment"># 设置连接服务器信息</span></span><br><span class="line">t = paramiko.Transport((<span class="string">&quot;host（主机号）&quot;</span>, 端口（一般为<span class="number">22</span>）))</span><br><span class="line">t.connect(username=<span class="string">&quot;用户名&quot;</span>, password=<span class="string">&quot;密码&quot;</span>)</span><br><span class="line"><span class="comment"># 将sshclient的对象的transport指定为以上的t，即进行ssh连接</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh._transport = t</span><br><span class="line"><span class="comment"># ssh连接后在服务器终端运行命令，此处为复合语句</span></span><br><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd /../var/www/;pwd;&#x27;</span>)</span><br><span class="line"><span class="comment"># 开启sftp通道，传输文件</span></span><br><span class="line">sftp = ssh.open_sftp()</span><br><span class="line"><span class="comment"># 文件传输</span></span><br><span class="line">sftp.put(localpath=<span class="string">&#x27;本地路径&#x27;</span>, remotepath=<span class="string">&#x27;远程路径’)</span></span><br><span class="line"><span class="string"># 关闭通道</span></span><br><span class="line"><span class="string">sftp.close</span></span><br></pre></td></tr></table></figure>



<h5 id="3-语法解释-2"><a href="#3-语法解释-2" class="headerlink" title="3. 语法解释"></a>3. 语法解释</h5><ul>
<li><p>paramiko模块主要用于远程操作服务器，利用该模块，可以方便的进行ssh连接和sftp协议进行sftp文件传输</p>
</li>
<li><p><code>pip install paramiko</code>下载安装paramiko模块</p>
</li>
<li><p>使用paramiko模块有两种连接方式，一种是通过<code>paramiko.SSHClient()</code>函数，另外一种是通过<code>paramiko.Transport()</code>函数</p>
</li>
<li><p><code>exec_command</code>函数调用会返回3个变量，其中stdout为标准输出，在输出内容比较少时，可以通过直接使用read读取出所有的输出</p>
</li>
<li><p>sftp用get函数即下载远程文件，put函数即上传本地文件</p>
</li>
</ul>
<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><h5 id="1-运用场景-3"><a href="#1-运用场景-3" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>筛选统计数据库，或者可以利用数据库批量快捷发布网站内容（如基于wordpress的站点）</p>
<h5 id="2-实例-3"><a href="#2-实例-3" class="headerlink" title="2.实例"></a>2.实例</h5><p>参考文章：<a href="https://www.runoob.com/python3/python3-mysql.html">https://www.runoob.com/python3/python3-mysql.html</a></p>
<p>（1）引入所需库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> sshtunnel <span class="keyword">import</span> SSHTunnelForwarder</span><br></pre></td></tr></table></figure>



<p>（2）连接一般数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span>():</span></span><br><span class="line">	data = pymysql.connect(host=<span class="string">&#x27;数据库主机号&#x27;</span>, port=端口, user=<span class="string">&#x27;用户名&#x27;</span>, passwd=<span class="string">&#x27;密码&#x27;</span>, db=<span class="string">&#x27;数据库名&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>



<p>（3）连接需要跳板机的数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link_base</span>():</span></span><br><span class="line">    server = SSHTunnelForwarder(</span><br><span class="line">            (<span class="string">&#x27;跳板机主机号&#x27;</span>, <span class="number">22</span>),  <span class="comment"># B机器的配置</span></span><br><span class="line">            ssh_password=<span class="string">&quot;跳板机密码&quot;</span>,</span><br><span class="line">            ssh_username=<span class="string">&quot;跳板机用户名&quot;</span>,</span><br><span class="line">            remote_bind_address=(<span class="string">&#x27;数据库主机号&#x27;</span>, 数据库端口))</span><br><span class="line">	</span><br><span class="line">    server.start()</span><br><span class="line"></span><br><span class="line">    data = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,  <span class="comment"># 此处必须是是127.0.0.1</span></span><br><span class="line">                               port=server.local_bind_port,</span><br><span class="line">                               user=<span class="string">&#x27;数据库用户名&#x27;</span>,</span><br><span class="line">                               passwd=<span class="string">&#x27;数据库密码&#x27;</span>,</span><br><span class="line">                               db=<span class="string">&#x27;数据库名&#x27;</span></span><br><span class="line">                               )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>



<p>（4） 利用sql语句操作数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取目标id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql</span>():</span></span><br><span class="line">    <span class="comment"># 获得连接后的数据库</span></span><br><span class="line">    data = link()</span><br><span class="line">    <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    cursor = data.cursor()</span><br><span class="line">    <span class="comment"># 用execute执行sql语句操作数据库</span></span><br><span class="line">    sql = <span class="string">&quot;sql语句&quot;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果为查询操作</span></span><br><span class="line">    <span class="comment"># 获取指针指向的数据</span></span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    <span class="comment"># 输出获取的元组数据</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 如果为增删改操作</span></span><br><span class="line">	<span class="comment"># 提交到数据库执行</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行sql语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交到数据库执行</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">       <span class="comment"># 如果发生错误则回滚</span></span><br><span class="line">       db.rollback()</span><br><span class="line">    <span class="comment"># 关闭数据库连接</span></span><br><span class="line">	db.close()    </span><br></pre></td></tr></table></figure>



<h5 id="3-语法解释-3"><a href="#3-语法解释-3" class="headerlink" title="3.语法解释"></a>3.语法解释</h5><ul>
<li>连接数据库的核心模块为pymysql,可以通过<code>pip install PyMySQL</code>安装</li>
<li>当需要跳板机连接服务器对象时（可以说数据库服务器也可以是文件服务器），要用到sshtunnel模块，可以通过<code>pip install sshtunnel</code>安装</li>
<li>数据库由多张关系表构成，往往需要查询多个表才能得到自己需要的批量数据</li>
<li>通过cursor可以不断指定执行新的sql语句</li>
<li>sql语句可以善用where筛选语句，应选择查询对象是某个字段，而不是*（全表）</li>
</ul>
<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><h5 id="1-运用场景-4"><a href="#1-运用场景-4" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>自动化操作往往会涉及到字符串的筛选和修改，这时候就要用到python的字符串操作和正则匹配</p>
<h5 id="2-实例-4"><a href="#2-实例-4" class="headerlink" title="2.实例"></a>2.实例</h5><p>（1）python字符串处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单筛选出含有指定子字符串的字符串</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;.pdf&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;.swf&#x27;</span> <span class="keyword">in</span> name:</span><br><span class="line">	print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单字符串切片，利用find找到切点，再用字符串索引取出所需的字符串</span></span><br><span class="line">num = <span class="built_in">str</span>(i).find(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">title = <span class="built_in">str</span>(i)[:num]</span><br></pre></td></tr></table></figure>



<p>（2）正则表达式处理字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用正则匹配筛选字符串，并修改取代字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="comment"># 正则匹配</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;embed&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> pattern.search(content):</span><br><span class="line">      content = <span class="built_in">str</span>(content).replace(<span class="string">&#x27;.pdf&#x27;</span>, <span class="string">&#x27;.swf&#x27;</span>).replace(<span class="string">&#x27;pdf&#x27;</span>, <span class="string">&#x27;x-shockwave-flash&#x27;</span>).replace(<span class="string">&#x27;height=&quot;100%&quot;&#x27;</span>, <span class="string">&#x27;height=&quot;400&quot;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则匹配的两种方法</span></span><br><span class="line">prog = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">result = prog.match(string)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">result = re.match(pattern, string)</span><br></pre></td></tr></table></figure>



<h5 id="3-语法解释-4"><a href="#3-语法解释-4" class="headerlink" title="3.语法解释"></a>3.语法解释</h5><ul>
<li>正则表达式往往是用大于看，看是很难看懂的，比较有用的正则工具：<a href="https://regex101.com/">https://regex101.com/</a></li>
<li>正则查找有match和search两种方式</li>
<li><code>re.match()</code> 从第一个字符开始找, 如果第一个字符就不匹配就返回None, 不继续匹配. 用于判断字符串开头或整个字符串是否匹配,速度快</li>
<li><code>re.search()</code> 会整个字符串查找,直到找到一个匹配</li>
<li><code>re.compile()</code>将正则表达式的样式编译为一个正则对象，如果需要多次使用这个正则表达式的话，使用 <code>re.compile()</code>和保存这个正则对象以便复用，可以让程序更加高效</li>
</ul>
<h4 id="Word文档操作"><a href="#Word文档操作" class="headerlink" title="Word文档操作"></a>Word文档操作</h4><h5 id="1-运用场景-5"><a href="#1-运用场景-5" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>在办公中可以批量生成只有日期和名字改动的模板，可以读取一篇word文档生成计算机可以处理的数据</p>
<h5 id="2-实例-5"><a href="#2-实例-5" class="headerlink" title="2.实例"></a>2.实例</h5><p>（1）引入基本模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负责新建文档</span></span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="comment"># 对齐</span></span><br><span class="line"><span class="keyword">from</span> docx.enum.text <span class="keyword">import</span> WD_ALIGN_PARAGRAPH</span><br><span class="line"><span class="comment"># 磅数</span></span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> Pt</span><br><span class="line"><span class="comment"># 中文格式</span></span><br><span class="line"><span class="keyword">from</span> docx.oxml.ns <span class="keyword">import</span> qn</span><br></pre></td></tr></table></figure>



<p>（2）文档基础设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个文档</span></span><br><span class="line">document = Document()</span><br><span class="line"><span class="comment"># 设置文档基础字体,注意该处的styles有个s</span></span><br><span class="line">document.styles[<span class="string">&#x27;Normal&#x27;</span>].font.name = <span class="string">u&#x27;微软雅黑&#x27;</span></span><br><span class="line">document.styles[<span class="string">&#x27;Normal&#x27;</span>].font.size = Pt(<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置文档基础中文字体</span></span><br><span class="line">document.styles[<span class="string">&#x27;Normal&#x27;</span>].element.rPr.rFonts.<span class="built_in">set</span>(qn(<span class="string">&#x27;w:eastAsia&#x27;</span>), <span class="string">u&#x27;微软雅黑&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>（3）创建纯文字模板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_context</span>(<span class="params">context</span>):</span></span><br><span class="line">	<span class="comment"># 创建自然段</span></span><br><span class="line">	p = document.add_paragraph()</span><br><span class="line">	<span class="comment"># 设置该自然段对齐方式</span></span><br><span class="line">	p.alignment = WD_ALIGN_PARAGRAPH.LEFT</span><br><span class="line">	<span class="comment"># 在该自然段添加文字</span></span><br><span class="line">	r = p.add_run(<span class="built_in">str</span>(context))</span><br><span class="line">	<span class="comment"># 设置字体格式</span></span><br><span class="line">	r.font.size = Pt(<span class="number">16</span>)</span><br><span class="line">    <span class="comment"># 段后距离5磅</span></span><br><span class="line">    p1.space_after = Pt(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 段前距离5磅</span></span><br><span class="line">    p1.space_after = Pt(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<p>（4）创建表格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height = <span class="built_in">len</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># 文档插入表格</span></span><br><span class="line">table = document.add_table(rows=height, cols=<span class="number">5</span>, style=<span class="string">&#x27;Table Grid&#x27;</span>)</span><br><span class="line"><span class="comment"># 填写字段</span></span><br><span class="line">table.cell(<span class="number">0</span>, <span class="number">0</span>).text = <span class="string">&#x27;序号&#x27;</span></span><br><span class="line">table.cell(<span class="number">0</span>, <span class="number">1</span>).text = <span class="string">&#x27;网址名称&#x27;</span></span><br><span class="line">table.cell(<span class="number">0</span>, <span class="number">2</span>).text = <span class="string">&#x27;网址&#x27;</span></span><br><span class="line">table.cell(<span class="number">0</span>, <span class="number">3</span>).text = <span class="string">&#x27;责任部门&#x27;</span></span><br><span class="line">table.cell(<span class="number">0</span>, <span class="number">4</span>).text = <span class="string">&#x27;负责人姓名&#x27;</span></span><br></pre></td></tr></table></figure>



<p>（5）存储文档</p>
<p>注意要标注后缀为docx，否则打不开文件，储存位置为程序根目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">document.save(<span class="string">&#x27;test.docx&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>（6）读取文档</p>
<p>可用于将记录题目的word文档转换为计算机可以处理的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="comment"># 打开一个文档</span></span><br><span class="line">document = Document(<span class="string">&quot;C语言.docx&quot;</span>)</span><br><span class="line"><span class="comment"># 获取所有段落</span></span><br><span class="line">all_paragraphs = document.paragraphs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维数组存储一道题</span></span><br><span class="line">passage = [[]]</span><br><span class="line">sent = []</span><br><span class="line"><span class="comment"># 逐个读取段落,一般不读取run中的，因为会出现文字割裂的问题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(all_paragraphs)):</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d&#x27;</span>)</span><br><span class="line">    matching = pattern.findall(all_paragraphs[i].text)</span><br><span class="line">    <span class="keyword">if</span> matching:</span><br><span class="line">        <span class="comment"># 重置单个题目的列表</span></span><br><span class="line">        passage.append(sent)</span><br><span class="line">        sent = []</span><br><span class="line">        sent.append(all_paragraphs[i].text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sent.append(all_paragraphs[i].text)</span><br></pre></td></tr></table></figure>



<p>（7）修改文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取word文件</span></span><br><span class="line">document = Document(<span class="string">&quot;资料2.0.docx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_text</span>(<span class="params">old_text, new_text</span>):</span></span><br><span class="line">    <span class="comment"># 修改纯文本</span></span><br><span class="line">    <span class="comment"># 复制粘贴word文档内容包括格式</span></span><br><span class="line">    all_paragraphs = document.paragraphs</span><br><span class="line">    <span class="keyword">for</span> paragraphs <span class="keyword">in</span> all_paragraphs:</span><br><span class="line">        <span class="keyword">for</span> run <span class="keyword">in</span> paragraphs.runs:</span><br><span class="line">            <span class="comment"># 修改文字</span></span><br><span class="line">            run_text = run.text.replace(old_text, new_text)</span><br><span class="line">            run.text = run_text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改表格</span></span><br><span class="line">    all_tables = document.tables</span><br><span class="line">    <span class="keyword">for</span> table <span class="keyword">in</span> all_tables:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> table.rows:</span><br><span class="line">           <span class="keyword">for</span> cell <span class="keyword">in</span> row.cells:</span><br><span class="line">                cell_text = cell.text.replace(old_text, new_text)</span><br><span class="line">                cell.text = cell_text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换字符串</span></span><br><span class="line">change_text(<span class="string">&#x27;社团&#x27;</span>, <span class="string">&#x27;协会&#x27;</span>)</span><br><span class="line"><span class="comment"># 可以覆盖保存，但注意要将打开程序关闭</span></span><br><span class="line">document.save(<span class="string">&quot;资料2.0.docx&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>8.word转pdf</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用win32模板的功能</span></span><br><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> Dispatch, constants, gencache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定读取docx的路径，保存pdf路径</span></span><br><span class="line">docx_path = <span class="string">&#x27;资料2.0.docx&#x27;</span></span><br><span class="line">pdf_path = <span class="string">&#x27;资料.pdf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指向offic的功能并调用</span></span><br><span class="line">gencache.EnsureModule(<span class="string">&#x27;&#123;00020905-0000-0000-C000-000000000046&#125;&#x27;</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用word服务，开始转换</span></span><br><span class="line">wd = Dispatch(<span class="string">&quot;Word.Application&quot;</span>)</span><br><span class="line">doc = wd.Documents.Open(docx_path, ReadOnly=<span class="number">1</span>)</span><br><span class="line">doc.ExportAsFixedFormat(pdf_path, constants.wdExportFormatPDF, Item=constants.wdExportDocumentWithMarkup,CreateBookmarks=constants.wdExportCreateHeadingBookmarks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出并保存</span></span><br><span class="line">wd.Quit(constants.wdDoNotSaveChanges)</span><br></pre></td></tr></table></figure>



<h5 id="3-语法解释-5"><a href="#3-语法解释-5" class="headerlink" title="3.语法解释"></a>3.语法解释</h5><ul>
<li>安装docx模块，<code>pip install python-docx</code></li>
<li>读取文档时要注意，<code>document.paragraphs</code>返回的数组的每一个元素即一行的内容</li>
<li>一维数组的增加可以直接使用append不断扩展数组<code>sent.append(&#39;str&#39;)</code></li>
<li>二维数组的二维增加，可以直接填入数组<code>passage.append(array)</code>，一维增加的前提的二维存在，否则会报错超出范围<code>passage[1].append(&#39;str&#39;)</code></li>
</ul>
<h4 id="Excel文档操作"><a href="#Excel文档操作" class="headerlink" title="Excel文档操作"></a>Excel文档操作</h4><h5 id="1-运用场景-6"><a href="#1-运用场景-6" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>办公中经常会用到excel表格来整理统计数据，利用python可以批量读取和写入表格，提高工作效率</p>
<h5 id="2-实例-6"><a href="#2-实例-6" class="headerlink" title="2.实例"></a>2.实例</h5><p>（1）xlrd库读取execl内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd  <span class="comment"># 引入xlrd库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入工作簿路径</span></span><br><span class="line">xlsx = xlrd.open_workbook(<span class="string">&#x27;E://考勤表.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定读取的工作表，也可以用工作表名字来索引</span></span><br><span class="line"><span class="comment"># table = xlsx.sheet_by_name(&quot;表名&quot;)</span></span><br><span class="line">table = xlsx.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定单元格的坐标值，并打印，注意不要超过单元格所有的内容否则会报错,以下三种形式是一致的</span></span><br><span class="line">print(table.cell_value(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(table.cell(<span class="number">1</span>, <span class="number">2</span>).value)</span><br><span class="line">print(table.row(<span class="number">1</span>)[<span class="number">2</span>].value)</span><br></pre></td></tr></table></figure>



<p>（2）xlwt库写入execl工作表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入xlwt库</span></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个工作簿</span></span><br><span class="line">new_workbook = xlwt.Workbook()</span><br><span class="line"><span class="comment"># 新建一个工作表</span></span><br><span class="line">worksheet = new_workbook.add_sheet(<span class="string">&#x27;sheet1&#x27;</span>)</span><br><span class="line"><span class="comment"># 在工作表指定坐标写入值</span></span><br><span class="line">worksheet.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存工作簿</span></span><br><span class="line">new_workbook.save(<span class="string">&#x27;test.xls&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Pandas分析数据"><a href="#Pandas分析数据" class="headerlink" title="Pandas分析数据"></a>Pandas分析数据</h4><h5 id="1-运用场景-7"><a href="#1-运用场景-7" class="headerlink" title="1.运用场景"></a>1.运用场景</h5><p>Pandas是一个强大的分析结构化数据的工具集；用于数据挖掘和数据分析，同时也提供数据清洗功能。</p>
<h5 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h5><p>参考文档：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p>
<p>读取excel数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用pandas打开excel</span></span><br><span class="line">file = pd.ExcelFile(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 指定表名，excel的数据以数组的形式返回</span></span><br><span class="line">data = file.parse(<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>开发实战</tag>
        <tag>脚本学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言|算法入门指南</title>
    <url>/2021/02/03/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904904.png" alt="image-20210210110218935"></p>
<span id="more"></span>



<h2 id="时间复杂度（Time-complexity）"><a href="#时间复杂度（Time-complexity）" class="headerlink" title="时间复杂度（Time complexity）"></a>时间复杂度（Time complexity）</h2><h3 id="1-一个例子"><a href="#1-一个例子" class="headerlink" title="1.一个例子"></a>1.一个例子</h3><p>情景：在一个有100个学生的教室里，仅有一名学生没过英语四级，我们要找到这名学生</p>
<ul>
<li>方法一：问每一个学生是否有过四级，时间复杂度为<strong>O(n)</strong></li>
<li>方法二：问每一个学生两个问题：1.是否有过四级 2.其他99个人过四级的情况，时间复杂度为<strong>O(n2)</strong></li>
<li>方法三：将100人分成两组，然后问没过四级的是在第一组还是在第二组，然后将该小组又分成两部分，再次询问，以此类推，直到最后找到没过四级的那个学生，时间复杂度为<strong>O(log n)</strong></li>
</ul>
<p>如果只有一个学生知道笔隐藏在哪个学生上，我可能需要进行O（n2）搜索。如果一个学生拿着笔，只有他们自己知道，我会使用O（n）。如果所有学生都知道，我会使用O（log n）搜索，但是只会告诉我是否猜对了。</p>
<h3 id="2-时间复杂度的含义"><a href="#2-时间复杂度的含义" class="headerlink" title="2.时间复杂度的含义"></a>2.时间复杂度的含义</h3><p>时间复杂度并不等于程序执行时间，我们没有考虑执行代码中每个语句所需的实际时间，而是考虑每个语句执行多少次</p>
<h3 id="3-时间复杂度图示"><a href="#3-时间复杂度图示" class="headerlink" title="3.时间复杂度图示"></a>3.时间复杂度图示</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040903611.png" alt="image-20210210104634026"></p>
<h3 id="4-时间复杂度计算方法"><a href="#4-时间复杂度计算方法" class="headerlink" title="4.时间复杂度计算方法"></a>4.时间复杂度计算方法</h3><ul>
<li>将算法/功能分解为单独的操作</li>
<li>计算每个操作的复杂度</li>
<li>将每个操作的复杂度加起来</li>
<li>删除常量</li>
<li>找到最高阶项-这就是我们认为算法/函数的复杂度</li>
</ul>
<h2 id="经典算法一览"><a href="#经典算法一览" class="headerlink" title="经典算法一览"></a>经典算法一览</h2><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904904.png" alt="image-20210210110218935"></p>
<h2 id="辗转相除法（Euclidean-algorithm）"><a href="#辗转相除法（Euclidean-algorithm）" class="headerlink" title="辗转相除法（Euclidean algorithm）"></a>辗转相除法（Euclidean algorithm）</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul>
<li>辗转相除法又称为欧几里得算法，常用于求解最大公约数</li>
<li>算法原理：若a除以b的余数为r , 则有 gcd(a , b) = gcd( b ,r )</li>
<li>算法思路：大数除于小数得余数，该余数再与小数重复上面步骤，直到最后得小数为0，这时大数即为最大公约数</li>
</ul>
<h3 id="2-基本案例"><a href="#2-基本案例" class="headerlink" title="2.基本案例"></a>2.基本案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归函数辗转相除返回最大公约数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> b;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> gcd(b%a, a);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果展示 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">15</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;GCD(%d, %d)=%d\n&quot;</span>, a, b, gcd(a,b));</span><br><span class="line">	</span><br><span class="line">	a = <span class="number">35</span>; </span><br><span class="line">	b = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;GCD(%d, %d)=%d\n&quot;</span>, a, b, gcd(a,b));</span><br><span class="line">	</span><br><span class="line">	a = <span class="number">31</span>; </span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;GCD(%d, %d)=%d\n&quot;</span>, a, b, gcd(a,b));	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法解析：</p>
<ul>
<li><code>b%a</code>即b除以a后的余数，当b&lt;a时，返回b，所以在以上程序中，我们不需要比较a，b大小，比如gcd(35,10) ,经过<code>b%a</code>会变成gcd(10,35)</li>
<li>递归是一种特殊的循环，其停止的信号是<code>return</code>语句</li>
<li>以上程序的时间复杂度是：O(Log min(a, b))  </li>
</ul>
<h3 id="3-扩展案例"><a href="#3-扩展案例" class="headerlink" title="3.扩展案例"></a>3.扩展案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// gcd扩展版，不仅可以得到最大公约数，还可以找到整数系数x和y</span></span><br><span class="line"><span class="comment">// ax + by = gcd(a, b) </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcdExtended</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">		*x = <span class="number">0</span>;</span><br><span class="line">		*y = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// x1,y1存储递归调用的结果</span></span><br><span class="line">	<span class="keyword">int</span> x1,y1;</span><br><span class="line">	<span class="keyword">int</span> gcd = gcdExtended(b%a, a, &amp;x1, &amp;y1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新x,y值 </span></span><br><span class="line">	*x = y1 - (b/a) * x1;</span><br><span class="line">	*y = x1;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> gcd; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">15</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> g = gcdExtended(a, b, &amp;x, &amp;y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a*%d + b*%d = %d &quot;</span>, x, y, g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>语法解析：</p>
<ul>
<li>以上程序目的是为了计算：  <code>ax + by = gcd(a, b)</code> 中的x，y</li>
<li>本程序使用了指针，可以在另一个函数中修改主函数的值，避免变量作用域的问题。在主函数内，可以通过<code>&amp;x,&amp;y</code>将x，y的地址传给其他函数，其他函数定义指针<code>int *x, int *y</code>存储地址，然后再用<code>*x,*y</code>读取地址中存的值即可修改主函数中的变量</li>
<li><code>int gcd = gcdExtended(b%a, a, &amp;x1, &amp;y1);</code>使程序反复执行其上面的语句，直至a==0,这时可以得到gcd,和x1=0，y1=1的初始值。然后再开始与以上执行方向相反执行其下面的语句。最后<code>return gcd</code>实际上在第二部分的循环中，值不变</li>
<li>主函数执行时，<code>gcdExtended</code>中的地址是主函数<code>x，y</code>的地址，而递归函数中的地址是<code>x1，y1</code>的地址;<code>x1,y1</code>存储的是上一个循环中的<code>*x，*y</code></li>
</ul>
<h2 id="埃拉托斯特尼筛法（sieve-of-Eratosthenes）"><a href="#埃拉托斯特尼筛法（sieve-of-Eratosthenes）" class="headerlink" title="埃拉托斯特尼筛法（sieve of Eratosthenes）"></a>埃拉托斯特尼筛法（sieve of Eratosthenes）</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>埃拉托斯特尼筛法是一种常用的素数筛法，可以筛选一定范围自然数内的质数（Prime numbers），时间复杂度：O(<em>n</em> log log <em>n</em>)</p>
<p>埃拉托斯特尼筛法演示动画（摘自维基百科）</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="img"></p>
<h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><p>该筛法的基本步骤案例，筛选2-50范围内的素数</p>
<p>（1）创建2-50所有数字的列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904338.png" alt="image-20210214200912413"></p>
<p>（2）标记所有<strong>2的倍数</strong>且<strong>大于或等于其平方（即4）</strong>的数字</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904399.png" alt="image-20210214200920690"></p>
<p>（3）标记所有<strong>3的倍数</strong>且<strong>大于或等于其平方（即9）</strong>的数字</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904633.png" alt="image-20210214202117142"></p>
<p>（4）标记所有<strong>5的倍数</strong>且<strong>大于或等于其平方（即25）</strong>的数字</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904951.png" alt="image-20210214202159136"></p>
<p>（5）标记所有<strong>7的倍数</strong>且<strong>大于或等于其平方（即49）</strong>的数字</p>
<p>​    查无数字，则跳过这一步</p>
<p>（6）去掉列表中标记的数字，剩下的未被标记数字即为素数：2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47.</p>
<h3 id="3-基本案例"><a href="#3-基本案例" class="headerlink" title="3.基本案例"></a>3.基本案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 筛选素数函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SieveOfEratosthenes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建标识数组</span></span><br><span class="line">	<span class="keyword">bool</span> primes[n+<span class="number">1</span>]; </span><br><span class="line">	<span class="comment">// 标识数组默认填入true,用索引当作自然数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		</span><br><span class="line">		primes[i] = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开始标记非质数（即标记p的倍数且大于或等于其平方的数字） </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>; p*p&lt;=n; p++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(primes[p] == <span class="literal">true</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=p*p; i&lt;=n; i+=p)&#123;</span><br><span class="line">				primes[i] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印出所有素数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>; p&lt;=n; p++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(primes[p])&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入筛选范围:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	SieveOfEratosthenes(n); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="线性查找（Linear-search）"><a href="#线性查找（Linear-search）" class="headerlink" title="线性查找（Linear search）"></a>线性查找（Linear search）</h2><h3 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>线性查找时间复杂度为：O(n)</p>
<p>线性查找的步骤如下：</p>
<ul>
<li>从arr []的最左边元素开始，然后将x与arr []的每个元素一一比较</li>
<li>如果x与元素匹配，则返回索引。</li>
<li>如果x与任何元素都不匹配，则返回-1。</li>
</ul>
<p>线性查找示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040904177.gif" alt="img"></p>
<h3 id="2-基本案例-1"><a href="#2-基本案例-1" class="headerlink" title="2.基本案例"></a>2.基本案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性查找函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逐个遍历查找，n为数组长度 ，x为查找对象 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(arr[i]==x)&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 目标数组 </span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找目标</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 测量数组大小</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找过程</span></span><br><span class="line">	<span class="keyword">int</span> result = search(arr, n, x);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	(result==<span class="number">-1</span>)? <span class="built_in">printf</span>(<span class="string">&quot;目标不存在&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;目标所在索引为%d&quot;</span>, result);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>





<h2 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h2><h3 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>二分查找的对象是从小到大的数组，其时间复杂度可以写作：O(Log n)</p>
<p>二分查找步骤：</p>
<ul>
<li>将x与中间元素比较</li>
<li>如果x与中间元素匹配，则返回中间索引</li>
<li>否则如果x大于中间元素则取中间元素后右半边数组重复操作</li>
<li>否则如果x小于中间元素则取中间元素后左半边数组重复操作</li>
</ul>
<p>二分查找示意图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040905289.gif" alt="“Binary Search”"></p>
<h3 id="2-基本案例-2"><a href="#2-基本案例-2" class="headerlink" title="2.基本案例"></a>2.基本案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="comment">// 递归法二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(r &gt;= l)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 求中间元素</span></span><br><span class="line">		<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 情况1：如果目标与中间元素匹配 </span></span><br><span class="line">		<span class="keyword">if</span>(arr[mid] == x)&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 情况2:如果目标小于中间元素</span></span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt; x)&#123;</span><br><span class="line">			<span class="comment">// 返回以中间-1为右的递归 </span></span><br><span class="line">			<span class="keyword">return</span> binarySearch(arr, l, mid<span class="number">-1</span>, x);</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 情况3：如果目标大于中间元素</span></span><br><span class="line">		<span class="comment">// 返回以中间+1为左的递归 </span></span><br><span class="line">		<span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, r, x);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查无结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 目标数组 </span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找目标</span></span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 测量数组大小</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找过程,定左右 </span></span><br><span class="line">	<span class="keyword">int</span> result =  binarySearch(arr, <span class="number">0</span>, n - <span class="number">1</span>, x);</span><br><span class="line">	</span><br><span class="line">	(result==<span class="number">-1</span>) ? <span class="built_in">printf</span>(<span class="string">&quot;目标不存在&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;目标所在索引为%d&quot;</span>, result);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">		</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="哈希表（Hash-table）"><a href="#哈希表（Hash-table）" class="headerlink" title="哈希表（Hash table）"></a>哈希表（Hash table）</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>哈希表是一种<strong>数据结构</strong>，其以键值对的形式表示数据。每一个键都映射哈希表中的一个值（与关联数组类似）</p>
<p>在哈希表中，对键进行处理以生成映射到所需元素的新索引。此过程称为hashing。</p>
<p>哈希表是存储和检索元素的有效方法，所以其也是一种有效的<strong>查找算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040905182.png" alt="“hashing”示意图"></p>
<h3 id="2-实现步骤-1"><a href="#2-实现步骤-1" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h3><p>（1）哈希表初始化</p>
<p>​    在将元素插入数组前，将数组默认值设为-1（-1表示元素不存    在或特定的索引可以插入）</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040905313.png" alt="image-20210215110519122"></p>
<p>（2）插入元素</p>
<p>​    哈希表插入元素的经典算法是：<code>key =  element % size</code> （key即数据插入位置，element即元素，size即数组大小）</p>
<p>​    如插入数字24</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040905850.png" alt="image-20210215111157606"></p>
<p>（3）搜索元素</p>
<p>搜索元素和插入元素使用同一算法获得索引（key），再按索引查找对应元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906618.png" alt="image-20210215111443960"></p>
<p>（4）删除元素</p>
<p>在哈希表中删除元素并不是指将数组中的元素移除，而是将元素的值初始化为-1</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906635.png" alt="image-20210215111738024"></p>
<h3 id="3-基本案例-1"><a href="#3-基本案例-1" class="headerlink" title="3.基本案例"></a>3.基本案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> size 7 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建数组作为基本结构</span></span><br><span class="line"><span class="keyword">int</span> arr[size]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表初始化，将所有元素赋值为-1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">		arr[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = value % size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(arr[key] == <span class="number">-1</span>)&#123;	</span><br><span class="line">		arr[key] = value;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d 插入到 arr[%d]\n&quot;</span>, value, key);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该位置存在冲突&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = value % size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(arr[key] == value)&#123;</span><br><span class="line">		arr[key] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该值不存在&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = value % size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(arr[key] == value)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查有此项&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查无此项&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, i, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化哈希表 </span></span><br><span class="line">	init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 填充哈希表  </span></span><br><span class="line">	insert(<span class="number">10</span>);</span><br><span class="line">	insert(<span class="number">4</span>);</span><br><span class="line">	insert(<span class="number">2</span>);</span><br><span class="line">	insert(<span class="number">5</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印哈希表</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	print(); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 删除测试</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	del(<span class="number">5</span>); </span><br><span class="line">	print();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查询测试</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	search(<span class="number">4</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="4-哈希冲突（collision）"><a href="#4-哈希冲突（collision）" class="headerlink" title="4.哈希冲突（collision）"></a>4.哈希冲突（collision）</h3><p>如果存在插入元素算法得到得索引相同，会出现哈希冲突的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906057.png" alt="image-20210215151206845"></p>
<p>以下介绍几种避免哈希冲突的方法</p>
<h3 id="5-线性探测-Linear-Probing"><a href="#5-线性探测-Linear-Probing" class="headerlink" title="5.线性探测(Linear Probing)"></a>5.线性探测(Linear Probing)</h3><p>（1）方法简介：通过<code>key = element % size</code>计算索引，如果该索引为空则直接填入，如果产生了冲突就检查下一个索引即<code>key = (key+1) % size</code>，重复执行该过程直到找到空间</p>
<p>（2）方法示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906001.png" alt="image-20210215153740661"></p>
<p>空间不足的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906542.png" alt="image-20210215154203024"></p>
<h3 id="6-单独链表法（separate-chaining）"><a href="#6-单独链表法（separate-chaining）" class="headerlink" title="6.单独链表法（separate chaining）"></a>6.单独链表法（separate chaining）</h3><p>（1）方法简介</p>
<p>单独链表法又被称为开放式哈希表（Open hashing），它采用数据结构中的链表（linked list）来解决哈希冲突的问题，这样的哈希表永远也不会被填满</p>
<p>这种方法使哈希表的每个单元指向具有相同索引值的链表</p>
<p>（2）方法示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906224.png" alt="image-20210215160449318"></p>
<p>（3）使用案例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> size 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="comment">// 存储该节点内容 </span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  存储下一个节点的地址 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单独链表（每一个哈希表的索引一条链表）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">chain</span>[<span class="title">size</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表初始化，每一列填入NULL </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">		chain[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表中插入元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 创造新节点存储数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">newNode</span> =</span> (struct node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">	newNode-&gt;data = value;</span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算索引（hash key）</span></span><br><span class="line">	<span class="keyword">int</span> key = value % size;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查单独链表是否为空</span></span><br><span class="line">	<span class="comment">// 为空则填入新节点 </span></span><br><span class="line">	<span class="keyword">if</span>(chain[key] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		chain[key] = newNode;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 不为空即产生了哈希冲突 </span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 需要在已有的末端节点后添加新节点</span></span><br><span class="line">		<span class="comment">// 获得指定索引的链表 </span></span><br><span class="line">		struct node *temp = chain[key];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 遍历链表得到末端节点 </span></span><br><span class="line">		<span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">			temp = temp-&gt;next; </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 在末尾连接上新节点 </span></span><br><span class="line">		temp-&gt;next = newNode; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表中搜索元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = value % size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> chain[key];</span><br><span class="line">	<span class="comment">// 遍历链表寻找元素 </span></span><br><span class="line">	<span class="keyword">while</span>(temp)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;data == value)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表中删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = value % size;</span><br><span class="line">	<span class="comment">// 存储头部节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> chain[key],*dealloc;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="comment">// 如果需要删除的元素在头部 </span></span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;data == value)&#123;</span><br><span class="line">			dealloc = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(dealloc);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">// 遍历链表寻找需要删除的元素 </span></span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">				<span class="keyword">if</span>(temp-&gt;next-&gt;data == value)&#123;</span><br><span class="line">					dealloc = temp-&gt;next;</span><br><span class="line">					temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">					<span class="built_in">free</span>(dealloc);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">				&#125;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> chain[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;chain[%d]--&gt;&quot;</span>,i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">// 打印链表	</span></span><br><span class="line">		<span class="keyword">while</span>(temp)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>, temp-&gt;data);</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行实例</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">// 初始化哈希表</span></span><br><span class="line">	init();</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// 填充数据</span></span><br><span class="line">    insert(<span class="number">7</span>);</span><br><span class="line">    insert(<span class="number">0</span>);</span><br><span class="line">    insert(<span class="number">3</span>);</span><br><span class="line">    insert(<span class="number">10</span>);</span><br><span class="line">    insert(<span class="number">4</span>);</span><br><span class="line">    insert(<span class="number">5</span>);  </span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> 	print(); </span><br><span class="line"> 	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 删除测试</span></span><br><span class="line">	<span class="keyword">if</span>(del(<span class="number">10</span>))&#123;</span><br><span class="line">		print(); </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除项不存在&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><h3 id="1-基本概念-5"><a href="#1-基本概念-5" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>（1）冒泡排序通过重复交换错误顺序的两个数来工作</p>
<p>（2）冒泡排序步骤：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p>（3）冒泡排序示意图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906428.gif" alt="“Bubble Sort gif”的图片搜索结果"></p>
<h3 id="2-基本案例-3"><a href="#2-基本案例-3" class="headerlink" title="2.基本案例"></a>2.基本案例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数字函数(此处的参数为地址，可以直接修改主函数中的值)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *xp;</span><br><span class="line">	*xp = *yp;</span><br><span class="line">	*yp = temp;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="comment">// 从头开始的次数 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123; </span><br><span class="line">	    <span class="comment">// 移动读取数组相邻两个数 </span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">			<span class="comment">// 符合条件，交换数值 </span></span><br><span class="line">			<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">				swap(&amp;arr[j], &amp;arr[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAarry</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;; </span><br><span class="line">	<span class="comment">// 计算数组大小 </span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">// 冒泡处理 </span></span><br><span class="line">	bubbleSort(arr, n);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序后的数组：\n&quot;</span>);</span><br><span class="line">	printAarry(arr, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="快速排序（Quick-sort）"><a href="#快速排序（Quick-sort）" class="headerlink" title="快速排序（Quick sort）"></a>快速排序（Quick sort）</h2><p>参考文章：<a href="https://juejin.cn/post/6844904122538278920">https://juejin.cn/post/6844904122538278920</a></p>
<h3 id="1-基本概念-6"><a href="#1-基本概念-6" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>（1）快速排序是一种分而治之的算法，它会一个元素为枢纽键对数组进行分区，枢纽有以下几种选择，本文以最简单的最后一个元素为枢纽为例</p>
<ul>
<li>始终选择第一个元素作为枢轴</li>
<li>始终选择最后一个元素作为枢轴</li>
<li>选择一个随机元素作为枢轴。</li>
<li>选择中位数作为枢轴</li>
</ul>
<p>（2）实现步骤</p>
<ul>
<li>在给定数组中确定一个元素x作为枢纽</li>
<li>将x放在排序数组中的正确位置</li>
<li>将小于x的元素放在x之前</li>
<li>将大于x的元素放在x之后</li>
<li>去掉枢纽分成两组后重复以上操作</li>
</ul>
<p>以末尾元素为枢纽排序示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040906440.png" alt="image-20210226194704522"></p>
<p>​    （3）将小于x的元素放在x之前，将大于x的元素放在x之后这一步是将一个数组分成两个数组，其运用到了分而治之的思想</p>
<ul>
<li><p>将一个数组分成两个数组的方法为：<br>先从数组右边找到一个比枢轴元素小的元素，将数组的第一个位置赋值为该元素；</p>
</li>
<li><p>再从数组的左边找到一个比枢轴元素大的元素，将从上面取元素的位置赋值为该值；</p>
</li>
<li><p>依次进行，直到左右相遇，把枢轴元素赋值到相遇位置。</p>
<p>示意图如下：</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17171276e5f8bb49?imageslim" alt="第一轮排序动态过程"></p>
<h3 id="2-基本案例-4"><a href="#2-基本案例-4" class="headerlink" title="2.基本案例"></a>2.基本案例</h3><p>基本案例中也运用了分而治之的方法，当操作步骤与上面步骤相异但是效果相同</p>
<ul>
<li>选择最后一个元素作为枢纽</li>
<li>从数组左端开始遍历一个数组，先设最左端元素为待交换元素。当遇到比枢纽值小的元素，就将其与待交换元素值相交换，并把下个元素设为待交换元素</li>
<li>完成遍历后，最后交换末尾元素与待交换元素，并返回待交换元素的索引</li>
<li>依据返回的索引将数组分成了两组：左边比枢纽元素小，右边比枢纽元素大</li>
<li>最后再递归分开处理左边数组和右边数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组大小\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;填入数组数据\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    quickSort(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;快速排序后的数组\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pIndex = partition(arr, start, end);</span><br><span class="line">        quickSort(arr, start, pIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, pIndex+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pIndex = start;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[end];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[pIndex]);</span><br><span class="line">            pIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[end], &amp;arr[pIndex]);</span><br><span class="line">    <span class="keyword">return</span> pIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>入门教程</tag>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言|最简管理系统</title>
    <url>/2020/06/15/C%E8%AF%AD%E8%A8%80%E6%9C%80%E7%AE%80%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>C语言结课作业：编写一个小型工资管理系统，用来管理职工的个人基本信息及工资薪酬等数据。在技术要求方面仅仅是要求了使用结构体数据类型，但基于我们的学习进度，考察的应该是用数组来储存。</p>
<!--more  -->



<h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><ol>
<li><p>每个职工的数据应包括：<strong>工号、姓名、性别、部门、基本工资、绩效工资、奖金、应发工资</strong>（应发工资=基本工资+绩效工资+奖金）。职工数据要求采用结构体数据类型。</p>
</li>
<li><p><strong>菜单显示：</strong>显示系统的一级功能菜单（数据输入、数据修改、数据处理、数据输出、退出）。</p>
</li>
<li><p><strong>数据输入</strong>：至少输入10个职工的各项数据（应发工资由系统自动计算，不需要输入）。<strong>录入的第一条记录用自已的真实姓名，部门为自己的真实班级。</strong>并将有自己真实姓名、班级的输出结果截屏保存到大作业总结报告中。</p>
</li>
<li><p><strong>数据修改</strong>：输入工号,修改指定工号的各项数据。输出修改完成后的全部职工数据。</p>
</li>
<li><p><strong>数据处理</strong>：处理方式包括：排序、查询。可提供子菜单让用户选择。其中：</p>
<p>1)<strong>排序</strong>：按工号排序，显示所有职工的全部数据。</p>
<p>2)<strong>查询</strong>：按工号查询，显示指定工号的全部数据。</p>
</li>
<li><p><strong>数据输出</strong>：输出全部职工的各项数据。</p>
</li>
<li><p><strong>退出</strong>：退出整个工资管理系统。</p>
</li>
</ol>
<h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><h5 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1.数据存储"></a>1.数据存储</h5><p>我使用的是结构体数组来自建一个数据库，放在全局环境下，将数据库设为一个全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自建数据库</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">staff</span> &#123;</span></span><br><span class="line"> 	</span><br><span class="line">	<span class="keyword">int</span>  id;</span><br><span class="line"> 	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"> 	<span class="keyword">char</span> sex[<span class="number">20</span>];</span><br><span class="line"> 	<span class="keyword">char</span> belong[<span class="number">20</span>];</span><br><span class="line"> 	<span class="keyword">int</span>  basic_pay;</span><br><span class="line">	<span class="keyword">int</span>  add_pay;</span><br><span class="line">	<span class="keyword">int</span>  reward_pay;</span><br><span class="line">	<span class="keyword">int</span>  all_pay;</span><br><span class="line"></span><br><span class="line"> &#125;data[<span class="number">999</span>] = &#123;</span><br><span class="line"> 	</span><br><span class="line">	&#123;<span class="number">44</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;技术部&quot;</span>, <span class="number">5000</span>, <span class="number">1000</span>, <span class="number">200</span>, <span class="number">6200</span> &#125;,</span><br><span class="line">	</span><br><span class="line">	&#123;<span class="number">14</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;运维部&quot;</span>, <span class="number">4000</span>, <span class="number">1000</span>, <span class="number">200</span>, <span class="number">5200</span> &#125;,</span><br><span class="line">	</span><br><span class="line">	&#123;<span class="number">56</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;网安部&quot;</span>, <span class="number">3000</span>, <span class="number">1000</span>, <span class="number">200</span>, <span class="number">4200</span> &#125;,</span><br><span class="line"> 		</span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure>



<p>另外还需要定义一个全局的数据库长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lenth &#x3D; 3;</span><br></pre></td></tr></table></figure>

<p>之所以直接定义为一个常量，而不是用sizeof这种方式来计算数组长度，因为我发现结构体数组用这种方式来计算数组长度会是一个大坑！所以还不如手动添加常量</p>
<h5 id="2-函数功能结构"><a href="#2-函数功能结构" class="headerlink" title="2.函数功能结构"></a>2.函数功能结构</h5><p>（1）函数声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数声明</span><br><span class="line">int create();    &#x2F;&#x2F;增</span><br><span class="line">int del();  	&#x2F;&#x2F;删</span><br><span class="line">int edit();    &#x2F;&#x2F;改</span><br><span class="line"></span><br><span class="line">int process();     &#x2F;&#x2F;处理 </span><br><span class="line">int req();     &#x2F;&#x2F;查</span><br><span class="line">int line();     &#x2F;&#x2F;排 </span><br><span class="line"></span><br><span class="line">int showall(); &#x2F;&#x2F;查询全部</span><br></pre></td></tr></table></figure>



<p>（2）函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单系统 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;****************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;主菜单：\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1.输入员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2.删除员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3.修改员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4.处理员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;5.显示所有员工信息\n&quot;</span>); </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;6.退出\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;****************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---请输入菜单项：---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;order); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(order==<span class="number">6</span>)&#123;		</span><br><span class="line">			</span><br><span class="line">			system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span>(order)&#123;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: 	create();<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: 	del();<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: 	edit();<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: 	process();<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: 	showall(); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:    <span class="built_in">printf</span>(<span class="string">&quot;\n404 NOT FOUND!&quot;</span>); getchar(); getchar(); system(<span class="string">&quot;cls&quot;</span>);	</span><br><span class="line">			</span><br><span class="line">			&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//增添信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信息 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工信息排序输出 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">line</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询员工信息 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">req</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询全部数据 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">showall</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>函数结构如下</p>
<p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20200615101249209.png" alt="image-20200615101249209"> </p>
<p>这些函数都会对全局中的数据库进行操作。</p>
<h3 id="菜单系统"><a href="#菜单系统" class="headerlink" title="菜单系统"></a>菜单系统</h3><p>main函数这里，就构建整体的函数调用框架，即本管理系统的菜单系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单系统 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">   	</span><br><span class="line">   <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;****************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;主菜单：\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1.输入员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2.删除员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3.修改员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4.处理员工信息\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;5.显示所有员工信息\n&quot;</span>); </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;6.退出\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;****************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---请输入菜单项：---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;order); </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(order==<span class="number">6</span>)&#123;		</span><br><span class="line">			</span><br><span class="line">			system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span>(order)&#123;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: 	create();<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: 	del();<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: 	edit();<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: 	process();<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: 	showall(); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:    <span class="built_in">printf</span>(<span class="string">&quot;\n404 NOT FOUND!&quot;</span>); getchar(); getchar(); system(<span class="string">&quot;cls&quot;</span>);	</span><br><span class="line">			</span><br><span class="line">			&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>菜单系统常用switch语句来调用各个函数，另外为了整个管理系统的输出整洁一点，我还用了</p>
<p>“stdlib.h”库中的清屏函数system(“cls”)</p>
<h3 id="增添员工信息"><a href="#增添员工信息" class="headerlink" title="增添员工信息"></a>增添员工信息</h3><p> 增添员工信息的基本设计思路：将新的信息填入到下一个数组空的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = lenth;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工工号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i].id); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工姓名：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;data[i].name); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工性别：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;data[i].sex); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工所属部门：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;data[i].belong);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);	 </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工基本工资：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i].basic_pay); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工绩效工资：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i].add_pay); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);		</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;新增员工奖金：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[i].reward_pay); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	data[i].all_pay = data[i].basic_pay + data[i].add_pay + data[i].reward_pay;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建成功！\n&quot;</span>);	</span><br><span class="line">	lenth++;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);	</span><br><span class="line">		</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p> 用在全局定义的lenth（突然发现自己记错了长度的英语单词2333）来确定新数据的填写地址，创建成功后要注意用<code>lenth++</code>，拓展数据的长度。</p>
<h3 id="删除员工信息"><a href="#删除员工信息" class="headerlink" title="删除员工信息"></a>删除员工信息</h3><p>删除员工信息的基本设计思路是：通过遍历所有的数据查询到指定的员工工号，然后将后面的数据依次向上填补被“删除”的空白</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除信息 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i = lenth;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n请输入删除员工工号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(num==data[j].id)&#123;</span><br><span class="line">			<span class="keyword">for</span>( ;j&lt;=i-j; j++)&#123;</span><br><span class="line">				</span><br><span class="line">				data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			lenth--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n删除成功!\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j==i+<span class="number">1</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n查无此人!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在遍历中用到了两个if语句，if(num==data[j].id)来寻找符合条件的员工号，而<code>if(j==i+1)</code>则是遍历所有的数据后未找到匹配条件。</p>
<p>说是删除实践上只是删除的数组元素的地位（下标）和财产（数据）被下一个数组元素给继承了，而下一个的数据元素的下标和数据又被下下个数据元素继承，以此类推。这里同样要注意用<code>lenth--</code>缩短数据长度。</p>
<h3 id="修改员工信息"><a href="#修改员工信息" class="headerlink" title="修改员工信息"></a>修改员工信息</h3><p>修改员工信息的思路和删除员工信息的思路相差无几：都需要查询定位对应的员工信息，不同的是定位后，这个还要修改员工的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i = lenth;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n请输入需要修改的员工工号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(num==data[j].id)&#123;</span><br><span class="line">					</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改姓名：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;data[j].name); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改性别：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;data[j].sex); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);	</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改所属部门：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;data[j].belong);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);	 </span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改基本工资：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[j].basic_pay); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);	</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改绩效工资：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[j].add_pay); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);		</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改奖金：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data[j].reward_pay); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			data[j].all_pay = data[j].basic_pay + data[j].add_pay + data[j].reward_pay;</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;修改成功！\n&quot;</span>);				</span><br><span class="line">			showall(); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j==i+<span class="number">1</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n查无此人!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">				</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓修改，无非是重新赋值罢了。</p>
<h3 id="处理信息"><a href="#处理信息" class="headerlink" title="处理信息"></a>处理信息</h3><p>处理信息分成了排序信息和查询信息两部分，所有采用菜单系统同样的方式来设计</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1.员工信息排序     2.员工信息查询\n&quot;</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请选择处理方式:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;order); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span>(order)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: line(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: req();  <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h5 id="1-信息排序"><a href="#1-信息排序" class="headerlink" title="1.信息排序"></a>1.信息排序</h5><p>说实话这个函数的设计是该项目唯一卡到我的地方，因为我一直把它理解成了“排序处理”，但我了解实际上的需求应该是“排序输出”，那问题就简单很多了，我的设计思路如下</p>
<p>将每个数组元素的地址看作是它们的住址，而员工工号信息就是它们的门牌号，把它们的门牌号记录下来，然后排列大小顺序，按顺序去拜访它们，期间它们的住处时是没有发生改变的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//员工信息排序输出 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">line</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> id_data[<span class="number">100</span>];</span><br><span class="line">	i = lenth;</span><br><span class="line">	<span class="keyword">char</span>* str[<span class="number">8</span>] = &#123;<span class="string">&quot;工号&quot;</span>, <span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;部门&quot;</span>, <span class="string">&quot;基本工资&quot;</span>, <span class="string">&quot;绩效工资&quot;</span>, <span class="string">&quot;奖金&quot;</span>, <span class="string">&quot;应发工资&quot;</span>&#125;; </span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">		</span><br><span class="line">		id_data[j] = data[j].id;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	qsort(id_data, i, <span class="keyword">sizeof</span>(id_data[<span class="number">0</span>]) , cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n排序成功！\n\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据表的字段输出	</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">8</span>; n++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%-12s&quot;</span> , str[n]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据排序输出	</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n1 = <span class="number">0</span>; n1&lt;i; n1++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> n2 = <span class="number">0</span>; n2&lt;i; n2++ )&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(id_data[n1] == data[n2].id)&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; %-10d&quot;</span>,    data[n2].id); </span><br><span class="line">		</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; %-10s&quot;</span>,    data[n2].name); </span><br><span class="line">			</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;   %-10s&quot;</span>,  data[n2].sex); </span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%-10s&quot;</span>,     data[n2].belong); </span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;    %-10d&quot;</span>, data[n2].basic_pay); </span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[n2].add_pay); 	</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[n2].reward_pay); </span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[n2].all_pay ); </span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">						</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line"> 	getchar();</span><br><span class="line"> 	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 依据代码，我的思路对应关系如下</p>
<ul>
<li>住址 ==&gt; 数组元素下标，即<code>data</code>数组的下标</li>
<li>门牌号 ==&gt;  <code>data[j].id</code></li>
<li>记录门牌号 ==&gt; 用了另一个数组：<code>id_data[j]</code> 来储存</li>
<li>排列门牌号大小 ==&gt; 将<code>id_data[j]</code> 存储的门牌号排序，这里使用了C语言内置的排序函数：qsort()</li>
<li>依次拜访 ==&gt; 两层循环，外层循环：<code>for(int n1 = 0; n1&lt;i; n1++)</code>循环名单上排列好的门牌号，内层循环：<code>for(int n2 = 0; n2&lt;i; n2++ )</code>，一个个去找符合名单上第一位的门牌号，然后输出</li>
</ul>
<p>另外注意，作为一个大学生的作业，使用内置的qsort()排序函数应该是非法的（狗头），应该使用冒泡排序或选择排序！</p>
<p>好，我摊牌啦，我就是想偷一下懒……</p>
<h5 id="2-查询员工信息"><a href="#2-查询员工信息" class="headerlink" title="2.查询员工信息"></a>2.查询员工信息</h5><p>查询的思路和删除信息，修改信息相似，没什么特别的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询员工信息 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">req</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i = lenth;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span>* str[<span class="number">8</span>] = &#123;<span class="string">&quot;工号&quot;</span>, <span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;部门&quot;</span>, <span class="string">&quot;基本工资&quot;</span>, <span class="string">&quot;绩效工资&quot;</span>, <span class="string">&quot;奖金&quot;</span>, <span class="string">&quot;应发工资&quot;</span>&#125;; </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n请输入需要查询员工工号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">8</span>; n++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%-12s&quot;</span> , str[n]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(num==data[j].id)&#123;</span><br><span class="line">	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %-10d&quot;</span>,    data[j].id); </span><br><span class="line">		</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %-10s&quot;</span>,    data[j].name); </span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;   %-10s&quot;</span>,  data[j].sex); </span><br><span class="line">				</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-10s&quot;</span>,     data[j].belong); </span><br><span class="line">				</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;    %-10d&quot;</span>, data[j].basic_pay); </span><br><span class="line">				</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[j].add_pay); 	</span><br><span class="line">				</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[j].reward_pay); </span><br><span class="line">				</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[j].all_pay ); </span><br><span class="line">				</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n查询成功！\n\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j==i+<span class="number">1</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; 无\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n查无此人!\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里输出数据表的表头，用了数组来存储字符串，要注意加<em>号：    `char</em> str[8]`</p>
<h3 id="查询全部数据"><a href="#查询全部数据" class="headerlink" title="查询全部数据"></a>查询全部数据</h3><p>无脑遍历输出即可，就是输出格式上要有调整，一般可以用<code>printf(&quot;%-9d&quot;)</code>占9个空格，左对齐的方式来调整输出格式，输出那里我也是为了美观才一个个去加空格调整格式，就不要吐槽我代码格式不整洁了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询全部数据 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">showall</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span>* str[<span class="number">8</span>] = &#123;<span class="string">&quot;工号&quot;</span>, <span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;部门&quot;</span>, <span class="string">&quot;基本工资&quot;</span>, <span class="string">&quot;绩效工资&quot;</span>, <span class="string">&quot;奖金&quot;</span>, <span class="string">&quot;应发工资&quot;</span>&#125;; </span><br><span class="line">	i = lenth - <span class="number">1</span>;</span><br><span class="line">	 </span><br><span class="line">	data[i].all_pay = 	data[i].basic_pay + data[i].add_pay + data[i].reward_pay;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;查询成功！\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">8</span>; n++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%-12s&quot;</span> , str[n]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">			</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %-10d&quot;</span>,    data[j].id); </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %-10s&quot;</span>,    data[j].name); </span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   %-10s&quot;</span>,  data[j].sex); </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%-10s&quot;</span>,     data[j].belong); </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;    %-10d&quot;</span>, data[j].basic_pay); </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[j].add_pay); 	</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[j].reward_pay); </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;  %-10d&quot;</span>,   data[j].all_pay ); </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	getchar();</span><br><span class="line"> 	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体来说，这个结课作业并不难，只用用课堂上的知识完全是可以完成了（我一个下午不到就写好）。</p>
<p>但事实上无论用哪门语言，增删改查的实现永远是入门重要的第一课，本项目和之前的python学生管理系统，都仅仅是在内部实现的数据增删改查，一旦退出程序，缓存就被清除了，无法保留。所以我们还应考虑——如何把这样的操作在文本中实现，如何连接mysql数据库实现同样增删改查的操作。</p>
<p>所以呀，流水的编程语言，铁打的管理系统，入门从管理系统开始！</p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>开发实战</category>
      </categories>
      <tags>
        <tag>开发实战</tag>
        <tag>C语言</tag>
        <tag>管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title>开发笔记：基于python开发学生管理系统</title>
    <url>/2020/05/28/python%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<img src="https://developer-tech.com/wp-content/uploads/sites/3/2020/12/python-right-business-programming-language-software-development-enterprise-2048x1318.jpg" height="300" alt="git" align="center">



<span id="more"></span>

<h3 id="模拟数据库"><a href="#模拟数据库" class="headerlink" title="模拟数据库"></a>模拟数据库</h3><p>用列表为主体储存全部学生信息，方便读取。用字典这种数据类型放置一个学生信息。方便对列表操作时整块操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [   <span class="comment">#列表</span></span><br><span class="line">		   <span class="comment">#字典	</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">        <span class="string">&quot;adress&quot;</span>:<span class="string">&quot;佛山&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Mary&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        <span class="string">&quot;adress&quot;</span>: <span class="string">&quot;广州&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;,  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jhon&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">        <span class="string">&quot;adress&quot;</span>: <span class="string">&quot;厦门&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="操作框架"><a href="#操作框架" class="headerlink" title="操作框架"></a>操作框架</h3><p>写代码优先规划好主框架，然后再补充功能函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            欢迎使用【学生管理系统】</span></span><br><span class="line"><span class="string">            0.退出系统</span></span><br><span class="line"><span class="string">            1.显示所有学生信息</span></span><br><span class="line"><span class="string">            2.新建学生信息</span></span><br><span class="line"><span class="string">            3.查询学生信息</span></span><br><span class="line"><span class="string">            4.修改学生信息</span></span><br><span class="line"><span class="string">            5.删除学生信息                            </span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          )</span><br><span class="line"></span><br><span class="line">    op = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的操作：&quot;</span>)) <span class="comment">#转化输入的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> op==<span class="number">1</span> :</span><br><span class="line">        print(<span class="string">&quot;显示所有学生信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> op==<span class="number">2</span> :</span><br><span class="line">        print(<span class="string">&quot;新建学生信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> op==<span class="number">3</span> :</span><br><span class="line">        print(<span class="string">&quot;查询学生信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> op==<span class="number">4</span> :</span><br><span class="line">        print(<span class="string">&quot;修改学生信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> op==<span class="number">5</span> :</span><br><span class="line">        print(<span class="string">&quot;删除学生信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> op==<span class="number">0</span> :</span><br><span class="line">        <span class="keyword">break</span>  						<span class="comment">#退出循环</span></span><br></pre></td></tr></table></figure>





<h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showall</span>() :</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas :</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;学生信息：&quot;</span>, data)</span><br></pre></td></tr></table></figure>

<p>1.Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串，相当于用data逐个存储列表datas的信息</p>
<p>2.值得注意的是，python的函数必须写在调用函数之前（毕竟没有声明嘛）</p>
<h3 id="新增学生"><a href="#新增学生" class="headerlink" title="新增学生"></a>新增学生</h3><p>用字典存储学生信息，用赋值的方法修改（添加）信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat</span>() :</span></span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;新增学生名字：&quot;</span>)</span><br><span class="line">    sex = <span class="built_in">input</span>(<span class="string">&quot;新增学生性别：&quot;</span>)</span><br><span class="line">    adress = <span class="built_in">input</span>(<span class="string">&quot;新增学生地址：&quot;</span>) <span class="comment">#变量储存</span></span><br><span class="line">    student = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">        <span class="string">&quot;sex&quot;</span>: sex,</span><br><span class="line">        <span class="string">&quot;adress&quot;</span>: adress</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    datas.append(student) <span class="comment">#新增列表的项</span></span><br></pre></td></tr></table></figure>



<h3 id="查询学生"><a href="#查询学生" class="headerlink" title="查询学生"></a>查询学生</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req</span>() :</span></span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;查询学生姓名：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span>  datas:</span><br><span class="line">        <span class="keyword">if</span>  data[<span class="string">&quot;name&quot;</span>] == name:</span><br><span class="line">            print(data)</span><br></pre></td></tr></table></figure>

<p>列表+字典的信息储存形式用循环遍历字典内容，data就是字典名</p>
<h3 id="修改学生信息"><a href="#修改学生信息" class="headerlink" title="修改学生信息"></a>修改学生信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>() :</span></span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;修改学生的姓名：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span>  datas:</span><br><span class="line">        <span class="keyword">if</span>  data[<span class="string">&quot;name&quot;</span>] == name:</span><br><span class="line">            print(<span class="string">&quot;修改前学生信息：&quot;</span>,data)</span><br><span class="line">            data[<span class="string">&quot;name&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;修改的名字：&quot;</span>)</span><br><span class="line">            data[<span class="string">&quot;sex&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;修改性别：&quot;</span>)</span><br><span class="line">            data[<span class="string">&quot;adress&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;修改地址：&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;修改后学生信息：&quot;</span>,data)</span><br></pre></td></tr></table></figure>

<p>循环遍历字典内容，赋值修改信息</p>
<h3 id="删除学生信息"><a href="#删除学生信息" class="headerlink" title="删除学生信息"></a>删除学生信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>() :</span></span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;删除学生的姓名：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span>  datas:</span><br><span class="line">        <span class="keyword">if</span>  data[<span class="string">&quot;name&quot;</span>] == name:</span><br><span class="line">            datas.remove(data)</span><br></pre></td></tr></table></figure>

<p>data中相当于存储了整个字典，把他一整个删去即可</p>
]]></content>
      <categories>
        <category>python</category>
        <category>实战笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>开发实战</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言|数据结构入门指南</title>
    <url>/2020/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040908422.png" alt="image-20210205093243144"></p>
<span id="more"></span>

<h3 id="数据结构入门指南（C语言版）"><a href="#数据结构入门指南（C语言版）" class="headerlink" title="数据结构入门指南（C语言版）"></a>数据结构入门指南（C语言版）</h3><p>（图片来源于《计算机是怎么跑起来的》一书和GeeksforGeeks网站）</p>
<h4 id="初识数据结构"><a href="#初识数据结构" class="headerlink" title="初识数据结构"></a>初识数据结构</h4><h5 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h5><p>数组是数据结构的基础。</p>
<p>数组在程序中往往是从内存整体中分配出一块连续的空间，数组反映了内存的物理结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040908422.png" alt="image-20210205093243144"></p>
<h5 id="2-数组的应用"><a href="#2-数组的应用" class="headerlink" title="2.数组的应用"></a>2.数组的应用</h5><p>以数组为基础的数据结构，可供各种各样的算法处理大量数据</p>
<h5 id="3-数据结构概念"><a href="#3-数据结构概念" class="headerlink" title="3.数据结构概念"></a>3.数据结构概念</h5><p>内存的物理结构无法改变，而数据结构可以通过程序在逻辑上改变内存的物理结构，使数据按照自己的相反分布</p>
<p>典型的数据结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909890.png" alt="image-20210205094134834"></p>
<h4 id="栈的实现方法（stack）"><a href="#栈的实现方法（stack）" class="headerlink" title="栈的实现方法（stack）"></a>栈的实现方法（stack）</h4><h5 id="1-栈的特点"><a href="#1-栈的特点" class="headerlink" title="1.栈的特点"></a>1.栈的特点</h5><p>栈中数据的使用顺序和堆积顺序是相反的，堆积顺序是从下到上，而使用顺序是从上到上，就好像干草堆一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909864.png" alt="image-20210205095057769"></p>
<p>这种数据存取方式称为LIFO（last in first out，后进先出），即最后存入的数据最先被处理</p>
<h5 id="2-栈的实现"><a href="#2-栈的实现" class="headerlink" title="2.栈的实现"></a>2.栈的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 构建数组作为栈的本体 </span></span><br><span class="line"><span class="keyword">char</span> Stack[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 栈顶指针，始终指向栈数据的最顶端 </span></span><br><span class="line"><span class="keyword">char</span> StackPointer = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈函数，存储数据 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">char</span> Data)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 数据存储在栈顶指针指向位置 </span></span><br><span class="line">	Stack[StackPointer] = Data;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新栈顶指针的值 </span></span><br><span class="line">	StackPointer++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈函数，读取数据 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新栈顶指针的值 </span></span><br><span class="line">	StackPointer--;</span><br><span class="line">	<span class="comment">// 在栈顶指针处取出数据 </span></span><br><span class="line">	<span class="keyword">return</span> Stack[StackPointer];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 运行实例 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//存储数据 </span></span><br><span class="line">	Push(<span class="number">1</span>);</span><br><span class="line">	Push(<span class="number">2</span>);</span><br><span class="line">	Push(<span class="number">3</span>);</span><br><span class="line">	Push(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读取数据 </span></span><br><span class="line">	<span class="keyword">while</span> (StackPointer !=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">char</span> result = Pop();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-原理图"><a href="#3-原理图" class="headerlink" title="3.原理图"></a>3.原理图</h5><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909584.png" alt="image-20210205104130629"></p>
<p>注意此图的栈底放在上面，最底部才是栈顶</p>
<h5 id="4-语法解释"><a href="#4-语法解释" class="headerlink" title="4.语法解释"></a>4.语法解释</h5><ul>
<li>最终实现效果是：存入顺序是1，2，3，4；取出顺序是4，3，2，1</li>
<li>栈的成分：数组，栈顶指针，入栈函数，出栈函数</li>
<li>入栈函数将数据压入栈中</li>
<li>出栈函数将数据从栈中弹出</li>
<li>存储5个数据，最后栈顶指针指向5的地址（地址4为最后一个数据），所以在出栈函数中，栈顶指针需要减1，才能取得第一个数据</li>
</ul>
<h4 id="队列的实现方法（queue）"><a href="#队列的实现方法（queue）" class="headerlink" title="队列的实现方法（queue）"></a>队列的实现方法（queue）</h4><h5 id="1-队列的特点"><a href="#1-队列的特点" class="headerlink" title="1.队列的特点"></a>1.队列的特点</h5><p>队列中最先存入的数据是被最先处理的，这种方式被称为FIFO（first in first out, 先进先出）。就像排队上车一样，先到的人就能先上车</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909768.png" alt="image-20210205154955234"></p>
<h5 id="2-队列的实现"><a href="#2-队列的实现" class="headerlink" title="2.队列的实现"></a>2.队列的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建作为队列本质的数组 </span></span><br><span class="line"><span class="keyword">char</span>  Queue[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 标识数据存储位置的索引 </span></span><br><span class="line"><span class="keyword">char</span> SetIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 标识数据读取位置的索引 </span></span><br><span class="line"><span class="keyword">char</span> GetIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 存储数据函数 </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">char</span> Data)</span></span>&#123;</span><br><span class="line"> 	<span class="comment">// 存入数据</span></span><br><span class="line">	 Queue [SetIndex] = Data;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 更新存储索引 </span></span><br><span class="line">	 SetIndex++;</span><br><span class="line">	  </span><br><span class="line">	 <span class="comment">// 到达数组末尾则折回开头 </span></span><br><span class="line">	 <span class="keyword">if</span>(SetIndex&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">	 	SetIndex = <span class="number">0</span>;</span><br><span class="line">	 &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 读取数据函数 </span></span><br><span class="line"> <span class="function"><span class="keyword">char</span> <span class="title">Get</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> Data;</span><br><span class="line"> 	</span><br><span class="line">	 <span class="comment">// 读取数据 </span></span><br><span class="line"> 	Data = Queue[GetIndex];</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 更新读取索引 </span></span><br><span class="line"> 	GetIndex++;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">//  到达数组末尾则折回开头 </span></span><br><span class="line"> 	<span class="keyword">if</span>(GetIndex&gt;=<span class="number">100</span>)&#123;</span><br><span class="line"> 		GetIndex = <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回读出数据 </span></span><br><span class="line">	<span class="keyword">return</span> Data;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 运行实例 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//存储数据 </span></span><br><span class="line">	Set(<span class="number">1</span>);</span><br><span class="line">	Set(<span class="number">2</span>);</span><br><span class="line">	Set(<span class="number">3</span>);</span><br><span class="line">	Set(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读取数据 </span></span><br><span class="line">	<span class="keyword">while</span> (GetIndex != SetIndex) &#123;</span><br><span class="line">		<span class="keyword">char</span> result = Get();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-原理图-1"><a href="#3-原理图-1" class="headerlink" title="3.原理图"></a>3.原理图</h5><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909593.png" alt="image-20210205161354653"></p>
<h5 id="4-语法解释-1"><a href="#4-语法解释-1" class="headerlink" title="4.语法解释"></a>4.语法解释</h5><ul>
<li>最终实现效果是：存入顺序是1，2，3，4；取出顺序是1，2，3，4</li>
<li>栈的成分：数组，数据存储指针，数据读取指针，存储函数，读取函数</li>
<li>队列的逻辑结构实际上是圆环，数据存满后又会回到开头开始存数据</li>
<li>数据读取指针和数据存储指针是一样的，走向一样，最终值（指存完数据和读完数据的最后值的值）也要相等</li>
</ul>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><h5 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h5><p>结构体即把若干个数据项汇集到一起并赋予其名字的一个整体</p>
<p>定义完结构体后，我们可以把结构体当作一个数据类型，可以用它来声明变量</p>
<p>每一个被汇集到结构体的每一个数据项叫做结构体的成员</p>
<h5 id="2-运用"><a href="#2-运用" class="headerlink" title="2.运用"></a>2.运用</h5><p>我们需要用到结构体数组来实现链表和二叉树</p>
<h5 id="3-内存分布"><a href="#3-内存分布" class="headerlink" title="3.内存分布"></a>3.内存分布</h5><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909289.png" alt="image-20210205182952994"></p>
<h4 id="链表的实现方法（Linked-list）"><a href="#链表的实现方法（Linked-list）" class="headerlink" title="链表的实现方法（Linked list）"></a>链表的实现方法（Linked list）</h4><h5 id="1-链表的特点"><a href="#1-链表的特点" class="headerlink" title="1.链表的特点"></a>1.链表的特点</h5><p>链表容易实现数据的插入和删除，任意改变数据的排列方式。就像人手拉手排成一排，要改变顺序，只需要改变牵手对象即可实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909642.png" alt="image-20210205183938605"></p>
<h5 id="2-链表的实现"><a href="#2-链表的实现" class="headerlink" title="2.链表的实现"></a>2.链表的实现</h5><p>参考文章：<a href="https://www.geeksforgeeks.org/linked-list-set-1-introduction/等系列文章">https://www.geeksforgeeks.org/linked-list-set-1-introduction/等系列文章</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表操作函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct Node* n)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAfter</span><span class="params">(struct Node* prev_node, <span class="keyword">int</span> new_data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct Node** head_ref, <span class="keyword">int</span> new_data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(struct Node**head_ref, <span class="keyword">int</span> new_data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct Node**head, <span class="keyword">int</span> key)</span> </span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="comment">// 存储该节点内容 </span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  存储下一个节点的地址 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序简单创建一个三节点链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 声明节点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">second</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">third</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 为三个节点分配空间</span></span><br><span class="line">	head = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); </span><br><span class="line">	second = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); </span><br><span class="line">	third = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在节点内存入数据（内容+下个节点的地址）构成链表</span></span><br><span class="line">	head -&gt; data = <span class="number">1</span>;</span><br><span class="line">	head -&gt; next = second; </span><br><span class="line">	</span><br><span class="line">	second -&gt; data = <span class="number">2</span>;</span><br><span class="line">	second -&gt; next = third;</span><br><span class="line">	</span><br><span class="line">	third -&gt; data = <span class="number">3</span>;</span><br><span class="line">	third -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最末端插入6，则链表为 1-&gt;2-&gt; 3-&gt;6-&gt;NULL</span></span><br><span class="line">	append(&amp;head,<span class="number">6</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在最前端插入7， 则链表为 7-&gt;1-&gt;2-&gt; 3-&gt;6-&gt;NULL</span></span><br><span class="line">	push(&amp;head,<span class="number">7</span>);</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// 在指定位置（第三个节点的下个节点后面）插入8， 则链表为 7-&gt;1-&gt;8-&gt;2-&gt;3-&gt;6-&gt;NULL</span></span><br><span class="line">	insertAfter(head-&gt;next,<span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 删除2</span></span><br><span class="line">	deleteNode(&amp;head, <span class="number">2</span>); </span><br><span class="line">	 </span><br><span class="line">	printList(head); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定位置开始遍历链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct Node* n)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 链表的末尾一定指向NULL </span></span><br><span class="line">	<span class="keyword">while</span>(n != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n-&gt;data);</span><br><span class="line">		n = n-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 链表插入有三种形式：1. 在最前面插入 2.指定位置插入  3. 在最末尾插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.在最前面插入</span></span><br><span class="line"><span class="comment">// 两个参数分别的含义是： 给定头的引用（指向指针的指针），插入的数据 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct Node** head_ref, <span class="keyword">int</span> new_data)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （1）为新节点分配空间 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （2）放入数据</span></span><br><span class="line">	new_node-&gt;data = new_data; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （3） 新节点存储原头部的地址</span></span><br><span class="line">	new_node-&gt;next = (*head_ref);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (4) 移动头部指向新节点，新节点成为新头部</span></span><br><span class="line">	(*head_ref) = new_node; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在指定节点后面插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAfter</span><span class="params">(struct Node* prev_node, <span class="keyword">int</span> new_data)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （1）检查给定节点是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(prev_node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (2)为新节点分配空间 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> (struct Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (3)放入数据</span></span><br><span class="line">	new_node-&gt;data = new_data;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (4)新节点存储插入节点存储的下个节点的地址</span></span><br><span class="line">	new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 插入节点存储新节点的地址</span></span><br><span class="line">	prev_node-&gt;next = new_node; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.在最末尾插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">(struct Node**head_ref, <span class="keyword">int</span> new_data)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//	(1) 为新节点分配空间 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">new_node</span> =</span> (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	<span class="comment">// 第5步中使用 ,让第五步的找尾部从头部开始 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">last</span> =</span> *head_ref;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (2) 放入数据</span></span><br><span class="line">	new_node-&gt;data = new_data;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (3)  新节点要放到最后，所以存储地址为NULL</span></span><br><span class="line">	new_node-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (4) 如果链表为空，则新节点成为头部</span></span><br><span class="line">	<span class="keyword">if</span>(*head_ref == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		</span><br><span class="line">		*head_ref = new_node;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (5) 链表不为空，一直摸到链表末端</span></span><br><span class="line">	<span class="keyword">while</span>(last-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		last = last-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (6) 原末端节点存储的地址改为新节点</span></span><br><span class="line">	last-&gt;next = new_node;</span><br><span class="line">	<span class="keyword">return</span>; </span><br><span class="line">	 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除给定值所在节点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct Node**head_ref, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 存储头部节点</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> *head_ref, *prev;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果头部节点含有给定值，需要删除头部</span></span><br><span class="line"><span class="keyword">if</span>(temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data == key)&#123;</span><br><span class="line">	<span class="comment">// 改变头部</span></span><br><span class="line">	*head_ref = temp-&gt;next; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放旧头部</span></span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历节点，搜索给定值的位置  </span></span><br><span class="line"><span class="keyword">while</span>(temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data !=key)&#123;</span><br><span class="line">	prev = temp;</span><br><span class="line">	temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给定值不存在</span></span><br><span class="line"><span class="keyword">if</span>(temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到位置后，开始删除操作</span></span><br><span class="line"><span class="comment">// 移动删除节点前一个节点的链接到删除节点的下一个节点</span></span><br><span class="line">prev-&gt;next = temp-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放需要删除的节点</span></span><br><span class="line"><span class="built_in">free</span>(temp); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-原理图-2"><a href="#3-原理图-2" class="headerlink" title="3.原理图"></a>3.原理图</h5><p>（1）链表结构图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909831.png" alt="image-20210208081719442"></p>
<p>（2）头部插入示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909591.png" alt="image-20210208081851924"></p>
<p>（3）指定位置插入示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909857.png" alt="image-20210208081923801"></p>
<p>（4）末端插入示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909257.png" alt="image-20210208082016685"></p>
<p>（5）删除示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909080.png" alt="image-20210208082128253"></p>
<h5 id="4-语法解释-2"><a href="#4-语法解释-2" class="headerlink" title="4.语法解释"></a>4.语法解释</h5><ul>
<li><p><code>struct Node* next</code>声明后，next存储地址，*next是地址中的值（自我引用结构体）</p>
</li>
<li><p>声明节点中，<code>struct Node* head = NULL</code>，则head内为地址</p>
</li>
<li><p>malloc()函数的声明方法为：<code>void *malloc(size_t size)</code>，其作用是分配所需的内存空间，返回值即为指向被分配内存的指针（地址）</p>
</li>
<li><p>则有head，second，third存储的是指向该节点的指针（地址），要使指向该节点的指针访问到节点的成员，那就用<code>-&gt;</code>运算符</p>
</li>
<li><p><code>struct Node** head_ref</code>相当于指向该结构体的指针的指针，即该指针存放的位置，相当于head（头部指针）取址即&amp;head；* head_ref则为该结构的指针（即head，但是*head_ref这种方式才能动态移动指针）</p>
</li>
</ul>
<h4 id="二叉树的实现方法（Binary-tree）"><a href="#二叉树的实现方法（Binary-tree）" class="headerlink" title="二叉树的实现方法（Binary tree）"></a>二叉树的实现方法（Binary tree）</h4><h5 id="1-二叉树的特点"><a href="#1-二叉树的特点" class="headerlink" title="1.二叉树的特点"></a>1.二叉树的特点</h5><p>  二叉树是基于链表的，用到的还是自我引用的结构体，但是会带有两个连接信息（即指向其他元素的指针）</p>
<p>  二叉树多用于实现用于搜索数据的算法（如：二分查找法）</p>
<p>  二叉树结构在搜索数据时，不是沿着一条线搜索，而是循着二叉树的分叉不断向下搜索</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909207.png" alt="image-20210208095901708"></p>
<h5 id="2-二叉树的实现"><a href="#2-二叉树的实现" class="headerlink" title="2.二叉树的实现"></a>2.二叉树的实现</h5>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> data;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">left</span>;</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">right</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 声明操作二叉树的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPostorder</span><span class="params">(struct node* node)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printInorder</span><span class="params">(struct node* node)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPreorder</span><span class="params">(struct node* node)</span></span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个新节点函数</span></span><br><span class="line">  <span class="comment">// 返回值为该节点的地址 </span></span><br><span class="line">  <span class="function">struct node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 分配空间给新节点 </span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">node</span> =</span> (struct node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 分配数据给该节点</span></span><br><span class="line">  	node-&gt;data = data;</span><br><span class="line">  	 </span><br><span class="line">  	<span class="comment">// 初始左右分叉的指向</span></span><br><span class="line">  	node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">  	node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">return</span> (node);   </span><br><span class="line">  		</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 创建二叉树的首节点（root）</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">root</span> =</span> newNode(<span class="number">1</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 从首节点出发分叉出两页 </span></span><br><span class="line">  	root-&gt;left = newNode(<span class="number">2</span>);</span><br><span class="line">  	root-&gt;right = newNode(<span class="number">3</span>); </span><br><span class="line">  	</span><br><span class="line">  	root-&gt;left-&gt;left = newNode(<span class="number">4</span>);</span><br><span class="line">  	root-&gt;left-&gt;right = newNode(<span class="number">5</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;后序顺序打印\n&quot;</span>);</span><br><span class="line">  	printPostorder(root); </span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;中序顺序打印\n&quot;</span>);</span><br><span class="line">  	printInorder(root); </span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;前序顺序打印\n&quot;</span>);</span><br><span class="line">  	printPreorder(root); </span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3种遍历方法 </span></span><br><span class="line">  <span class="comment">// 1.后序遍历 （左-&gt;右-&gt;根） </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPostorder</span><span class="params">(struct node* node)</span></span>&#123;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span>(node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	printPostorder(node-&gt;left);</span><br><span class="line">  	printPostorder(node-&gt;right); </span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 打印出该节点的数据 </span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;data); </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.中序遍历（左-&gt;根-&gt;右）</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printInorder</span><span class="params">(struct node* node)</span></span>&#123;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span>(node==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	printInorder(node-&gt;left);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;data);</span><br><span class="line">  	printInorder(node-&gt;right);</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  3. 前序遍历 (根-&gt;左-&gt;右)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printPreorder</span><span class="params">(struct node* node)</span></span>&#123;</span><br><span class="line">   	</span><br><span class="line">  	<span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">   		<span class="keyword">return</span>;</span><br><span class="line">  	 &#125;</span><br><span class="line">  	 </span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;data);</span><br><span class="line">  	printPreorder(node-&gt;left);</span><br><span class="line">  	printPreorder(node-&gt;right);</span><br><span class="line">   	</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<h5 id="3-二叉树原理图"><a href="#3-二叉树原理图" class="headerlink" title="3.二叉树原理图"></a>3.二叉树原理图</h5><p>  （1）遍历方法示意图</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040909994.png" alt="image-20210208150838184"></p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>算法学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>入门教程</tag>
        <tag>C语言</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
