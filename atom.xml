<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Autovy&#39;s blog</title>
  
  <subtitle>Just For Interest</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://autovy.github.io/"/>
  <updated>2023-03-26T14:50:15.941Z</updated>
  <id>https://autovy.github.io/</id>
  
  <author>
    <name>Autovy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记|工作、消费主义和新穷人</title>
    <link href="https://autovy.github.io/2022/11/27/BookNote/%E3%80%8A%E5%B7%A5%E4%BD%9C%E3%80%81%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89%E5%92%8C%E6%96%B0%E7%A9%B7%E4%BA%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://autovy.github.io/2022/11/27/BookNote/%E3%80%8A%E5%B7%A5%E4%BD%9C%E3%80%81%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89%E5%92%8C%E6%96%B0%E7%A9%B7%E4%BA%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-27T06:30:00.000Z</published>
    <updated>2023-03-26T14:50:15.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280912430.jpeg" alt="img"></p><span id="more"></span><p>工作、消费主义和新穷人<br>(英)齐格蒙特·鲍曼<br>272个笔记</p><p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280952983.png" alt="image-20221128095201586"></p><h3 id="◆-导言"><a href="#◆-导言" class="headerlink" title="◆ 导言"></a>◆ 导言</h3><p>=&gt; 每一个成年成员都需要从事生产劳动的社会中的贫穷，与完成了数百年劳动积累，无需大量成员参与就能生产一切所需的社会中的贫穷，是不同的。</p><p>服从性训练从学校教育就开始了，国家需要的是相似的一个模子刻印出来的零件，以便能随时替换到到机器、系统亦或者体制上，你从不属于你自己<br>=&gt; 吸引穷人到正规的工厂工作，消除贫困并保证社会安宁。实际上，它的作用是训练和约束人们，向他们灌输新的工厂制度发挥作用所必需的服从性。</p><p>=&gt; 吸引穷人到正规的工厂工作，消除贫困并保证社会安宁。实际上，它的作用是训练和约束人们，向他们灌输新的工厂制度发挥作用所必需的服从性。</p><p>社会贡献的标尺从为社会贡献多少生产力滑向了为社会贡献了多少消费力，职业标签早已被淡化（铁饭碗除外），高薪有钱能进行高消费就是大爷<br>=&gt; 在消费者社会中，大规模的生产不再需要大规模劳动，于是，曾经作为“劳动力后备军”的穷人被重铸为“有缺陷的消费者”</p><p>=&gt; 在消费者社会中，大规模的生产不再需要大规模劳动，于是，曾经作为“劳动力后备军”的穷人被重铸为“有缺陷的消费者”</p><h3 id="◆-第一章-工作的意义：创造工作伦理"><a href="#◆-第一章-工作的意义：创造工作伦理" class="headerlink" title="◆ 第一章　工作的意义：创造工作伦理"></a>◆ 第一章　工作的意义：创造工作伦理</h3><p>=&gt; 即使你看不到任何（尚未得到的或不需要的）收益，你也应该继续工作。工作即正义，不工作是一种罪恶。</p><p>工业史就是资本驯服工人的历史，是机器奴役工人的历史<br>=&gt; 工作伦理就进入了欧洲人的视野，之后则以多种形式贯穿于整个现代化的曲折进程中，成为政治家、哲学家和传教士们嘹亮的号角（或借口），帮助他们不择手段地拔除其时的普遍性恶习：大多数人都不愿被工厂雇佣，也拒绝服从由工头、时钟和机器设定的生活节奏。这种恶习被视为建立一个美丽新世界的最大障碍</p><p>=&gt; 工作伦理就进入了欧洲人的视野，之后则以多种形式贯穿于整个现代化的曲折进程中，成为政治家、哲学家和传教士们嘹亮的号角（或借口），帮助他们不择手段地拔除其时的普遍性恶习：大多数人都不愿被工厂雇佣，也拒绝服从由工头、时钟和机器设定的生活节奏。这种恶习被视为建立一个美丽新世界的最大障碍</p><p>=&gt; 传统的观念根深蒂固地认为人的需求是既定的，并不渴望追求更多。一旦这些既定需求得到满足，“因循守旧”的工人就彻底丧失了继续工作的动力，无意赚取更多金钱。</p><p>精英叙事下特有的刁民<br>=&gt; 在历史叙事典籍中，记录了现代理性主义的先驱发起的英勇战争。他们最终战胜了那些毫无理性、无知愚昧、不可原谅、拒绝进步的庸碌大众。</p><p>=&gt; 在历史叙事典籍中，记录了现代理性主义的先驱发起的英勇战争。他们最终战胜了那些毫无理性、无知愚昧、不可原谅、拒绝进步的庸碌大众。</p><p>=&gt; 工厂体系的诞生事实上瓦解了工匠和他们的事业之间的亲密关系，而这正好是工作伦理所追求的。被记载为引入工作伦理概念（或者说实践“绩效原则”）的道德改革运动，实质上只是试图在新环境下恢复工业化前人们普遍拥有的工作态度，但正是这个新环境使人们曾经的工作态度失去了意义。</p><p>=&gt; 我们徒劳地在工人阶层中寻找自尊，这会驱动他们选择以优秀的工作回报高薪，但在绝大多数情况下，单方面的善意被报以竭尽所能的偷懒。”[1]他哀叹过去的工匠这么快就变成了工人，只剩下计算成本效益的冷漠，哀叹前工业时代的工匠本能如此迅速地消亡。</p><p>=&gt; 工作伦理的幌子之下演化出一种纪律伦理：不用在意尊严或荣誉，感受或目的——全力工作就好，日复一日，争分夺秒，即使你完全看不到努力的意义所在</p><p>=&gt; 新的工厂系统需要的只是人的一部分：身处复杂机器之中，如同没有灵魂的小齿轮一样工作的那部分。这场战斗是为了对抗人身上那些无用的“部分”——兴趣和雄心，它们不仅与生产力无关，还会干扰生产需要的那些有用的“部分”。工作伦理本质上是对自由的摒弃。</p><p>😢<br>=&gt; 工作伦理改革运动是一场关于控制和服从的战争。除名称以外，这是一场彻头彻尾的权力斗争，以崇高道德为名，迫使劳动者接受既不高尚，也不符合他们道德标准的生活</p><p>=&gt; 工作伦理改革运动是一场关于控制和服从的战争。除名称以外，这是一场彻头彻尾的权力斗争，以崇高道德为名，迫使劳动者接受既不高尚，也不符合他们道德标准的生活</p><p>=&gt; 工作伦理也把生产活动和人的需要分离开来。这是历史上第一次，人们优先考虑“能做什么”，而非“需要做什么”。它使得满足人的需要与生产活动的逻辑无关，更重要的是，与生产活动的限度无关。这形成了一个新时代的悖论：“为增长而增长</p><p>工人是新时代的奴隶，所谓的共产运动实际上是彻头彻尾地失败了<br>=&gt; 他们应该认识到自己在国家经济中最适当的地位就是过去种植园经济时代奴隶所处的地位。我们平时赞赏的人类美德，到了奴隶身上就成为了罪恶</p><p>=&gt; 他们应该认识到自己在国家经济中最适当的地位就是过去种植园经济时代奴隶所处的地位。我们平时赞赏的人类美德，到了奴隶身上就成为了罪恶</p><p>=&gt; 工匠对于传统权利的捍卫，以及工业化前穷人表现出的对合理、高效的机械化工作体制的抵制，都被视为自然放置的障碍之一，意图延缓人类的进步。如同精心设计却被揭露、破坏、清除的其他诡计一样，这些抵抗也必将被毫不留情地消灭</p><p>为了社会进步把劳动力当做燃料消耗掉，然后精英们安然享受着进步的列车驶向美好的未来，我可去你妈<br>=&gt; 这种拒绝进步的抵抗经常被用来证明穷人的懒散，以及强硬、严格、不留情面的工厂纪律在道德上的必要性。让穷人和“不思进取”的人工作，不仅是一项经济任务，更是一项道德任务</p><p>=&gt; 这种拒绝进步的抵抗经常被用来证明穷人的懒散，以及强硬、严格、不留情面的工厂纪律在道德上的必要性。让穷人和“不思进取”的人工作，不仅是一项经济任务，更是一项道德任务</p><p>标榜文明穿着西装的流氓<br>=&gt; 在新秩序中，有产者重新成为无产者父亲般的监护人……并非消灭贫穷——这似乎很难成为目的——而是消灭那些卑劣的恶习，消灭极端贫穷和肉体苦难</p><p>=&gt; 在新秩序中，有产者重新成为无产者父亲般的监护人……并非消灭贫穷——这似乎很难成为目的——而是消灭那些卑劣的恶习，消灭极端贫穷和肉体苦难</p><p>=&gt; 他也认为这些可怜的朋友“内在品质上与那些未开化的孩童没什么不同”[9]，他们需要更成熟的人来照看他们，为他们的行为负责。睿智的人达成共识：劳动者（无论当下的还是未来的）没有管理好自己生活的能力。他们像那些愚蠢、任性的孩子一样，不能约束自己，无法明辨是非，更不用说认识到什么更符合自己的“长远利益”。他们只是有待加工、塑造的“人类原材料”，至少在肉眼可见的未来，他们注定只能被动地接受社会的变迁，他们只能成为当下如火如荼的理性变革的对象，而非主体。工作伦理是意义深远的道德教育议程中的关键项目之一，它为思想者和行动者设定的任务，构成了后来现代化的拥趸所谓的“文明化进程”之核心。</p><p>=&gt; 工作伦理同时提供了建设性的愿景和拆除旧有习惯的方案。它彻底否定了这场伦理改革运动的目标对象原有的生活习惯、喜好和欲望。它描绘了正确的行为模式，但更重要的是质疑所有需要接受道德训练的人，质疑他们在未经教育和未经监督时所做的一切。他们的秉性绝不能得到信任。如果任由他们随心所欲，任由他们自作主张，他们宁愿饿死也不会努力，宁愿沉湎于污秽也不求自我完善，他们会置短暂的麻痹于长远稳定的幸福之上。</p><p>工匠变成了工人，生产的主体沦为生产的附庸<br>=&gt; 在工作伦理发起的反对前工业时代穷人“传统主义”的战争中，工作伦理表面上的对手是“无欲无求”，但真正的火力（最猛烈、最残酷的），对准的是那些准工人的反抗心态。后者认为新的工作制度令他们感到屈辱、不适，他们并不期望也不愿理解这种制度，遑论自愿选择。</p><p>=&gt; 在工作伦理发起的反对前工业时代穷人“传统主义”的战争中，工作伦理表面上的对手是“无欲无求”，但真正的火力（最猛烈、最残酷的），对准的是那些准工人的反抗心态。后者认为新的工作制度令他们感到屈辱、不适，他们并不期望也不愿理解这种制度，遑论自愿选择。</p><p>=&gt; 穷人和老鼠一样，确实可以用这种方法消灭，或者至少把他们赶出人们的视线。需要做的只是下决心把他们当作老鼠对待，并接受“穷人和不幸的人是需要解决的麻烦</p><p>=&gt; 人们希望，不工作的穷人越是生活堕落，越是深陷赤贫，那些有工作的、出卖劳动力换取最微薄工资的穷人的生活就越诱人，至少不至于无法忍受；这样，工作伦理得到了支撑，胜利也触手可及</p><p>=&gt; 工厂工作的要求确实严苛、令人厌恶，但相较其他选项是否真的那么糟糕。一旦有了比较，工厂中微薄的工资和无趣繁重的苦役，似乎也没那么不能接受，甚至令人向往。</p><p>=&gt; 济贫院壁垒之内的流言越是恐怖，工厂工人的奴役看起来就越像自由，他们遭遇的悲惨也越像一种幸运和福祉</p><p>=&gt; 必须强制执行统一的、规范性的、可预测的行为模式，以约束五花八门、本质上不守规矩的囚犯。</p><p>=&gt; 在这些圆形监狱里，无论是救济院、劳教所还是工厂，“如果一个人不工作，那他就什么都不能做，只能吃变质发霉的面包、喝淡然无味的水，没有人会和他说话……这种激励能恰到好处地促使他竭尽所能地工作”。</p><p>=&gt; 这使得工作伦理的说教看起来有些表里不一。事实上，若真的希望工人道德完善，就必须扩大其自由的边界——这才是道德能够生长并最终开花结果的唯一土壤。但是工作伦理，至少在其早期的历史上，选择了削减（或者说完全消除）穷人的选择</p><p>不事生产的人挺多的，他们道德堪忧哦<br>=&gt; 许多人认为体力劳动是必要的，是一种责任和义务，但也值得称颂”[16]，因为它将为国家带来荣誉和财富，为工人带来道德上的提升</p><p>=&gt; 许多人认为体力劳动是必要的，是一种责任和义务，但也值得称颂”[16]，因为它将为国家带来荣誉和财富，为工人带来道德上的提升</p><p>=&gt; 对那些体面性和品格受到质疑的人来说，去工作（接受一份工作，找一个老板，做一些老板愿意付钱所以一定有用的事情）是一个颇为得体的自证方法。给予所有人工作，让所有人都去工作，通常被视为治愈因社会（暂时）的不完美、不成熟导致的一切弊病和麻烦的良方。</p><p>=&gt; 这些现代的口号同时回荡在分割资本主义和共产主义的巨大鸿沟两侧。在马克思主义影响下，反对资本主义的政治口号是“不劳动者，不得食”，关于未来无产阶级社会的愿景也是完全基于工厂的模样构建的。</p><p>=&gt; 对于后传统的现代社会（一个根据选择的能力和承担的责任来评估、奖励其成员的社会）中大部分（且越来越多）的男性成员来说，工作是他们终其一生构建和捍卫的身份的核心。身份的构建可能来源于诸多雄心壮志，但都取决于人们选择/被分配的工作类型</p><p>=&gt; 工作是主要的基准，所有其他生活追求都可以基于它来规划和安排</p><p>=&gt; 工厂生产花样繁多的商品，除此之外，它们也生产顺从于现代国家的公民</p><p>=&gt; 如果让大部分男性进入工厂工作是生产和维持社会秩序的主要手段，那么以（“养家糊口”的）男性为绝对权威建立强大、稳定的父权制家庭，就成为一个必要的补充。</p><p>=&gt; 家庭的父权将秩序生产和服务网络的规训压力传导到圆形监狱无法触及的人群</p><p>企业能创造的岗位数量和劳动力失业率<br>=&gt; 衡量政策成败的主要指标是：资本的雇佣能力和民众对生产过程的参与程度。</p><p>=&gt; 衡量政策成败的主要指标是：资本的雇佣能力和民众对生产过程的参与程度。</p><p>=&gt; 工作伦理要求人们心甘情愿地、欣然地、热情地拥抱一种无法避免的必然——新经济的实践者在新国家立法者的协助和合谋下，竭尽全力提供的这种不可避免的困境。心甘情愿地接受这种必然，就意味着彻底放弃了对外来的、痛苦的、强加的新规则的抵抗。在工作场所，工人的自治权是不被容忍的。工作伦理要求人们选择一种献身于劳动的生活，但这也就意味着没有选择、无法选择和禁止选择。</p><p>=&gt; 现代组织（包括工厂在内）的总体趋势是使人的道德情操和他们的行动无关（adiaphora），从而使他们的行为更具规律性、更容易预测，这是非理性的道德冲动不可能做到的。</p><p>工作不需要被热爱，也不需要被认为是道德的象征<br>=&gt; 工作是获得更多财富，从而更加独立的手段，是摆脱令人厌恶的必须为他人工作这种境遇的手段。即使是血汗工厂的半奴隶制，也能以未来自由的名义被他们接受和平静地忍受，无需任何高贵品质的伪装。工作不需要被热爱，也不需要被认为是道德的象征，人们可以公开反感工作，这不会招致纪律的崩坏，因为他们相信当下的忍耐（哪怕是最恶劣的境况）是为了并不遥远的自由而暂时付出的代价。</p><p>=&gt; 工作是获得更多财富，从而更加独立的手段，是摆脱令人厌恶的必须为他人工作这种境遇的手段。即使是血汗工厂的半奴隶制，也能以未来自由的名义被他们接受和平静地忍受，无需任何高贵品质的伪装。工作不需要被热爱，也不需要被认为是道德的象征，人们可以公开反感工作，这不会招致纪律的崩坏，因为他们相信当下的忍耐（哪怕是最恶劣的境况）是为了并不遥远的自由而暂时付出的代价。</p><p>=&gt; 对那些放弃自身独立性，服从工厂纪律的工人给予奖励。过去道德说教实现的成就，正越来越多地通过“胡萝卜”的诱惑（无论是否配以“大棒”的协助）来实现。与其宣扬努力工作通向道德高尚的生活，不如告诉大家这是赚取更多金钱的手段。不要在意“更好”，“更多”才是最重要的。</p><p>=&gt; 越来越多的人认为，从工匠变成工人时失去的人的尊严，只有通过赢得更多盈余才能恢复。这种变迁中，努力工作能使人们道德升华的呼声日益衰弱。现在，衡量人们声望和社会地位的是工资的差别，而不是勤于工作的道德或惰于工作的罪恶。</p><p>=&gt; 它实现了当初工作伦理在经济手段和偶尔的肉体胁迫的帮助下徒劳争取的目标。它在现代生产者的思想和行动中灌输的与其说是“资本主义精神”，不如说是以经济水平评判人的价值和尊严的倾向。这也把人的动机和对自由的渴望牢牢地、不可逆地转向消费领域。这些影响在很大程度上决定了现代社会后续的发展——从生产者社会转向消费者社会。</p><h3 id="◆-第二章-从工作伦理到消费美学"><a href="#◆-第二章-从工作伦理到消费美学" class="headerlink" title="◆ 第二章　从工作伦理到消费美学"></a>◆ 第二章　从工作伦理到消费美学</h3><p>=&gt; 之所以称之为“生产者社会”，是因为那时人们主要以生产者的身份参与其中。社会塑造其成员的方式由社会分工的需要决定，社会希望其成员有能力和意愿参与社会分工。在当前这个近现代（late-morden）、次现代（second-morden）或后现代（postmorden）阶段，社会主要要求人们以消费者的能力参与其中，首先依照“消费者”角色需要塑造其成员，并期望他们具有消费的能力和意愿。</p><p>中国的圆形监狱很快也无法维持了<br>=&gt; 曾经举足轻重的圆形监狱逐渐失去了作用，大规模工业化雇佣迅速萎缩，小规模的、自由的职业群体取代了全民大生产，大部分人不可能再受到他们的影响。技术的进步在就业萎缩的前提下确保了生产力的增长，工厂的员工越来越少，“精简”成为新的行为准则。</p><p>=&gt; 曾经举足轻重的圆形监狱逐渐失去了作用，大规模工业化雇佣迅速萎缩，小规模的、自由的职业群体取代了全民大生产，大部分人不可能再受到他们的影响。技术的进步在就业萎缩的前提下确保了生产力的增长，工厂的员工越来越少，“精简”成为新的行为准则。</p><p>=&gt; 圆形监狱式训练不仅在后工业化时代大幅减少，而且与消费者社会的需求背道而驰。它擅长培养的气质和生活态度，与理想的消费者大相径庭</p><p>=&gt; 理想状态下，消费者应该不固守任何东西，没有永久的承诺，没有可以被完全满足的需求，也没有所谓的终极欲望</p><p>=&gt; 理想情况下，消费者立刻得到满足——消费应该立刻带来满足感，没有时延，不需要旷日持久的技能学习和准备工作；而一旦消费行为完成，这种满足感就应该尽可能快地消失</p><p>=&gt; ，越是陌生的需求越具吸引力，能获取的未知生活体验会带来大量的乐趣。前所未有的新鲜的兴奋感，就是消费者游戏的秘密</p><p>=&gt; 欲望不求被满足。恰恰相反，欲望永无止境”</p><p>信息时代的海量信息不是为了充实你的大脑，拓宽你的深度亦或者是阐明一种事实，而是为你制造虚假的需求并掏空你的口袋<br>=&gt; 想要提高消费者的消费能力就不能让他们休息。他们需要不断地接受新的诱惑，持续处于永不枯竭的兴奋之中，持续处于怀疑和不满之中。</p><p>=&gt; 想要提高消费者的消费能力就不能让他们休息。他们需要不断地接受新的诱惑，持续处于永不枯竭的兴奋之中，持续处于怀疑和不满之中。</p><p>=&gt; 在正常运转的消费者社会中，消费者会主动寻求被诱惑。他们的生活从吸引到吸引，从诱惑到诱惑，从吞下一个诱饵到寻找另一个诱饵，每一个新的吸引、诱惑和诱饵都不尽相同，似乎比之前的更加诱人。他们生活于这种轮回，就像他们的先辈，那些生产者，生活于一个传送带和下一个传送带之间。</p><p>不买立省百分百<br>=&gt; 消费者都觉得自己在掌控一切。他们可以评判、评论和选择，他们可以拒绝无限选择中的任何一个——除了“必须作出选择”之外。寻求自我认同，获取社会地位，以他人认为有意义的方式生活，这些都需要日复一日地到访消费市场。</p><p>=&gt; 消费者都觉得自己在掌控一切。他们可以评判、评论和选择，他们可以拒绝无限选择中的任何一个——除了“必须作出选择”之外。寻求自我认同，获取社会地位，以他人认为有意义的方式生活，这些都需要日复一日地到访消费市场。</p><p>=&gt; 解决所有麻烦、重获转机的希望被寄托于消费者重拾他们的义务——再次购买，大量购买，不断购买</p><p>作者是懂灵活的<br>=&gt; 今天流行的口号是“灵活”，这个越来越时髦的概念代表的是一场几乎没有任何规则的雇佣和解雇游戏，而且在游戏进行时，单方面就可以随时更改规则。</p><p>=&gt; 今天流行的口号是“灵活”，这个越来越时髦的概念代表的是一场几乎没有任何规则的雇佣和解雇游戏，而且在游戏进行时，单方面就可以随时更改规则。</p><p>=&gt; 无论人们渴望的身份是什么，都必须像当下的劳动力市场一样，具有灵活性。它必须能够适应紧急通知甚至没有通知的变化，必须遵循“拥有尽可能多的选择，最好拥有所有选择”的原则。未来必然充满不确定性，如果不这样做，就等于自己放弃机会，放弃那些未来曲折命运以及难以预料的生活带来的未知的、只能模糊感觉到的利益。</p><p>=&gt; 身份是多重的：大多数人的生命旅程中可能都散布着遗失或遗弃的身份。每一个后继的身份可能都是不完全的、有条件的，因此，如何避免身份的固化成为一个难题。“身份”这个词或许已经失去了效用，因为在日常生活中，它所掩饰的比揭露的更多。随着社会地位越来越得到关注，人们恐惧过于牢固的身份认同，害怕在必要时难以全身而退。对社会身份的渴望和恐惧，社会身份唤起的吸引和排斥，混合在一起，产生了一种持久、矛盾、困惑的复杂心态。</p><p>=&gt; 市场上的消费品一样，对一种身份的消费不应该——不允许——熄灭对其他更新、更好身份的渴望，也不应该——不允许——妨碍人们接纳新身份的能力。</p><p>=&gt; 如果市场能够解决社会身份带来的问题，专门的“规范管制”（normative regulation）或“模式维持”（pattern maintenance）社会机制就不再必要，也不可取。传统的、圆形监狱的训练方法显然与消费者的任务格格不入，对围绕欲望和选择构建的社会来说，这些将是灾难性的。</p><p>=&gt; “还利于民”变得不容置疑，它呼吁消费者履行选择的责任——一种已经被内化、重塑为人生使命的责任。更多税后收入的吸引力，与其说是来自更多消费，不如说是来自有了更多消费选择的预期、更多购物和选择的乐趣。</p><p>=&gt; 生产者只能集体完成使命，生产是一种集体性事业，需要分工、合作和协调。</p><p>=&gt; 消费者恰恰相反。消费彻头彻尾是一种个人的、独立的乃至孤独的活动。这种活动通过不断地满足和唤醒、缓释和激发某种欲望实现，这种欲望通常是一种私人的、难以言表的感觉</p><p>=&gt; 一个人选择的自由度越大，自由行使的选择权越多，他在社会阶层中的地位就越高，获得的社会尊重和自尊就越多，距离“美好生活”的理想也越近。</p><p>=&gt; 储蓄增加和消费信贷萎缩绝对是坏消息，信贷的膨胀才是“事情朝正确方向发展”的可靠信号，受到欢迎。消费者社会不会轻易呼吁延迟满足。这是一个信用卡社会，而非存折社会</p><p>=&gt; 是美学，而非伦理学，被用于整合消费者社会，确保其走在正确的道路上，并屡次拯救其于危难。伦理学赋予履行责任以最高的价值，而美学则把崇高的体验放在首位。</p><p>消费者社会其背景必然是生产的过剩，这也是所谓内卷的本质，不管是实体还是互联网相似的产品有很多，要打差异牌烧钱牌营销牌才能吸引到用户。在资本不在青睐的赛道烧钱牌大抵是走不通了（说的就是你，互联网公司），再加上中国房地产行业一直压抑着消费而且近些年各路媒体一直给人勒紧裤腰带的暗示，营销牌大概作用也不大。所以能做出差异性且同时具备不可复制的高技术的产品才有活路，即所谓异胜同汰。对人也一样，过去生产社会的时代里，中国高校制造出太多同质化严重的零件，在生产者社会逐步瓦解的今天，那些相似的零件自然要内卷，卷出身卷项目卷学历卷实习，可实际上每个零件都大抵都是一个模子打出来的，无非是这个漆得光鲜那个镀得精美。我们或忙忙碌碌或碌碌无为走过被预设好的成长之路，被不断地画饼——这条路呀是成功之路，最终我们在相似的成功之路上互相竞争，自然而然就成为了机器上系统上的可被随时更换的零件，所以做个特色鲜明的人很好无论是对个人发展还是对自由的天性，当然啦只是对权威者和投资家来说回报就没那么大了<br>=&gt; 如果说生产者社会是柏拉图式的，追求牢不可破的规则和事物的终极模式，那么消费者社会就是亚里士多德式的——务实、灵活，遵循船到桥头自然直的原则。理智的消费者唯一能掌控的，就是在已知的机会最密集的时间守候在已知的机会最多的地方。这种主动性只能采纳“实践智慧”（phronesis）。它是经验法则的集合，而不是万无一失的秘方或算法指令。因此，“实践智慧”需要大量的信任，需要安全的避风港让信任安全地停泊。于是，消费者社会也是咨询和广告的天堂，是预言家、算命先生、贩卖魔法药水的商人和点金术士的沃土。</p><p>=&gt; 如果说生产者社会是柏拉图式的，追求牢不可破的规则和事物的终极模式，那么消费者社会就是亚里士多德式的——务实、灵活，遵循船到桥头自然直的原则。理智的消费者唯一能掌控的，就是在已知的机会最密集的时间守候在已知的机会最多的地方。这种主动性只能采纳“实践智慧”（phronesis）。它是经验法则的集合，而不是万无一失的秘方或算法指令。因此，“实践智慧”需要大量的信任，需要安全的避风港让信任安全地停泊。于是，消费者社会也是咨询和广告的天堂，是预言家、算命先生、贩卖魔法药水的商人和点金术士的沃土。</p><p>=&gt; 工作失去了它的特权地位，不再是自我构建和身份构建的轴心，也不再是道德关注的焦点，不再是道德改善、忏悔和救赎的必由之路。与生活中的其他活动一样，工作现在首先受到美学的审视。工作的价值取决于产生愉悦体验的能力，不能使人获得“内在满足”的工作没有价值</p><p>=&gt; 这种意识对所有工作的执行者都是成立的，即使是那些最卑微、最没有吸引力的工作。工作伦理传达了一种平等的信息，它淡化了工作之间原本显著的差异，包括带来满足感的能力、带来地位和声望的能力，以及能够提供的物质利益。</p><p>无聊的工作受人偏爱，怎么会事呢？<br>=&gt; 美学已取代伦理学，主导了工作的价值判断。如同所有其他可以成为消费标的、被消费者自由选择的事物一样，工作必须是“有趣的”——多样化、令人兴奋、具有挑战性，包含适度的风险，并不断带来崭新的体验。那些单调、重复、例行、缺乏冒险精神、不允许创新、没有挑战、无法带来提升和自信的工作，就是“无聊的”。</p><p>=&gt; 美学已取代伦理学，主导了工作的价值判断。如同所有其他可以成为消费标的、被消费者自由选择的事物一样，工作必须是“有趣的”——多样化、令人兴奋、具有挑战性，包含适度的风险，并不断带来崭新的体验。那些单调、重复、例行、缺乏冒险精神、不允许创新、没有挑战、无法带来提升和自信的工作，就是“无聊的”。</p><p>=&gt; 那些令人厌恶的工作未能保留过去假定的道德价值。只有未经消费者社会改造、尚未皈依消费主义的人才会心甘情愿选择那样的工作，满足于出卖劳动力勉强生存</p><p>奋斗，贡献，福报的基本语境<br>=&gt; 为了让那些已经皈依消费主义的人去从事那些经不起美学考验的工作岗位，必须人为地重新创造一种没有选择、迫不得已、为最基本的生存而奋斗的处境。只是这一次，不会再扯上什么崇高的道德救赎。</p><p>=&gt; 为了让那些已经皈依消费主义的人去从事那些经不起美学考验的工作岗位，必须人为地重新创造一种没有选择、迫不得已、为最基本的生存而奋斗的处境。只是这一次，不会再扯上什么崇高的道德救赎。</p><p>稳定是最大的风险<br>=&gt; 灵活的劳动力市场”不提供终生职业，也不容许它们存在。对从事的工作产生感情，爱上这份工作，根据这份工作和运用的技能确定自己在世界上的位置，意味着成为命运的人质。鉴于所有工作的短暂性和所有合同中都包含的期限条款，这既不现实，也不值得推荐。除了少数的天之骄子，对于大多数人来说，在当今灵活的劳动力市场上，对工作从一而终会带来巨大的风险，会招致心理和情感上的灾难。</p><p>=&gt; 灵活的劳动力市场”不提供终生职业，也不容许它们存在。对从事的工作产生感情，爱上这份工作，根据这份工作和运用的技能确定自己在世界上的位置，意味着成为命运的人质。鉴于所有工作的短暂性和所有合同中都包含的期限条款，这既不现实，也不值得推荐。除了少数的天之骄子，对于大多数人来说，在当今灵活的劳动力市场上，对工作从一而终会带来巨大的风险，会招致心理和情感上的灾难。</p><p>=&gt; 勤奋和奉献的劝诫显得虚伪、空洞，理智的人最好能够洞察本质，看穿老板所布置游戏中的“使命感”外衣</p><p>旧穷人赖以生存的工作伦理瓦解后，便诞生了既无法皈依于工作伦理而被社会认可，又没有内外部条件构建工作美学的新穷人。消费者社会是精英的社会，是少数人的社会<br>=&gt; 就社会底层的现实生活而言，这种观念和前者一样，都无比荒唐。[6]它使人们相信，上层人士热情追求、自愿选择、珍惜且拥护的“灵活性”，对其他人也一定是一种无上的祝福，哪怕这种“灵活性”最终带来的与其说是选择的自由和自主的权利，不如说是安全感的丧失、被迫背井离乡和前途未卜。</p><p>=&gt; 就社会底层的现实生活而言，这种观念和前者一样，都无比荒唐。[6]它使人们相信，上层人士热情追求、自愿选择、珍惜且拥护的“灵活性”，对其他人也一定是一种无上的祝福，哪怕这种“灵活性”最终带来的与其说是选择的自由和自主的权利，不如说是安全感的丧失、被迫背井离乡和前途未卜。</p><p>还不是你不努力😋<br>=&gt; 把穷人的悲惨遭遇归咎于他们不愿意工作，指控他们道德沦丧，把贫穷说成是对罪恶的惩罚，这是工作伦理在新的消费者社会能做的最后贡献。</p><p>=&gt; 把穷人的悲惨遭遇归咎于他们不愿意工作，指控他们道德沦丧，把贫穷说成是对罪恶的惩罚，这是工作伦理在新的消费者社会能做的最后贡献。</p><p>经由网络营销的体面生活，让真实生活逐渐失真，人为制造了不体面的大多数。体面的标准越来越高，人们越来越不幸福是消费者社会不断营销不断膨胀的结果，若最终社会的价值导向无法回归正轨，那便跳出这样的价值标尺保智商吧<br>=&gt; 每个社会都有“体面生活”的衡量标准，如果无法达到这些标准，人们就会烦恼、痛苦、自我折磨。贫穷意味着被排除在“正常生活”之外，意味着“达不到标准”，从而导致自尊心受到打击，产生羞愧感和负罪感。贫穷也意味着与既定社会的“幸福生活”无缘，无法享受“生活的馈赠”。</p><p>=&gt; 每个社会都有“体面生活”的衡量标准，如果无法达到这些标准，人们就会烦恼、痛苦、自我折磨。贫穷意味着被排除在“正常生活”之外，意味着“达不到标准”，从而导致自尊心受到打击，产生羞愧感和负罪感。贫穷也意味着与既定社会的“幸福生活”无缘，无法享受“生活的馈赠”。</p><p>被消费给pua了🤭<br>=&gt; 消费者社会的穷人没有机会过上正常生活，更不用说过上幸福生活。在消费者社会中，一个人无法幸福地生活，甚至无法正常地生活，就意味着他/她是失败的消费者，或者说是有缺陷的消费者。所以，消费者社会的穷人，被社会，也被其自身定义为有瑕疵的、有缺陷的、不完美的、先天不足的消费者。简而言之，就是不合格的消费者。</p><p>=&gt; 消费者社会的穷人没有机会过上正常生活，更不用说过上幸福生活。在消费者社会中，一个人无法幸福地生活，甚至无法正常地生活，就意味着他/她是失败的消费者，或者说是有缺陷的消费者。所以，消费者社会的穷人，被社会，也被其自身定义为有瑕疵的、有缺陷的、不完美的、先天不足的消费者。简而言之，就是不合格的消费者。</p><p>新时代幸福——不断追求被商家营销出的新需求从而获得短暂的满足感<br>=&gt; 消费市场比弗洛伊德更有创造力，它唤起了弗洛伊德认为无法实现的幸福状态。秘诀在于：在欲望被安抚之前激发新的欲望，在因占有而感到厌倦、烦躁之前替换新的猎物。永远不出现厌倦——这才是消费者的生活准则，也是切实可行的准则、触手可及的目标。达不到这个目标的人只能怪自己，并容易成为他人鄙视和谴责的对象。</p><p>=&gt; 消费市场比弗洛伊德更有创造力，它唤起了弗洛伊德认为无法实现的幸福状态。秘诀在于：在欲望被安抚之前激发新的欲望，在因占有而感到厌倦、烦躁之前替换新的猎物。永远不出现厌倦——这才是消费者的生活准则，也是切实可行的准则、触手可及的目标。达不到这个目标的人只能怪自己，并容易成为他人鄙视和谴责的对象。</p><p>=&gt; 无聊是消费者社会特有的社会分层因素产生的心理学结果。这些因素包括：选择的自由度和丰富度、流动的自由度、消除孤立和组织时间的能力。</p><p>=&gt; 因为得体的标准已经被设定了，并不断提升。它来自远离邻里守望的地方，来自报纸杂志和光鲜亮丽、永不间断地传递消费者福音的电视广告。贫民区那些绞尽脑汁的替代品不堪一击，不值得骄傲，无法减弱自卑的痛苦。关于一个人是否是合格消费者的评价来自远方，本地舆论根本无法与之抗争。</p><p>=&gt; 制造人为的、主观的不满足感”，因为本质上“人们满足于自己拥有的东西才是最可怕的威胁”。[10]于是，人们真正拥有的东西被淡化，被贬低，被较富裕的人锋芒毕露的奢侈消费所掩盖</p><p>无论生产力还是经济或增或减，燃料都不能体面，兴百姓苦，衰百姓苦。<br>=&gt; “穷人与富人并非生存于相互独立的文化中。他们只能生活在同一个世界里，而这个世界是为有钱人的利益设计的。穷人的贫困不但因经济增长而加剧，也因经济衰退和停滞而加剧</p><p>=&gt; 穷人与富人并非生存于相互独立的文化中。他们只能生活在同一个世界里，而这个世界是为有钱人的利益设计的。穷人的贫困不但因经济增长而加剧，也因经济衰退和停滞而加剧</p><p>=&gt; 经济增长”指的是什么，随之而来的都是以“灵活的劳动力”替代铁饭碗，以“滚动合同”（rolling contracts）替代工作保障，采用固定期限合同，临时性雇佣，裁员重组和“企业优化”——所有这些最终都在削减就业数量。</p><p>=&gt; “主观上的不满足”，以及随之而来的耻辱和污名化造成的痛苦，由于生活水平下降和相对贫困恶化的双重压力而加剧。目前，这两种压力都因放松管制、自由放任的经济增长而加剧，非减轻。</p><h3 id="◆-第三章-福利国家的兴衰"><a href="#◆-第三章-福利国家的兴衰" class="headerlink" title="◆ 第三章　福利国家的兴衰"></a>◆ 第三章　福利国家的兴衰</h3><p>=&gt; “福利国家”（welfare state）的概念传达了这样一种思想：国家有责任和义务保障其所有公民的“福利”——不仅仅是维持生计，而是在身处的社会中有尊严地生存。</p><p>=&gt; 我们需要帮助暂时失业的人渡过难关，帮他们做好准备随时重返“正常生活”，即一旦经济复苏，工作机会重新开放，他们就能够就业。</p><p>=&gt; 公共福利允许（明示或暗示）把公民生活与“对社会的贡献”分离开来，生产贡献只应在职业范畴中讨论，由此削弱了工作伦理最神圣的、最不容置疑的前提。这种理念使有尊严的生活成为政治性的公民权利问题，而不是经济绩效问题</p><p>=&gt; 一些人坚持国家福利是对于工作伦理的必要补充，另一些人则认为国家福利是反对工作伦理的具有政治动机的阴谋。</p><p>=&gt; 国家福利是“一个用于压迫的工具，还是一个扩大需求，减轻自由市场经济残酷性的制度？是扩大资本积累和利润的助力，还是如工资袋中的现金一样是应该被捍卫、去扩增的社会性工资？是资本主义的欺诈，还是工人阶级的胜利？</p><p>=&gt; 处于困境的资本主义经济，无法在缺失政治帮助的状态下只依靠自己的力量生存；有组织的劳工，无法在缺失政治帮助的状态下确保自己不受“经济周期”的影响；通过减轻最令人不能忍受的社会不平等来保护和重申社会不平等原则；通过边缘化无法参与再生产的人来刺激社会接受不平等；以及帮助社会成员安然度过不受政治控制的经济冲击。所有这些强大的、异质的驱动力汇聚在一起，诞生于（工业化的、资本主义的、市场化的、民主的）现代社会某个高级阶段的国家福利，确实是“多因素决定的”（over-determined）</p><p>=&gt; 福利国家在某种意义上“已经成为一种不可逆转的结构，要废除这种结构，就必须废除政治民主和工会，并从根本上改变政党制度”</p><p>草，差点信了奥菲<br>=&gt; 一个不存在国家福利的国家，一个缺乏国家管理的社会保障体系的资本主义经济，如果说在最富裕、最为“经济成功”的社会中还没有成为现实，至少也越来越成为一种清晰的可能</p><p>=&gt; 一个不存在国家福利的国家，一个缺乏国家管理的社会保障体系的资本主义经济，如果说在最富裕、最为“经济成功”的社会中还没有成为现实，至少也越来越成为一种清晰的可能</p><p>=&gt; 免于匮乏和对于匮乏的恐惧，免于失业和对失业的恐惧”，那么这种自由和权利就不是人人生而平等的自由</p><p>=&gt; 如果这种自由不能覆盖社会的每一个成员，只针对那些（伤害发生后）已经失败的人，即那些“一无所有”的、不幸的、失去能力的社会成员，这种预防和支持的理念显然就失去了意义</p><p>=&gt; 普遍性和选择性（经济审查）的社会福利制度造就了两种完全不同的福利国家模式，两者产生了不同的社会影响和文化影响。各类人群对它们的感知，它们的政治命运预期，也大相径庭。</p><p>=&gt; 若只服务于众所周知缺乏政治力量和公众话语权的贫困人口，选择性社会保障只能吸引最差而不是最好的专业人士和管理者。</p><p>=&gt; 把服务的范围用经济审查的结果来限定，社会就会立即分裂为二元：付出而没有得到任何回报的人和不付出就能有所得的人[7]。利益理性于是和团结道德对立起来，道德变成了一个人“能负担什么”的问题，或者说在政治意愿上一个人愿意分享什么的问题</p><p>=&gt; 通过对被排斥者的污名化，社会主流人群的真正或假定的价值得到了强化：“观察者通过构建他人来构建自己”。[9]</p><p>=&gt; 福利国家的长盛不衰曾被解释为它缔造与维持和平的能力：它能使工人更容易接受资本家设定的规则，且成本更低。只依靠强制措施的工作伦理无法做到这一点</p><p>=&gt; 福利国家正在迅速失去政治支持的事实，“既不能用经济和财政危机完全解释，也不能用强调新保守主义菁英和意识形态崛起的政治观点完全解释。现有福利国家体系对正义性、合理性的道德诉求也无法挽救它</p><p>=&gt; 福利国家在长期的“劳动力再商品化”过程中也发挥了至关重要的作用。通过为贫困家庭的孩子提供良好的教育、适当的医疗服务、体面的住所和健康的营养品，它保证了资本主义工业可雇佣劳动力的稳定供给，这是任何公司或集团都无法做到的</p><p>=&gt; 多余的劳动力可能永远不会再成为商品。不是因为有质量缺陷，而是因为需求消失了。</p><p>福利国家总需要一个中国<br>=&gt; 现代工业世界可能仍然需要少量老式的劳动力，但考虑到金融已经获得新的移动自由，放松管制的资本主义企业也拥有了珍贵的灵活性，这类需求可以在其他遥远的国度得到满足。</p><p>=&gt; 现代工业世界可能仍然需要少量老式的劳动力，但考虑到金融已经获得新的移动自由，放松管制的资本主义企业也拥有了珍贵的灵活性，这类需求可以在其他遥远的国度得到满足。</p><p>=&gt; 如果一家企业打算扩大规模，雇佣更多劳动力，它可以随时从国家福利体系的用户池中募集。然而，时代发生了转变，现在是以股票价值而非产品数量来衡量企业的成败。伴随着劳动力在生产过程中的作用迅速下降，以及企业全球化布局的自由，投资国家福利体系的吸引力大幅下降，以更少的代价就能获得等价甚至更好的效果。在遥远的国度，在缺乏公共福利压力的政府的支持下获得“方便旗”[14]，似乎是一个更好的主意。</p><p>还真是那个岁月静好，负重前行<br>=&gt; 这种新获得的全球流动自由消减了补充劳动力的经济负担：取之不尽、用之不竭的，新鲜、顺从、没有被宠坏的劳动力正在远方招手。这个星球上，部分地区已经充满老于世故的消费者，但也还存在广袤的处女地，那里有不需要激发消费欲望就能获得的顺从劳动力，那里的人为了维持生计而卑微地工作。</p><p>=&gt; 这种新获得的全球流动自由消减了补充劳动力的经济负担：取之不尽、用之不竭的，新鲜、顺从、没有被宠坏的劳动力正在远方招手。这个星球上，部分地区已经充满老于世故的消费者，但也还存在广袤的处女地，那里有不需要激发消费欲望就能获得的顺从劳动力，那里的人为了维持生计而卑微地工作。</p><p>=&gt; 把消费者欲望作为主要的社会动员和整合力量，作为解决冲突和秩序维持的主要手段，从长远来看，这会使“劳动力成本过高”。那些被资本主义生产方式耕耘过的连绵土地迟早都会枯竭，成为收益递减规律的牺牲品。为了保持生产利润，必须寻找新的处女地，未被开垦过的土地。这种困境在很大程度上解释了为什么要拆除所有妨碍贸易自由，特别是妨碍资本自由流动的障碍，以及为什么同时要扎紧禁止劳动力自由流动的藩篱。</p><p>=&gt; 对“劳动力再商品化”的投资已经没有任何收益，一旦被要求承担社会福利成本，优秀的商人就会利用新获得的全球化自由，把他们的资金和企业带到国外，带到那些索求更少的地方。因此，那些坚持保持福利标准不变的政府被“双重打击”的恐惧所困扰：无家可归、一无所有的人蜂拥而入，资本（以及潜在的收入来源）蜂拥而出</p><p>=&gt; 民主的包容性越强，它就越果断地走向对弱者的保护，走向集体保险。选举权从普及的那一刻起，就一次又一次地把权力赋予那些承诺借集体力量驱逐个体苦难的政客</p><p>=&gt; 不久前对福利国家的支持也几乎是一个“跨越左和右”的共识，是一种真正的跨阶层的团结。对福利国家的态度长期具有大众共识，但是在近半个世纪，这个共识从普遍支持走向普遍反对。</p><p>=&gt; 民主政体中的大多数选民基于自己的意志支持社会不平等的加剧，这怎么可能呢？自从投票权实现真正的民主以来，自从投票权从有产阶级扩展到所有成年人并成为一种普遍权利以来，这种情况从未发生</p><p>=&gt; 毕竟穷困潦倒、难以自食其力的人始终是少数，在政治上也微不足道。他们也几乎不会去投票，忽视他们的利益和意愿相对容易，丝毫不会影响政治家的前途</p><p>=&gt; 于是政客自然而然地降低税收，讨好那些大多数更幸运的正常人。众所周知，那些真正需要帮助的人缺乏政治力量。</p><p>=&gt; “给穷人的方案都是糟糕的方案”，这个法则使得用于社会保障的金额不断地减少。“欺诈、欺骗和虐待”迟早会被发现：一个单亲母亲，通常是非裔母亲，用食品券买伏特加酒（这是里根主义者惯常的言论），不负责任的穷人，他们在福利政策的鼓励下生下孩子，等等。于是，到了最后一个阶段，福利保障体系不再受到欢迎，中产阶级对继续提供福利保障不再感兴趣，转而同意废除它。</p><p>=&gt; 国家福利体系和消费主义社会的氛围格格不入，这与它能提供的服务品质无关。产品的营销必须宣扬（至少口头上）对差异化和选择的崇拜，福利国家则必须追求公民生存环境、需求和人权的平等，它们是彼此对立的。</p><p>=&gt; 平权法案”的存在，使很多“业已成功”的非裔遭受轻视和贬低。如果没有人能找到理由质疑他们的成就名不副实，认为那只是一种恩赐，而非自觉努力、个人天赋、勤奋工作和正确抉择的产物，他们当然会更加欣慰。</p><p>既得利益者的嘴脸<br>=&gt; 一个新的、自信的非裔中产阶级已经诞生。但是，这些受益者们不愿承认，他们之所以能有今天的地位，并不是因为他们像其他美国人一样发挥了自己的智慧和勤奋，而是因为得到了帮助。这是他们争取尊严无法回避的问题。他们大声又明确地宣布，如果他们“做到了”，那么其他人也能做到，如果有人做不到，一定是因为他们不够努力。毕竟，这意味着，他们取得的所有成功都完全源于自己的努力</p><p>=&gt; 一个新的、自信的非裔中产阶级已经诞生。但是，这些受益者们不愿承认，他们之所以能有今天的地位，并不是因为他们像其他美国人一样发挥了自己的智慧和勤奋，而是因为得到了帮助。这是他们争取尊严无法回避的问题。他们大声又明确地宣布，如果他们“做到了”，那么其他人也能做到，如果有人做不到，一定是因为他们不够努力。毕竟，这意味着，他们取得的所有成功都完全源于自己的努力</p><p>他们是懂车门焊死的<br>=&gt; 获得社会帮助并脱离劣势地位的人，不仅失去了回馈的动力，而且变成了最强烈的诋毁者。从某种意义上说，“平权法案”培养的是自己的掘墓人</p><p>=&gt; 获得社会帮助并脱离劣势地位的人，不仅失去了回馈的动力，而且变成了最强烈的诋毁者。从某种意义上说，“平权法案”培养的是自己的掘墓人</p><p>=&gt; 仅仅是利用了一个历史上的瞬间——此时福利国家创造的社会资本还没有完全消散，福利国家衰败导致的新的社会成本尚且不高。福利国家和非福利国家的社会成本都很高，但介于两者之间的转型阶段的社会成本却可以被无知或虚伪地描绘为很小。或许很小，但这只是暂时的。</p><h3 id="◆-第四章-工作伦理和新穷人"><a href="#◆-第四章-工作伦理和新穷人" class="headerlink" title="◆ 第四章　工作伦理和新穷人"></a>◆ 第四章　工作伦理和新穷人</h3><p>=&gt; 无论接受救济的穷人是否真的不愿意参加生产，都丝毫不会影响生产力的增长。现在的企业不需要用更多的工人增加利润。即使他们需要工人，在世界的其他地方也能很容易地找到，而且价格便宜得多，虽然这加剧了本地穷人的贫困</p><p>真不能让大资本左右政治，太哈人了😨<br>=&gt; 对大公司而言，进步首先意味着“裁员”，科技进步意味着用软件取代人。谴责接受救济的人不愿意工作，推断他们只要摆脱麻木和依赖的惯性，就能轻而易举地自力更生，现在听起来像是自欺欺人。这从证券交易市场对就业波动的反应可以看出来，证券交易市场无意中成为企业利益最真诚的代言人。某国整体失业率快速上升时，你看不到证券市场有任何焦虑的迹象，更谈不上恐慌，它们反倒可能表现火爆。</p><p>=&gt; 对大公司而言，进步首先意味着“裁员”，科技进步意味着用软件取代人。谴责接受救济的人不愿意工作，推断他们只要摆脱麻木和依赖的惯性，就能轻而易举地自力更生，现在听起来像是自欺欺人。这从证券交易市场对就业波动的反应可以看出来，证券交易市场无意中成为企业利益最真诚的代言人。某国整体失业率快速上升时，你看不到证券市场有任何焦虑的迹象，更谈不上恐慌，它们反倒可能表现火爆。</p><p>=&gt; 这类人很少有抗争的意愿，特别是团结起来一致行动的意愿。所有的情况似乎都对他们不利。他们的工作是脆弱的，肯定不会持续很久，随时可能消失不见；今天的伙伴明天可能就各奔东西，去向遥远的地方……投身于工人的团结和集体抗争，需要付出长期的、充满风险的努力，注定收益不大，成本却高得难以计量。如果这样的状况持续很久，看不到任何改观，那些受雇者的世界观和心态也会相应变化。“今朝有酒今朝醉，明日愁来明日愁”和“各人自扫门前雪，莫管他人瓦上霜”在潜移默化之间不可避免地成为审慎而有效的生存哲学。</p><p>这也许就是编制的诱人之处吧，私企的话最好的永远是下家<br>=&gt; 即使是最常规、最乏味、最没有尊严的工作，只要（也正是因为）有望长期（在实践中，是需要无限期）持续，就有利于稳定、扎实、持久的人际关系的成长。这种“我们同舟共济”的感觉，即无论发生什么都一直待在一起——有福同享，有难同当——推动和促进了人们寻求最舒适、压力最小的共存模式。然而，如果你每天都可能身处不同的公司，又何必如此呢？在这种情况下，所有持久的关系、坚定的承诺和牢不可破的友谊都令人生疑地像是痛苦和失望的配方。如果你喜欢为之工作的公司，并期望未来一直和它携手前行，那么最多在下一轮的“外包”或“裁员”时，你就会受到伤害。总而言之，这种被称为“劳动力市场灵活性”的重要转变，给长期协作的可能性蒙上了一层阴影，更不用说对“共同事业”全心全意、无条件的承诺和忠诚。</p><p>=&gt; 即使是最常规、最乏味、最没有尊严的工作，只要（也正是因为）有望长期（在实践中，是需要无限期）持续，就有利于稳定、扎实、持久的人际关系的成长。这种“我们同舟共济”的感觉，即无论发生什么都一直待在一起——有福同享，有难同当——推动和促进了人们寻求最舒适、压力最小的共存模式。然而，如果你每天都可能身处不同的公司，又何必如此呢？在这种情况下，所有持久的关系、坚定的承诺和牢不可破的友谊都令人生疑地像是痛苦和失望的配方。如果你喜欢为之工作的公司，并期望未来一直和它携手前行，那么最多在下一轮的“外包”或“裁员”时，你就会受到伤害。总而言之，这种被称为“劳动力市场灵活性”的重要转变，给长期协作的可能性蒙上了一层阴影，更不用说对“共同事业”全心全意、无条件的承诺和忠诚。</p><p>=&gt; 在各种裁员、缩减规模的挤压游戏中，工人的士气和积极性急剧下降，幸存者等待着下一波冲击，而不是因为在竞争中战胜了被解雇的同僚而欣喜若狂”[5]。不管是失败还是（暂时）幸免，他们都充满怨恨，并以同样的方式屈服于恐惧</p><p>=&gt; 在一个灵活性的体制中，有难度的任务只会带来麻烦。这就带来一个可怕的悖论，当我们减少困难和阻力的时候，我们也在培育工作者不去挑选和漠不关心的行为</p><p>=&gt; 工作仍然是生存的源泉，但不是生命意义的源泉，当然也不是培育人与人之间纽带的温室，它不足以支撑和维持道德信念和道德实践。这个由工厂、办公室、工作间和商店构成的世界崇尚“灵活性”，“工作伦理”的戒律显得空洞乏味</p><p>=&gt; 资本家雇用工人不再受限于本地劳动力市场，因此，他们选择基地的首要标准是利润最大化，以及充足的低要求、温顺、不会招惹麻烦的劳动力。合格并迫切愿意成为“常规劳动者”的人随处可见，他们愿意接受任何工作，愿意接受最卑微的薪水。</p><p>=&gt; ，“他们不拥有工厂和土地，也不担任行政职务。他们的财富来自一种便携式资产：他们对迷宫法则的熟稔</p><p>=&gt; 他们都在不同程度上掌握并实践着“液态生活”（liquid life）的艺术：接受方向的迷失，免疫于晕头转向，容忍旅行计划和方向的缺失，以及无限期的旅行。以“赤脚医生”为笔名的《观察家报》专栏作家大概就是这样的人，他建议人们做任何事情都要从容</p><p>自私利己的新精英压榨另一个空间的大多数为少数人创造价值，于人类社会向上的发展是无益的<br>=&gt; 他们难以捉摸，坚定地拒绝付出，避免承诺。他们精通胡迪尼式的逃脱术，总是打破最复杂的枷锁，从最牢固的牢笼里逃脱。</p><p>=&gt; 他们难以捉摸，坚定地拒绝付出，避免承诺。他们精通胡迪尼式的逃脱术，总是打破最复杂的枷锁，从最牢固的牢笼里逃脱。</p><p>=&gt; 资本的流动削弱了国家对利率和汇率的影响，跨国公司的灵活性侵蚀了按地域分配投资的控制能力，技术和专业劳动力的全球流动使收入和财富的累进税征收更加困难，进而维持公共服务也更加困难。</p><p>=&gt; 如果说“失业”，甚至是长期失业，意味着工作生活的一个阶段，那么“过剩”则更贴近如今失业的本质。它暗示了一场不可逆转的灾难最终到来。它是通向废品站的一张单程票……</p><p>=&gt; 我们似乎从来没能在连续的萧条之后恢复就业水平。无论国民生产总值（GNP）和国内生产总值（GDP）的统计数字多么振奋人心，工作岗位仍在持续流失，徒劳寻找工作或因绝望放弃寻找工作的人持续增加。起初还不起眼，但渐渐地，经济“发展之路”的理念残酷地转向用更少的劳动力完成同样甚至更多的工作</p><p>=&gt; 过剩”的人则不同，他们是多余的、编外的，不被需要。他们要么出生在一个“饱和”的社会里（即社会的续存无需更多的人从事生产），要么由于经济和技术进步（即有了新的生产力，较少的人员参与就能满足日益增长的商品和服务需求），变得不再必要。所谓“过剩”的人被标记在资产负债表的借方，而非贷方，因为无论是现在还是可预见的未来，他们都不能增加社会的财富——他们增加的只是社会的负担（公共支出）</p><p>=&gt; “重返工作岗位”这个概念变得虚无缥缈，天真幼稚，又自欺欺人，这也证实，人们对“繁荣”的理解以及经济“向好”/“向坏”的理解，正在发生深刻的转变。</p><p>=&gt; 如今的精简型、小型化、资本和知识密集型产业，则把劳动力视为生产力提升的制约要素。这是对曾被奉为经典的斯密-里卡多-马克思劳动价值论的直接挑战。劳动力过剩被视为灾难，所有寻求合理化（提升投入产出比）的努力首先都会集中于进一步削减雇员数量的可能性。“经济增长”和就业率的提升，实际上是相互矛盾的；技术进步是以劳动力的替代和淘汰为标准的</p><p>=&gt; 近来重新鼓吹工作伦理的目的，是为了“将值得帮助的穷人和不值得帮助的穷人分开，把责难倾倒给后者，以合理化社会对他们的冷漠”，因此“说明贫穷是个人缺陷的必然后果，进而促成对穷人和被剥夺者的漠不关心”[9]。换言之，工作伦理虽然不再是减少贫困的手段，却能帮助调和社会众生和永恒存在的穷人之间的关系，有助于整个社会的安宁平和。</p><p>社会达尔文主义的偏执和傲慢<br>=&gt; 他们确实有一个共同点：在其他人看来，他们没有存在的必要，正是因为完全无用才会被归入底层社会——若他们消失，其他人会生活得更好。他们无疑是美丽风景线中的污渍，是丑陋又贪婪的杂草，他们对园林的和谐之美没有任何贡献，还偷走了其他植物的养分。如果他们消失，所有人都会获益。</p><p>=&gt; 他们确实有一个共同点：在其他人看来，他们没有存在的必要，正是因为完全无用才会被归入底层社会——若他们消失，其他人会生活得更好。他们无疑是美丽风景线中的污渍，是丑陋又贪婪的杂草，他们对园林的和谐之美没有任何贡献，还偷走了其他植物的养分。如果他们消失，所有人都会获益。</p><p>=&gt; 已有的分类可以不费吹灰之力地吸收和驯化新的威胁，同时让散布的恐惧集中在一个目标上——这个目标因具象化而使人安心。</p><p>=&gt; 这是底层阶级的无用性为社会提供的一种重要价值——这个社会中没有哪个行业或职业能够确信自己的长期有用性；这也是底层阶级的危险性为社会提供的一项重要服务——这个社会被太多焦虑困扰，人们根本无法分辨究竟在恐惧什么，如何减缓这种恐惧。</p><p>专家或资本家总喜欢鼓吹某种有利于己的观点，而不愿意承担创造这样条件的成本，失信于民在所难免<br>=&gt; 正如他的担心，去工业化似乎使越来越多的人口永久失业并无法再就业。这并不是因为失业的人自身的缺陷或道德上的瑕疵，纯粹是因为缺乏就业机会；也不是因为工作伦理无法有效激励，而是因为社会没能按照工作伦理的规则来保障生活。</p><p>=&gt; 正如他的担心，去工业化似乎使越来越多的人口永久失业并无法再就业。这并不是因为失业的人自身的缺陷或道德上的瑕疵，纯粹是因为缺乏就业机会；也不是因为工作伦理无法有效激励，而是因为社会没能按照工作伦理的规则来保障生活。</p><p>=&gt; 底层社会拒绝公认的价值观，只是因为他们觉得受到排斥。在和“大多数美国人”的双边关系中，底层阶级是主动行动的一方。他们的行为，也只有他们的行为，受到了批判性的审视，并被宣布为异常，而“大多数美国人”则理所当然地坐在审判席上审判底层阶级的行为。</p><p>=&gt; 在一个选择自由的国度里，没有做应该做的事，通常被不假思索地解释为作出了其他选择——在这个场景下，是选择了“反社会行为”。堕入底层阶级是自由的一种体现</p><p>=&gt; 永远不缺少机会，我们不都是活生生的例子吗？但是，必须具备发现机会的能力，具备拥抱它们的能力：一些智慧、一些意愿和一些努力。穷人很明显缺少这三种能力。</p><p>在从前工作伦理是约束劳动力直面苦闷工作的枷锁，在后现代中存在工作伦理不过是既得利益者自我开脱高高挂起的说辞，社会本就从未按工作伦理对其奉行者有任何实质馈赠与嘉奖而是宣扬什么自我贡献精神，不能站在弱势一方为民说话的专家当真可以闭嘴了<br>=&gt; 一开始，工作伦理是一种非常有效的手段，它可以帮助急需劳动力的工厂迅速扩充人员。随着劳动力迅速变成提高生产力的障碍，工作伦理仍然可以发挥作用，但这次是作为另一种有效手段：洗涤社会中正常人的双手和良知，帮他们从抛弃同胞致使同胞永久失业的罪责中摆脱出来。在对穷人的道德进行谴责的同时，对非穷人的道德实施赦免，通过这种双管齐下的方法，达到双手和良心的洁净。</p><p>=&gt; 一开始，工作伦理是一种非常有效的手段，它可以帮助急需劳动力的工厂迅速扩充人员。随着劳动力迅速变成提高生产力的障碍，工作伦理仍然可以发挥作用，但这次是作为另一种有效手段：洗涤社会中正常人的双手和良知，帮他们从抛弃同胞致使同胞永久失业的罪责中摆脱出来。在对穷人的道德进行谴责的同时，对非穷人的道德实施赦免，通过这种双管齐下的方法，达到双手和良心的洁净。</p><p>好家伙，直接挑起内部的阶级矛盾是吧<br>=&gt; 这个比喻简直无可挑剔。底层阶级在当今富裕社会最重要的作用之一，就是吸纳恐惧和焦虑，过去强大的外部敌人扮演了这个角色，但他们已不复存在。底层阶级是内部的敌人，注定要取代外部敌人，成为保持社会健康的关键药物，成为源于个体不安全感的社会紧张的安全阀。</p><p>=&gt; 这个比喻简直无可挑剔。底层阶级在当今富裕社会最重要的作用之一，就是吸纳恐惧和焦虑，过去强大的外部敌人扮演了这个角色，但他们已不复存在。底层阶级是内部的敌人，注定要取代外部敌人，成为保持社会健康的关键药物，成为源于个体不安全感的社会紧张的安全阀。</p><p>=&gt; 底层阶级冒犯了大多数人珍视的价值观，却又紧紧抓着它们，渴望像其他自力更生的人一样，获得消费生活的乐趣。换句话说，美国人对底层阶级真正的不满意在于，这些人的梦想，他们渴望的生活模式居然和自己如此相似</p><p>=&gt; 一个社会如果对自己的生存方式缺乏自信，就会产生围城心态。攻击城墙的敌人是它自己“内部的恶魔”：被压抑的、环绕着它的恐惧渗透进它的日常生活，渗透进它的“常态”。为了长盛不衰，这些恐惧必须被逐渐挤出，被塑造为一个异端形象：成为一个有形的敌人，人们可以与之不断斗争，并有望征服它。</p><p>=&gt; 这些人被告知，奢侈的消费是成功的标志，是赢得公众掌声和名誉的捷径。他们还了解到，拥有和消费某些商品，践行这种生活方式，是幸福的必要条件，甚至是实现人类尊严的必要条件。</p><p>=&gt; 如果消费是衡量成功人生的标准，衡量幸福的标准，甚至是衡量尊严的标准，那么人类欲望的潘多拉之盒已经打开，再多的购买和刺激的感觉，都不能唤回过去“达到标准”带来的满足感：现在根本就没有标准可言</p><p>玩游戏的人无论怎样都是输，而制订规则的人无论怎样都是赢，我们的焦虑与欲望是他人的收入与财富<br>=&gt; 无能、懒惰的玩家必须被排除在游戏之外，他们是这场游戏的废弃品，只要不停止游戏，不停止吸纳参与者，这种废弃品就会源源不断地产生。不停生产这种废弃品还有个重要原因：需要让仍在参与游戏的人看到作出其他选择的可怕后果（他们也被告知这是唯一的后果），这样他们就能够忍受，并愿意忍受这场游戏给他们的生活带来的艰辛压力。</p><p>=&gt; 无能、懒惰的玩家必须被排除在游戏之外，他们是这场游戏的废弃品，只要不停止游戏，不停止吸纳参与者，这种废弃品就会源源不断地产生。不停生产这种废弃品还有个重要原因：需要让仍在参与游戏的人看到作出其他选择的可怕后果（他们也被告知这是唯一的后果），这样他们就能够忍受，并愿意忍受这场游戏给他们的生活带来的艰辛压力。</p><p>=&gt; 在一个由消费市场激活和运营的、彻底去监管和私有化的社会里，放缓这个进程的希望可以说微乎其微，更不用说停止或逆转这个进程。</p><p>=&gt; 被政客们无所顾忌地用来恐吓日益壮大的底层社会”。美国那些沉默的大多数需要对底层阶级进行恐吓，以驱逐自己内心的恐惧</p><p>=&gt; 穷人不再是消费者社会的弃儿，他们在全面的竞争中败下阵来，彻头彻尾地成为社会的公敌。依赖救济的人和毒贩、强盗、杀人犯之间，只有一条能够轻易跨越的纤细界线。依赖救济的人是犯罪集团天然的温床，让人们依赖救济生存无异于支持犯罪。</p><p>=&gt; 道德的本质是为弱者、不幸的人、受苦难的人谋求福祉的责任冲动，给贫穷定罪可以消除和减弱这种冲动</p><p>=&gt; 当世界上任何一个国家宣称，我们的穷人是幸福的，他们之中没有无知，也没有痛苦，我们的监狱里没有囚犯，街道上没有有乞丐，年长者免于贫困，没有苛捐杂税……当一个国家敢于这么说时，它的宪法和政府就是值得夸赞的。</p><p>=&gt; 他们一旦失败，就会自然而然被认为是他们自己选择把自己排除在道德义务的边界之外。社会大众于是不再对他们的困境负有任何责任，也不会因为背弃了自己的道德义务而内疚。鉴于道德冲动的普遍性以及对人类苦难和屈辱的敏感性，这可以说是一项伟大的成就</p><p>=&gt; 所有的慈善盛宴都是为了间接强化（而非破坏）日常的规则。大规模慈善的景象使日常的镇静和道德的冷漠更容易忍受。最终，它们强化了在道德世界放逐穷人的信念。</p><p>=&gt; 我们声称需要帮助的人的人性”。“贫穷=饥饿”，这则等式掩盖了贫穷的复杂性：“令人恐怖的生存和居住条件、疾病、文盲、敌视、支离破碎的家庭、衰弱的社会关系、没有未来、没有生产能力”。</p><p>=&gt; 世界上的发达地区以事不关己的藩篱将自己包围起来，竖起一道全球的柏林墙，来自“外部”的信息都是战争、谋杀、毒品、抢劫、传染病、难民和饥荒，都是那些对我们造成威胁的东西</p><p>=&gt; 一个人造的咎由自取的景像沉淀在公众意识中：一个显而易见的“贫民街区”和“危险区域”的形象，一个夸张的黑帮，一个没有道德无法救赎的低等人的世界。把他们从自己酿造的苦果中拯救出来只能短暂有效，长期来看则注定失败，所有抛出的救命索必然纠缠在一起，形成死结。</p><p>=&gt; 一说到我们（富人们）对世界上穷人的持续痛苦负有集体责任，经济计算就会占据上风，自由贸易规则、竞争力和生产力取代了道德准则。经济发言的时候，道德最好保持沉默。</p><p>=&gt; 工作伦理是单向的。它阐述了那些在生存中挣扎的人的职责，却只字未提那些超越了维持生计、有着更高层次追求的人的职责。特别是，它否定了前者对后者的依赖，于是免除了后者对前者的责任</p><h3 id="◆-第五章-全球化之下的工作与过剩"><a href="#◆-第五章-全球化之下的工作与过剩" class="headerlink" title="◆ 第五章　全球化之下的工作与过剩"></a>◆ 第五章　全球化之下的工作与过剩</h3><p>=&gt; 资本主导的现代化逻辑违背了人们的期望。资本主义初期，其动力来自征服并殖民“处女地”——把生产者和生产资料分离，把商业活动和家庭经济分离，从而把非现代化的生活带入市场经济的轨道，并将其变成资本的牧场。</p><p>=&gt; 股东的短期回报极大地激励了这个信誓旦旦的表述掩盖的乱象”。于是，“有效可行的商业被破坏和弃置，有能力的员工被解雇而非获得奖励，只因为组织必须向市场证明它有能力改变”</p><p>=&gt; 在目前的情况下，一种有效的方法是兼并，这种兼并有时是友好的，但大多数是恶意的，随之而来的就是“资产剥离”“精简”“外包”和大规模（自愿或不自愿的）裁员。</p><p>=&gt; 通过大规模驱逐过剩人口，把本地产生的“社会问题”输出到远方的另一个原因，是担心拥挤在城市里“过剩的人”成为不安定因素</p><p>=&gt; 但总体来说，移民都是从世界上“较发达”（现代化程度较高）的地区向“不发达”（在现代化冲击下还未舍弃其传统的社会经济平衡）的地区流动。</p><p>=&gt; 欧洲人走到哪里，死神就降临哪里</p><p>=&gt; “本质上，正义站在殖民者和开拓者这边：否则这片伟大的大陆只能成为肮脏野蛮人的庇护所。”[7]罗卡将军（Roca）是阿根廷历史上臭名昭著的“征服沙漠”事件的指挥官，“征服沙漠”这个委婉的名字背后是对潘帕斯地区的印第安人的“种族清洗”。罗卡将军向他的同胞解释说，他们的自尊迫使他们“尽快以理性或武力的方式打倒这群野蛮人。他们破坏了我们的财富，阻止我们以法律、进步和自身安全的名义，占领共和国最富饶最肥沃的土地”[8]。</p><p>=&gt; 技术的进步拓展了曾被认为不适合人类居住的区域（当然成本也不断增加），但也削弱了很多区域容纳人类居住和耕作的能力，经济进步使过去的谋生方式不再可行、不切实际，从而增加了休耕和废弃的荒地面积。</p><p>=&gt; 制造“人类废弃物”，或者更正确地表述为，制造无用的人（“过剩”“不必要”“编外”“冗余”的人口，即那些不能被留下、也不被接纳的人口），是现代化过程不可避免也难以处理的结果，与现代化如影相随。这是秩序建立（每种秩序都会丢弃现存人口中“不协调”“不合适”或“不受欢迎”的部分）和经济发展（经济发展不可能不破坏和废弃之前行之有效的谋生方式，也必须剥夺一些从业者的生计）不可避免的副作用。</p><p>=&gt; 当商品化、商业化和货币化进程渗透进人类的每个缝隙，本地产生问题的全球化解决方案也就不再可行，或者说本地过剩人口的全球出口方案不再能够实施</p><p>=&gt; 地球的这种饱和，本质上意味着过剩人口处理面临严重危机。在过剩人口的产生有增无减，不断上升到新高度的同时，地球上的垃圾场和垃圾回收的工具却急剧短缺</p><p>=&gt; 全球人口过剩的警报（没有足够的就业，也没有足够的福利保障）已经拉响。于是，“移民”和“难民”成了当代政治议程新的核心，模糊又无所不在的“安全担忧”在新兴的全球战略和权力斗争中发挥着越来越重要的作用。</p><p>=&gt; 远方的人遭受苦难直接或间接的源头，或许正是我们此时此地的所作所为，但由于距离遥远，它们并不会引起道德上的共鸣，也不会像身边所见的苦难那样能够引发强烈的行动意愿</p><p>=&gt; 我们的相互依赖是全球性的，而道德义务，始终局限于本地</p><p>=&gt; 全球化正在产生一种全球经济。在这个体系中，任何一个国家试图阻止其工人贫困化的努力只能导致他们丧失工作机会。”[9]不要问丧钟为谁而鸣，丧钟为所有人而鸣</p><p>=&gt; 我们应该教育我们的孩子，让他们认识到不公平：我们这些坐在桌子后面敲打键盘的人的工资，是那些打扫厕所弄脏双手的人的10倍，是那些在第三世界国家制造键盘的工人的100倍。我们应当让他们看到问题的所在：先实现工业化的国家的财富是尚未实现工业化的国家的100倍</p><p>=&gt; 计算机只是号称要创造平等世界的众多商品的一个代表，事实上，这些商品确实取悦于消费者，但根本无法拯救其生产者于苦难。“耐克运动鞋的轨迹可以追溯到越南的血汗工厂，芭比娃娃的衣服可以追溯到苏门答腊的童工，星巴克的拿铁咖啡可以追溯到危地马拉被烈日炙烤的咖啡园，壳牌石油则可以追溯到尼日尔三角洲被污染的贫困村庄。</p><p>=&gt; 丧失工作能力的人和被永远废弃的人之间的界限逐渐模糊，不再清晰可辨。现在，“过剩”不再是一部分人的问题，所有人都将面对这种可能性，人们的社会地位将不断在两级之间摇摆</p><p>=&gt; 这是“现代性后来者”被迫实施的“本地解决方案”之一。成千上万的人被赶出家门，死于杀戮，或被迫逃出国境。</p><p>=&gt; 过去那些致力于争取减少国家干预，以解放资本及其对于劳动力的使用，并取得显著成功的人，今天却在拼命要求增加国家干预，以遏制放松就业管制和落后区域社会保护恶化造成的恶</p><p>=&gt; 如果这种开除或跌落被认为是暂时的，是短暂的回收再造阶段（一个“康复期”，以回归到生产工作中去）的开始，那么这种社会保障对政治谱系的两翼来说都是具有显著意义的。然而，一旦这种回收再造的前景变得遥不可及，用于重塑的设施也越来越无法容纳那些堕落的、永远无法重生的人，这种社会保障很快就失去了“不只是左右”的支持</p><p>=&gt; 社会国家正在逐步地，不可逆转地变成亨利·A.吉鲁（Henry A. Giroux）所说的“卫戍型国家”（garrison state）[13]。他将其描述为一个越来越多地保护全球跨国企业利益的国家，“同时在国内加强了压制和军事化程度”。如今，社会问题越来越趋向于犯罪化</p><p>简单赋个红码<br>=&gt; 所有系统都要执行的“模式维持”（pattern-maintenance）和“紧张关系管理”（tension-management）任务，目前可以完全归结为通过物理区域来隔离这些“无用之人”，并将其排除在其他正常人所处的法律框架之外，以“化解”和“中和”这个问题。既然“无用之人”已经不能被放逐到遥远的垃圾处理场，也不能被放置在“正常生活”的边界之外，那就需要用密闭的容器将其封存起来。</p><p>=&gt; 所有系统都要执行的“模式维持”（pattern-maintenance）和“紧张关系管理”（tension-management）任务，目前可以完全归结为通过物理区域来隔离这些“无用之人”，并将其排除在其他正常人所处的法律框架之外，以“化解”和“中和”这个问题。既然“无用之人”已经不能被放逐到遥远的垃圾处理场，也不能被放置在“正常生活”的边界之外，那就需要用密闭的容器将其封存起来。</p><p>=&gt; 监狱是把穷人和失业者（更准确地说，无法就业的人）从“社会问题”范畴转移到法律秩序范畴的过程中采用的手段，是消除他们对于整个社会潜在的破坏性影响的投资。所有这些手段，如不断扩展的城市贫民窟、了无生气的难民营，都涉及由安保人员提供的空间隔离服务。社会工作者和社会福利人员已经被他们完全取代。</p><p>=&gt; 保护自己的公民，保护他们不被裁员、不被排斥、不被拒绝，帮助他们对抗命运的冲击——不因个人不足或不幸而沦为“过剩人口”。简而言之，承诺公民生活的确定性和安全性，对抗混乱和偶然性。如果有人不幸跌倒，身边的人会拉住他们的手，帮助他们再次站起来。</p><p>=&gt; 个人身心安全和私人财产无时不处于威胁之中的心态，是可以积极培养的。威胁必须被渲染上最邪恶的色彩，这样一来，无形的不可预测的威胁，就可以作为一个非常事件展现在惊慌失措的公众面前，当然更重要的是让他们认识到国家机关应对这些威胁的卓越能力、警惕性和良好意愿</p><p>=&gt; 附带伤害”（collateral damage）是一个新生词，专门用来指代世界新边域环境中的过剩人口。这种新边域环境被无法抑制的猛烈全球化力量制造出来。</p><h3 id="◆-第六章-新穷人的前景"><a href="#◆-第六章-新穷人的前景" class="headerlink" title="◆ 第六章　新穷人的前景"></a>◆ 第六章　新穷人的前景</h3><p>=&gt; 渴望把人类世界变成一个无机的世界，在那里一切都完美运行，按部就班，服从于一个超越个体的系统。然而，向往秩序就是向往死亡，因为生命本身就是不断破坏秩序的过程。或者换句话说：对秩序的渴望是一种堂皇的托辞，是强烈厌世的借口。</p><p>=&gt; 规范是秩序模式在人类行为上的投影。规范告诉人们，在一个秩序井然的社会中，有秩序的行为意味着什么；可以说，它把秩序的思想翻译为人类的行为选择</p><p>=&gt; 秩序的设立和推广意味着实施驱逐——把一种特殊的管理制度加诸将被驱逐的人，使他们屈服于这种制度，从而驱逐他们。另一方面，规范（任何规范，工作伦理的规范只是其中之一）则间接地发挥着作用，使得驱逐看上去更像是自我边缘化。</p><p>=&gt; 就秩序而言，被流放、被驱逐的是那些“违反秩序”的人；就规范而言，则是那些“不符合规范”的人。无论哪种情况，责任主要都在于被驱逐者，秩序和规范都预置了责任，先验地决定了“罪”与“罚”</p><p>现代化经济不停地制造出新穷人，而现代化的主人们也自发地将他们打上懒惰的烙印并心安理得将他们驱逐，只因他们同样期望与我们拥有同样有尊严的生活。市场的自由化，阶层的固化，少数人支配着大多数的资源，时至今日人类还是需要共产主义，一个真正地让弱势群体也可以操控自己命运的体制<br>=&gt; 被驱逐的人可能根本无力对抗自己不幸的命运，更遑论控制。有些人可能只是因为自己的出身“违背了秩序”。他们因为自己无法决定的一些特质而被驱逐，他们没有做错什么，只是“像他们这样的人”不符合其他人的秩序观。另一些人或许也不是因为缺乏意愿而“达不到规范”，而是因为缺乏某些必要的资源——其他人有而他们没有的资源。这些资源供不应求，不可能所有人都充分拥有。</p><p>=&gt; 被驱逐的人可能根本无力对抗自己不幸的命运，更遑论控制。有些人可能只是因为自己的出身“违背了秩序”。他们因为自己无法决定的一些特质而被驱逐，他们没有做错什么，只是“像他们这样的人”不符合其他人的秩序观。另一些人或许也不是因为缺乏意愿而“达不到规范”，而是因为缺乏某些必要的资源——其他人有而他们没有的资源。这些资源供不应求，不可能所有人都充分拥有。</p><p>=&gt; 剥夺那些不知道如何正确使用自己力量的人的力量，千方百计使他们屈从于他们逃避、反抗的“超越个人的制度”。</p><p>=&gt; 每一个已知的社会都对穷人持一种特有的矛盾态度，一方面是恐惧和反感，另一方面是怜悯和同情。这两种成分都不可或缺。前者允许在需要秩序维护的时候对穷人进行严厉的处理；后者强调了那些达不到标准的人的悲惨命运，由此让正常生活的人在遵守社会规范时遭遇的所有艰辛都变得微不足道。</p><p>=&gt; 穷人的存在是上帝的礼物：一个实践自我牺牲、施行善举、忏悔罪孽、获得救赎的机会。可以说，一个依靠来世寻求尘世生活的意义的社会，如果没有穷人的存在，就需要另外寻找一种救赎的手段。</p><p>=&gt; 褪去宗教光环的世界里，没有什么可以仅仅因为存在而享有权利，所有事物都必须展示出合法、合理的证据证明自己可以享有权利。</p><p>=&gt; 他们对稳定的工资不感兴趣，一旦有了足以度日的面包，就不愿意继续忍受长时间的苦役。这确实是一个恶性循环：穷人反抗他们遭受的苦难导致叛乱和革命，穷人妥协于他们悲惨的命运遏制和阻碍工业企业的进步。[4]强迫穷人在工厂长期劳作似乎是解决这种循环的一种有效方法。</p><p>=&gt; 人们还是普遍认为工作伦理是一剂良药，甚至不可或缺，可以一石三鸟地解决贫困、劳动力不足和革命的威胁，能够成为撒在苦涩糕点表面的糖霜。把枯燥无味的工作提升到崇高的道德责任，或许能够让从事这些工作的人甘之如饴，同时也迎合了那些提供工作的人的道德良知</p><p>=&gt; 约翰·洛克（John Locke）制定了一个全面的方案以消除穷人与生俱来的“放纵”和“懒惰”：把穷人的孩子关在贫民学校里培训他们从事正规的工作，把他们的父母关在工棚里严加管教，用微薄的收入、强迫劳动和体罚约束他们。另一方面，哀叹穷人“悲惨、可怜、不幸、软弱、无用”的约瑟亚·柴尔德（Josiah Child），也认为“让穷人工作”是“人对上帝和自然的责任”</p><p>口头说的：工人要为厂里想，少谈薪资多谈贡献<br>心里想的：xx懒狗，工资不低到吃不饱饭能行吗？<br>=&gt; 人们普遍认为，穷人往往安于现状，不会为了更多利益而拼命工作，所以他们的工资必须保持在满足生存的最低水平。这样一来，即使有了工作，穷人也只能勉强糊口，就会为了生存而保持忙碌</p><p>=&gt; 人们普遍认为，穷人往往安于现状，不会为了更多利益而拼命工作，所以他们的工资必须保持在满足生存的最低水平。这样一来，即使有了工作，穷人也只能勉强糊口，就会为了生存而保持忙碌</p><p>=&gt; 任何形式的经济诱导都达不到目的，要对付善变又愚蠢的穷人，赤裸裸的强制最为有效。他建议建造500间房屋，每间房屋容纳2 000个“累赘的穷人”，由专人全权负责，不间断地监视</p><p>=&gt; 尽管存在大量的反面证据，人们还是顽固地认为废除普遍的以工代赈是造成贫困的首要原因，解决贫困问题应当着力于引导失业者重返劳动力市场。若用通俗的话来表述公共政策，那就是：只有作为商品的劳动才能换取同样商品化的生活资料。</p><p>=&gt; 今天的穷人保留着工业化时代初期赋予他们的职能——后备的劳动力。这种定位使人们对那些“未服役者”的操守产生了怀疑，并为他们明确指出“归队”（从而恢复因逃避服役而破坏的秩序）的途径。然而，问题在于，曾经用于把握和阐述工业时代初期现实的哲学，已经迷失在工业时代末期的现实之中。这种哲学曾致力于建立新秩序，却慢慢地变成了烟幕，掩盖了穷人前所未有的新困境。把穷人塑造成后备劳动力的工作伦理，在诞生时是一种启示，在死后却变成了一种掩饰。</p><p>=&gt; 后现代的消费者社会无需把大部分社会成员卷入工业劳动就能够茁壮成长。实际上，穷人不再是后备劳动力，工作伦理的呼吁越来越虚无缥缈，与当今的现实脱节。</p><p>=&gt; 今天的穷人是“不消费的人”，而非“失业者”。他们首先被定义为有缺陷的消费者，因为他们没有履行最重要的社会责任——积极有效地购买市场提供的商品和服务。</p><p>=&gt; 由此，福利国家的全面衰退也就不足为奇。只有极少数国家的福利体系还完好无损，或者说去福利国家的进程较为缓慢。</p><p>=&gt; 要么是欧洲式高速上升的失业率，要么是美国式快速下降的底层阶级收入，但这两者并没有多大区别。</p><p>=&gt; 过去的20年里，美国收入最低20%家庭的总收入下降了21%，而收入最高20%家庭的总收入则上升了22%。[5]劫贫济富的收入再分配以不可阻挡的速度进行着。</p><p>=&gt; 如果穷人试图捍卫福利体系的残存，他们很快就会发现自己没有谈判的筹码，无法传达自己的声音，更不可能给对手造成威胁。他们尤其没有任何能力来打动社会上的普通公民，大众受到了政客的蛊惑，他们被劝说不要因为内心的冲动投票，而要根据自己的利益投票</p><p>=&gt; 穷人似乎并不关心自己的困境，即使他们关心，也没有任何实际证据表明他们的愤怒和付诸行动的决心。</p><p>=&gt; 临时雇用制深刻影响了饱受其苦的人，通过把人们的未来变得更不确定，它制止了所有的理性预期，尤其熄灭了人们对未来的基本信念和希望。然而人们需要这种信念和希望来反抗（特别是集体反抗）目前这个最无可容忍的现状。</p><p>=&gt; 这就是为什么现在那些“被驱逐者”没有要求，也没有计划，不重视自己的权利，也不履行自己作为人、作为公民的义务。既然他们在别人眼里如同不存在，逐渐地，他们在自己眼里也不复存在。</p><p>=&gt; 把剥夺的故事改写为自甘堕落的故事。穷人可以作为“嫌疑惯犯”，一旦日常秩序中出现问题，他们就成为公众追捕的对象。穷人被描绘为懒散、罪恶、缺乏道德标准的人。媒体与警方欣然合作，向追求耸人听闻的公众展示犯罪、毒品、滥交等“犯罪分子”的丑陋画面，而穷街陋巷正是他们的栖身之所。于是，贫困问题首先是（也许仅仅是）法律和秩序问题，人们应该以应对其他违法行为的方法来对待贫困问题。</p><p>=&gt; 纳粹的暴行并非因为喜欢暴行，而是因为责任；并非为了施虐，而是为了美德；并非基于快感，而是基于方法；并非肆无忌惮、释放野性的冲动，而是以优秀的价值观为名，以专业的能力持之以恒地完成面前的任务</p><p>=&gt; 一旦道德共同体的消亡与解决棘手问题的先进技术相结合，“你的生存机会几乎为零”[10]。解决麻烦的理性方案，辅之以道德上的冷漠，造就一件爆炸性混合物。很多人会死于这场爆炸，而最醒目的牺牲品是躲过这场劫难的幸存者的人性。</p><p>=&gt; 幸运的是，人类的历史上到处都是未能成为现实的不祥预言。但是，因为缺少警告或对警告不以为然，历史中也发生了很多最令人发指的罪行。现在和过去一样，选择权在我们手中。</p><p>=&gt; 西方世界的危机“恰恰在于不再质疑自己”[11]。然而，“质疑自己”正是西方世界追求令人惊讶的、史无前例的自我完善的最深层秘密，也是西方世界成功追求最雄心勃勃目标的最深层秘密。</p><p>独立思考从质疑开始<br>=&gt; 一切都以有效性优先，但对谁有效？基于什么？目的是什么？经济增长是实现了，但这是什么的增长？为谁而增长？付出了什么代价？达到了什么目的？”</p><p>=&gt; 一切都以有效性优先，但对谁有效？基于什么？目的是什么？经济增长是实现了，但这是什么的增长？为谁而增长？付出了什么代价？达到了什么目的？”</p><p>=&gt; 个人收入权利和实际收入能力脱钩”[13]的构想。这是可以实现的，只需要改变一个视角，即从工作伦理决定的以雇佣劳动为中心，转变为人的地位和尊严决定的以基本权利、基本保障为中心。通过以税收为社会保障提供资金且废除经济审查和工作意愿评估的原则，通过逐步以需求原则取代等价原则，通过个人作为权利基础的原则，这种构想就能够切实推进</p><p>=&gt; 当所有依靠选举的政治力量都在奔向相反的方向，把疾病的症状看作康复的迹象，把疾病的原因看作良药，这些建议不可能引起任何关注</p><p>=&gt; 工作和劳动力市场的去耦。梅丽莎·本恩（Melissa Benn）最近指出：“当男性政治家谈论工作时，他们所指的总是有偿工作。”[14]这并不完全正确，因为不论男性，还是女性政治家，他们在谈论工作时想到的都是“有偿工作”</p><p>=&gt; 这种无人质疑的歧视和工作伦理同流合污，认为劳动力市场之外不以交易为目的的劳动，都意味着失业，等同于没有工作</p><p>=&gt; 为了把工作从以市场为中心的计算和限制中解放出来，就必须以工艺伦理（ethics of workmanship）取代劳动力市场发展过程中形成的工作伦理。索尔斯坦·凡勃伦（Thorstein Veblen）早就指明，“工艺本能”（instinct of workmanship）有别于工作伦理这个现代发明，是人类的自然倾向。人是具有创造力的生物。如果认为标价牌是区分工作与非工作、努力与懒惰的标准，那是对人类本性的贬低；如果认为没有收益，人们宁愿闲着，让自己的技能和想象力腐烂生锈，那是对人类本性的肢解。工艺伦理将恢复人类本能的尊严，恢复社会公认的意义。现代资本主义社会形成且根深蒂固的工作伦理却否认了这种尊严和意义。</p><p>=&gt; 收入权利与收入能力脱钩，工作与劳动力市场脱钩</p><p>=&gt; 我们的时代并未阻止乌托邦的脚步，反而为其回归做好了准备。我们越是复述政治没有梦想的空间，就越是渴望一个完全不同的世界</p><p>=&gt; 我们将不得不放弃目前生活模式中一些神圣不可侵犯的假设（由于缺少反思，它们显得更加神圣）。例如，效率是一件好事，无论它目的何在，也无论它是否会带来痛苦的副作用。再例如，凡是“经济增长”的东西，即统计意义上“今天比昨天多，明天比今天多”的东西，就是好的，而无视其增长过程中对人类生存环境和自然（全人类共享的生存环境）造成的损害。</p><p>=&gt; 我们只能再次引用科尼利厄斯的话来回答。当一个采访者问他：“那么，你想要什么？改变人类吗？”，卡斯托利亚蒂斯回答说：“不，没有那么夸张：我希望人类改变，正像他们已经改变过两三次那样。</p><p>=&gt; 群体自愿的返璞归真，正成为群体贫困的唯一有意义的替代</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.fosu.gq/Autovy/ImageExpand/master/img202211280912430.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="社会" scheme="https://autovy.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="政治" scheme="https://autovy.github.io/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="工作伦理" scheme="https://autovy.github.io/tags/%E5%B7%A5%E4%BD%9C%E4%BC%A6%E7%90%86/"/>
    
      <category term="消费型社会" scheme="https://autovy.github.io/tags/%E6%B6%88%E8%B4%B9%E5%9E%8B%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="底层阶级" scheme="https://autovy.github.io/tags/%E5%BA%95%E5%B1%82%E9%98%B6%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|倦怠社会</title>
    <link href="https://autovy.github.io/2022/09/04/BookNote/%E3%80%8A%E5%80%A6%E6%80%A0%E7%A4%BE%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://autovy.github.io/2022/09/04/BookNote/%E3%80%8A%E5%80%A6%E6%80%A0%E7%A4%BE%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-04T06:30:00.000Z</published>
    <updated>2023-03-26T14:51:54.127Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280959526.jpeg" alt="img"></p><span id="more"></span><p>倦怠社会（回归哲学的人文传统和批判传统，独辟哲学写作新境界，在数字媒体时代照察现实社会和人类心灵）<br>韩炳哲<br>100个笔记</p><p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280956508.png" alt="image-20221128095633124"></p><h3 id="◆前言-倦怠的普罗米修斯"><a href="#◆前言-倦怠的普罗米修斯" class="headerlink" title="◆前言 倦怠的普罗米修斯"></a>◆前言 倦怠的普罗米修斯</h3><p>=&gt; 如此看来，普罗米修斯同鹫鹰的关系是一种自我指涉关系，一种对自我的剥削。肝脏自身并无痛觉，而由此导致的疼痛感即是倦怠感（Müdigkeit）。普罗米修斯作为自我剥削式主体被一种永无止境的倦怠感攫住。他是倦怠社会（Müdigkeitsgesellschaft）的原初喻象。</p><p>在“正能量”的，被胁迫着跑的社会，佛丧躺都是个人的自我愈合<br>=&gt; “诸神累了，老鹰累了，伤口在倦怠中愈合了。”卡夫卡在此呈现了一种有治愈功能的倦怠，这种倦怠不会撕裂伤口，反而使之愈合。</p><p>=&gt; “诸神累了，老鹰累了，伤口在倦怠中愈合了。”卡夫卡在此呈现了一种有治愈功能的倦怠，这种倦怠不会撕裂伤口，反而使之愈合。</p><h3 id="◆精神暴力"><a href="#◆精神暴力" class="headerlink" title="◆精神暴力"></a>◆精神暴力</h3><p>没有并没有🙃<br>=&gt; 每个时代都有其占据主流的疾病。例如历史上的细菌时代，随着抗生素的发现而走向终结。尽管我们对于大型流感仍然怀有强烈的恐惧，然而如今我们已不再身处病毒时代。有赖于免疫科学的发展，我们已经摆脱了这一历史阶段。</p><p>=&gt; 每个时代都有其占据主流的疾病。例如历史上的细菌时代，随着抗生素的发现而走向终结。尽管我们对于大型流感仍然怀有强烈的恐惧，然而如今我们已不再身处病毒时代。有赖于免疫科学的发展，我们已经摆脱了这一历史阶段。</p><p>=&gt; 各种精神疾病，如抑郁症、注意力缺陷多动症（ADHS）、边缘性人格障碍（BPS）或疲劳综合征（BS）主导了21世纪初的疾病形态。它们不是传染性疾病，而是一种梗阻病，不是由免疫学上他者的“否定性”导致，而是由一种过量的“肯定性”引发。</p><p>=&gt; 一种盲目性被烙印其中：对一切陌生之物，都采取防御措施。免疫防御的对象即是这种陌生之物。即便陌生者毫无恶意，即便他不会产生任何威胁，仍然会基于他的“他者性”（Andersheit）而受到排挤。</p><p>=&gt; 杂糅性（Hybridisierung）不仅主导着当下的文化理论话语，同时也操控了现今的一切生活体验，这与免疫原则恰恰相反。免疫学上的知觉过敏（Hyperästhesie）不能容忍杂糅性</p><p>=&gt; 由过度生产、超负荷劳作和过量信息导致的肯定性暴力不再是“病毒性的”。免疫反应无法与之沟通。由过量肯定性引发的排斥反应不等同于免疫反应，而是一种消化神经上的功能异常和障碍。由于过量导致的疲乏、困倦和窒息感也并非免疫反应。它们都是神经暴力引发的现象，由于它们不是由免疫学的他者所致，因此是非病毒性的。</p><p>=&gt; 肯定性的暴力不需要一种敌对关系作为前提。相反，它正产生于一个宽容、平和的社会。因此它比病毒性暴力更加隐蔽。它存在于一个缺乏否定性的同质的空间内，没有敌我、内外、自我与他者的两极对立。</p><p>=&gt; 肯定性暴力不是剥离式（privativ），而是饱和式（saturativ）；不是单一排他，而是兼收并蓄。因此，人们不能直观地感受到这种暴力形式</p><p>人类的危机不再是来着外部的威胁，而是内部的自我锈蚀<br>=&gt; 神经暴力并不来自一个系统之外的否定性他者，而是源自系统内部。无论是抑郁症、注意力缺陷多动症或疲劳综合征都指向一种过度的肯定性。疲劳综合征即自我在过度狂热中燃尽了自身，源自过量的同类者。多动症中的“过量”概念也不属于免疫学范畴，它仅体现了肯定性的过度。</p><p>=&gt; 神经暴力并不来自一个系统之外的否定性他者，而是源自系统内部。无论是抑郁症、注意力缺陷多动症或疲劳综合征都指向一种过度的肯定性。疲劳综合征即自我在过度狂热中燃尽了自身，源自过量的同类者。多动症中的“过量”概念也不属于免疫学范畴，它仅体现了肯定性的过度。</p><h3 id="◆超越规训社会"><a href="#◆超越规训社会" class="headerlink" title="◆超越规训社会"></a>◆超越规训社会</h3><p>=&gt; 21世纪的社会不再是一个规训社会，而是功绩社会。其中的成员也不再是“驯化的主体”，而是功绩主体</p><p>规训社会的运行逻辑是建立在恐吓上，而功绩社会的运行逻辑建立在画饼上<br>=&gt; 规训社会尚由否定主导，它的否定性制造出疯人和罪犯。与之相反，功绩社会则生产抑郁症患者和厌世者。</p><p>=&gt; 规训社会尚由否定主导，它的否定性制造出疯人和罪犯。与之相反，功绩社会则生产抑郁症患者和厌世者。</p><p>=&gt; 将生产最大化的渴望显然存在于社会集体无意识之中。当生产达到一定发展阶段时，禁令的规训法则，或者说其否定模式，便达到其极限。为了进一步扩大生产，规训范式必须由功绩范式，或曰“能够”的肯定性模式来取代。因为当生产水平发展到一定程度时，禁令的否定性起到阻塞的效果，妨碍了继续发展。肯定性的“能够”比否定性的“应当”更有效率。</p><p>=&gt; 抑郁的人是一种劳作动物（animal laboran），他在没有任何外力压迫的情况下，完全自愿地剥削自我。他同时是施暴者和受害者</p><p>阴郁来源于功绩社会过度的期待，这一代年轻人不断地造新词——佛丧躺，其本质都是功绩社会对青年人不切实际的期待，真别相信后人的智慧了，你们烂摊子我们真没责任去背负<br>=&gt; 只有在一种相信“一切皆有可能”的社会中，才有抑郁症病人发出哀叹：“没有什么是可能的。”不再能够的能够（Nicht-Mehr-Können-Können）导向一种毁灭性的自我谴责和自我攻击。功绩主体和自身作战。抑郁症患者是这场内在战争中的伤残者。一个社会苦于过度的积极性，因此患上了抑郁症。</p><p>=&gt; 只有在一种相信“一切皆有可能”的社会中，才有抑郁症病人发出哀叹：“没有什么是可能的。”不再能够的能够（Nicht-Mehr-Können-Können）导向一种毁灭性的自我谴责和自我攻击。功绩主体和自身作战。抑郁症患者是这场内在战争中的伤残者。一个社会苦于过度的积极性，因此患上了抑郁症。</p><p>=&gt; 工作和效绩的过度化日益严重，直到发展成一种自我剥削。这比外在的剥削更有效率，因为它伴随着一种自由的感觉。剥削者同时是被剥削者。施虐者和受害者之间不分彼此。这种自我指涉性产生了一种悖论式自由，由于其内部固有的强制结构而转化为暴力。</p><h3 id="◆深度无聊"><a href="#◆深度无聊" class="headerlink" title="◆深度无聊"></a>◆深度无聊</h3><p>=&gt; 过度的积极性还可以呈现为过度的刺激、信息和资讯，它从根本上改变了注意力的结构和运作方式。感知因此变得分散、碎片化。</p><p>=&gt; 过去人们关心如何拥有美好的生活，其中也包含了如何融洽地共同生活，如今人们则只考虑如何存活下去。</p><p>=&gt; 这种涣散的注意力体现为不断地在多个任务、信息来源和工作程序之间转换焦点。由于这种注意力不能容忍一丝无聊，因此它也绝不接受一种深度无聊，而这种深度无聊恰恰对于创造活动具有重要意义。瓦尔特·本雅明把这种深度无聊称作“梦之飞鸟，孵化经验之蛋”</p><p>=&gt; 一味的忙碌不会产生新事物。它只会重复或加速业已存在的事物。</p><p>=&gt; 然而同线型、笔直的走路相比较，动作花哨的舞蹈显得过于铺张，完全不符合效绩原则的要求。</p><p>=&gt; 只有沉思的专注力才能解读悬浮不定之物，隐蔽或飘忽即逝之物。[3]只有停留在沉思之中，才能进入悠长、从容的状态。持久的形式和状态消除了一切过动症状</p><p>我们逐渐失去对不干正事的耐心，总在希望着追求什么获得什么，对结果太过执着也无法安心体会过程之美<br>=&gt; 由于缺少安宁，我们的文明将逐渐终结于一种新的野蛮状态。行动者，即那些永不安息的人如今大行其道，超越以往任何时代。因此，人们应当对人性做出必要的修正，在其中大量增加悠闲冥想的成分</p><p>=&gt; 由于缺少安宁，我们的文明将逐渐终结于一种新的野蛮状态。行动者，即那些永不安息的人如今大行其道，超越以往任何时代。因此，人们应当对人性做出必要的修正，在其中大量增加悠闲冥想的成分</p><h3 id="◆积极生活"><a href="#◆积极生活" class="headerlink" title="◆积极生活"></a>◆积极生活</h3><p>=&gt; 在这个外太空的观察者看来，人类的发展如同一种生物的突变过程，在这一过程中，人类的躯体像蜗牛一般包裹着金属外壳，如同细菌一样，以突变的方式同抗生素进行对抗</p><p>=&gt; 过去，宗教信仰作为一种塔纳托斯技术（Thanatotechnik）能够平息人类对死亡的恐惧，并带来一种永久持存的感受，如今也完全失效了。世界进入一种普遍的去叙事化（Entnarrativisierung）进程，更加增强了人的飘忽即逝之感。这种转变揭去了人类生活的遮蔽，使其呈现出赤裸（nackt）的状态</p><p>=&gt; 现代晚期的功绩社会把我们所有人的生命都降低为赤裸的生活，那么所有人都毫无例外地成了神圣人，而不仅是那些位于社会边缘、身处特殊状态的人，即那些被排除在外的人</p><p>=&gt; 主仆辩证法并没有导向一个自由的社会，在那里所有人都能够享有自由、闲适。它更多地导向了一个劳动社会，在这里，主人自身也成了工作的奴隶。在这一规训社会中，每个人都身处自己的劳动营里。这种劳动营的特殊之处在于，一个人同时是囚犯和看守、受害者和施暴者。人类以这种方式进行自我剥削。在没有主人的情况下，剥削也能照常进行</p><p>=&gt; 并非积极的生活，而是沉思的生活，才能使人类获得其应有的状态</p><h3 id="◆观看的教育"><a href="#◆观看的教育" class="headerlink" title="◆观看的教育"></a>◆观看的教育</h3><p>=&gt; 这不是一种被动的自我敞开，不是接受任何出现或发生的事物，而是抵抗那些蜂拥而至、不由自主的冲动刺激。目光不再臣服于外在的刺激，沉思生活将自主地控制它。这种否定性的、自主的行动比任何一种过度活跃都更加积极，因为过度活跃是精神衰竭的征兆</p><p>=&gt; 我们如今生活的世界中很少出现停顿，少有间隔和休息。为了提高效率，一切间歇都被取消了。在格言录“行动者的主要缺陷”中尼采写道：“行动者往往缺少更高等级的行动。……在这方面他们是惰性的。……行动者如同石头一样滚动，遵循愚蠢的机械法则。”</p><p>=&gt; 伴随着世界变得普遍积极化，人类和社会也都转化为一部自我封闭的效能机器。可以说，超负荷劳作使效绩最大化，同时也消除了否定性，因为后者将阻碍工作程序的加速。如果人类是一种否定性生物，那么世界的全面积极化将导致危险的后果。按照黑格尔的观点，正是否定性为存在赋予活力。</p><p>不去做不再向前思考，极度的活跃是最大的被动<br>=&gt; 如果一个人只拥有去做某事的能力，缺少不做某事的能力，那么他将陷入致命的过度活跃之中。如果一个人只有去思考的能力，那么思想将迷失在一系列无止境的对象中。沉思（Nachdenken）也便不可能存在，因为积极的力量，也就是过度的积极性，只允许“持续不断地向前思考”（Fortdenken）。</p><p>=&gt; 如果一个人只拥有去做某事的能力，缺少不做某事的能力，那么他将陷入致命的过度活跃之中。如果一个人只有去思考的能力，那么思想将迷失在一系列无止境的对象中。沉思（Nachdenken）也便不可能存在，因为积极的力量，也就是过度的积极性，只允许“持续不断地向前思考”（Fortdenken）。</p><p>=&gt; 尽管看似矛盾，过度活跃是一种极度被动的行为方式，阻碍了一切自由的行动。它基于一种片面的、绝对化的积极力量</p><h3 id="◆抄写员巴托比"><a href="#◆抄写员巴托比" class="headerlink" title="◆抄写员巴托比"></a>◆抄写员巴托比</h3><p>=&gt; “他为生活奔波，这些信件却加速他的死亡”，这也许是整篇小说要传递的最重要的信息。为生活付出的一切努力，都将导向死亡。</p><p>=&gt; 他的死亡，无人关心，却给周遭的人带来了极大的轻松感，一种“即便是最迟钝的感官也能体会到的放松”。他的死亡为朝气蓬勃的猎豹空出了位置，后者象征了对生命的纯粹喜悦，别无他求</p><h3 id="◆倦怠社会"><a href="#◆倦怠社会" class="headerlink" title="◆倦怠社会"></a>◆倦怠社会</h3><p>=&gt; 功绩社会作为积极的社会，逐渐发展成一种“兴奋剂社会”（Dopinggesellschaft）。</p><p>=&gt; 禁令也不能阻止这一发展趋势，不仅是人的身体，而且是人类整体都演变为一架效能机器，顺畅无阻地运转，力图最大化地发挥自身的功效。</p><p>=&gt; 生命原本是一种极为复杂的现象，如今也被简化成一种生命机能、生命效能。相应的负面后果是，功绩社会和积极社会导致了一种过度疲劳和倦怠。这一精神状态是现代社会的典型特征，由于缺少否定性，因此过量的肯定性占据了统治地位。</p><p>=&gt; 功绩社会的倦怠感是一种孤独的疲惫，造成了彼此孤立和疏离。</p><p>=&gt; 地带是不分彼此的、友谊的空间，其中“没有任何人或事物占据统治或主导地位”。随着自我逐渐弱化，自我存在的重心从自我转移到世界。这是一种“亲近世界的倦怠”，而自我—倦怠则是一种孤独的倦怠，一种厌世的、摧毁一切的倦怠。</p><p>=&gt; 倦怠赋予人们一种特殊的闲适、一种放松的无为。在这种状态下，各种感官没有变得疲惫虚弱，而是唤醒了一种特殊的视觉能力。汉德克便论及一种“目光清澈的倦怠”。它提供了另一种注意力形式，一种悠长、缓慢的关注，取代了那种短暂、仓促、过量的注意力。“倦怠区分了目光所及的形态，常见的纷杂混乱变得富有韵律，成为有益的形态。”</p><p>=&gt; 尽管过劳症式的疲倦是积极的，它却剥夺了我们做事的能力。激发灵感的疲倦则是一种消极的倦怠，即无为。</p><p>积极社会里，倦怠是愈合心灵伤口的秘宝，什么都不做就是做了最重要的事情<br>=&gt; “一个疲惫的人就是另一个俄耳甫斯（Orpheus），在他周围，最野性的动物都聚集起来，并最终一同享受这困倦。倦怠赋予孤立分散的个体一种共同的节奏。”[2]圣灵降临教派启发了“无为”的生活方式，他们同积极社会相对立。汉德克设想他们“慵懒地坐在长椅上”。他们是一种特殊意义上的倦怠的群体。如果“圣灵降临教派”是未来社会的一个同义词，那么这一社会亦可称为倦怠社会。</p><p>=&gt; “一个疲惫的人就是另一个俄耳甫斯（Orpheus），在他周围，最野性的动物都聚集起来，并最终一同享受这困倦。倦怠赋予孤立分散的个体一种共同的节奏。”[2]圣灵降临教派启发了“无为”的生活方式，他们同积极社会相对立。汉德克设想他们“慵懒地坐在长椅上”。他们是一种特殊意义上的倦怠的群体。如果“圣灵降临教派”是未来社会的一个同义词，那么这一社会亦可称为倦怠社会。</p><h3 id="◆外二篇"><a href="#◆外二篇" class="headerlink" title="◆外二篇"></a>◆外二篇</h3><p>中国是规训社会和功绩社会并存，并且适用于完全不同的群体<br>=&gt; 弗洛伊德构想的心理机制是一种充满了禁令和戒律的压抑性机制。它如同规训社会一样，主要由医院、疯人院、监狱、军营和工厂构成。因此，弗洛伊德的精神分析学只有在压抑性社会中才有效，其组织结构以否定性的禁令为基础。但如今的社会不再以规训为主要内容，而是一个功绩社会，它逐步消除了戒律和禁令，成为一个自由的社会。</p><p>=&gt; 弗洛伊德构想的心理机制是一种充满了禁令和戒律的压抑性机制。它如同规训社会一样，主要由医院、疯人院、监狱、军营和工厂构成。因此，弗洛伊德的精神分析学只有在压抑性社会中才有效，其组织结构以否定性的禁令为基础。但如今的社会不再以规训为主要内容，而是一个功绩社会，它逐步消除了戒律和禁令，成为一个自由的社会。</p><p>=&gt; 自我成为一个“恐惧的场所”（Angststätte）。[1]现代晚期的功绩主体则完全不同。他是一个肯定的主体。如果说无意识（das Unbewusste）必须和否定性的排斥和压抑相连，那么这种全新的、解放的功绩主体则不再拥有无意识，而是后弗洛伊德式的“自我”。</p><p>=&gt; 康德的主体和弗洛伊德的一样是内在分裂的。一个他者发号施令，却同时也是他自身的一部分：“这种原始的知性、道德（由于它是一种义务的观念）能力，也被称为良心，它具有这种特性，即，虽然它的工作是一项针对自身的任务，却被它自己的理性所逼迫，好像是在另一个人的命令下去从事这一工作。</p><p>为自己而工作<br>=&gt; 现代晚期的功绩主体不再臣服于任何义务。他的信条不再是顺从、法规和履行义务，而是自由和自愿。他工作的首要目的在于获得乐趣。他并非遵从他人的指令行事，而是更多地听命于自己。他成了自身的雇主，从而摆脱了负面的、发号施令的他者。这种脱离他者的自由却并非一种单纯的释放和解脱。自由的辩证法不幸地将其自身转化为强制和束缚。</p><p>=&gt; 现代晚期的功绩主体不再臣服于任何义务。他的信条不再是顺从、法规和履行义务，而是自由和自愿。他工作的首要目的在于获得乐趣。他并非遵从他人的指令行事，而是更多地听命于自己。他成了自身的雇主，从而摆脱了负面的、发号施令的他者。这种脱离他者的自由却并非一种单纯的释放和解脱。自由的辩证法不幸地将其自身转化为强制和束缚。</p><p>=&gt; “自恋是一种人格障碍，它恰恰同自爱相反。沉浸于自我之中不会带来奖赏，而只会导致痛苦。自我和他者之间的界限消失了，这意味着自我再也不能遭遇‘新事物’或‘他者’。后者已经被吸收和改造，直到自我在其中发现了自身——然而他者也因此丧失了意义。……自恋者不从经验出发，他希望——在一切他遭遇的对象中——体验到自身。……自恋者沉溺于自身之中……”</p><p>kpi就是黄金镇魂曲，你永远无法达到获得奖赏的真实<br>=&gt; 现实情况恰恰相反。完成某项任务的感觉并没有被有意地“屏蔽”，而是从未产生过这种大功告成的感觉。自恋的主体并非不渴望终结，而是无法抵达终点。效绩强迫症促使他不断地提升效能。因此永远无法达到获得奖赏的休止点。他永远生活在负罪感和匮乏感之中。由于他同自身竞争，不断试图超越自己，直到最终崩溃毁灭。他苦于精神瘫痪——过劳症——的折磨，功绩主体努力实现自我，直至死亡。自我实现和自我毁灭在这里合而为一</p><p>=&gt; 现实情况恰恰相反。完成某项任务的感觉并没有被有意地“屏蔽”，而是从未产生过这种大功告成的感觉。自恋的主体并非不渴望终结，而是无法抵达终点。效绩强迫症促使他不断地提升效能。因此永远无法达到获得奖赏的休止点。他永远生活在负罪感和匮乏感之中。由于他同自身竞争，不断试图超越自己，直到最终崩溃毁灭。他苦于精神瘫痪——过劳症——的折磨，功绩主体努力实现自我，直至死亡。自我实现和自我毁灭在这里合而为一</p><p>=&gt; 欲望被驱赶进入无意识，并“转化”为身体症状，显著地呈现在患者身上</p><p>=&gt; 个性”是一种否定性现象，因为如果没有心理审查机制，个性便无法形成。弗洛伊德将它定义为“客体侵占的痕迹”[8]。当自我意识到在本我之中发生了客体入侵时，他通过压抑机制试图抵抗入侵。个性之中便包含了压抑的经历。</p><p>=&gt; 后现代个体在脸书上拥有众多好友，只体现了自身缺乏个性和形态。从积极的方面讲，无个性的人是灵活变通的，他能够呈现出任何一种形态，承担任何一种角色和任务。不定型和灵活性产生了巨大的经济效益</p><p>=&gt; 当今的功绩社会充满了自由观念和去管制化，大规模地解除了规训社会下的种种限制和禁令。其后果是彻底的去界限化和普遍的混乱无序。</p><p>=&gt; 导致抑郁症和最终精力枯竭的原因在于，过度紧张的、过量的、自恋式自我指涉，这种自我关注带有自我毁灭的性质。疲惫的、抑郁的功绩主体在不断地消耗自我。在同自身的战斗中，他因为自身而困苦不堪。现代功绩主体没有能力从自身中抽离，无法抵达外在和他者，无法进入世界，只能沉湎于自身之中，却导致了矛盾的结果——自我的瓦解和空虚。他将自己困在一架不断加速、围绕自身旋转的疯狂竞争（Hamsterrad）之中。</p><p>建立自我与他者真实的联系<br>=&gt; 新媒体和信息交流技术也逐渐消除了自我同他者的关联。数码世界缺少他者和反抗力量。在虚拟空间中，自我甚至能够摆脱“现实原则”任意移动，现实原则即一种他者的、对抗的原则。自恋式自我在虚拟空间中主要面对自身。虚拟化和数字化进程将导致对抗的现实世界逐渐消失。</p><p>=&gt; 新媒体和信息交流技术也逐渐消除了自我同他者的关联。数码世界缺少他者和反抗力量。在虚拟空间中，自我甚至能够摆脱“现实原则”任意移动，现实原则即一种他者的、对抗的原则。自恋式自我在虚拟空间中主要面对自身。虚拟化和数字化进程将导致对抗的现实世界逐渐消失。</p><p>=&gt; 如果说抑郁曾经是一个独特群体的属性，那么抑郁症则显示这种独特性已然变得大众化。”</p><p>=&gt; 抑郁症患者因为其自主性而精疲力竭，他没有力量做自己的主人。由于持续不断地追求主动性，他变得疲惫不堪</p><p>=&gt; 一个古代的抑郁者完全不同于抑郁症患者，后者没有能力“做自己的主人”，亦缺少“成为自己的激情”</p><p>=&gt; 患有抑郁症的功绩主体不是自主的“超人”，而更多地是“末人”。</p><p>=&gt; “强大的灵魂”拥有“宁静”，他“行动迟缓”并“对一切过于活跃之物感到厌恶”。</p><p>=&gt; 你们所有热爱苦工的人，你们热爱快速、新颖和陌生之物。你们无法承受自身，你们的辛劳是一种逃避，是意图忘却自我。如果你们更加相信人生，你们便不会拜倒在瞬间面前。然而你们的内在缺少足够充实的内容去等待——甚至也不能偷懒。”</p><p>=&gt; 即自我拥有一个固定的“内涵”，对于资本主义生产关系来说过于僵化。换言之，终极形式阻碍了资本主义生产的加速发展。当功绩主体保持开放、灵活的状态时，他能够最有效地进行自我剥削，因此他成了“末人”。</p><p>=&gt; 个体面对扩展、转化、创造个人的命令，这一命令的背面便是抑郁症，它同时需要一定数量的身份选项。人们越频繁地更换身份，便需要开发越多的选项。在工业时代的规训社会中，个体拥有固定不变的身份，而后工业时代的功绩社会则需要灵活的个体身份，以便不断提高生产效率。</p><p>“精神内耗”<br>=&gt; 理想的自我对个体形成一种积极的压力。超我的否定性限制了自我的自由。按照理想自我去建构自身则被视作一种自由之举。自我被困在一个永远无法达到的理想自我之中，因此变得日益消沉疲惫。由于真实自我和理想自我之间存在鸿沟，从而产生了一种自我攻击。</p><p>=&gt; 理想的自我对个体形成一种积极的压力。超我的否定性限制了自我的自由。按照理想自我去建构自身则被视作一种自由之举。自我被困在一个永远无法达到的理想自我之中，因此变得日益消沉疲惫。由于真实自我和理想自我之间存在鸿沟，从而产生了一种自我攻击。</p><p>=&gt; 积极社会摆脱了一切来自他者的约束，却陷入了毁灭性的自我束缚。因此，精力枯竭、抑郁症等精神疾病成为21世纪的流行病，它们都带有自我攻击的特征。病人对自身施加暴力、剥削自我。自我形成的暴力取代了他者的暴力，前者的破坏力更大，由于受害者生活在一种虚假的自由感之中</p><p>=&gt; 外在统治机构的消亡并没有取消强制结构。如今，自由和束缚融为一体。功绩主体投身于一种自由的约束之中，即追求效率最大化。他进行自我剥削。剥削者同时是受剥削者，也是施暴者和受害者、主人和奴隶。为了提供效率，资本主义制度把他者剥削转化为自我剥削</p><p>=&gt; 资本主义经济制度把生存绝对化。人们生活在一种幻觉中，即更多的资本能够创造更长久的生命。生命和死亡被严格、僵硬地区分开来，生命也因此被蒙上了恐怖、僵化的阴影。</p><p>=&gt; 生命被简化成一种生物机能过程，生命变得赤裸，褪去了一切装饰和叙事。然而，生命远比生物机能和健康要复杂、丰富，简化的生命失去了活力。当生命变得赤裸，如同一枚钱币，并且空洞无物，缺乏任何叙事性内容，这时便产生了健康狂热症。</p><h3 id="◆神圣时间——禁锢在没有节日的时代"><a href="#◆神圣时间——禁锢在没有节日的时代" class="headerlink" title="◆神圣时间——禁锢在没有节日的时代"></a>◆神圣时间——禁锢在没有节日的时代</h3><p>=&gt; 节日是不会消逝的时刻。它是一种特殊意义上的神圣时间（Hoch-Zeit）。</p><p>=&gt; 节日是一件不寻常之事、一个特殊的场所，在其中人们与神同在，自身也变成了神。当人们游戏时，神感到喜悦；人类为了神灵而游戏。如今，我们生活在没有节日的时代，也因此失去了和神的联结</p><p>=&gt; 一般而言，当我们从事劳作或生产时，我们便不再与神同在，也失去了自身的神性。诸神不进行生产，亦不工作。也许我们也应当重新回归神性和节日，不再甘愿忍受工作和效绩的奴役</p><p>=&gt; 如今盛行的高效主义者没有意识到，提高或降低工作速度不能解决我们当下的时代危机。我们需要一种新的生活形式，一种新型叙事，由此产生一个新时代、一种新的生命状态，把我们从飞转的停滞状态（rasender Stillstand）中解救出来。</p><p>=&gt; 神圣时间是充盈的，工作时间则是空虚的，后者仅仅不断地在无聊和忙碌之间来回重复，以此填满时间。与之相反，节日在一个瞬间内实现了一种提升的强烈生命体验</p><p>=&gt; 我们进行自我剥削。剥削者即被剥削者，二者已经无法分辨。为了更高效地工作，我们不断优化自身，直至死亡。以这种恐怖的方式，自我完善被理解为绩效的提升。</p><p>工作与生活分明也是一种奢侈<br>=&gt; 如今车间厂房和起居室已经融为一体。随时随地工作成为可能。笔记本电脑和智能手机构建了一座移动的劳动营</p><p>=&gt; 如今车间厂房和起居室已经融为一体。随时随地工作成为可能。笔记本电脑和智能手机构建了一座移动的劳动营</p><p>996是福报.jpg<br>=&gt; 在马克思看来，工作是一种延伸的自我去现实化（Sich-Entwirklichung）。我们现在生活在一个后马克思时代。在新自由主义政权中，剥削不再是以异化和去现实化的方式进行，而变成了自由和自我实现（Sich-Verwirklichung）。这里没有作为剥削者的他者，而是自我心甘情愿地压榨自身，基于一种完善自我的信念。个体实现自我，直至死亡。自我优化通向死亡。在这一语境下，反抗、起义和革命已经不再可能。</p><p>=&gt; 在马克思看来，工作是一种延伸的自我去现实化（Sich-Entwirklichung）。我们现在生活在一个后马克思时代。在新自由主义政权中，剥削不再是以异化和去现实化的方式进行，而变成了自由和自我实现（Sich-Verwirklichung）。这里没有作为剥削者的他者，而是自我心甘情愿地压榨自身，基于一种完善自我的信念。个体实现自我，直至死亡。自我优化通向死亡。在这一语境下，反抗、起义和革命已经不再可能。</p><p>=&gt; 规训社会的“应当”产生了种种规定和禁令，与之相比，自由的“能够”甚至带来了更多的束缚。“应当”尚且存在界限，“能够”，却没有边界，它是开放的、没有上限</p><p>=&gt; 在当今的生存型社会中，健康变得绝对化，也因此失去了美。赤裸的、健康的生命，如今成为一种歇斯底里的生存形式，最终转变成死亡和活死人。我们变成了健康、健身式僵尸，效绩和肉毒杆菌僵尸。如今，我们在生时形同已死，在死前只能偷生。</p><p>=&gt; 在他面前有三种自由的生命形式可供选择，第一种生命用于享受美的事物，第二种用于为城邦施行善举，最后一种是沉思的生命，通过探索那永不消逝者，而停留在永恒的美的领域。因此真正的自由人是诗人、政治家和哲学家</p><p>=&gt; 当下的政治似乎仅剩下紧急命令，它失去了自由。换言之：如今已经不存在政治。当政治中不再有其他可能性，它便近乎专政，即资本的独裁。如今，政治家降格为体制的傀儡，至多算是有天赋的管家或记账员，他们不再是亚里士多德式的政治家</p><p>=&gt; 世界变成一片废墟。在那里我们如儿童一般用纸币进行游戏，并最终将之撕毁。如今，资本被奉为新的神明，希腊这群孩子却通过游戏的方式，使钱变得世俗化。世俗化改变了作为偶像的资本，它在顷刻间成了玩具</p><p>=&gt; 如今，只有当事物被展示出来并得到关注时，才拥有了价值。我们在脸书上展示自我，也因此把自身变成了商品。</p><p>=&gt; 我们加工自我，为了便于生产和加速信息交流。生命变成了商品，导致了仪式和庆典消失。因为在庆典中，我们耗费物资，而不从事生产。</p><p>=&gt; 如今一切都屈从于资本。生命价值意味着，一个人作为客户所能创造的价值总和，由于生命的每个时刻都被商品化了。人的价值被简化为客户价值或市场价值。完整的生命被转化为纯粹的商业利益。在如今的超资本主义（Hyperkapitalismus）中，人的存在彻底瓦解，融入了商品关系编织的网络。没有一个生活领域能够摆脱商业的控制。超级资本主义把一切人类关系变成了商业关系。它剥夺了人类的尊严，取而代之的是彻底的市场价值。</p><p>=&gt; 所谓的共享型经济（Sharing-Ökonomie）把我们每个人变成了售货员，期待着顾客的到来。我们用越来越劣质的快消品填满世界，世界在商品中窒息。这座百货商店和疯人院并无本质区别。看上去我们似乎拥有了一切，我们却失去了最根本之物，即世界。世界丧失了语言和声音。在交流的喧哗声中，宁静消失了。商品的堆积和大众化填满了一切空白。商品占据了天空和地面。商品化的世界不再适于居住，它失去了和上帝、神圣、奥秘、无限、崇高的联结。我们亦失去了惊奇的能力，生活在一座透明的百货商店里，成为透明的顾客，时刻受到监视和操控。逃离这座百货商店成为当务之急。我们应当把商店改造成一个庆典场所，在其中生命才能获得应有的意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.fosu.gq/Autovy/ImageExpand/master/img202211280959526.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://autovy.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="社会科学" scheme="https://autovy.github.io/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
      <category term="功绩社会" scheme="https://autovy.github.io/tags/%E5%8A%9F%E7%BB%A9%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="倦怠社会" scheme="https://autovy.github.io/tags/%E5%80%A6%E6%80%A0%E7%A4%BE%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|置身事内</title>
    <link href="https://autovy.github.io/2022/09/03/BookNote/%E3%80%8A%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://autovy.github.io/2022/09/03/BookNote/%E3%80%8A%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-03T06:30:00.000Z</published>
    <updated>2023-03-26T14:48:38.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic1.zhimg.com/v2-eb414291bccfc96be1c4f0c87e2f31a2_720w.jpg?source=172ae18b" alt="置身事内读书笔记"></p><span id="more"></span><p>置身事内 中国政府与经济发展【复旦经院“毕业课”解读经济生活背后的政府角色。罗永浩、刘格菘、张军、周黎安、王烁联袂推荐】<br>兰小欢<br>409个笔记</p><p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280949833.png" alt="image-20221128094724174"></p><h3 id="◆-目录"><a href="#◆-目录" class="headerlink" title="◆ 目录"></a>◆ 目录</h3><p>=&gt;社会进程本是整体，密不可分。所谓经济，不过是研究者从这洪流中人工提炼出的部分事实。何谓经济，本身已然是种抽象，而之后大脑还须经过若干抽象，方能复刻现实。没有什么事是纯粹经济的，其他维度永远存在，且往往更为重要</p><p>=&gt;社会科学总渴望发现一套“放之四海而皆准”的方法和规律，但这种心态需要成熟起来。不要低估经济现实的复杂性，也不要高估科学工具的质量。</p><h3 id="◆-前言-从了解现状开始"><a href="#◆-前言-从了解现状开始" class="headerlink" title="◆ 前言 从了解现状开始"></a>◆ 前言 从了解现状开始</h3><p>政府既是裁判也是运动员，如果人民有对政府没有纠错的机制，资源流向掌握权利的人手上是不可避免的，价格双轨制这样的事情不会是个例，周公子这样的人也绝非个别人<br>=&gt;在我国，政府不但影响“蛋糕”的分配，也参与“蛋糕”的生产，所以我们不可能脱离政府谈经济。必须深入了解这一政治经济机体如何运作，才可能对其进行判断。我们生活在这个机体中，我们的发展有赖于对这个机体的认知。要避免把舶来的理论化成先入为主的判断——看到现实与理论不符，便直斥现实之非，进而把要了解的现象变成了讥讽的对象——否则就丧失了“同情的理解”的机会。</p><p>=&gt;在我国，政府不但影响“蛋糕”的分配，也参与“蛋糕”的生产，所以我们不可能脱离政府谈经济。必须深入了解这一政治经济机体如何运作，才可能对其进行判断。我们生活在这个机体中，我们的发展有赖于对这个机体的认知。要避免把舶来的理论化成先入为主的判断——看到现实与理论不符，便直斥现实之非，进而把要了解的现象变成了讥讽的对象——否则就丧失了“同情的理解”的机会。</p><p>建政之所以可笑是在于不在其位，不谋其职，对现实情况了解的信息不足的情况下，只能去套别国的经验和死板的理论<br>=&gt;了解政府认为应该怎么办，比了解“我”认为应该怎么办，重要得多</p><p>=&gt;了解政府认为应该怎么办，比了解“我”认为应该怎么办，重要得多</p><h3 id="◆-第一章-地方政府的权力与事务"><a href="#◆-第一章-地方政府的权力与事务" class="headerlink" title="◆ 第一章 地方政府的权力与事务"></a>◆ 第一章 地方政府的权力与事务</h3><p>=&gt;要理解政府治理和运作的模式，首先要了解权力和资源在政府体系中的分布规则，既包括上下级政府间的纵向分布，也包括同级政府间的横向分布。</p><h4 id="◆-第一节-政府治理的特点"><a href="#◆-第一节-政府治理的特点" class="headerlink" title="◆ 第一节 政府治理的特点"></a>◆ 第一节 政府治理的特点</h4><p>=&gt;在乡以下的村落，则实行村民自治，因为行政能力毕竟有限，若村落也建制，那财政供养人口又要暴涨一个数量级。</p><p>中华人民共和国行政区划图<br>=&gt;<img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280857501.png" alt="image-20221128085713999"></p><p>=&gt;一方面，维持大一统的国家必然要求维护中央权威和统一领导；另一方面，中国之大又决定了政治体系的日常运作要以地方政府为主。</p><p>=&gt;中央和地方的国家机构职权的划分，遵循在中央的统一领导下，充分发挥地方的主动性、积极性的原则。”</p><p>本书基本贯彻党即政府，党即国家的观念，一党制的特色<br>=&gt;党负责重大决策和人事任免，政府负责执行，但二者在组织上紧密交织、人员上高度重叠，很难严格区分。</p><p>=&gt;党负责重大决策和人事任免，政府负责执行，但二者在组织上紧密交织、人员上高度重叠，很难严格区分。</p><p>=&gt;我国政治体系的一个鲜明特点是“层层复制”：中央的主要政治架构，即党委、政府、人大、政协等，省、市、县三级都完全复制，即所谓“四套班子”。中央政府的主要部委，除外交部等个别例外，在各级政府中均有对应部门</p><p>上下部门的业务关系，行政划分的领导关系，这样的条条块块构成了最基本的政府组织架构<br>=&gt;这种从上到下的部门垂直关系，被称为“条条”，而横向的以行政区划为界的政府，被称为“块块”。大多数地方部门都要同时接受“条条”和“块块”的双重领导。拿县教育局来说，既要接受市教育局的指导，又要服从县委、县政府的领导。通常情况下，“条条”关系是业务关系，“块块”关系才是领导关系，因为地方党委和政府可以决定人事任免。</p><p>=&gt;这种从上到下的部门垂直关系，被称为“条条”，而横向的以行政区划为界的政府，被称为“块块”。大多数地方部门都要同时接受“条条”和“块块”的双重领导。拿县教育局来说，既要接受市教育局的指导，又要服从县委、县政府的领导。通常情况下，“条条”关系是业务关系，“块块”关系才是领导关系，因为地方党委和政府可以决定人事任免。</p><p>=&gt;复杂的行政体系中，权力高度分散在各部门，往往没有清晰的法律界限，所以一旦涉及跨部门或跨地区事务，办起来就比较复杂，常常理不清头绪，甚至面对相互矛盾的信息</p><p>=&gt;尤其当没有清楚的先例和流程时，办事人员会在部门之间“踢皮球”，或者干脆推给上级，所以权力与决策会自然而然向上集中。制度设计的一大任务就是要避免把过多决策推给上级，减轻上级负担，提高决策效率，所以体制内简化决策流程的原则之一，就是尽量在能达成共识的最低层级上解决问题</p><p>=&gt;这一体系的三大特点延续至今：官员必须学习和贯彻统一的意识形态；官员由上级任命；地方主官需要在多地轮换任职</p><p>=&gt;我国有一套立足于自身历史和文化的政治制度。像所有政治制度一样，实际的权力运作与纸面的规章制度并不完全一致，但也绝不是任性随意的。在任何体制下，权力运作都受到两种约束：做事的能力及做事的意愿。前者取决于掌握的资源，后者取决于各方的积极性和主动性。</p><h4 id="◆-第二节-外部性与规模经济"><a href="#◆-第二节-外部性与规模经济" class="headerlink" title="◆ 第二节 外部性与规模经济"></a>◆ 第二节 外部性与规模经济</h4><p>=&gt;一件事情该不该由地方自主决定，可以从外部性的角度来考虑。若此事只影响本地，没有外部性，就该由本地全权处理；若还影响其他地方，那上级就该出面协调</p><p>=&gt;按照经典经济学的看法，政府的核心职能是提供公共物品和公共服务</p><p>=&gt;一方面，因为规模经济，覆盖的人越多越划算，政区越大越好；另一方面，受制于人们获取这些服务的代价和意愿，政区不能无限扩大</p><p>=&gt;以公共物品的规模经济和边界为切入点，也可以帮助理解中央和地方政府在分工上的一些差异。</p><p>=&gt;按人口密度划分行政区域的思路非常自然。提供公共物品和服务需要成本，人多，不仅税收收入多，而且成本能摊薄，实现规模收益。人口稠密的地方，在比较小的范围内就可以服务足够多的人，实现规模收益，因此行政区域面积可以小一些；而地广人稀的地方，行政区域就该大一些。</p><p>=&gt;无论是人口密度、地理还是语言文化，都只是为理解行政区划勾勒了一个大致框架，无法涵盖所有复杂情况</p><p>人口 地理 文化<br>=&gt;这一俗称“三不管地带”的现象，也可以用公共物品规模效应和边界的理论来解释。</p><p>=&gt;这一俗称“三不管地带”的现象，也可以用公共物品规模效应和边界的理论来解释。</p><p>=&gt;这些因素在民国时期已存在，所以“三不管地带”才为革命时期的中国共产党提供了广阔空间</p><p>不得不说中国社会一直都挺社达的，不论是对弱势地区还是弱势群体，河南怎么你了🤬<br>=&gt;路网交通中的“边界效应”（省界地区路网密度较低）依然存在，虽然比以前改善了很多。即使在排除了经济发展、人口密度、地形等因素之后，“边界效应”也还是存在的，不过只限于由省政府投资的高速公路和省道中，在由中央政府投资的国道和铁路中则不存在，可见省政府不会把有限的资源优先配置到边界地区</p><p>=&gt;路网交通中的“边界效应”（省界地区路网密度较低）依然存在，虽然比以前改善了很多。即使在排除了经济发展、人口密度、地形等因素之后，“边界效应”也还是存在的，不过只限于由省政府投资的高速公路和省道中，在由中央政府投资的国道和铁路中则不存在，可见省政府不会把有限的资源优先配置到边界地区</p><p>=&gt;上级可以干预下级的所有事务，但在现实工作中，干预与否、干预到什么程度、能否达到干预效果，都受制于公共事务的外部性大小、规模经济、跨地区协调的难度等。</p><p>想要建立全国统一大市场，户籍制度这种落后的地方保护制度显得不合时宜（冷知识，今年8月越南取消了户籍制度🤗）<br>=&gt;行政边界影响经济发展，地方保护主义和市场分割现象今天依然存在，尤其在生产要素市场上，用地指标和户籍制度对土地和人口流动影响很大。</p><p>=&gt;行政边界影响经济发展，地方保护主义和市场分割现象今天依然存在，尤其在生产要素市场上，用地指标和户籍制度对土地和人口流动影响很大。</p><p>加强区域性整合，一是加强县的独立性和自主性，弱化其与市区的联系，二是要扩张城市，撤县设市。早该向地方食利阶层重拳出击了，特别是房东这种群体早就吸干了城市发展的红利<br>=&gt;目前的行政区划继承自古代社会和计划经济时期，并不能完全适应工业与现代服务业急速的发展和集聚。而且在像中国这样一个地区差异极大的大国，建设产品和要素的全国统一大市场必然是个长期过程，难免要先经过区域性整合。</p><p>=&gt;目前的行政区划继承自古代社会和计划经济时期，并不能完全适应工业与现代服务业急速的发展和集聚。而且在像中国这样一个地区差异极大的大国，建设产品和要素的全国统一大市场必然是个长期过程，难免要先经过区域性整合。</p><p>=&gt;撤县设区扩张了城市面积，整合了本地人口，将县城很多农民转化为了市民，有利于充分利用已有的公共服务，发挥规模收益。很多撤县设区的城市还吸引了更多外来人口。(21)这些新增人口扩大了市场规模，刺激了经济发展。撤县设区也整合了对城市发展至关重要的土地资源。随着区县合并，市郊县的大批农村土地被转为城市建设用地，为经济发展提供了更大空间。</p><h4 id="◆-第三节-复杂信息"><a href="#◆-第三节-复杂信息" class="headerlink" title="◆ 第三节 复杂信息"></a>◆ 第三节 复杂信息</h4><p>=&gt;所以有信息优势的一方，或者说能以更低代价获取信息的一方，自然就有决策优势。</p><h4 id="◆-第四节-激励相容"><a href="#◆-第四节-激励相容" class="headerlink" title="◆ 第四节 激励相容"></a>◆ 第四节 激励相容</h4><p>=&gt;上级政府想做的事大概分两类，一类比较具体，规则和流程相对明确，成果也比较容易衡量和评价。另一类比较抽象和宽泛，比如经济增长和稳定就业，上级往往只有大致目标，需要下级发挥主动性和创造性调动资源去达成</p><p>=&gt;在专业性强、标准化程度高的部门，具体而明确的事务更多，更倾向于垂直化领导和管理</p><p>=&gt;虽然工作性质也比较专业，但与地方经济密不可分，很多工作需要本地配合，如果完全实行垂直管理可能会有问题。</p><p>=&gt;所有面临双重领导的部门，都有一个根本的激励机制设计问题：到底谁是主要领导？工作应该向谁负责？假如所有领导的目标和利益都一样，激励机制就不重要。</p><p>想法很美好，但是现在地方债严重也是现实<br>=&gt;不仅要让地方负责，也要与地方分享发展成果；不仅要能激励地方努力做好，还要能约束地方不要搞砸，也不要努力过头。做任何事都有代价，最优的结果是让效果和代价匹配，而不是不计代价地达成目标。若不加约束，地方政府要实现短期经济高速增长目标并不难，可以尽情挥霍手中的资源，大肆借债、寅吃卯粮来推高增长数字，但这种结果显然不是最优的。</p><p>=&gt;不仅要让地方负责，也要与地方分享发展成果；不仅要能激励地方努力做好，还要能约束地方不要搞砸，也不要努力过头。做任何事都有代价，最优的结果是让效果和代价匹配，而不是不计代价地达成目标。若不加约束，地方政府要实现短期经济高速增长目标并不难，可以尽情挥霍手中的资源，大肆借债、寅吃卯粮来推高增长数字，但这种结果显然不是最优的。</p><p>=&gt;我们的国家这样大，人口这样多，情况这样复杂，有中央和地方两个积极性，比只有一个积极性好得多。我们不能像苏联那样，把什么都集中到中央，把地方卡得死死的，一点机动权也没有。”</p><p>=&gt;其次是权力和资源的配置要制度化，不能朝令夕改。无论对上级还是对下级，制度都要可信，才能形成明确的预期。制度建设，一方面是靠行政体制改革（比如前文中的工商和环保部门改革）和法制建设，另一方面是靠财政体制改革。明确了收入和支出的划分，也就约束了谁能调用多少资源，不能花过头的钱，也不能随意借债，让预算约束“硬”起来。</p><p>=&gt;事权划分的三大原则：公共服务的规模经济、信息复杂性、激励相容。</p><p>=&gt;三大原则的共同主题是处理不同群体的利益差别与冲突。从公共服务覆盖范围角度看，不同人对公共服务的评价不同，享受该服务的代价不同，所以要划分不同的行政区域。从信息复杂性角度看，掌握不同信息的人，看法和判断不同，要把决策权交给占据信息优势的一方。从激励相容角度看，上下级的目标和能力不同，所以要设立有效的机制去激励下级完成上级的目标</p><p>现实是，医疗养老教育的地域性差别极大，公平无从谈起<br>=&gt;要逐步将义务教育、高等教育、科技研发、公共文化、基本养老保险、基本医疗和公共卫生、城乡居民基本医疗保险、就业、粮食安全、跨省（区、市）重大基础设施项目建设和环境保护与治理等体现中央战略意图、跨省（区、市）且具有地域管理信息优势的基本公共服务确定为中央与地方共同财政事权，并明确各承担主体的职责。”</p><p>=&gt;要逐步将义务教育、高等教育、科技研发、公共文化、基本养老保险、基本医疗和公共卫生、城乡居民基本医疗保险、就业、粮食安全、跨省（区、市）重大基础设施项目建设和环境保护与治理等体现中央战略意图、跨省（区、市）且具有地域管理信息优势的基本公共服务确定为中央与地方共同财政事权，并明确各承担主体的职责。”</p><h4 id="◆-第五节-招商引资"><a href="#◆-第五节-招商引资" class="headerlink" title="◆ 第五节 招商引资"></a>◆ 第五节 招商引资</h4><p>=&gt;地方政府不仅可以为经济发展创造环境，它本身就是经济发展的深度参与者，</p><p>=&gt;地方政府是城市土地的所有者，为了招商引资发展经济，会把工业用地以非常优惠的价格转让给企业使用，并负责对土地进行一系列初期开发，比如“七通一平”（通电、通路、通暖、通气、给水、排水、通信，以及平整场地）。</p><p>中国的经济成就绝不可以忽视各级政府在其中的发挥的作用，地方政府更是在没有自由市场的中国中企业最好的合伙人，所以很少有真正白手起家的大资本，没有官方背景作为初创时的跳板，扩张时的护盾就没有今天这些垄断性质的巨头<br>=&gt;对于规模较大的企业，地方通常会给予很多金融支持。比如以政府控制的投资平台入股，调动本地国企参与投资，通过各种方式协助企业获得银行贷款，等等。对一些业务比较复杂、所在行业管制较严的企业，地方也会提供法律和政策协助</p><p>=&gt;对于规模较大的企业，地方通常会给予很多金融支持。比如以政府控制的投资平台入股，调动本地国企参与投资，通过各种方式协助企业获得银行贷款，等等。对一些业务比较复杂、所在行业管制较严的企业，地方也会提供法律和政策协助</p><p>终究是低端人口不配罢了，中国的精英如果不在乎言论自由，民主法治这些东西真的过得比美国二流人才要好<br>=&gt;对于规模很大的企业，地方政府常常对部分高管的个人收入所得税进行返还。我国高收入人群的所得税边际税率很高，年收入超过96万元的部分税率是45%，所以税收返还对高管个人来说有一定吸引力。对企业高管或特殊人才，若有需要，地方政府也会帮助安排子女入学、家人就医等</p><p>=&gt;对于规模很大的企业，地方政府常常对部分高管的个人收入所得税进行返还。我国高收入人群的所得税边际税率很高，年收入超过96万元的部分税率是45%，所以税收返还对高管个人来说有一定吸引力。对企业高管或特殊人才，若有需要，地方政府也会帮助安排子女入学、家人就医等</p><p>政府掌握着土地，资金，劳动力，核心技术，没了政府资本真的什么都不是，很多左壬热衷于骂资本，但是资本背后最大的推手从来就是人民的政府<br>=&gt;这种“混合经济”体系，不是主流经济学教科书中所说的政府和市场的简单分工模式，即政府负责提供公共物品、市场主导其他资源配置；也不是简单的“政府搭台企业唱戏”模式。而是政府及其各类附属机构（国企、事业单位、大银行等）深度参与大多数生产和分配环节的模式。在我国，想脱离政府来了解经济，是不可能的。</p><p>=&gt;这种“混合经济”体系，不是主流经济学教科书中所说的政府和市场的简单分工模式，即政府负责提供公共物品、市场主导其他资源配置；也不是简单的“政府搭台企业唱戏”模式。而是政府及其各类附属机构（国企、事业单位、大银行等）深度参与大多数生产和分配环节的模式。在我国，想脱离政府来了解经济，是不可能的。</p><h3 id="◆-第二章-财税与政府行为"><a href="#◆-第二章-财税与政府行为" class="headerlink" title="◆ 第二章 财税与政府行为"></a>◆ 第二章 财税与政府行为</h3><p>一个王朝的崩溃都是从经济崩溃开始<br>=&gt;然而算着算着，观众就看到了刀光剑影，原来所有的政见冲突和人事谋略，都隐在这一两一两银子的账目之中。</p><p>=&gt;然而算着算着，观众就看到了刀光剑影，原来所有的政见冲突和人事谋略，都隐在这一两一两银子的账目之中。</p><p>=&gt;办事要花钱，如果没钱，话说得再好听也难以落实。要想把握政府的真实意图和动向，不能光读文件，还要看政府资金的流向和数量，所以财政从来不是一个纯粹的经济问题。</p><p>=&gt;所以从花钱的角度看，“事权与财力匹配”或者说“事权与支出责任匹配”这个原则，争议不大。但从预算收入的角度看，地方政府是否也应该有与事权相适应的收钱的权力，让“事权与财权匹配”，这个问题争议就大了。</p><h4 id="◆-第一节-分税制改革"><a href="#◆-第一节-分税制改革" class="headerlink" title="◆ 第一节 分税制改革"></a>◆ 第一节 分税制改革</h4><p>=&gt;我国的基本国策决定了不能对所有权做出根本性变革，只能对使用权和经营权实行承包制，以提高工作积极性</p><p>=&gt;收入递增包干</p><p>=&gt;定额上解</p><p>=&gt;中央财政预算收入占全国财政预算总收入的比重越来越低，而全国财政预算总收入占GDP的比重也越来越低（图2-2）。不仅中央变得越来越穷，财政整体也越来越穷。</p><p>=&gt;虽然地方预算内的税收收入要和中央分成，但预算外收入则可以独享。如果给企业减免税，“藏富于企业”，再通过其他诸如行政收费、集资、摊派、赞助等手段收一些回来，就可以避免和中央分成，变成可以完全自由支配的预算外收入。地方政府因此经常给本地企业违规减税，企业偷税漏税也非常普遍，税收收入自然上不去，但预算外收入却迅猛增长。</p><p>=&gt;1994年的分税制改革把税收分为三类：中央税（如关税）、地方税（如营业税）、共享税（如增值税）。同时分设国税、地税两套机构，与地方财政部门脱钩，省以下税务机关以垂直管理为主，由上级税务机构负责管理人员和工资。</p><p>=&gt;。为防止地方收入急剧下跌，中央设立了“税收返还”机制：保证改革后地方增值税收入与改革前一样，新增部分才和中央分</p><p>=&gt;分税制的实施远比制订方案要复杂，因为它涉及地方的利益。当时中央财政收入占整个财政收入的比重不到30%，我们改革以后，中央财政收入占整个国家财政收入的比重达到55%，多大的差别！</p><p>成功的政策背后是成功的协商和妥协，而不是领导一言堂下面机械执行命令<br>=&gt;这段故事我上课时经常讲，但很多学生不太理解为何谈判如此艰难：只要中央做了决策，地方不就只有照办的份儿吗？“00后”一代有这种观念，不难理解。一方面，经过分税制改革后多年的发展，今天的中央政府确实要比20世纪80年代末和90年代初更加强势；另一方面，公众所接触的信息和看到的现象，大都已经是博弈后的结果，而缺少社会阅历的学生容易把博弈结果错当成博弈过程。</p><p>=&gt;这段故事我上课时经常讲，但很多学生不太理解为何谈判如此艰难：只要中央做了决策，地方不就只有照办的份儿吗？“00后”一代有这种观念，不难理解。一方面，经过分税制改革后多年的发展，今天的中央政府确实要比20世纪80年代末和90年代初更加强势；另一方面，公众所接触的信息和看到的现象，大都已经是博弈后的结果，而缺少社会阅历的学生容易把博弈结果错当成博弈过程。</p><p>这段挺有意思的，政客的小心思呀<br>=&gt;所以财政部很自然地想把“基年”定为1992年。时光不能倒流，地方做不了假。可一旦把“基年”定在1993年，那到年底还有三个多月，地方可能突击收税，甚至把明年的税都挪到今年来收，大大抬高税收基数，以增加未来的税收返还。所以财政部不同意广东的要求。但为了改革顺利推行，中央最终做了妥协，决定在全国范围内用1993年做基年。这个决定立刻引发了第四季度的收税狂潮</p><p>=&gt;所以财政部很自然地想把“基年”定为1992年。时光不能倒流，地方做不了假。可一旦把“基年”定在1993年，那到年底还有三个多月，地方可能突击收税，甚至把明年的税都挪到今年来收，大大抬高税收基数，以增加未来的税收返还。所以财政部不同意广东的要求。但为了改革顺利推行，中央最终做了妥协，决定在全国范围内用1993年做基年。这个决定立刻引发了第四季度的收税狂潮</p><p>=&gt;在2002年的所得税改革中，除一些特殊央企的所得税归中央外，所有企业的所得税中央和地方六四分成（仅2002年当年为五五分）。为防止地方收入下降，同样也设置了税收返还机制，并把2001年的所得税收入定为返还基数</p><p>=&gt;分税制是20世纪90年代推行的根本性改革之一，也是最为成功的改革之一。改革扭转了“两个比重”不断下滑的趋势（图2-2）：中央占全国预算收入的比重从改革前的22%一跃变成55%，并长期稳定在这一水平；国家预算收入占GDP的比重也从改革前的11%逐渐增加到了20%以上。</p><h4 id="◆-第二节-土地财政"><a href="#◆-第二节-土地财政" class="headerlink" title="◆ 第二节 土地财政"></a>◆ 第二节 土地财政</h4><p>它来了它来了，土地财政来了🤗<br>=&gt;分税制并没有改变地方政府以经济建设为中心的任务，却减少了其手头可支配的财政资源。虽然中央转移支付和税收返还可以填补预算内收支缺口，但发展经济所需的诸多额外支出，比如招商引资和土地开发等，就需要另筹资金了</p><p>=&gt;分税制并没有改变地方政府以经济建设为中心的任务，却减少了其手头可支配的财政资源。虽然中央转移支付和税收返还可以填补预算内收支缺口，但发展经济所需的诸多额外支出，比如招商引资和土地开发等，就需要另筹资金了</p><p>政府各种鼓吹制造业的本质不是什么大国工匠，大国基建的宏大叙事，而是制造生存流程中的增值税有利可图。<br>=&gt;地方政府尤其青睐重资产的制造业，一是因为投资规模大，对GDP的拉动作用明显；二是因为增值税在生产环节征收，跟生产规模直接挂钩；三是因为制造业不仅可以吸纳从农业部门转移出的低技能劳动力，也可以带动第三产业发展，增加相关税收。</p><p>=&gt;地方政府尤其青睐重资产的制造业，一是因为投资规模大，对GDP的拉动作用明显；二是因为增值税在生产环节征收，跟生产规模直接挂钩；三是因为制造业不仅可以吸纳从农业部门转移出的低技能劳动力，也可以带动第三产业发展，增加相关税收。</p><p>=&gt;地方政府重视企业而相对轻视民生，重视生产而相对轻视消费</p><p>首先，预算内财政支出从重点支持生产建设转向了重点支持公共服务和民生，其次，分税制改革前，企业不仅缴税，还要向地方政府缴纳很多费（行政收费、集资、摊派、赞助等），这部分预算外收入在改革后大大减少<br>=&gt;分税制改革后，地方政府手中能用来发展经济的资源受到了几方面的挤压。</p><p>=&gt;分税制改革后，地方政府手中能用来发展经济的资源受到了几方面的挤压。</p><p>一步错，步步错，在错误的方向上处处打补丁解决不了任何问题<br>=&gt;国有土地的价值远远高于农地。为什么会有这种城乡割裂的土地制度？追根溯源，其实也没有什么惊天动地的大道理和顶层设计，不过是从1982年宪法开始一步步演变成今天这样罢了。(18)虽说每一步变化都有道理，针对的都是当时亟待解决的问题，但演变到今天，已经造成了巨大的城乡差别、飞涨的城市房价以及各种棘手问题</p><p>=&gt;国有土地的价值远远高于农地。为什么会有这种城乡割裂的土地制度？追根溯源，其实也没有什么惊天动地的大道理和顶层设计，不过是从1982年宪法开始一步步演变成今天这样罢了。(18)虽说每一步变化都有道理，针对的都是当时亟待解决的问题，但演变到今天，已经造成了巨大的城乡差别、飞涨的城市房价以及各种棘手问题</p><p>=&gt;1998年发生了两件大事，城市土地的真正价值才开始显现。第一是单位停止福利分房，逐步实行住房分配货币化，商品房和房地产时代的大幕拉开。1997—2002年，城镇住宅新开工面积年均增速为26%，五年增长了近4倍。第二是修订后的《中华人民共和国土地管理法》开始实施，基本上锁死了农村集体土地的非农建设通道，规定了农地要想转为建设用地，必须经过征地后变成国有土地，这也就确立了城市政府对土地建设的垄断权力。(19)</p><p>=&gt;有些开发商趁着国有企业改革，拿到了企业出让的土地，再从城市规划部门取得开发许可，只需支付国家规定的少量土地出让金，就可以搞房地产开发。这是个转手就能发家致富的买卖，其中的腐败可想而知</p><p>=&gt;地方政府发展经济的方式就从之前的“工业化”变成了“工业化与城市化”两手抓：一方面继续低价供应大量工业用地，招商引资；另一方面限制商住用地供给，从不断攀升的地价中赚取土地垄断收益</p><p>人力资源和土地资源是中国最大的资源<br>=&gt;我国是一个自然资源相对贫乏的国家，在经济起步阶段，能利用的资源主要就是人力和土地</p><p>=&gt;我国是一个自然资源相对贫乏的国家，在经济起步阶段，能利用的资源主要就是人力和土地</p><p>=&gt;土地的资本化运作，本质是把未来的收益抵押到今天去借钱，如果借来的钱投资质量很高，转化成了有价值的资产和未来更高的收入，那债务就不是大问题。但地方官员任期有限，难免会催生短视行为，寅吃卯粮，过度借债去搞大项目，搞“面子工程”，功是留在当代了，利是不是有千秋，就是下任领导的事了。如此一来，投资质量下降，收益不高，债务负担就越来越重。</p><p>人力资源和土地资源是中国最大的资源，要想搞全国大市场，就要允许人口和土地的自由流动，而这两大生产要素一直以来都被户籍制度和行政土地划分所牵制<br>=&gt;地区间虽然搞竞争，但用地指标不能跨省流动到效率更高的地区。珠三角和长三角的经济突飞猛进，人口大量涌入，却没有足够的建设用地指标，工业和人口容量都遭遇了人为的限制。</p><p>=&gt;地区间虽然搞竞争，但用地指标不能跨省流动到效率更高的地区。珠三角和长三角的经济突飞猛进，人口大量涌入，却没有足够的建设用地指标，工业和人口容量都遭遇了人为的限制。</p><p>=&gt;放在最前面的就是“推进土地要素市场化配置”。要求不仅要在省、市、县内部打破城乡建设用地之间的市场壁垒，建设一个统一的市场，盘活存量建设用地，而且要“探索建立全国性的建设用地、补充耕地指标跨区域交易机制”，以提高土地资源在全国范围内的配置效率。</p><h4 id="◆-第三节-纵向不平衡与横向不平衡"><a href="#◆-第三节-纵向不平衡与横向不平衡" class="headerlink" title="◆ 第三节 纵向不平衡与横向不平衡"></a>◆ 第三节 纵向不平衡与横向不平衡</h4><p>=&gt;总数能补上，不等于每级政府都能补上，也不等于每个地区都能补上。省里有钱，乡里不见得有钱；广州有钱，兰州不见得有钱。这种纵向和横向的不平衡，造成了不少矛盾和冲突，也催生了很多改革</p><p>=&gt;分税制改革之后，中央和省分成，省也要和市县分成。可因为上级权威高于下级，所以越往基层分到的钱往往越少，但分到的任务却越来越多，出现了“财权层层上收，事权层层下压”的局面。改革后没几年，基层财政就出现了严重的困难。20世纪90年代末有句顺口溜流行很广：“中央财政蒸蒸日上，省级财政稳稳当当，市级财政摇摇晃晃，县级财政哭爹叫娘，乡级财政精精光光。”</p><p>宇宙尽头的编制供养了多少闲职？这么多人对编制趋之若鹜，钱从哪里来呢？在蛋糕没有增量，权贵把持大多数存量的经济状况下，这样的安稳还能维系多久？<br>=&gt;从全国平均来看，地方财政预算收入（本级收入加上级转移支付）普遍仅够给财政供养人员发工资，但地区间差异很大。在东部沿海，随着工业化和城市化的大发展，可以从“土地财政”中获取大量额外收入，一手靠预算财政“吃饭”，一手靠土地财政“办事”。但在很多中西部县乡，土地并不值钱，财政收入可能连发工资都不够，和用于办事的钱相互挤占，连“吃饭财政”都不算，要算“讨饭财政”。</p><p>=&gt;从全国平均来看，地方财政预算收入（本级收入加上级转移支付）普遍仅够给财政供养人员发工资，但地区间差异很大。在东部沿海，随着工业化和城市化的大发展，可以从“土地财政”中获取大量额外收入，一手靠预算财政“吃饭”，一手靠土地财政“办事”。但在很多中西部县乡，土地并不值钱，财政收入可能连发工资都不够，和用于办事的钱相互挤占，连“吃饭财政”都不算，要算“讨饭财政”。</p><p>=&gt;“农民真苦，农村真穷，农业真危险。”这个“三农问题”，就成了21世纪初政策和改革的焦点之一。</p><p>=&gt;农村税费改革降低了农民负担，但也让本就捉襟见肘的基层财政维持起来更加艰难，所以之后的改革就加大了上级的统筹和转移支付力度。</p><p>=&gt;其一，是把农村基本公共服务开支纳入国家公共财政保障范围，由中央和地方政府共同负担。</p><p>=&gt;其二，是在转移支付制度中加入激励机制，鼓励基层政府达成特定目标，并给予奖励</p><p>😅<br>=&gt;冗员过多一直是政府顽疾，分税制改革后建立的转移支付体系中，相当一部分转移支付是为了维持基层政府正常运转和保障人员工资。财政供养人员（即有编制的人员）越多，得到的转移支付越多，这自然会刺激地方政府扩编</p><p>=&gt;冗员过多一直是政府顽疾，分税制改革后建立的转移支付体系中，相当一部分转移支付是为了维持基层政府正常运转和保障人员工资。财政供养人员（即有编制的人员）越多，得到的转移支付越多，这自然会刺激地方政府扩编</p><p>=&gt;其三，是把基层财政资源向上一级政府统筹，比如2003年开始试点的“乡财县管”改革。</p><p>=&gt;市管县的行政体制下，县的收入要和市里分账，可市财政支出和招商引资却一直偏向市区，“市压县，市刮县，市吃县”现象严重，城乡差距不断拉大</p><p>=&gt;分税制改革后，基层财政出现了不少困难，引发了一系列后续改革，最终涉及了财税体制的层级问题。到底要不要搞扁平化，学发达国家搞三级财政？是不是每个省都应该搞？对于相关改革效果和未来方向，目前仍有争议。</p><p>一个很有意思的对比，中国是中央政府人员少地方政府平均人员多，美国是中央政府人员多地方政府平均人员少<br>=&gt;中央对地方的转移支付大概可以分为两类：一般性转移支付（2009年之后改称“均衡性转移支付”）和专项转移支付。(35)简单来说，前者附加条件少，地方可自行决定用途，而后者必须专款专用。为什么要指定资金用途、不让地方自主决策呢？因为无条件的均衡性转移支付是为了拉平地区差距，所以越穷的地方拿到的钱越多，地方也就越缺乏增收动力。而且均衡性转移支付要保证政府运作和公务员工资，可能会刺激财政供养人员增加，恶化冗员问题。</p><p>=&gt;中央对地方的转移支付大概可以分为两类：一般性转移支付（2009年之后改称“均衡性转移支付”）和专项转移支付。(35)简单来说，前者附加条件少，地方可自行决定用途，而后者必须专款专用。为什么要指定资金用途、不让地方自主决策呢？因为无条件的均衡性转移支付是为了拉平地区差距，所以越穷的地方拿到的钱越多，地方也就越缺乏增收动力。而且均衡性转移支付要保证政府运作和公务员工资，可能会刺激财政供养人员增加，恶化冗员问题。</p><p>=&gt;专项转移支付约占转移支付总额的四成，一般以“做项目”的形式来分配资金，专款专用，可以约束下级把钱花在上级指定的地方，但在实际操作中，这种转移支付加大了地区间的不平等</p><p>=&gt;公共财政的重要功能是实现人均公共服务的均等化，虽然我国在这方面已取得了长足进展，但可改进的空间依然很大。从目前情况来看，东中西部省份之间、同一省份的城乡之间、同一城市的户籍人口和非户籍人口之间，公共服务的差别依然很大。</p><h4 id="◆-结语"><a href="#◆-结语" class="headerlink" title="◆ 结语"></a>◆ 结语</h4><p>=&gt;图2-7　第二章内容小结</p><p>=&gt;所以土地真正的力量还不在“土地财政”，而在以土地为抵押而撬动的银行信贷与其他各路资金。“土地财政”一旦嫁接了资本市场，加上了杠杆，就成了“土地金融”，能像滚雪球般越滚越大，推动经济飞速扩张，也造就了地方政府越滚越多的债务，引发了一系列宏观经济问题。</p><h3 id="◆-第三章-政府投融资与债务"><a href="#◆-第三章-政府投融资与债务" class="headerlink" title="◆ 第三章 政府投融资与债务"></a>◆ 第三章 政府投融资与债务</h3><p>=&gt;土地资本化的魔力，在于可以挣脱物理属性，在抽象的意义上交易承诺和希望，将过去的储蓄、现在的收入、未来的前途，统统汇聚和封存在一小片土地上，使其价值暴增。由此产生的能量不亚于科技进步，支撑起了工业化和城市化的巨大投资。经济发展的奥秘之一，正是把有形资产转变成为这种抽象资本，从而聚合跨越空间和时间的资源</p><h4 id="◆-第一节-城投公司与土地金融"><a href="#◆-第一节-城投公司与土地金融" class="headerlink" title="◆ 第一节 城投公司与土地金融"></a>◆ 第一节 城投公司与土地金融</h4><p>=&gt;实业投资通常是个连续的过程，需要不断投入，每个阶段打交道的对象不同，所需的专业和资源不同，要处理的事务和关系也不同。任一阶段出了纰漏，都会影响整个项目。就拿盖一家商场来说，前期的土地拆迁、中期的开发建设、后期的招商运营，涉及不同的专业和事务，往往由不同的主体来投资和运作，既要考虑项目整体的连续性，也要处理每一阶段的特殊性。</p><p>这样的公司一般叫法为“城投公司”<br>=&gt;法律规定，地方政府不能从银行贷款，2015年之前也不允许发行债券，所以政府要想借钱投资，需要成立专门的公司。(2)这类公司大都是国有独资企业，一般统称为“地方政府融资平台”。</p><p>=&gt;法律规定，地方政府不能从银行贷款，2015年之前也不允许发行债券，所以政府要想借钱投资，需要成立专门的公司。(2)这类公司大都是国有独资企业，一般统称为“地方政府融资平台”。</p><p>=&gt;第一，它持有从政府取得的大量土地使用权。</p><p>=&gt;第二，盈利状况依赖政府补贴</p><p>=&gt;融资平台公司投资的大多数项目都有基础设施属性，项目本身盈利能力不强，否则也就无需政府来做了。这类投资的回报不能只看项目本身，要算上它带动的经济效益和社会效益</p><p>=&gt;第三，政府的隐性担保可以让企业大量借款</p><p>=&gt;当地的融资平台公司一般只参与前期的拆迁和土地整理。用术语来说，一块划出来的“生地”，平整清理后才能成为向市场供应的“熟地”，这个过程称为“土地一级开发”。“一级开发”投入大、利润低，且涉及拆迁等复杂问题，一般由政府融资平台公司完成。之后的建设和运营称为“二级开发”，大都由房地产公司来做</p><p>=&gt;一手低价供应工业用地，招商引资，换取税收和就业；一手高价供应商住用地，取得卖地收入。但政府“亏本”招商引资，图的是税收和就业，可作为民企的华夏幸福，又能从工业园区发展中得到什么呢？答案是它也可以和政府分享税收收益。</p><p>现实是复杂的，抽象的理论根本无法涵盖所有情况<br>=&gt;现实世界中没有定义，只有现象，只有环环相扣的权责关系。或者按张五常的说法，只有一系列合约安排。(9)要想理解这些现象，需要深入调研当事人面临的各种约束，包括能力、资源、政策、信息等，简单的政府—市场二元观，没什么用。</p><p>=&gt;现实世界中没有定义，只有现象，只有环环相扣的权责关系。或者按张五常的说法，只有一系列合约安排。(9)要想理解这些现象，需要深入调研当事人面临的各种约束，包括能力、资源、政策、信息等，简单的政府—市场二元观，没什么用。</p><h4 id="◆-第二节-地方政府债务"><a href="#◆-第二节-地方政府债务" class="headerlink" title="◆ 第二节 地方政府债务"></a>◆ 第二节 地方政府债务</h4><p>我们这代人将见证的土地金融的土崩瓦解，一直以来国家的很多方针都以经济的快速增长为前提，当经济增速放缓甚至倒退，底层民众才是最能感受到寒气的人<br>=&gt;随着城市化和商品房改革，土地价值飙升，政府不仅靠土地使用权转让收入支撑起了“土地财政”，还将未来的土地收益资本化，从银行和其他渠道借入了天量资金，利用“土地金融”的巨力，推动了快速的工业化和城市化。但同时也积累了大量债务。这套模式的关键是土地价格。只要不断地投资和建设能带来持续的经济增长，城市就会扩张，地价就会上涨，就可以偿还连本带利越滚越多的债务。可经济增速一旦放缓，地价下跌，土地出让收入减少，累积的债务就会成为沉重的负担，可能压垮融资平台甚至地方政府。</p><p>=&gt;随着城市化和商品房改革，土地价值飙升，政府不仅靠土地使用权转让收入支撑起了“土地财政”，还将未来的土地收益资本化，从银行和其他渠道借入了天量资金，利用“土地金融”的巨力，推动了快速的工业化和城市化。但同时也积累了大量债务。这套模式的关键是土地价格。只要不断地投资和建设能带来持续的经济增长，城市就会扩张，地价就会上涨，就可以偿还连本带利越滚越多的债务。可经济增速一旦放缓，地价下跌，土地出让收入减少，累积的债务就会成为沉重的负担，可能压垮融资平台甚至地方政府。</p><p>=&gt;快速猛烈的经济刺激，对提振急速恶化的经济很有必要，但大水漫灌的结果必然是泥沙俱下。财政状况不佳的地方也能大量借钱，盈利前景堪忧的项目也能大量融资。短短三五年，地方政府就积累了天量债务。</p><p>既要马儿跑，又要马儿不吃草，分税制下的游戏规则为中国的经济埋下了不少地雷<br>=&gt;但要想在城市建设开发中引入银行资金，需要解决三个技术问题。第一，需要一个能借款的公司，因为政府不能直接从银行贷款；第二，城建开发项目繁复，包括自来水、道路、公园、防洪，等等，有的赚钱，有的赔钱，但缺了哪个都不行，所以不能以单个项目分头借款，最好捆绑在一起，以赚钱的项目带动不赚钱的项目；第三，仅靠财政预算收入不够还债，要能把跟土地有关的收益用起来。</p><p>=&gt;但要想在城市建设开发中引入银行资金，需要解决三个技术问题。第一，需要一个能借款的公司，因为政府不能直接从银行贷款；第二，城建开发项目繁复，包括自来水、道路、公园、防洪，等等，有的赚钱，有的赔钱，但缺了哪个都不行，所以不能以单个项目分头借款，最好捆绑在一起，以赚钱的项目带动不赚钱的项目；第三，仅靠财政预算收入不够还债，要能把跟土地有关的收益用起来。</p><p>=&gt;我国地方政府借来的钱，并没有多少用于政府运营性支出，也没有像一些欧洲国家如希腊那样去支付社会保障，而主要是投资在了基础设施项目上，形成了实实在在的资产。虽然这些投资项目的回报率很低，可能平均不到1%，但如果“算大账”，事实上也拉动了GDP，完善了基础设施，方便了民众生活，整体经济与社会效益可能比项目回报率高</p><p>=&gt;但政府补贴的前提是政府有钱，这些钱主要来自和土地开发有关的各种收入。一旦经济遇冷，地价下跌，政府也背不起这沉重的债务。</p><p>=&gt;债务置换就是用地方政府发行的公债，替换一部分融资平台公司的银行贷款和城投债</p><p>=&gt;债务置换是为了限制债务增长，规范借债行为，所以地方政府不能无限制地发债去置换融资平台债务。</p><p>=&gt;第二项改革是推动融资平台转型，厘清与政府之间的关系，剥离其为政府融资的功能，同时破除政府对其形成的“隐性”担保。</p><p>=&gt;第三项改革是约束银行和各类金融机构，避免大量资金流入融资平台。</p><p>=&gt;第四项改革就是问责官员，对过度负债的行为终身追责</p><h4 id="◆-第三节-招商引资中的地方官员"><a href="#◆-第三节-招商引资中的地方官员" class="headerlink" title="◆ 第三节 招商引资中的地方官员"></a>◆ 第三节 招商引资中的地方官员</h4><p>=&gt;要对招商机会有敏感度，要做一个执着的跟踪者，不能轻言放弃。要在招商中锻炼自己，做到‘铜头、铁嘴、顺风耳、橡皮腰、茶壶肚、兔子腿’。”铜头，是指敢闯、敢创造机会；铁嘴，是指能说会道，不怕磨破嘴皮；顺风耳和兔子腿，指消息灵通且行动敏捷；茶壶肚，指能喝酒、能社交。这些形容非常形象，容易理解。我当时不太懂什么是“橡皮腰”，后来听他解释：“要尊重客商，身段该软的时候要能弯得下腰，但在谈判过程中也不能随便让步，若涉及本市重要利益，该把腰挺起来的时候也要挺直了。</p><p>这和地方政府利用转移支付的漏洞无限制扩编有没有关系呢？<br>=&gt;从人数构成上看，地方官员是官僚体系的绝对主体。按公务员总人数算，中央公务员只占6%，若把各类事业单位也算上，中央只占4%。这在世界各主要国家中是个异数。美国中央政府公务员占比为19%，日本为14%，德国为11%，而经济合作与发展组织（OECD）成员国的平均值高达41%</p><p>=&gt;从人数构成上看，地方官员是官僚体系的绝对主体。按公务员总人数算，中央公务员只占6%，若把各类事业单位也算上，中央只占4%。这在世界各主要国家中是个异数。美国中央政府公务员占比为19%，日本为14%，德国为11%，而经济合作与发展组织（OECD）成员国的平均值高达41%</p><p>在中国更加被普遍使用的是“大棒”，无论是政府还是私企更倾向于用恐吓而非激励的管理方式。当人们发现执棒人只是纸老虎时，“躺平”便随之而来，若中国还执意要用恐吓的方式去管理人口，除非是用坦克碾，不然“躺平”才是屁民追求幸福生活的唯一答案<br>=&gt;人才的选拔和激励机制是官僚体制的核心，决定着政府运作的效果。所谓激励机制，简单来说就是“胡萝卜加大棒”：事情做好了对个人有什么好处？搞砸了有什么坏处？</p><p>=&gt;人才的选拔和激励机制是官僚体制的核心，决定着政府运作的效果。所谓激励机制，简单来说就是“胡萝卜加大棒”：事情做好了对个人有什么好处？搞砸了有什么坏处？</p><p>=&gt;从“胡萝卜”角度看，经济发展是地方官的主要政绩，对其声望和升迁有重要影响。而对广大普通政府工作人员而言，职务晋升机会虽然很少，但实际收入与本地财政情况密切相关，也和本部门、本单位的绩效密切相关，这些又都取决于本地的经济发展。从“大棒”角度看，一方面有党纪国法的监督惩罚体系，另一方面也有地区间招商引资的激烈竞争。</p><p>=&gt;地方主官任期有限，要想在任内快速提升经济增长，往往只能加大投资力度，上马各种大工程、大项目。</p><p>中国经济要考虑两个周期，一个是贷款借出收还周期，一个是官员上任离职周期<br>=&gt;全国平均每年都有三成左右的地级市要更换市长或市委书记，所以各地的投资都热火朝天，“政治-投资周期”比较频繁</p><p>=&gt;全国平均每年都有三成左右的地级市要更换市长或市委书记，所以各地的投资都热火朝天，“政治-投资周期”比较频繁</p><p>=&gt;2016年之前，官员升迁或调任后就无需再对任内的负债负责，而新官又通常不理旧账，会继续加大投资，所以政府债务不断攀升。在经济发展到一定阶段之后，低风险高收益的工业投资项目减少，基础设施和城市建设投资的经济效益也在减弱，继续加大投资会降低经济整体效率，助推产能过剩</p><p>=&gt;明确了“选人用人不能简单以地区生产总值及增长率论英雄”这项通知之后，再加上一系列财政和金融改革措施，地方GDP增长率和固定资产投资增长率开始下降</p><p>=&gt;明确在考核地方党委和政府领导班子的工作实绩时，要看“全面工作”，“看推动本地区经济建设、政治建设、文化建设、社会建设、生态文明建设，解决发展不平衡不充分问题，满足人民日益增长的美好生活需要的情况和实际成效</p><p>=&gt;人情和业绩之间可能互相促进：业绩突出容易受领导青睐，而领导支持也有助于做好工作。但如果某些领导为扩大自己的权力和影响，在选人用人中忽视工作业绩，任人唯亲，就可能打击下属的积极性。</p><p>=&gt;地方官场的人情关系对于局部的政治经济生态会有影响，但是否重要到对整体经济现象有特殊的解释力，我持怀疑态度。一方面，地方之间有竞争关系，会限制地方官员恣意行事；另一方面，人情关系网依赖其中的关键人物，不确定性很大，有“一人得道鸡犬升天”，就有“树倒猢狲散”。但无论是张三得志还是李四倒霉，工作都还是一样要继续做，发展经济也一样还是地方政府工作的主题</p><p>有人总会抱有精英思维，高估了自己进步的程度，总认为自己能通过“卷”成为晋升的1%，但是大部分的人大概率只会成为那99%，更多关注那99%的生活状态才不至于一叶障目<br>=&gt;政绩和晋升无疑对地方一把手和领导班子成员非常重要，却无法激励绝大多数公务员。他们的日常工作与政绩关系不大，晋升希望也十分渺茫。在庞大的政府工作人员群体中，“县处级”及以上的干部大约只占总人数的1%。平均来说，在一个县里所有的正科实职干部中，每年升副县级的概率也就1%，而从副县级干部到县委副书记，还要经历好几个岗位和台阶，动辄数年乃至数十年。(30)因此绝大多数政府工作人员最在意的激励并不是晋升，而是实际收入以及一些工作福利，包括工资、奖金、补助、补贴、实惠的食堂、舒适的办公条件，等等。这些收入和福利都与本地经济发展和地区财政紧密相关，在地区之间甚至同一地区的部门之间，差异很大。大部分人在日常工作中可以感受到这种差异，知道自己能从本地发展和本单位发展中得到实惠。</p><p>=&gt;政绩和晋升无疑对地方一把手和领导班子成员非常重要，却无法激励绝大多数公务员。他们的日常工作与政绩关系不大，晋升希望也十分渺茫。在庞大的政府工作人员群体中，“县处级”及以上的干部大约只占总人数的1%。平均来说，在一个县里所有的正科实职干部中，每年升副县级的概率也就1%，而从副县级干部到县委副书记，还要经历好几个岗位和台阶，动辄数年乃至数十年。(30)因此绝大多数政府工作人员最在意的激励并不是晋升，而是实际收入以及一些工作福利，包括工资、奖金、补助、补贴、实惠的食堂、舒适的办公条件，等等。这些收入和福利都与本地经济发展和地区财政紧密相关，在地区之间甚至同一地区的部门之间，差异很大。大部分人在日常工作中可以感受到这种差异，知道自己能从本地发展和本单位发展中得到实惠。</p><p>《中国官员腐败历史》<br>=&gt;从经济发展的角度看，我国的腐败现象有两个显著特点。第一，腐败与经济高速增长长期并存。这与“腐败危害经济”这一过度简单化的主流观念冲突，以腐败为由唱空中国经济的预测屡屡落空。第二，随着改革的深入，政府和市场间关系在不断变化，腐败形式也在不断变化。20世纪80年代的腐败案件大多与价格双轨制下的“官倒”和各种“投机倒把”有关；90年代的案件则多与国企改革和国有资产流失有关；21世纪以来，与土地开发相关的案件成了主流。</p><p>=&gt;从经济发展的角度看，我国的腐败现象有两个显著特点。第一，腐败与经济高速增长长期并存。这与“腐败危害经济”这一过度简单化的主流观念冲突，以腐败为由唱空中国经济的预测屡屡落空。第二，随着改革的深入，政府和市场间关系在不断变化，腐败形式也在不断变化。20世纪80年代的腐败案件大多与价格双轨制下的“官倒”和各种“投机倒把”有关；90年代的案件则多与国企改革和国有资产流失有关；21世纪以来，与土地开发相关的案件成了主流。</p><p>=&gt;腐败大概可以分为两类。第一类是“掠夺式”腐败，比如对私营企业敲诈勒索、向老百姓索贿、盗用挪用公款等，这类腐败对经济增长和产权保护极其有害</p><p>此类腐败会带来四大恶果：<br>其一，长期偏重投资导致经济结构扭曲，资本收入占比高而劳动收入占比低，老百姓收入和消费增长速度偏慢。<br>其二，扭曲投资和信贷资源配置，把大量资金浪费在效益不高的关系户项目上，推升债务负担和风险。<br>其三，权钱交易扩大了贫富差距。<br>其四，地方上可能形成利益集团，不仅可能限制市场竞争，也可能破坏政治生态，出现大面积的“塌方式腐败”。<br>=&gt;第二类腐败是“官商勾连共同发财式”腐败。比如官员利用职权把项目批给关系户企业，而企业不仅要完成项目、为官员贡献政绩，也要在私下给官员很多好处。这类腐败发生在招商引资过程中，而相关投资和建设可以促进经济短期增长，所以腐败在一段时期内可以和经济增长并存。</p><p>=&gt;第二类腐败是“官商勾连共同发财式”腐败。比如官员利用职权把项目批给关系户企业，而企业不仅要完成项目、为官员贡献政绩，也要在私下给官员很多好处。这类腐败发生在招商引资过程中，而相关投资和建设可以促进经济短期增长，所以腐败在一段时期内可以和经济增长并存。</p><p>政府一直都是有针对性改进政策问题的，政府并没有反贼说得怎么糟糕。但是政府一直在埋头做事，而信息不向公众透明，也不允许自由言论，内宣还沉浸在大国叙事这种低级宣传，除了滋养了民族主义蛆虫别无他用，什么时候政府真能还政于民，政府才真算是好政府<br>=&gt;但在尚未完成转型之前，习惯了旧有工作方式的地方官员在反腐高压之下难免会变得瞻前顾后、缩手缩脚。2016年，中央开始强调“庸政懒政怠政也是一种腐败”，要破除“为官不为”。2018年，中共中央办公厅印发《关于进一步激励广大干部新时代新担当新作为的意见》，强调“建立健全容错机制，宽容干部在改革创新中的失误错误，把干部在推进改革中因缺乏经验、先行先试出现的失误错误，同明知故犯的违纪违法行为区分开来；把尚无明确限制的探索性试验中的失误错误，同明令禁止后依然我行我素的违纪违法行为区分开来；把为推动发展的无意过失，同为谋取私利的违纪违法行为区分开来。”这些措施如何落到实处，还有待观察。</p><p>=&gt;但在尚未完成转型之前，习惯了旧有工作方式的地方官员在反腐高压之下难免会变得瞻前顾后、缩手缩脚。2016年，中央开始强调“庸政懒政怠政也是一种腐败”，要破除“为官不为”。2018年，中共中央办公厅印发《关于进一步激励广大干部新时代新担当新作为的意见》，强调“建立健全容错机制，宽容干部在改革创新中的失误错误，把干部在推进改革中因缺乏经验、先行先试出现的失误错误，同明知故犯的违纪违法行为区分开来；把尚无明确限制的探索性试验中的失误错误，同明令禁止后依然我行我素的违纪违法行为区分开来；把为推动发展的无意过失，同为谋取私利的违纪违法行为区分开来。”这些措施如何落到实处，还有待观察。</p><p>22年的清零政策还是蛮尴尬的，人口生命健康与人民对个人利益损失的容忍度的两难拉锯中让政府骑虎难下，更是为本就放缓的经济一着沉重的打击，政府的公信力在各种因素下逐渐丧失<br>=&gt;反腐败是国家治理能力建设的一部分，除了专门针对腐败的制度建设之外，更为根本的措施还是简政放权、转变政府角色。正如党的十九大报告所提出的，要“转变政府职能，深化简政放权，创新监管方式，增强政府公信力和执行力，建设人民满意的服务型政府”</p><p>=&gt;反腐败是国家治理能力建设的一部分，除了专门针对腐败的制度建设之外，更为根本的措施还是简政放权、转变政府角色。正如党的十九大报告所提出的，要“转变政府职能，深化简政放权，创新监管方式，增强政府公信力和执行力，建设人民满意的服务型政府”</p><h4 id="◆-结语-1"><a href="#◆-结语-1" class="headerlink" title="◆ 结语"></a>◆ 结语</h4><p>=&gt;至于实体企业，很多行业在资金“大水”漫灌之下盲目扩张，导致产能过剩和产品价格下跌。但同时也有很多行业在宽松的投资环境中迅速成长，跻身世界一流水准，为产业转型升级做出了卓越贡献，比如光电显示、光伏、高铁产业等</p><h3 id="◆-第四章-工业化中的政府角色"><a href="#◆-第四章-工业化中的政府角色" class="headerlink" title="◆ 第四章 工业化中的政府角色"></a>◆ 第四章 工业化中的政府角色</h3><p>中国政府是中国市场最大的垄断性利益群体<br>=&gt;现实世界没有黑白分明的“市场”和“政府”分界，只有利益关系环环相扣的各种组合。我国经济改革的起点是计划经济，所以地方政府掌握着大量资源（土地、金融、国企等），不可避免会介入实业投资。由于实业投资的连续性、复杂性和不可逆性（第三章），政府的介入必然也是深度的，与企业关系复杂而密切，不容易退出。</p><p>=&gt;现实世界没有黑白分明的“市场”和“政府”分界，只有利益关系环环相扣的各种组合。我国经济改革的起点是计划经济，所以地方政府掌握着大量资源（土地、金融、国企等），不可避免会介入实业投资。由于实业投资的连续性、复杂性和不可逆性（第三章），政府的介入必然也是深度的，与企业关系复杂而密切，不容易退出。</p><p>=&gt;讨论和分析政府干预和产业政策，不能脱离具体行业细节，否则易流于空泛。社会现象复杂多变，任何理论和逻辑都可以找到不少反例，因为逻辑之外还有天时、地利、人和，不确定性和人为因素对结果影响非常大，而结果又直接影响到对过程和理论的评判。成功了才是宝贵经验，失败了只有惨痛教训。产业政策有成功有失败，市场决策也有成功有失败，用一种成功去质疑另一种失败，或者用一种失败去推崇另一种成功，争论没有尽头。</p><p>=&gt;经济学的数学模型和统计数据不是讲道理的唯一形式，也不一定是最优形式，具体的案例故事常常比抽象的道理更有力量，启发更大</p><h4 id="◆-第一节-京东方与政府投资"><a href="#◆-第一节-京东方与政府投资" class="headerlink" title="◆ 第一节 京东方与政府投资"></a>◆ 第一节 京东方与政府投资</h4><p>=&gt;大陆企业在全球市场的占有率已接近四成，成为世界第一，彻底摆脱了依赖进口的局面，涌现出了一批重量级企业，如京东方、华星光电、深天马、维信诺等。国产显示面板行业的崛起不仅推动了彩电和显示器等价格的直线下降，也推动了华为和小米等国产手机价格的下降，促成了使用液晶屏幕的各类国产消费电子品牌的崛起</p><p>=&gt;国内彩电巨头TCL、创维、康佳、长虹等计划联手解决“卡脖子”问题，于是拉来了京东方，在深圳启动了“聚龙计划”</p><p>深圳上海真的大无语🤧<br>=&gt;在这个过程中，夏普又来搅局，但因为京东方已经吃过两次夏普的亏，所以在与合肥合作之初就曾问过市领导：如果夏普来了怎么办？领导曾表示过绝不动摇，所以这次搅局没有成功。</p><p>=&gt;在这个过程中，夏普又来搅局，但因为京东方已经吃过两次夏普的亏，所以在与合肥合作之初就曾问过市领导：如果夏普来了怎么办？领导曾表示过绝不动摇，所以这次搅局没有成功。</p><p>新时代不会立刻取代旧时代，新产品不会立刻取代旧产品，而是有个此消彼长的过程<br>=&gt;若新企业成功实现大规模量产，不仅自身成本会降低，还会抢占旧企业的市场份额，削弱其规模经济，推高其生产成本，因此一定会遭遇旧企业的各种打压，比如三星可以打价格战，夏普也可以到处搅局</p><p>=&gt;若新企业成功实现大规模量产，不仅自身成本会降低，还会抢占旧企业的市场份额，削弱其规模经济，推高其生产成本，因此一定会遭遇旧企业的各种打压，比如三星可以打价格战，夏普也可以到处搅局</p><p>=&gt;若资源不能流动和重组，市场竞争、优胜劣汰及比较优势等传统经济学推理的有效性，都会受到挑战</p><p>=&gt;政府若投资和补贴国内企业，这些企业无法利用国内市场的规模经济来降低成本，必须依赖出口，那政府的投入实际上是在补贴外国消费者</p><p>=&gt;本国企业能以更低的价格生产（不一定非要有技术优势，能够拉低国际厂商的漫天要价也可以），政府就可以考虑扶持本国企业进入，这不仅能打破国际市场的扭曲和垄断，还可以降低国内下游产业的成本，促进其发展</p><p>=&gt;一旦行业集聚形成，企业自身的规模经济效应就会和行业整体的规模经济效应叠加，进一步降低运输和其他成本</p><p>=&gt;规模经济和产业集聚也会刺激技术创新。市场大，利润就大，就能支撑更大规模的研发投入。产业的集聚还会带来技术和知识的外溢，促进创新</p><p>=&gt;“比较优势”具有很大的不确定性，是可以靠人为创造的。其实“比较优势”并不神秘，就是机会成本低的意思。而对于没干过的事情，事前其实无从准确判断机会成本，没干过怎么知道呢？</p><h4 id="◆-第二节-光伏发展与政府补贴"><a href="#◆-第二节-光伏发展与政府补贴" class="headerlink" title="◆ 第二节 光伏发展与政府补贴"></a>◆ 第二节 光伏发展与政府补贴</h4><p>=&gt;我国的光伏产业已经成为全球龙头，国内企业（包括其海外工厂）的产能占全球八成。该产业的几乎全部关键环节，如多晶硅、硅片、电池、组件等，我国企业都居于主导地位。</p><p>=&gt;“标杆电价”补贴（feed-in tariff，FiT）。光伏要依靠太阳能，晚上无法发电，电力供应不稳定，会对电网造成压力，因此电网一般不愿意接入光伏电站。但在“标杆电价”制度下，电网必须以固定价格持续购买光伏电量，期限20年，该价格高于光伏发电成本。这种价格补贴会加到终端电价中，由最终消费者分摊</p><p>=&gt;很多光伏电站建在阳光充足且地价便宜的西部，但当地人口密度低、经济欠发达，用电量不足，消纳不了这么多电。跨省配电不仅成本高，且面临配电体系固有的很多制度扭曲，所以电力公司经常以未拿到政府拖欠的补贴为由，拒绝给光伏电厂结算，导致甘肃、新疆等西部省份的“弃光”现象严重</p><p>=&gt;新能源的技术升级和成本下降，只有在大规模的生产和市场应用中才能逐步发生，不可能只依靠实验室。实验技术再突破，若没有全产业链的工业化量产和技术创新，就不可能实现规模经济和成本下降。研发和创新从来不只是象牙塔里的活动，离不开现实市场，也离不开边干边学的企业</p><p>新时代与旧时代的此消彼长<br>=&gt;新能源技术必须在没有竞争优势的时候就进入市场，这时候只有两个办法：第一是对传统能源征收高额碳税或化石燃料税，增加其成本，为新能源的发展制造空间；第二是直接补贴新能源行业。第一种办法明显不够经济，因为在新能源发展早期，传统能源占据九成以上的市场，且成本低廉，对其征收重税会大大加重税收负担，造成巨大扭曲。所以更加合理的做法是直接补贴新能源，加速其技术进步和成本降低，待其市场份额不断扩大、成本逼近传统能源之后，再逐渐降低补贴，同时对传统能源征税，加速其退出</p><p>=&gt;新能源技术必须在没有竞争优势的时候就进入市场，这时候只有两个办法：第一是对传统能源征收高额碳税或化石燃料税，增加其成本，为新能源的发展制造空间；第二是直接补贴新能源行业。第一种办法明显不够经济，因为在新能源发展早期，传统能源占据九成以上的市场，且成本低廉，对其征收重税会大大加重税收负担，造成巨大扭曲。所以更加合理的做法是直接补贴新能源，加速其技术进步和成本降低，待其市场份额不断扩大、成本逼近传统能源之后，再逐渐降低补贴，同时对传统能源征税，加速其退出</p><p>=&gt;三头在外”的局面：需求和市场来自海外，关键技术和设备来自海外，关键原材料也来自海外。所以基本就是一个代工行业，处处受制于人</p><p>行业起起伏伏很正常，别妄想你所在的行业能一路高歌40年直到你退休🤗<br>=&gt;企业不是“人”，不会在“死”后一了百了，积累的技术、人才、行业知识和经验，并不会随企业破产而消失。一旦需求回暖，这些资源就又可以重新整合</p><p>=&gt;企业不是“人”，不会在“死”后一了百了，积累的技术、人才、行业知识和经验，并不会随企业破产而消失。一旦需求回暖，这些资源就又可以重新整合</p><p>=&gt;无论是补贴也好、贸易保护也罢，政策最多可以帮助企业降低一些财务风险和市场风险，但政府不能帮助企业克服最大的不确定性，即在不断变化的市场中发展出足够的能力和竞争优势。如果做不到这一点，保护和补贴政策最终会变成企业的寻租工具。这一点不仅对中国适用，对欧美也适用。但这个逻辑不能构成反对所有产业政策的理由。</p><p>=&gt;地方政府招商引资的优惠政策，会降低产业进入门槛，可能会带来重复投资和产能过剩。</p><p>大部分产业的产能过剩是“内卷”社会的本质<br>=&gt;若市场乐观情绪弥漫，投资者往往一拥而上，导致产能过剩，产品价格下跌，淘汰一批企业，而价格下跌可能刺激新一轮需求上升，引发新的过剩投资。这种供需动态匹配和调整过程中周期性的产能过剩是市场经济的常态。但也正是因为这种产能过剩，企业才不得不在这场生存游戏中不断创新，增加竞争优势，加速优胜劣汰和技术进步。</p><p>=&gt;若市场乐观情绪弥漫，投资者往往一拥而上，导致产能过剩，产品价格下跌，淘汰一批企业，而价格下跌可能刺激新一轮需求上升，引发新的过剩投资。这种供需动态匹配和调整过程中周期性的产能过剩是市场经济的常态。但也正是因为这种产能过剩，企业才不得不在这场生存游戏中不断创新，增加竞争优势，加速优胜劣汰和技术进步。</p><p>=&gt;经济发展早期，各地政府扶持下的工业“重复投资”至少有两个正面作用。首先，当地工厂不仅提供了就业，也为当地农民转变为工人提供了学习场所和途径。“工业化”最核心的一环是把农民变成工人，这不仅仅是工作的转变，也是思想观念和生活习惯的彻底转变。这个转变不会自动发生，需要学习和培训，而这种学习和培训只能在工厂中完成。</p><p>=&gt;“重复投资”的第二个好处是加剧竞争。蜂拥而上的低水平产能让“价格战”成为我国很多产品的竞争常态。所以在很长一段时间内，“成本创新”是本土创新的主流。虽然西方会将此讥讽为“仿造”和“山寨”，但其实成本创新和功能简化非常重要。</p><p>=&gt;所以不管有没有政府扶持，要害都不是“重复建设”，而是“保持竞争”。市场经济的根本优势不是决策优势。面对不可知的未来，谁也看不清，自由市场上，失败也比成功多得多。市场经济的根本优势是可以不断试错，在竞争中优胜劣汰</p><p>=&gt;中央政府提倡的产业政策是普惠全行业的，并不针对特定企业，但到了地方政府，政策终归要落实到“特定”的本地企业头上。若地方政府保护本地企业，哪怕是低效率的“僵尸企业”也要不断输血和挽救，做不到“劣汰”，竞争的效果就会大打折扣，导致资源的错配和浪费。</p><p>=&gt;其破产重整方案由地方政府直接主导，损害了债权人利益。当受偿率太低的债权人无法接受重整方案时，地方法院又强制裁决，引发了媒体、法律和金融界的高度关注</p><p>=&gt;产业政策要有退出机制，若效率低的企业不能退出，“竞争性”就是一句空话</p><p>产业政策降低了企业进入的门槛，企业可以很快做大规模，但是一些地方政府的产业政策同时提高了企业退出的门槛，企业破产难就嗯吸地方人民的血<br>=&gt;“破产难”一直是我国经济的顽疾。一方面，债权银行不愿走破产程序，因为会暴露不良贷款，无法再掩盖风险；另一方面，地方政府也不愿企业（尤其是大企业）走破产程序，否则职工安置和民间借贷等一系列矛盾会公开化。</p><p>=&gt;“破产难”一直是我国经济的顽疾。一方面，债权银行不愿走破产程序，因为会暴露不良贷款，无法再掩盖风险；另一方面，地方政府也不愿企业（尤其是大企业）走破产程序，否则职工安置和民间借贷等一系列矛盾会公开化。</p><h4 id="◆-第三节-政府产业引导基金"><a href="#◆-第三节-政府产业引导基金" class="headerlink" title="◆ 第三节 政府产业引导基金"></a>◆ 第三节 政府产业引导基金</h4><p>这一小节完全没看懂，烂完了😖</p><p>=&gt;出钱的人叫“有限合伙人”（limited partner，以下简称LP），管钱和投资的人叫“普通合伙人”（general partner，以下简称GP）。LP把钱交给GP投资和运作，同时付给GP两种费用：一种是基本管理费。一般是投资总额的2%，无论亏赚，每年都要交。另一种是绩效提成，行话叫“carry”。若投资赚了钱，GP要先偿还LP的本金和事先约定的基本收益（一般为8%），若还有多余利润，GP可从中提成，一般为20%</p><p>=&gt;LP和GP这种特殊的称呼和合作方式，法律上称为“有限合伙制”。与常见的股份制公司相比，“有限合伙”最大的特点是灵活。股份制公司一般要求“同股同权”和“同股同利”。无论持股多少，每一股附带的投票权和分红权是一样的，持有的股票数量越多，权利越多。但在“有限合伙”中，出钱的是LP，做投资决定的却是GP，LP的权利相当有限。</p><p>=&gt;政府引导基金本身就是一支基金，投资对象又是各种私募基金，所以也被称为“基金中的基金”或“母基金”（fund of funds, FOF）。第二，把政府引导基金交给市场化的基金管理人运作，实质上是借用市场力量去使用财政资金，其中涉及诸多制度改革，也在实践中遭遇了各种困难（见下文）</p><p>=&gt;政府不可以直接向银行借贷，所以需要设立城投公司。政府当然也不可以直接去资本市场上做股权投资，所以在设立引导基金之后，也需要成立专门的公司去管理和运营这支基金，通过这些公司把基金投资到其他私募基金手中。</p><p>=&gt;国务院为设立引导基金提供了政策基础，明确其宗旨是“发挥财政资金的杠杆放大效应，增加创业投资资本的供给，克服单纯通过市场配置创业投资资本的市场失灵问题”</p><p>=&gt;在公众熟知的很多新技术领域，比如新能源、芯片、人工智能、生物医药、航空航天等，大多数知名企业和投资基金的背后都有政府引导基金的身影</p><h4 id="◆-结语-2"><a href="#◆-结语-2" class="headerlink" title="◆ 结语"></a>◆ 结语</h4><p>=&gt;我国的经济改革脱胎于计划经济，政府手中掌握大量对产业发展至关重要的资源，如土地、银行、大学和科研机构等，所以必然会以各种方式深度参与工业化进程。</p><p>经济能不能等等你的人民呀😰<br>=&gt;基础设施不完善、法制环境不理想、资本市场和社会信用机制不健全，因此以信用级别高的地方政府和国企为主体、以土地为杠杆，可以撬动大量资源，加速投资进程，推动快速城市化和工业化。这种模式的成就有目共睹，但也会带来如下后果：与土地相关的腐败猖獗；城市化以“地”为本，忽略了“人”，民生支出不足，教育、医疗等公共服务供给滞后；房价飞涨，债务急升；经济过度依赖投资，既表现在民众收入不高所以消费不足，也表现在过剩产能无法被国内消化、向国际输出时又引起贸易失衡和冲突。</p><p>=&gt;基础设施不完善、法制环境不理想、资本市场和社会信用机制不健全，因此以信用级别高的地方政府和国企为主体、以土地为杠杆，可以撬动大量资源，加速投资进程，推动快速城市化和工业化。这种模式的成就有目共睹，但也会带来如下后果：与土地相关的腐败猖獗；城市化以“地”为本，忽略了“人”，民生支出不足，教育、医疗等公共服务供给滞后；房价飞涨，债务急升；经济过度依赖投资，既表现在民众收入不高所以消费不足，也表现在过剩产能无法被国内消化、向国际输出时又引起贸易失衡和冲突。</p><h3 id="◆-扩展阅读"><a href="#◆-扩展阅读" class="headerlink" title="◆ 扩展阅读"></a>◆ 扩展阅读</h3><p>事在人为<br>=&gt;事在人为，理解这其中所蕴含的随机性，是理解所谓“entrepreneurship”的起点。相比于“企业家精神”，这个词更应该翻译为“进取精神”，不仅企业家，官员、科学家、社会各界都离不开这种精神。</p><p>=&gt;事在人为，理解这其中所蕴含的随机性，是理解所谓“entrepreneurship”的起点。相比于“企业家精神”，这个词更应该翻译为“进取精神”，不仅企业家，官员、科学家、社会各界都离不开这种精神。</p><h3 id="◆-下篇-宏观现象"><a href="#◆-下篇-宏观现象" class="headerlink" title="◆ 下篇 宏观现象"></a>◆ 下篇 宏观现象</h3><p>=&gt;地方政府推动经济发展的模式。这种模式的第一个特点是城市化过程中“重土地、轻人”，优点是可以快速推进城市化和基础设施建设，缺点是公共服务供给不足，推高了房价和居民债务负担，拉大了地区差距和贫富差距</p><p>=&gt;第二个特点是招商引资竞争中“重规模、重扩张”，优点是推动了企业成长和快速工业化，缺点是加重了债务负担。企业、地方政府、居民三部门债务互相作用，加大了经济整体的债务和金融风险</p><p>这样看来全国统一大市场确实是正确方向，内需不足，教育医疗住房三座大山压抑了消费。世界工厂背后赤裸裸的现实是，生产一方的劳工没有没法享受到自己生产的产品，不生产的一方的人，享受着更加低廉的工业产品<br>=&gt;第三个特点是发展战略“重投资、重生产、轻消费”，优点是拉动了经济快速增长，扩大了对外贸易，使我国迅速成为制造业强国，缺点是经济结构不平衡。对内，资源向企业部门转移，居民收入和消费占比偏低，不利于经济长期稳定发展；对外，国内无法消纳的产能向国外输出，加剧了贸易冲突。</p><p>=&gt;第三个特点是发展战略“重投资、重生产、轻消费”，优点是拉动了经济快速增长，扩大了对外贸易，使我国迅速成为制造业强国，缺点是经济结构不平衡。对内，资源向企业部门转移，居民收入和消费占比偏低，不利于经济长期稳定发展；对外，国内无法消纳的产能向国外输出，加剧了贸易冲突。</p><h3 id="◆-第五章-城市化与不平衡"><a href="#◆-第五章-城市化与不平衡" class="headerlink" title="◆ 第五章 城市化与不平衡"></a>◆ 第五章 城市化与不平衡</h3><p>梦想买不起，故乡回不去😢<br>=&gt;大一新生刚从中学毕业，无忧无虑，爱思考“为什么”；大四毕业生和研究生则要走向社会，扛起工作和生活的重担，普遍焦虑，好琢磨“怎么办”。大多数人的困境可以概括为：有心仪工作的城市房价太高，而房价合适的城市没有心仪的工作。梦想买不起，故乡回不去。</p><p>=&gt;大一新生刚从中学毕业，无忧无虑，爱思考“为什么”；大四毕业生和研究生则要走向社会，扛起工作和生活的重担，普遍焦虑，好琢磨“怎么办”。大多数人的困境可以概括为：有心仪工作的城市房价太高，而房价合适的城市没有心仪的工作。梦想买不起，故乡回不去。</p><p>=&gt;房价连着地价，地价连着财政，财政连着基础设施投资，于是经济增长、地方财政、银行、房地产之间就形成了“一荣俱荣，一损俱损”的复杂关系。</p><p>中国的城市化现代化仅仅是器物上的升级，其组织架构，精神文明都是落后于现代的，错位下自然会有诸多矛盾与撕扯<br>=&gt;所以土地的资本化，实质是个人收入的资本化。支撑房价和地价的，是人的收入。忽略了人，忽略了城市化本该服务于人，本该为人创造更好的环境和更高的收入，城市化就入了歧途。</p><p>=&gt;所以土地的资本化，实质是个人收入的资本化。支撑房价和地价的，是人的收入。忽略了人，忽略了城市化本该服务于人，本该为人创造更好的环境和更高的收入，城市化就入了歧途。</p><p>=&gt;2019年的城镇户籍人口只占总人口的44%，比常住人口占比少了16个百分点。也就是说有超过2亿人虽然常住城镇，却没有当地户口，不能完全享受到应有的公共服务（如教育），因为这些服务的供给是按户籍人数来规划的</p><h4 id="◆-第一节-房价与居民债务"><a href="#◆-第一节-房价与居民债务" class="headerlink" title="◆ 第一节 房价与居民债务"></a>◆ 第一节 房价与居民债务</h4><p>=&gt;1994年之前实行财政包干制，促进了乡镇企业的崛起，为工业化打下了基础，但农民离土不离乡，大多就地加入乡镇企业，没有大量向城市移民。分税制改革后，乡镇企业式微，农民工大潮开始形成。</p><p>=&gt;集中。随着收入增长和生活水平提高，人们高价竞争城市住房。这种需求压力是否会推升房价，取决于房屋和住宅用地供给是否灵活。若政策严重限制了供给，房价上涨就快。</p><p>=&gt;地理分布上看，东部地区的城镇人口要比用地增速高出近10%，住房十分紧张；而西部和东北地区则反过来，建设用地指标增加得比人口快</p><p>=&gt;中国对建设用地指标实行严格管理，每年的新增指标由中央分配到省，再由省分配到地方。这些指标无法跨省交易，所以即使面对大量人口流入，东部也无法从西部调剂用地指标。2003年后的十年间，为了支持西部大开发并限制大城市人口规模，用地指标和土地供给不但没有向人口大量流入的东部倾斜，反而更加向中西部和中小城市倾斜。</p><p>=&gt;地方政府招商引资竞争虽然激烈，也经常以土地作为手段，却很难持续提高土地资源利用效率。发达地区土地需求旺盛，地价大涨，本应增加用地指标，既满足需求也抑制地价。但因为土地分配受制于行政边界，结果却是欠发达地区能以超低价格（甚至免费）大量供应土地。这种“东边干旱，西边浇水”的模式需要改革</p><p>=&gt;各国房价上涨都是因为供不应求，一来城市化过程中住房需求不断增加；二来土地和银行按揭的供给都受政治因素影响。</p><p>=&gt;政府为讨好这部分选民，不愿让房价下跌。无房者也想尽快买房，赶上房价上涨的财富快车，政府于是顺水推舟，降低了买房的首付门槛和按揭利率</p><p>=&gt;房地产常被称作“经济周期之母”，根源就在于其内在的供需矛盾：一方面，银行可以通过按揭创造几乎无限的新购买力；而另一方面，不可再生的城市土地供给却有限。这对矛盾常常会导致资产泡沫与破裂的周期循环，是金融和房地产不稳定的核心矛盾。而房地产不仅连接着银行，还连接着千家万户的财富和消费，因此影响很大。</p><p>世界三大经济奇观：美国的股市，日本的债市，中国的楼市<br>=&gt;中国人财富的压舱石是房子，美国人财富的压舱石是金融资产。这个重大差别可以帮助理解两国的一些基本政策，比如中国对房市的重视以及美国对股市的重视</p><p>=&gt;中国人财富的压舱石是房子，美国人财富的压舱石是金融资产。这个重大差别可以帮助理解两国的一些基本政策，比如中国对房市的重视以及美国对股市的重视</p><p>=&gt;房价上涨不仅会增加按揭债务负担，还会拉大贫富差距，进而刺激低收入人群举债消费，这一现象被称为“消费下渗”</p><p>经济上行期，你是韭菜，嘎嘎地长嘎嘎地被割，经济下行期，你是腌菜，石头尽往你身上压，榨干你的剩余价值<br>=&gt;很多穷人的资产一夜清零。2007年至2010年，美国最穷的20%的人，净资产从平均3万美元下降到几乎为零。而最富的20%的人，净资产只下跌了不到10%，从平均320万美元变成了290万美元，而且这种下跌非常短暂。</p><p>=&gt;很多穷人的资产一夜清零。2007年至2010年，美国最穷的20%的人，净资产从平均3万美元下降到几乎为零。而最富的20%的人，净资产只下跌了不到10%，从平均320万美元变成了290万美元，而且这种下跌非常短暂。</p><p>到大城市！到新兴行业！<br>=&gt;要化解居民债务风险，除了遏制房价上涨势头以外，根本的解决之道还在于提高收入，尤其是中低收入人群的收入，鼓励他们到能提供更多机会和更高收入的地方去工作。让地区间的经济发展和收入差距成为低收入人群谋求发展的机会，而不是变成人口流动的障碍。</p><p>=&gt;要化解居民债务风险，除了遏制房价上涨势头以外，根本的解决之道还在于提高收入，尤其是中低收入人群的收入，鼓励他们到能提供更多机会和更高收入的地方去工作。让地区间的经济发展和收入差距成为低收入人群谋求发展的机会，而不是变成人口流动的障碍。</p><h4 id="◆-第二节-不平衡与要素市场改革"><a href="#◆-第二节-不平衡与要素市场改革" class="headerlink" title="◆ 第二节 不平衡与要素市场改革"></a>◆ 第二节 不平衡与要素市场改革</h4><p>原来主要矛盾已经改了，我还停留在教科书上😆<br>=&gt;2017年党的十九大报告指出：我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。这是自1981年党的十一届六中全会提出“我国所要解决的主要矛盾”（即人民日益增长的物质文化需要同落后的社会生产之间的矛盾）以来，中央首次重新定义“主要矛盾”，说明经济政策的根本导向发生了变化。</p><p>=&gt;2017年党的十九大报告指出：我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。这是自1981年党的十一届六中全会提出“我国所要解决的主要矛盾”（即人民日益增长的物质文化需要同落后的社会生产之间的矛盾）以来，中央首次重新定义“主要矛盾”，说明经济政策的根本导向发生了变化。</p><p>=&gt;低收入人群想要提高收入，最直接的方式就是到经济发达城市打工，这些城市能为低技能工作（如快递或家政）提供不错的收入。若人口不能自由流动，被限制在农村或经济落后地区，那人与人之间的收入差距就会拉大，地区和城乡间的收入差距也会拉大。</p><p>万恶的资本，尽抢劳动人民的血汗钱😣<br>=&gt;地方政府长期倚重投资，还会导致收入分配偏向资本，降低劳动收入占比，对中低收入人群尤其不利。</p><p>=&gt;地方政府长期倚重投资，还会导致收入分配偏向资本，降低劳动收入占比，对中低收入人群尤其不利。</p><p>大城市本可以容纳更多的人，城市是中国的城市，是人民的城市，不应该是少数所谓本地人的福利，这么屌干脆独立建国算了<br>=&gt;在广东、江苏、浙江、上海和北京等发达地区，折线比柱子低很多，人口规模远小于经济规模，更少的人分更多的收入，自然相对富有。而在其他大多数省份，柱子比折线低很多，经济规模小于人口规模，更多的人分更少的收入，自然相对贫穷。</p><p>=&gt;在广东、江苏、浙江、上海和北京等发达地区，折线比柱子低很多，人口规模远小于经济规模，更少的人分更多的收入，自然相对富有。而在其他大多数省份，柱子比折线低很多，经济规模小于人口规模，更多的人分更少的收入，自然相对贫穷。</p><p>想缩小地区收入差异，光凭扶持落后地区产业是不够的，还要让落后地区的劳动力也可以有资格享用发达地区的蛋糕，让市场和经济规模来决定人口集聚的规模，而不是用户籍和不合理的政策将人留在落后地区。（ps：既想要廉价劳动力，又不想让这些“低端人口”享有同等的待遇，城市佬司马了）<br>=&gt;让每个城市都像上海和北京一样，或者在内地再造长三角和珠三角这样巨大的工业和物流网络（包括港口），既无可能也无必要。现代经济越来越集聚，即使在欧美和日本，经济在地理上的集聚程度也依然还在加强，没有减弱。(24)所以理想的状况是达到地区间人均意义上的平衡。而要实现这种均衡，关键是让劳动力自由流动。</p><p>=&gt;让每个城市都像上海和北京一样，或者在内地再造长三角和珠三角这样巨大的工业和物流网络（包括港口），既无可能也无必要。现代经济越来越集聚，即使在欧美和日本，经济在地理上的集聚程度也依然还在加强，没有减弱。(24)所以理想的状况是达到地区间人均意义上的平衡。而要实现这种均衡，关键是让劳动力自由流动。</p><p>“低端人口”不是你们的服务奴隶😡<br>=&gt;正是这些看上去低技能的服务业工作，支撑着大城市的繁华，也支撑着所谓“高端人才”的生活质量。若没有物美价廉的服务，生活成本会急升。</p><p>=&gt;正是这些看上去低技能的服务业工作，支撑着大城市的繁华，也支撑着所谓“高端人才”的生活质量。若没有物美价廉的服务，生活成本会急升。</p><p>=&gt;靠行政规划来限制人口规模，成功例子不多。人口不断流入的城市，规划人口往往过少；而人口不断流出的城市，规划人口往往过多。</p><p>总有人把农民工当做城市的蛆虫，生怕他们抢走自己的既得利益，但是现实是农民工群体创造的价值远超他们所能获得的，那么到底谁才是城市的蛆虫呢🤭？农民工？新时代的奴隶和贫农罢了，以前是土地聚齐劳作现在是机器聚集劳作。<br>=&gt;让更多人进入城市，尤其是大城市，逻辑上的好处是清楚的，但在现实中尚有很多争议，主要是担心人口涌入会造成住房、教育、医疗、治安等资源紧张。这种担心可以理解，任何城市都不可能无限扩张。劳动力自由流动意味着有人来也有人走，若拥挤带来的代价超过收益，自会有人离开。至于教育、医疗等公共服务，缓解压力的根本之道是增加供给，而不是限制需求。涌入城市的人是来工作和谋生的，他们不仅分享资源，也会创造资源</p><p>=&gt;让更多人进入城市，尤其是大城市，逻辑上的好处是清楚的，但在现实中尚有很多争议，主要是担心人口涌入会造成住房、教育、医疗、治安等资源紧张。这种担心可以理解，任何城市都不可能无限扩张。劳动力自由流动意味着有人来也有人走，若拥挤带来的代价超过收益，自会有人离开。至于教育、医疗等公共服务，缓解压力的根本之道是增加供给，而不是限制需求。涌入城市的人是来工作和谋生的，他们不仅分享资源，也会创造资源</p><p>=&gt;假如用地指标可以跟着人口流动，人口流出地的用地指标减少，人口流入地的指标增多，就可能缓解土地供需矛盾、提高土地利用效率。而要让建设用地指标流转起来，首先是让农村集体用地参与流转。</p><p>中央政府真心不差了，一直给政策打补丁，一直将经济涨势撑到今年的4%，不得不说还是挺nb的<br>=&gt;中央政府提出，“在租赁住房供需矛盾突出的超大和特大城市，开展集体建设用地上建设租赁住房试点”。(27)这是一个体制上的突破，意味着城市政府对城市住宅用地的垄断将被逐渐打破。</p><p>=&gt;中央政府提出，“在租赁住房供需矛盾突出的超大和特大城市，开展集体建设用地上建设租赁住房试点”。(27)这是一个体制上的突破，意味着城市政府对城市住宅用地的垄断将被逐渐打破。</p><p>=&gt;法律上确认了集体经营性建设用地使用权可以直接向市场中的用地者出让、出租或作价出资入股，不再需要先行征收为国有土地。农村集体经营性用地与城市国有建设用地从此拥有了同等权能，可以同等入市，同权同价，城市政府对土地供应的垄断被打破了</p><p>🙏<br>=&gt;强调要守住“三条底线”：土地公有制性质不改变、耕地红线不突破、农民利益不受损。</p><p>=&gt;强调要守住“三条底线”：土地公有制性质不改变、耕地红线不突破、农民利益不受损。</p><p>市场经济下行计划经济的政策只会造成对社会的扭曲，要开倒车的话请开回计划经济时代😋<br>=&gt;人为限定城市土地可以转让而集体土地不能转让，用户籍把人分为三六九等，除非走计划经济的回头路，否则难以持久。就算不谈权利和价值观，随着市场化改革的深入，这些限定性的制度所带来的扭曲也会越来越严重，代价会高到不可维持，</p><p>=&gt;人为限定城市土地可以转让而集体土地不能转让，用户籍把人分为三六九等，除非走计划经济的回头路，否则难以持久。就算不谈权利和价值观，随着市场化改革的深入，这些限定性的制度所带来的扭曲也会越来越严重，代价会高到不可维持，</p><p>扶贫最简单的方法不是扶持本地产业，而是让低收入的劳动力流向真正需要劳动力的地方。他们已经没有了投票的权利，请至少给他们选择的权利<br>=&gt;要真正帮助低收入群体，就要增加他们的流动性和选择权，帮他们离开穷地方，去往能为他的劳动提供更高报酬的地方，让他的人力资本更有价值。同时也要允许农民所拥有的土地流动，这些土地资产才会变得更有价值</p><p>=&gt;要真正帮助低收入群体，就要增加他们的流动性和选择权，帮他们离开穷地方，去往能为他的劳动提供更高报酬的地方，让他的人力资本更有价值。同时也要允许农民所拥有的土地流动，这些土地资产才会变得更有价值</p><p>=&gt;等基本公共服务与常住人口挂钩机制，推动公共资源按常住人口规模配置。</p><h4 id="◆-第三节-经济发展与贫富差距"><a href="#◆-第三节-经济发展与贫富差距" class="headerlink" title="◆ 第三节 经济发展与贫富差距"></a>◆ 第三节 经济发展与贫富差距</h4><p>现在经济减缓了，让我们多看看周公子之流<br>=&gt;第一，我国十几亿人在40年间摆脱了贫困，大大缩小了全世界70亿人之间的不平等。第二，在经济快速增长过程中，虽然收入差距在拉大，但低收入人群的收入水平也在快速上升，社会对贫富差距的敏感度在一段时间之内没有那么高。第三，在经济增长减速时，社会对不平等的容忍度会减弱，贫富差距更容易触发社会矛盾。</p><p>=&gt;第一，我国十几亿人在40年间摆脱了贫困，大大缩小了全世界70亿人之间的不平等。第二，在经济快速增长过程中，虽然收入差距在拉大，但低收入人群的收入水平也在快速上升，社会对贫富差距的敏感度在一段时间之内没有那么高。第三，在经济增长减速时，社会对不平等的容忍度会减弱，贫富差距更容易触发社会矛盾。</p><p>=&gt;经济增长过程伴随着生产率的提高和各种新机会的不断涌现，虽然不一定会降低收入差距，但可以在一定程度上遏制贫富差距在代际间传递。如果每代人的收入都远远高于上一代人，那人们就会更看重自己的劳动收入，继承自父母的财富相对就不太重要。</p><p>=&gt;但对“80后”和“90后”来说，父母的财富和资源对子女收入的影响就大了。(36)原因之一是财富差距在其父母一代中就扩大了，财产性收入占收入的比重也扩大了，其中最重要的是房产</p><p>😇<br>=&gt;人力资本无法在代际之间不打折扣地传承，但房产和存款却可以</p><p>=&gt;人力资本无法在代际之间不打折扣地传承，但房产和存款却可以</p><p>我真的想笑.jpg<br>=&gt;累积的财富差距一般远大于每年的收入差距，因为有财富的人往往更容易积累财富，资产回报更高，可选择的投资方式以及应对风险的手段也更多。如前文所述，按照国家统计局公布的城镇居民收入数据：2019年收入最高的20%的人占有全部收入的48%，而最低的20%的人只占4%。而按照中国人民银行对城镇居民的调查数据，2019年净资产最高的20%的家庭占有居民全部净资产的65%，而最低的20%只占有2%。(38)在经济发达、资产增值更快的沿海省份，父母累积的财产对子女收入的影响，比在内地省份更大。(39)当经济增速放缓、新创造的机会变少之后，年轻人间的竞争会更加激烈，而其父母的财富优势会变得更加重要。如果“拼爹”现象越来越严重的话，社会对不平等的容忍程度便会下降，不安定因素会增加。<br>=&gt;对收入差距的容忍度<br>=&gt;收入差距不可能完全消除，但社会也无法承受过大的差距所带来的剧烈冲突，因此必须把不平等控制在可容忍的范围之内。影响不平等容忍程度的因素有很多，其中最重要的是经济增速，因为经济增速下降首先冲击的是穷人收入。不妨想象正在排队的两队人，富人队伍前进得比穷人快，但穷人队伍也在不停前进，所以排队的穷人相对来说比较有耐心。但如果穷人的队伍完全静止不动，哪怕富人队伍的前进速度也减慢了，困在原地的穷人也会很快失去耐心而骚动起来。这种现象被称为“隧道效应”（tunnel effect），形容隧道中两条车道一动一静时，静的那条的焦虑和难耐。(40)<br>=&gt;上文提到，1988年以来，我国城镇居民中高收入群体的实际收入（扣除物价因素）增长了约13倍，低收入群体和中等收入群体的收入也分别增长了6倍和9倍。在“经济蛋糕”膨胀的过程中，虽然高收入群体切走了更大一块，但所有人分到的蛋糕都比以前大多了，因此暂时可以容忍贫富差距拉大。美国情况则不同，自20世纪70年代以来，穷人（收入最低的50%）的实际收入完全没有增长，中产（收入居中的40%）的收入近40年的累积增幅不过区区35%，而富人（收入最高的10%）的收入却增长了2.5倍。因此社会越来越无法容忍贫富差距。2008年的全球金融危机让穷人财富大幅缩水，贫富差距进一步扩大，引发了“占领华尔街运动”，之后特朗普当选，美国政治和社会的分裂越来越严重。<br>=&gt;另一个影响不平等容忍度的因素是人群的相似性。改革开放前后，绝大多数中国人的生活经历都比较相似，或者在农村的集体生产队干活，或者在城镇的单位上班。在这种情况下，有些人先富起来可能会给另一些人带来希望：“既然大家都差不多，那我也可以，也有机会。”20世纪90年代很多人“下海”</p><p>这个观点我也反复说了很多次了——未来10年是低增量无增量社会，还能享受经济放缓前同等的生活质量的，只能是占有一定存量的人，还不快给你们父母哦不你们市中心的房子磕个头<br>=&gt;当经济增速放缓、新创造的机会变少之后，年轻人间的竞争会更加激烈，而其父母的财富优势会变得更加重要。如果“拼爹”现象越来越严重的话，社会对不平等的容忍程度便会下降，不安定因素会增加。</p><p>=&gt;当经济增速放缓、新创造的机会变少之后，年轻人间的竞争会更加激烈，而其父母的财富优势会变得更加重要。如果“拼爹”现象越来越严重的话，社会对不平等的容忍程度便会下降，不安定因素会增加。</p><p>=&gt;因为经济增速下降首先冲击的是穷人收入。不妨想象正在排队的两队人，富人队伍前进得比穷人快，但穷人队伍也在不停前进，所以排队的穷人相对来说比较有耐心。但如果穷人的队伍完全静止不动，哪怕富人队伍的前进速度也减慢了，困在原地的穷人也会很快失去耐心而骚动起来。这种现象被称为“隧道效应”（tunnel effect），形容隧道中两条车道一动一静时，静的那条的焦虑和难耐。</p><p>=&gt;美国情况则不同，自20世纪70年代以来，穷人（收入最低的50%）的实际收入完全没有增长，中产（收入居中的40%）的收入近40年的累积增幅不过区区35%，而富人（收入最高的10%）的收入却增长了2.5倍</p><p>中国的这个因素是户籍吧<br>=&gt;但如果贫富差距中参杂了人种、肤色、种姓等因素，那人们感受就不一样了</p><p>=&gt;但如果贫富差距中参杂了人种、肤色、种姓等因素，那人们感受就不一样了</p><p>决不决定生育最直接的判断是儿女的收入能超越自己的几率，如果低于40%而且还得看运气，这还生你妈呢。生孩子的结果是拉低自己的可支配收入还得挪用自己的养老储备，我可去你妈<br>=&gt;家庭观念也会影响对不平等的容忍度。在家庭观念强的地方，如果子女发展得好、有出息，自己的生活就算是有了保障，对贫富差距容忍度也会比较高，毕竟下一代还能赶上。而影响子女收入最重要的因素就是经济增长的大环境。</p><p>=&gt;家庭观念也会影响对不平等的容忍度。在家庭观念强的地方，如果子女发展得好、有出息，自己的生活就算是有了保障，对贫富差距容忍度也会比较高，毕竟下一代还能赶上。而影响子女收入最重要的因素就是经济增长的大环境。</p><p>各位领导，你们也不想看到集会游行静坐罢🤗<br>=&gt;经济增长与贫富差距之间的关系非常复杂。经济学中有一条非常有名的“库兹涅茨曲线”，宣称收入不平等程度会随着经济增长先上升而后下降，呈现出“倒U形”模式。这条在20世纪50年代声名大噪的曲线，其实不过是一些欧美国家在“二战”前后那段特殊时期中的特例。一旦把时间拉长、样本扩大，数据中呈现的往往不是“倒U形”，而是贫富差距不断起起伏伏的“波浪形”。(43)造成这些起落的因素很多，既有内部的也有外部的，既有经济的也有政治的。并没有什么神秘的经济力量会自动降低收入不平等，“先富带动后富”也不会自然发生，而需要政策的干预。不断扩大的不平等会让社会付出沉重的代价，必须小心谨慎地对待。</p><p>=&gt;经济增长与贫富差距之间的关系非常复杂。经济学中有一条非常有名的“库兹涅茨曲线”，宣称收入不平等程度会随着经济增长先上升而后下降，呈现出“倒U形”模式。这条在20世纪50年代声名大噪的曲线，其实不过是一些欧美国家在“二战”前后那段特殊时期中的特例。一旦把时间拉长、样本扩大，数据中呈现的往往不是“倒U形”，而是贫富差距不断起起伏伏的“波浪形”。(43)造成这些起落的因素很多，既有内部的也有外部的，既有经济的也有政治的。并没有什么神秘的经济力量会自动降低收入不平等，“先富带动后富”也不会自然发生，而需要政策的干预。不断扩大的不平等会让社会付出沉重的代价，必须小心谨慎地对待。</p><h3 id="◆-第六章-债务与风险"><a href="#◆-第六章-债务与风险" class="headerlink" title="◆ 第六章 债务与风险"></a>◆ 第六章 债务与风险</h3><p>=&gt;人们在乐观时往往会低估负债的风险，过多借债。当风险出现时，又会因为债务负担沉重而缺乏腾挪空间，没办法应对。</p><p>经济发展快？我们债务发展更是领先世界，我只感觉到快，国又赢！<br>=&gt;。即便我国经济增长强劲，同期GDP还增加了2.8倍，但债务占GDP的比重在10年间还是翻了一番，引发了国内外的广泛关注和担忧。</p><p>=&gt;。即便我国经济增长强劲，同期GDP还增加了2.8倍，但债务占GDP的比重在10年间还是翻了一番，引发了国内外的广泛关注和担忧。</p><h4 id="◆-第一节-债务与经济衰退"><a href="#◆-第一节-债务与经济衰退" class="headerlink" title="◆ 第一节 债务与经济衰退"></a>◆ 第一节 债务与经济衰退</h4><p>=&gt;债务关系让经济各部门之间的联系变得更加紧密，任何部门出问题都可能传导到其他部门，一石激起千层浪，形成系统风险。</p><p>=&gt;第一，负债率高的经济中，资产价格的下跌往往迅猛。若债务太重，收入不够还本，甚至不够还息，就只能变卖资产，抛售的人多了，资产价格就会跳水。</p><p>=&gt;第二，资产价格下跌会引起信贷收缩，导致资金链断裂。借债往往需要抵押物（如房产和煤矿），若抵押物价值跳水，债权人（通常是银行）坏账就会飙升，不得不大幅缩减甚至干脆中止新增信贷，导致债务人借不到钱，资金链断裂，业务难以为继。</p><p>=&gt;债务累积或“加杠杆”的过程，就是人与人之间商业往来增加的过程，会推动经济繁荣。而债务紧缩或“去杠杆”也就是商业活动减少的过程，会带来经济衰退</p><p>穷人就是活该，谁叫你们不努力.jpg<br>=&gt;因为债务危机对穷人和富人的打击高度不对称。这种不对称源于债的特性，即法律优先保护债权人的索赔权，而欠债的无论是公司还是个人，即使破产也要清算偿债。以按揭为例，穷人因为收入低，买房借债的负担也重，房价一旦下跌，需要先承担损失，直到承担不起破产了，损失才转到银行及其债主或股东，后者往往是更富的人。换句话说，债务常常把风险集中到承受能力最弱的穷人身上。</p><p>=&gt;因为债务危机对穷人和富人的打击高度不对称。这种不对称源于债的特性，即法律优先保护债权人的索赔权，而欠债的无论是公司还是个人，即使破产也要清算偿债。以按揭为例，穷人因为收入低，买房借债的负担也重，房价一旦下跌，需要先承担损失，直到承担不起破产了，损失才转到银行及其债主或股东，后者往往是更富的人。换句话说，债务常常把风险集中到承受能力最弱的穷人身上。</p><h4 id="◆-第二节-债台为何高筑欧美的教训"><a href="#◆-第二节-债台为何高筑欧美的教训" class="headerlink" title="◆ 第二节 债台为何高筑欧美的教训"></a>◆ 第二节 债台为何高筑欧美的教训</h4><p>=&gt;债务源于人性：总想尽早满足欲望，又对未来盲目乐观，借钱时总觉得将来能还上。但人性亘古不变，债务周期却有起有落，每一次起伏都由特定的外部因素推动，这些因素会引发乐观情绪、刺激人们借债，也会增加资金供给、为借债大开方便之门。</p><p>=&gt;金融风险的核心是银行，历次金融危机几乎都伴随着银行危机。简单说来原因有四。(9)第一，银行规模大、杠杆高</p><p>=&gt;第二，银行借进来的钱很多是短期的（比如活期存款），但贷出去的钱却大都是长期的（比如企业贷款），这种负债和资产的期限不匹配会带来流动性风险。</p><p>=&gt;第三，银行信贷大都和房地产有关，常常与土地和房产价值一同起落，放大经济波动</p><p>就很真实😆<br>=&gt;地价上涨，抵押物价值上行，银行利润上升，资本充足率也上升，更加愿意多放贷，为此不惜降低放贷标准，逐渐积累了风险。经济衰退时，上述过程逆转。所以银行很少雪中送炭，却常常晴天送伞，繁荣时慷慨解囊、助推经济过热，衰退时却捂紧口袋、加剧经济下行。</p><p>=&gt;地价上涨，抵押物价值上行，银行利润上升，资本充足率也上升，更加愿意多放贷，为此不惜降低放贷标准，逐渐积累了风险。经济衰退时，上述过程逆转。所以银行很少雪中送炭，却常常晴天送伞，繁荣时慷慨解囊、助推经济过热，衰退时却捂紧口袋、加剧经济下行。</p><p>=&gt;第四，银行风险会传导到其他金融部门</p><p>=&gt;如果银行借出去的钱转手就能打包卖给下家，那银行就不会在乎借钱的人是不是真的有能力还钱。击鼓传花的游戏，传的是什么东西并不重要，只要有人接盘就行。</p><p>生产力的上限是金融的下限，而金融是有周期波动的，所以必须提高生产力<br>=&gt;频繁的金融活动并没有提高资本配置的效率，反而给经济带来了不必要的成本。过多的短期交易扩大了市场波动，挤压了实体经济的发展空间。资金和资源在金融体系内部空转，但实体经济的蛋糕却没有做大。而且大量金融交易都是业内互相“薅羊毛”，所以“军备竞赛”不断升级，大量投资硬件，高薪聘请人才，导致大量高学历人才放弃本专业而转投金融部门</p><p>=&gt;频繁的金融活动并没有提高资本配置的效率，反而给经济带来了不必要的成本。过多的短期交易扩大了市场波动，挤压了实体经济的发展空间。资金和资源在金融体系内部空转，但实体经济的蛋糕却没有做大。而且大量金融交易都是业内互相“薅羊毛”，所以“军备竞赛”不断升级，大量投资硬件，高薪聘请人才，导致大量高学历人才放弃本专业而转投金融部门</p><p>=&gt;中国等东亚国家借钱给美国，与贸易不平衡有关。2018年，中美双边贸易逆差约4 000亿美元，也就是说美国需要从全世界借入4 000亿美元来为它从中国额外的进口买单</p><p>=&gt;为保持美元的国际储备货币地位，美国的对外贸易可能需要常年保持逆差，以向世界提供更多美元。但持续的逆差会累积债务，最终威胁美元的储备货币地位，这个逻辑也被称为“特里芬悖论”。(17)所以如今的全球经济失衡，是贸易失衡和美元地位带来的资本流动失衡所共同造就的</p><h4 id="◆-第三节-中国的债务与风险"><a href="#◆-第三节-中国的债务与风险" class="headerlink" title="◆ 第三节 中国的债务与风险"></a>◆ 第三节 中国的债务与风险</h4><p>=&gt;国外债水平很低，债务基本都是以人民币计价的内债，所以不太可能出现国际上常见的外债危机</p><p>=&gt;国进民退”现象。2008年以后，国有企业规模快速扩张，但效率比私营企业低，多占用的资金没有转化为同比例的新增收入，推升了整体债务负担</p><p>=&gt;低效率乃至亏损的国企或大中型私企，若不能破产重组，常年依靠外力“输血”，挤占有限的信贷资源，变成“僵尸企业”，就会拉低经济整体效率，推升宏观债务负担</p><p>=&gt;房地产是支柱型产业，不仅本身规模巨大，而且直接带动钢铁、玻璃、家具、家电等众多行业。</p><p>=&gt;我国企业债务负担较重，应对风险的能力受限。若遭遇重大外部冲击，就可能面临债务违约风险。而企业裁员甚至倒闭，会降低居民收入，加大居民的风险，也加大其债主银行的风险。</p><p>=&gt;银行贷给企业家李四500万元买设备，实质也不是因为设备值钱，而是用设备生产出的产品值钱，这500万元来源于李四公司未来数年的经营收入。但作为抵押物，设备的专用性太强，价值远不如住房或土地，万一出事，想找到人接盘并不容易。就算有人愿意接，价格恐怕也要大打折扣，所以银行风险不小。但若李四的企业有政府担保，甚至干脆就是国企，银行风险就小多了</p><p>=&gt;所谓“影子银行”，就是类似银行的信贷业务，却不在银行的资产负债表中，不受银行监管规则的约束。</p><p>搞金融的人是会玩，左手倒腾一下右手倒腾一下钱就能生钱<br>=&gt;银行可以卖给老百姓一个理财产品，利息5%，再把筹来的钱委托给信托公司，让信托公司把钱借给房企。在这笔“银信合作”业务中，发行的理财产品不算银行储蓄，委托给信托公司的投资不算银行贷款，所以这笔“表外业务”就绕开了对银行的监管，是一种“影子银行”业务</p><p>=&gt;银行可以卖给老百姓一个理财产品，利息5%，再把筹来的钱委托给信托公司，让信托公司把钱借给房企。在这笔“银信合作”业务中，发行的理财产品不算银行储蓄，委托给信托公司的投资不算银行贷款，所以这笔“表外业务”就绕开了对银行的监管，是一种“影子银行”业务</p><h4 id="◆-第四节-化解债务风险"><a href="#◆-第四节-化解债务风险" class="headerlink" title="◆ 第四节 化解债务风险"></a>◆ 第四节 化解债务风险</h4><p>=&gt;任何国家的债务问题，解决方案都可以分成两个部分：一是偿还已有债务；二是遏制新增债务，改革滋生债务的政治、经济环</p><p>=&gt;没有新增收入，还债就得靠压缩支出：居民少吃少玩，企业裁员控费，政府削减开支。但甲的支出就是乙的收入，甲不花钱乙就不挣钱，乙也得压缩支出。大家一起勒紧裤腰带，整个经济就会收缩，大家的收入一起减少。若收入下降得比债务还快，债务负担就会不降反升。这个过程很痛苦，日子紧巴巴，东西没人买，物价普遍下跌，反而会加重实际债务负担，因为钱更值钱</p><p>=&gt;还债让债务人不好过，赖账让债权人不好过。所以偿债过程很痛苦，还有可能陷入经济衰退。相比之下，增发货币也能缓解债务负担，似乎还不那么痛苦，因为没有明显的利益受损方，实施起来阻力也小。</p><p>=&gt;第一类是以增发货币来降低利率</p><p>=&gt;第二类方式是“量化宽松”，即央行增发货币来买入各类资产，把货币注入经济，这是金融危机后发达国家的主流做法。</p><p>=&gt;央行“发钱”的方式是购买各种金融资产，所以会推高资产价格，受益的是资产所有者，也就是相对富裕的人。</p><p>=&gt;第三类增加货币供给的做法是把债务货币化。政府加大财政支出去刺激经济，由财政部发债融资，央行直接印钱买过来，无需其他金融机构参与也无需支付利息，这便是所谓“赤字货币化”。</p><p>=&gt;“赤字货币化”的核心，是用无利率的货币替代有利率的债务，以政府预算收支的数量代替金融市场的价格（即利率）来调节经济资源配置。</p><p>=&gt;国民党政府就曾经搞过赤字化，彻底搞垮了货币经济</p><p>=&gt;清华大学教授们领了工资以后要立刻跑步去买米，“跑快跑慢价格不一样！</p><p>=&gt;不搞“大水漫灌”，“不搞竞争性的零利率或量化宽松政策”。(41)主要原因可能有二：第一，政府不愿看到宽松的货币政策再次推高房价，“房住不炒”是个底线原则；第二，货币政策治标不治本，无法从根本上解决债务负担背后的经济增速放缓问题，因为这是结构性的问题，是地方政府推动经济发展的模式问题。</p><p>=&gt;困难在于，就算搞清楚了原因，也不一定就能处理好后果，因为“因”毕竟是过去的“因”，但“果”却是现在的“果”，时过境迁，很多东西都变了</p><p>政策有时代的局限性，历史没办法假设<br>=&gt;反过来看，当年种下的“因”，也有当年的道理，或干脆就是不得已而为之</p><p>=&gt;反过来看，当年种下的“因”，也有当年的道理，或干脆就是不得已而为之</p><p>=&gt;我国的债务问题是以出口和投资驱动的经济体系的产物。</p><p>=&gt;近几年围绕供给侧结构性改革所推行的一系列重大经济金融改革，包括严控房价上涨、“资管新规”、限制土地融资、债务置换、“反腐”、国企混改等，确实有效遏制了新增债务的增长，但是高度依赖负债和投资的发展模式还没有完成转型，因此限制债务虽限制了这种模式的运转，但并不会自动转化为更有效率的模式，于是经济增速下滑</p><p>=&gt;与债权相比，股权的约束力更强。一来股东风险共担，共赚共赔；二来股权可以转让，股价可以约束公司行为。哪怕同样是借债，债券的约束力也比银行贷款强，因为债券也可以转让</p><p>=&gt;融资体系和投资体系是一体两面：谁来做投资决策，谁就该承担投资风险，融资体系也就应该把资源和风险向谁集中。若投资由政府和国企主导，风险也自然该由它们承担。</p><p>决策我来做，风险你们担🤗<br>=&gt;这一体系在过去的经济增长中发挥过很大作用，但如果投资主体不变，权力不下放给市场，那想要构建降低政府和银行风险的直接融资体系、想让分散的投资者去承担风险，就不符合“谁决策谁担风险”的逻辑，自然进展缓慢</p><p>=&gt;这一体系在过去的经济增长中发挥过很大作用，但如果投资主体不变，权力不下放给市场，那想要构建降低政府和银行风险的直接融资体系、想让分散的投资者去承担风险，就不符合“谁决策谁担风险”的逻辑，自然进展缓慢</p><p>=&gt;我国债务风险的本质不是金融投机的风险，而是财政和资源分配机制的风险</p><p>=&gt;实际生产率的增长还是通货膨胀速度，都赶不上信贷或债务增长的速度，所以宏观上就造成了高投资挤压消费，部分工业产能过剩和部分地区房地产投资过剩，同时伴随着腐败和行政效率降低</p><h4 id="◆-结语-3"><a href="#◆-结语-3" class="headerlink" title="◆ 结语"></a>◆ 结语</h4><p>产能过剩并不可怕，可怕的是产能过剩无法淘汰吸血的企业，地方政府总想维持繁荣的假象不断为无法在市场立足生产效率低的企业输血，其结果是捧的越高，摔得越狠<br>ps：国人很爱吹中国制造遍及世界，其实只要多想想——为什么美国人可以不生产就能享受到廉价的工业品，为什么工业品生产量如此巨大自己却消费不起，还能说话吗😆？<br>=&gt;产能过剩可以从三个角度去理解。第一是生产效率下降。宏观上表现为GDP增速放缓，低于债务增速，所以宏观债务负担加重。微观上表现为地方政府过度投资、不断为一些“僵尸企业”输血，扭曲了资源配置，加重了政府和企业的债务负担。而且地方政府的“土地财政”和“土地金融”模式过度依赖地价上涨和房地产繁荣，推升了房价和居民债务负担，也加大了银行风险。<br>=&gt;第二个角度是国际失衡。地方政府重视投资、生产和企业税收，相对忽视消费、民生和居民收入，造成经济结构失衡，分配体制偏向资本，劳动收入偏低，所以消费不足，必须向国外输出剩余产能。我国和韩国、日本等东亚邻居不同，体量巨大，所以对国际经济体系冲击巨大，贸易冲突由此而来。<br>=&gt;第三个角度是产业升级。因为产能过剩，我国制造业竞争激烈，价格和成本不断降低，不仅冲击了外国的中低端制造业，也冲击了本国同行。要想在国内市场上存活和保持优势，头部企业必须不断创新，进入附加值更高的环节。所以我国制造业的质量和技术含量在竞争中不断上升，在全球价值链上不断攀升，也带动了技术创新和基础科学的进步，进一步冲击了发达国家主导的国际分工体系。</p><p>=&gt;产能过剩可以从三个角度去理解。第一是生产效率下降。宏观上表现为GDP增速放缓，低于债务增速，所以宏观债务负担加重。微观上表现为地方政府过度投资、不断为一些“僵尸企业”输血，扭曲了资源配置，加重了政府和企业的债务负担。而且地方政府的“土地财政”和“土地金融”模式过度依赖地价上涨和房地产繁荣，推升了房价和居民债务负担，也加大了银行风险。第二个角度是国际失衡。地方政府重视投资、生产和企业税收，相对忽视消费、民生和居民收入，造成经济结构失衡，分配体制偏向资本，劳动收入偏低，所以消费不足，必须向国外输出剩余产能。我国和韩国、日本等东亚邻居不同，体量巨大，所以对国际经济体系冲击巨大，贸易冲突由此而来。第三个角度是产业升级。因为产能过剩，我国制造业竞争激烈，价格和成本不断降低，不仅冲击了外国的中低端制造业，也冲击了本国同行。要想在国内市场上存活和保持优势，头部企业必须不断创新，进入附加值更高的环节。所以我国制造业的质量和技术含量在竞争中不断上升，在全球价值链上不断攀升，也带动了技术创新和基础科学的进步，进一步冲击了发达国家主导的国际分工体系。</p><h3 id="◆-扩展阅读-1"><a href="#◆-扩展阅读-1" class="headerlink" title="◆ 扩展阅读"></a>◆ 扩展阅读</h3><p>但愿吧，我对中国政府还是很没有信心的🤔<br>=&gt;中国经济发展史也是各种“中国崩溃论”的失败史。在别人忙着讥讽“水多加面，面多加水”的手忙脚乱时，作者问：馒头为什么越蒸越大</p><p>=&gt;中国经济发展史也是各种“中国崩溃论”的失败史。在别人忙着讥讽“水多加面，面多加水”的手忙脚乱时，作者问：馒头为什么越蒸越大</p><h3 id="◆-第七章-国内国际失衡"><a href="#◆-第七章-国内国际失衡" class="headerlink" title="◆ 第七章 国内国际失衡"></a>◆ 第七章 国内国际失衡</h3><p>=&gt;我来自印度，过去的大半辈子，一直都是发达国家用各种手段打开发展中国家市场，要求贸易。没想到世界有一天会倒过来。</p><p>=&gt;由于本土制造业体量巨大，全球产业链在向我国集聚，也带动了本土供应商越来越壮大。因此我国出口模式早已不是简单的“来料加工”，绝大部分出口价值均由本土创造。</p><p>=&gt;这些巨大的成功背后，也隐藏着两重问题。第一是内部经济结构失衡：重生产、重投资，相对轻民生、轻消费，导致与巨大的产能相比，国内消费不足，而消化不了的产品只能对外输出。这就带来了第二个问题：国外需求的不稳定和贸易冲突。</p><h4 id="◆-第一节-低消费与产能过剩"><a href="#◆-第一节-低消费与产能过剩" class="headerlink" title="◆ 第一节 低消费与产能过剩"></a>◆ 第一节 低消费与产能过剩</h4><p>=&gt;所以当我们观察到消费占GDP的比重下降时，无非就是两种情况：或者GDP中可供老百姓支配的收入份额下降了，或者老百姓把更大一部分收入存了起来，储蓄率上升了。实际上这两种情况都发生了。</p><p>生育欲望是怎么消失的呢？90后可能要一人承担6个人的开支，你们觉得现实吗？🤣<br>=&gt;孩子数量的减少还是降低了育儿支出，增加了居民储蓄。21世纪初，独生子女们开始陆续走上工作岗位，而随着城市化大潮、商品房改革和房价上涨，他们不仅要攒钱买房、结婚、培养下一代，还要开始分担多位父母甚至祖父母的养老和医疗支出，储蓄率于是再次攀升</p><p>=&gt;孩子数量的减少还是降低了育儿支出，增加了居民储蓄。21世纪初，独生子女们开始陆续走上工作岗位，而随着城市化大潮、商品房改革和房价上涨，他们不仅要攒钱买房、结婚、培养下一代，还要开始分担多位父母甚至祖父母的养老和医疗支出，储蓄率于是再次攀升</p><p>=&gt;地方政府“重土地轻人”的发展模式将大量资源用在了基础设施建设和招商引资上，民生支出比如公立教育和卫生支出相对不足（第五章）。而且教育和医疗等领域由于体制原因，市场化供给受限，市场化服务价格偏高，所以家庭需要提高储蓄以应对相关支出。</p><p>=&gt;居民收入转移到了政府和企业手中，变成了公路和高铁等基础设施、厂房和机器设备等，而老百姓汽车和家电等消费品占比则相对降低。此外，总支出中还有一块是外国人的支出，也就是我国的出口。居民消费支出占比下降，不仅对应着投资占比上升，也对应着出口占比上升。因此在很长一段时间里，拉动我国GDP增长的主力是投资和出口，而国内消费则相对不振。</p><p>=&gt;在经济发展初期，将更多资源从居民消费转为资本积累，变成基础设施和工厂，可以有效推动经济起飞和产业转型，提高生产率和收入</p><p>=&gt;但当经济发展到一定阶段后，这种方式就不可持续了，会导致四个问题。第一，基础设施和工业体系已经比较完善，投资什么都有用的时代过去了，投资难度加大，因此投资决策和调配资源的体制需要改变，地方政府主导投资的局面需要改变。这方面前文已说过多次（第三章和第六章），不再赘述。第二，由于老百姓收入和消费不足，无法消化投资形成的产能，很多投资不能变成有效的收入，都浪费掉了，所以债务负担越积越重，带来了一系列风险（第六章），这种局面也必须改变。第三，劳动收入份额下降和资本收入份额上升，会扩大贫富差距。因为与劳动相比，资本掌握在少数人手中。贫富差距持续扩大会带来很多问题，社会对此的容忍度是有限的（第五章）。第四，由于消费不足和投资过剩，过剩产能必须向国外输出，而由于我国体量巨大，输出产能会加重全球贸易失衡，引发贸易冲突（见下节）。</p><p>=&gt;居民收入份额的下降很大程度上对应着企业留存收入份额（即“企业储蓄”）的上升。要想增加居民收入，就要把这些企业留存资源转给居民。民营企业整体利润率比国企高，所以留存收入或“总储蓄”较多，但这些钱都用作了投资，还不够，所以“净储蓄”是负的，还要融资。而国企整体盈利和“总储蓄”比民营企业少，但“净储蓄”却是正的。“净储蓄”虽是正的，国企的平均分红率比民营企业要低</p><p>=&gt;在一个开放的世界中，内部失衡必然伴随着外部失衡。本国生产的东西若不能在本国消化，就只能对外输出。GDP由三大部分组成：消费、投资、净出口（出口减进口）。</p><p>=&gt;投资确实可以提升当下的GDP数字，但若投资形成的资产不能提高生产率、带来更高的收入，不能成为未来更高的消费，这种投资就没有形成实质性的财富，就是浪费</p><p>=&gt;。我国国内失衡，生产多消费少，必须向外输出剩余。但反过来看，美国人大手支出，高价向我国购买，我国的相应资源也会从本国消费者向出口生产企业转移，以满足外国需求，这就加剧了国内的消费和生产失衡</p><h4 id="◆-第二节-中美贸易冲突"><a href="#◆-第二节-中美贸易冲突" class="headerlink" title="◆ 第二节 中美贸易冲突"></a>◆ 第二节 中美贸易冲突</h4><p>美元就相当于一种世界货币，只是流通手段不同<br>=&gt;只要全世界还信任美元的价值，美国就可以源源不断地用美元去换取他国实际的产品和资源，这是一种其他国家所没有的、实实在在的“挥霍的特权”（exorbitant privilege）</p><p>=&gt;只要全世界还信任美元的价值，美国就可以源源不断地用美元去换取他国实际的产品和资源，这是一种其他国家所没有的、实实在在的“挥霍的特权”（exorbitant privilege）</p><p>=&gt;虽然确有部分工人因工厂关闭而失业，但美国整体就业情况并未因中美贸易而降低</p><p>=&gt;如今人们对“中国制造”的产品质量的认可度远高于10年前，这个认知有个滞后的过程。对技术和科学，也是同样的道理。</p><p>=&gt;制造业不仅有学习效应，还有很强的集聚效应和规模效应。最近十几年，我国制造业产业链的优势一直在自我强化，不断吸引供应链上的外国企业来中国设厂，而本国的上下游厂商也发展迅猛，产业链协同创新的效应也很强。</p><p>=&gt;但在美国政坛和媒体中，这些年保守心态占了上风，对华技术高压政策可能会持续下去。假如世界上最大的市场和最强的科创中心渐行渐远的话，对双方乃至全世界都会是很大的损失。毕竟我国在基础科研质量、科技成果转化效率等方面，还有很长的路要走，而美国要想在全球再找一个巨大的市场，也是天方夜谭。</p><p>=&gt;技术高压虽然可能让我国企业在短期内受挫，但很多相对落后的国产技术也因此获得了市场机会，可能提高市场份额和收入，进而增大研发力度，进入“市场—研发—迭代—更大市场”的良性循环，最终实现国产替代。但这一切的前提，是我国国内市场确实能继续壮大，国民消费能继续提升，能真正支撑起“国内大循环为主体”的“双循环”模式。</p><h4 id="◆-第三节-再平衡与国内大循环"><a href="#◆-第三节-再平衡与国内大循环" class="headerlink" title="◆ 第三节 再平衡与国内大循环"></a>◆ 第三节 再平衡与国内大循环</h4><p>=&gt;要提高居民收入，就要继续推进城市化，让人口向城市尤其是大城市集聚。虽然制造业是生产率和科技进步的主要载体，但从目前的技术发展和发达国家的经验看，制造业的进一步发展吸纳不了更多就业。产业链全球化之后，标准化程度越来越高，大多数操作工序都由机器完成。比较高端的制造业，资本密集度极高，自动化车间里没有几个工人。</p><p>大量的劳动力最终会流向服务业，有没有这种可能呢？低端人口的归宿，从以前的耕地变为现在的机器以后会更多地变成互联网平台？<br>=&gt;所以解决就业和提高收入必须依靠服务业的大发展，而这只能发生在人口密集的城市中。不仅传统的商铺和餐馆需要人流支撑，新兴的网约车、快递、外卖等都离不开密集的人口。要继续推进城市化，必须为常住人口提供相应的公共服务，让他们在城市中安居乐业。</p><p>=&gt;所以解决就业和提高收入必须依靠服务业的大发展，而这只能发生在人口密集的城市中。不仅传统的商铺和餐馆需要人流支撑，新兴的网约车、快递、外卖等都离不开密集的人口。要继续推进城市化，必须为常住人口提供相应的公共服务，让他们在城市中安居乐业。</p><p>食利阶层手握选票，你看他们同不同意吧（都说一言堂但实际上还是要稳住这些所谓的精英阶层的）<br>=&gt;要提高居民收入和消费，就要把更多资源从政府和企业手中转移出来，分配给居民。</p><p>=&gt;要提高居民收入和消费，就要把更多资源从政府和企业手中转移出来，分配给居民。</p><p>简单总结一下，过去的体制下政府引导投资可以快速形成大规模生产确实对中国经济的腾飞有很大的帮助，但是生产型政府无法适应高精尖制造和生产的市场，如果无法将将投资的主导权从政府手中拿过来，其结果是政府腐败企业失败民生衰败<br>=&gt;过去几十年，从铁路到互联网，我国各类基础设施发展极快，为全国统一大市场的发展打下了坚实基础，也冲击着一些旧有制度的藩篱。未来，只有继续推进各类要素的市场化改革，继续扩大开放，真正转变地方政府角色，从生产型政府转型为服务型政府，才能实现国内市场的巨大潜力，推动我国迈入中高收入国家行列</p><p>=&gt;过去几十年，从铁路到互联网，我国各类基础设施发展极快，为全国统一大市场的发展打下了坚实基础，也冲击着一些旧有制度的藩篱。未来，只有继续推进各类要素的市场化改革，继续扩大开放，真正转变地方政府角色，从生产型政府转型为服务型政府，才能实现国内市场的巨大潜力，推动我国迈入中高收入国家行列</p><h4 id="◆-结语-4"><a href="#◆-结语-4" class="headerlink" title="◆ 结语"></a>◆ 结语</h4><p>=&gt;：一是对先进国的高效模仿和学习；二是结合本土实际，带有本国特色，发展路径与先进国有诸多不同之处。虽然第一个特征也常被先进国斥为“抄袭”，但第二个特征中所蕴含的不同体制以及与之伴生的不同思想和意识，先进国恐怕更难接受</p><p>不要形成路径依赖，一些事情现在能成不代表未来也能成，要用发展的阳光看待事物的规律<br>=&gt;一方面，理解发展目的不等于发展过程，发达国家目前的做法不一定能解决我们发展中面临的问题；另一方面，情况在不断变化，我们过去的一些成功经验和发展模式也不可能一直有效。若不能继续改革，过去的成功经验就可能成为负担甚至陷阱。要始终坚持实事求是，坚持具体问题具体分析，抛开意识形态，不断去解决实践中所面临的问题，走一条适合自己的发展道路</p><p>=&gt;一方面，理解发展目的不等于发展过程，发达国家目前的做法不一定能解决我们发展中面临的问题；另一方面，情况在不断变化，我们过去的一些成功经验和发展模式也不可能一直有效。若不能继续改革，过去的成功经验就可能成为负担甚至陷阱。要始终坚持实事求是，坚持具体问题具体分析，抛开意识形态，不断去解决实践中所面临的问题，走一条适合自己的发展道路</p><h3 id="◆-第八章-总结政府与经济发展"><a href="#◆-第八章-总结政府与经济发展" class="headerlink" title="◆ 第八章 总结政府与经济发展"></a>◆ 第八章 总结政府与经济发展</h3><p>不要空想，不要低估现实的复杂性<br>=&gt;第八章　总结：政府与经济发展<br>=&gt;关于经济学家的笑话特别多，每个经济学学生都知道起码十个八个，编一本笑话集应该没问题。经济学家们也经常自嘲。有一段时间，美国经济学会年会还专门设置了脱口秀环节，供本专业人士吐槽。有个笑话是这么讲的。一个物理学家、一个化学家和一个经济学家漂流到孤岛上，饥肠辘辘。这时海面上漂来一个罐头。物理学家说：“我们可以用岩石对罐头施以动量，使其表层疲劳而断裂。”化学家说：“我们可以生火，然后把罐头加热，使它膨胀以至破裂。”经济学家则说：“假设我们有一个开罐头的起子……”<br>=&gt;任何理论当然都需要假设，否则说不清楚。有些假设不符合现实，但是否会削弱甚至推翻其理论，还要依据理论整体来评判。但一旦走出书斋，从理论思考走到现实应用和政策建议，就必须要符合实际，要考虑方案的可行性。所以在经济学理论研究与现实应用之间，常常存在着鸿沟。做过美联储副主席的普林斯顿大学经济学家艾伦·布林德（Alan Blinder）曾发明过一条“经济政策的墨菲定律”：在经济学家理解最透、共识最大的问题上，他们对政策的影响力最小；在经济学家理解最浅、分歧最大的问题上，他们对政策的影响力最大。<br>=&gt;依托市场经济的理论来研究中国经济，有个很大的好处，就是容易发现问题，觉察到各种各样的“扭曲”和“错配”。但从发现问题到提出解决方案之间，还有很长的路要走。不仅要摸清产生问题的历史和现实根源，还要深入了解各种可行方案的得失。现实世界中往往既没有皆大欢喜的改革，也没有一无是处的扭曲。得失利弊，各个不同。以假想的完善市场经济为思考和判断基准，不过是无数可能的基准之一，换一套“假想”和“标准”，思路可能完全不同。正如在本书开篇引用的哈佛大学经济史家格申克龙的话：“一套严格的概念框架无疑有助于厘清问题，但也经常让人错把问题当成答案。社会科学总渴望发现一套‘放之四海而皆准’的方法和规律，但这种心态需要成熟起来。不要低估经济现实的复杂性，也不要高估科学工具的质量。”<br>=&gt;经济落后的国家之所以落后，正是因为它缺乏发达国家的很多硬件或软件资源，缺乏完善的市场机制。所以在推进工业化和现代化的过程中，落后国家所采用的组织和动员资源的方式，注定与发达国家不同。落后国家能否赶超，关键在于能否找到一套适合国情的组织和动员资源的方式，持续不断地推动经济发展。所谓“使市场在资源配置中起决定性作用”</p><p>=&gt;在经济学家理解最透、共识最大的问题上，他们对政策的影响力最小；在经济学家理解最浅、分歧最大的问题上，他们对政策的影响力最大</p><p>不要空想，不要低估现实的复杂性<br>=&gt;现实世界中往往既没有皆大欢喜的改革，也没有一无是处的扭曲。得失利弊，各个不同。以假想的完善市场经济为思考和判断基准，不过是无数可能的基准之一，换一套“假想”和“标准”，思路可能完全不同</p><p>=&gt;现实世界中往往既没有皆大欢喜的改革，也没有一无是处的扭曲。得失利弊，各个不同。以假想的完善市场经济为思考和判断基准，不过是无数可能的基准之一，换一套“假想”和“标准”，思路可能完全不同</p><p>=&gt;市场经济今天的发展状况也是几十年来经济、政府、社会协同发展和建设的结果。毫无疑问，我国的经济发展和市场化改革是由政府强力推动的。</p><p>=&gt;既不要高估发达国家经验的普适性，也不要高估自己过去的成功经验在未来的适用性。老话说回来，还是要坚持“实事求是”，坚持“具体问题具体分析”，在实践中不断探索和解决问题，一步一个脚印，继续推进改革</p><h4 id="◆-第一节-地区间竞争"><a href="#◆-第一节-地区间竞争" class="headerlink" title="◆ 第一节 地区间竞争"></a>◆ 第一节 地区间竞争</h4><p>这也一直是我持有的观点，最大的垄断性资本集团一直是政府，没有竞争没有淘汰机制只会成为滋养蛆虫和腐败的温床<br>=&gt;经济发展的核心原则，就是优化资源配置，提高使用效率，尽量做到“人尽其才，物尽其用”。实现这一目标要依靠竞争。我国改革的起点是计划经济，政府不仅直接掌控大量资源，还能通过政策间接影响资源分配，这种状况在渐进性的市场化改革中会长期存在。所以要想提高整体经济的效率，就要将竞争机制引入政府。</p><p>=&gt;经济发展的核心原则，就是优化资源配置，提高使用效率，尽量做到“人尽其才，物尽其用”。实现这一目标要依靠竞争。我国改革的起点是计划经济，政府不仅直接掌控大量资源，还能通过政策间接影响资源分配，这种状况在渐进性的市场化改革中会长期存在。所以要想提高整体经济的效率，就要将竞争机制引入政府。</p><p>=&gt;第一种是以中央政府为主，按功能划分许多部委，以部委为基本单位在全国范围内调动资源。竞争主要体现在中央设定目标和规划过程中部委之间的博弈</p><p>=&gt;第二种是以地方政府为主，在设定经济发展目标之后，放权给地方政府，让它们发挥积极性，因地制宜，在实际工作中去竞争资源。</p><p>=&gt;在工业化进程中搞地方竞争，前提是大多数地区的工业基础不能相差太远，否则资源会迅速向占绝对优势的地区集聚，劣势地区很难发展起来。</p><p>=&gt;“工业化”最核心的一环就是把农民变成工人。这不仅仅是工作的转变，也是思想观念和生活习惯的彻底转变。要让农民斩断和土地的联系，成为可靠的、守纪律的、能操作机械的工人，并不容易。不是说人多就能成为促进工业化的人口红利，一支合格的产业工人大军，在很多人口众多的落后国家，实际上非常稀缺。</p><p>=&gt;若单纯从理论模型出发来认识经济效率，那么这些缓冲机制，无论是社会自发建立还是政府有意设计，都会被解读为“扭曲”或“资源错配”，因其未能实现提高效率所要求的“最优资源配置”。但这种“最优”往往不过是空中楼阁</p><p>=&gt;第一，缺乏真正的淘汰机制。地方政府就算不思进取，也不会像企业一样倒闭。政绩不佳的官员虽然晋升机会可能较少，但只要不违法乱纪，并不会因投资失败或经济低迷而承担个人损失。第二，绝大多数市场竞争是“正和博弈”，有合作共赢、共同做大蛋糕的可能。而官员升迁则是“零和博弈”，晋升位置有限，甲上去了，乙就上不去。所以在地区经济竞争中会产生地方保护主义，甚至出现“以邻为壑”的恶性竞争现象。第三，市场和公司间的竞争一般是长期竞争，延续性很强。但地方官员任期有限，必须在任期内干出政绩，且新官往往不理旧账，因此会刺激大干快上的投资冲动，拉动地区GDP数字快速上涨，不惜忽视长期风险和债务负担。</p><p>=&gt;政府需要承担起更加多元的职能，将更多资源投入教育、医疗、社会保障等民生领域，改变与市场和企业的互动方式，由“生产型政府”向“服务型政府”转型。</p><h4 id="◆-第二节-政府的发展与转型"><a href="#◆-第二节-政府的发展与转型" class="headerlink" title="◆ 第二节 政府的发展与转型"></a>◆ 第二节 政府的发展与转型</h4><p>=&gt;社会发展是个整体，不仅包括企业和市场的发展，也包括政府的发展，相辅相成。国家越富裕，政府在国民经济中所占的比重也往往越大，而不是越小，这一现象也被称为“瓦格纳法则”。</p><p>=&gt;政府能否为市场运行打造出一个基本框架和空间的问题。这需要投入很多资源，一步一步建设。如果政府不去做这些事，市场经济和所谓“企业家精神”，不会像变戏法一样自动出现。</p><p>=&gt;无论是政府服务的质量，还是政府收入的数量，都在不断发展和变化。“有为政府”和“有效市场”一样，都不是天然就存在的，需要不断建设和完善。市场经济的形式和表现，要受到政府资源和能力的制约，而政府的作用和角色，也需要不断变化，以适应不同发展阶段的不同要求。</p><p>落后的国家想要在市场杀出一条血路，举国体制的动员和资源调配是必不可少的，但是妄图让产品技术快速成熟的“大跃进”思维不可取，技术的迭代和投入与时间有密切关系，不要无视事物发展的规律急用拿出成绩，不要外行指导内行<br>=&gt;对落后国家而言，经济发展的关键在于能否在市场机制不完善的情况下，找到其他可行的动员和调配资源的方式，推动经济增长，在增长过程中获得更多资源和时间去建设和完善市场经济</p><p>=&gt;对落后国家而言，经济发展的关键在于能否在市场机制不完善的情况下，找到其他可行的动员和调配资源的方式，推动经济增长，在增长过程中获得更多资源和时间去建设和完善市场经济</p><p>=&gt;既有在国际竞争中脱颖而出的杰出企业，也有各种骗补和寻租的低效企业。这种结果上的差异，源于各国和各地政商关系的差异。所谓强力政府，不仅在于它有能力和资源支持企业发展，也在于它有能力拒绝对企业提供帮助</p><p>=&gt;政府和国企于是主导投资，深度介入了工业化和城市化的进程。这一模式的成就有目共睹，也推动了市场机制的建立和完善。</p><p>让资源流向高效率的地方，让劳动力流向需要劳动力的地方，让土地流向缺乏土地指标的地方，明明是很简单的资源分配策略，却是因既得利益者的声音更大而淹没了弱势群体诉求，久而久之中国社会便成了社达社会<br>=&gt;当经济发展到一定阶段后，市场机制已经相对成熟，法治的基础设施也已经建立，民间的各种市场主体已经积累了大量资源，市场经济的观念也已经深入人心，此时若仍将资源继续向政府和国企集中，效率就会大打折扣</p><p>=&gt;当经济发展到一定阶段后，市场机制已经相对成熟，法治的基础设施也已经建立，民间的各种市场主体已经积累了大量资源，市场经济的观念也已经深入人心，此时若仍将资源继续向政府和国企集中，效率就会大打折扣</p><p>=&gt;在教育、医疗、社会保障、养老方面的政府平均支出占到GDP的24%，而我国只有13%。(16)一方面，随着国家变富裕，民众对这类服务的需求会增加；另一方面，市场经济内在的不稳定和波动会产生失业和贫富差距等问题，需要政府和社会的力量去做缓冲。就拿贫富差距扩大来说，政府的再分配政策不仅包括对富人多征税，还包括为穷人多花钱，把支出真正花在民生上</p><p>=&gt;生产投资型政府”就要向“服务型政府”转型，原因有二。其一，与重规模、标准化的工业生产相比，服务业规模通常较小，且更加灵活多变，要满足各种非标准化、本地化的需求。在这种行业中，政府“集中力量办大事”的投资和决策机制，没有多大优势。其二，“投资型”和“服务型”的区别并非泾渭分明。“服务型”政府实质上就是投资于“人”的政府。服务业（包括科技创新）的核心是人力资本，政府加大教育、医疗等民生支出，也就是在加大“人力资本”投资。但因为服务业更加灵活和市场化，政府在这个领域的投入是间接的、辅助性的，要投资和培育更一般化的人力资本，而非直接主导具体的项目</p><p>=&gt;因此要想扩大民生支出，可能需要改革税制，将税入向地方倾斜</p><h4 id="◆-第三节-发展目标与发展过程"><a href="#◆-第三节-发展目标与发展过程" class="headerlink" title="◆ 第三节 发展目标与发展过程"></a>◆ 第三节 发展目标与发展过程</h4><p>=&gt;对于发展中国家而言，核心议题并不是良好的市场机制如何运行，而是如何逐步建立和完善市场经济体制。因此，发展中国家所采用的资源动员和配置方式，肯定与发达国家不同。诸多发展中国家所采用的具体方式和路径，当然也各不相同</p><p>=&gt;但对发展中国家来说，提高生产率的关键不是探索未知和创新，而是学习已知的技术和管理模式，将更多资源尽快组织和投入到学习过程中，以提高学习效率。</p><p>=&gt;后进国家虽然有模仿和学习先进国家技术的“后发优势”，但其“组织学习模式”不可能一直持续下去。当技术和生产率提高到一定水平之后，旧有的模式若不能成功转型为“探索创新模式”，就可能会阻碍经济进一步发展，“后发优势”可能变成“后发劣势”</p><p>=&gt;目前的经济学术潮流是追求“放之四海而皆准”的理论，国别和案例研究式微，被称为“轶事证据”（anecdotal evidence），听起来就很不“科学”，低人一等</p><p>=&gt;可行的政策不仅受既有制度的约束，也受既有利益的约束。政策方案的设计，必须考虑到利益相关人和权力持有者的利益。既要提高经济效率，也要保证做决策的人或权力主体的利益不受巨大损害，否则政策就难以推行</p><p>少数人的利益绑架大多数人的利益，沉默的大多数声音被拿着金喇叭的少数人的声音埋没<br>=&gt;“精英俘获”（elite capture），一个例子就是地方政治精英被地方利益集团俘获，损害民众利益。在我国历史上，这一“山高皇帝远”的问题就长期存在，应对之道不仅有各类制度建设，也从来没离开过对官僚群体统一的意识形态和道德教化</p><p>=&gt;“精英俘获”（elite capture），一个例子就是地方政治精英被地方利益集团俘获，损害民众利益。在我国历史上，这一“山高皇帝远”的问题就长期存在，应对之道不仅有各类制度建设，也从来没离开过对官僚群体统一的意识形态和道德教化</p><p>=&gt;从理论上讲，即便有人受损，也该支持自由贸易，因为整体得益远大于部分损失，只要从受益方那里拿一点利益出来，就足够补偿受损方且有余。</p><p>弱势群体的利益受损是真切存在的，不是平均值可以掩盖的<br>=&gt;补偿可能迟迟落实不到位，最终是受益者得益越来越多，而受损者却屡遭打击。虽说平均值是变好了，但那些受损的人的生活不是理论上的平均数字，他们会为了自己的利益而反抗和行动，这是保护主义的根源。</p><p>=&gt;补偿可能迟迟落实不到位，最终是受益者得益越来越多，而受损者却屡遭打击。虽说平均值是变好了，但那些受损的人的生活不是理论上的平均数字，他们会为了自己的利益而反抗和行动，这是保护主义的根源。</p><p>=&gt;什么事先办，什么事后办，不容易决定。每一步都有人受益、有人受损，拼命争取和拼命抵制的都大有人在。就算能看清对岸的风景，也不见得就能摸着石头成功过河，绊脚石或深坑比比皆是</p><p>=&gt;经济发展必然要改变旧有的生活方式，重新分配利益，所以必然伴随着矛盾和冲突。政府的关键作用之一，就是调控改变速度的快慢。</p><p>=&gt;在成功的经济体中，经济政策一定是务实的，不是意识形态化的。是具体的，不是抽象的</p><h4 id="◆-结语-5"><a href="#◆-结语-5" class="headerlink" title="◆ 结语"></a>◆ 结语</h4><p>=&gt;发现和提出好的问题，是解决问题的第一步，且“提问”本身，往往已蕴含了对解决思路的探索。切中要害的问题，必然基于对现实情况的深刻理解。</p><h3 id="◆-结束语"><a href="#◆-结束语" class="headerlink" title="◆ 结束语"></a>◆ 结束语</h3><p>=&gt;我的乐观并不需要这些头头是道的逻辑支撑，它就是一种朴素的信念：相信中国会更好。这种信念不是源于学术训练，而是源于司马迁、杜甫、苏轼，源于“一条大河波浪宽”，源于对中国人勤奋实干的钦佩。它影响了我看待问题的角度和处理信息的方式，我接受这种局限性，没有改变的打算。</p><p>=&gt;生活过得好一点，比大多数宏伟更宏伟</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eb414291bccfc96be1c4f0c87e2f31a2_720w.jpg?source=172ae18b&quot; alt=&quot;置身事内读书笔记&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="经济" scheme="https://autovy.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
      <category term="社会" scheme="https://autovy.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="政治" scheme="https://autovy.github.io/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="消费型社会" scheme="https://autovy.github.io/tags/%E6%B6%88%E8%B4%B9%E5%9E%8B%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="分税制" scheme="https://autovy.github.io/tags/%E5%88%86%E7%A8%8E%E5%88%B6/"/>
    
      <category term="服务型政府" scheme="https://autovy.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%9E%8B%E6%94%BF%E5%BA%9C/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|经济为什么会崩溃：鱼、美元与经济学的故事</title>
    <link href="https://autovy.github.io/2022/08/13/BookNote/%E3%80%8A%E7%BB%8F%E6%B5%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9A%E9%B1%BC%E3%80%81%E7%BE%8E%E5%85%83%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%95%85%E4%BA%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://autovy.github.io/2022/08/13/BookNote/%E3%80%8A%E7%BB%8F%E6%B5%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9A%E9%B1%BC%E3%80%81%E7%BE%8E%E5%85%83%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%95%85%E4%BA%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-13T06:30:00.000Z</published>
    <updated>2023-03-26T14:52:10.607Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280948141.jpeg" alt="img"></p><span id="more"></span><p>经济为什么会崩溃：鱼、美元与经济学的故事<br>安德鲁·J.希夫<br>85个笔记</p><p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202211280944724.png" alt="image-20221128094426971"></p><h3 id="◆序-言"><a href="#◆序-言" class="headerlink" title="◆序  言"></a>◆序  言</h3><p>=&gt; 经济学家们拿出的补救方案令大多数人瞠目——为了解决债务危机，我们必须负债更多；为了经济繁荣，我们必须花钱</p><p>=&gt; 消费。过去，他们缺乏远见，而今他们的解决方案又如此违背常识，究其原因，是因为几乎没有任何经济学家明白他们的学科如何发挥作用。</p><p>狂<br>=&gt; 从根本上说，凯恩斯只不过是玩了一个聪明的把戏而已，他把一件简单的事情搞得极其复杂。</p><p>=&gt; 凯恩斯的核心观点是在经济不景气时，政府可以通过扩大货币供给和财政赤字来缓和自由市场的波动。</p><p>=&gt; 凯恩斯主义者力图减轻经济萧条，而奥地利经济学派则寻求避免虚假繁荣的途径。</p><p>=&gt; 低息贷款和宽松货币</p><p>=&gt; 我们打算证明凯恩斯主张的经济模式——政府相信没有价值的货币可以作为有效的经济润滑剂并不加证实地采纳了这个模式——是错误的，而且是危险的。</p><h3 id="◆第一章-一个好点子出炉了"><a href="#◆第一章-一个好点子出炉了" class="headerlink" title="◆第一章 一个好点子出炉了"></a>◆第一章 一个好点子出炉了</h3><p>=&gt;    牢记这一点，就很容易理解经济增长的原因：找到了生产人类所需物品的更好方式。不管一种经济最后变得多么强大，这个原因是不会改变的。</p><h3 id="◆第二章-把财富分享给别人"><a href="#◆第二章-把财富分享给别人" class="headerlink" title="◆第二章　把财富分享给别人"></a>◆第二章　把财富分享给别人</h3><p>=&gt; 大多数经济学家认为，给老百姓更多的钱花就可以增加需求，但是这种做法并不能改变真正的需求：只会使人们花更多的钱去购买已经生产出来的产品。只有增加供给才能切实满足人们更多的需求。</p><p>=&gt; 人们认为富人之所以富有，是因为他们攫取別人的财富，并由此产生了穷人。在现代经济学中有一个理论认为，利润是通过少付工人工资产生的，有人称之为“劳动价值论</p><h3 id="◆第三章-信用卡的多种用途"><a href="#◆第三章-信用卡的多种用途" class="headerlink" title="◆第三章　信用卡的多种用途"></a>◆第三章　信用卡的多种用途</h3><p>=&gt; 一旦外部力量——比如政府干预——以各种理由鼓励或者要求储蓄者借出款项，而不考虑实际还款的可能性，这时贷款人就难免要承受较大的损失。这种有悖常规的做法只会浪费社会的储蓄。</p><p>=&gt; 为消费贷款如果不能提高产能的话，这笔贷款无论是对贷款人还是借款人来说，都是一种负担。</p><p>=&gt; 这些政策关键的推动因素就是认为政府规划者要比储蓄者更清楚什么有利于社会发展的观念。但是，并没有证据表明事实就是这样。实际上，历史上充斥着各种浮夸的政策与方案，这些方案都</p><p>=&gt; 是政府智囊团策划的，最终全都没有兑现它们的诺言。</p><p>=&gt; 贷给个人或者企业的款项如果无法成功促成必要的创新或者提高产能，就会浪费储蓄的供给，削弱整体经济。</p><h3 id="◆第四章-经济到底是如何发展的"><a href="#◆第四章-经济到底是如何发展的" class="headerlink" title="◆第四章　经济到底是如何发展的"></a>◆第四章　经济到底是如何发展的</h3><p>=&gt; 储蓄不只是提高个人消费能力的手段，更是防止经济受到意外因素影响的重要缓冲器。</p><p>=&gt; 我们的消费不能超过产能，我们的借款不能超出存款</p><p>=&gt; 储蓄创造了资本，而资本使生产扩大成为可能。所以，储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元</p><h3 id="◆第五章-在鱼被指宣为货币之后"><a href="#◆第五章-在鱼被指宣为货币之后" class="headerlink" title="◆第五章　在鱼被指宣为货币之后"></a>◆第五章　在鱼被指宣为货币之后</h3><p>=&gt; 由于生产率提高了(储蓄、创新和投资的结果)，独木舟的价格便随之下降，更多顾客能够享受到拥有独木舟的好处。昔日富人独享的奢侈品也成了普通消费品。</p><p>=&gt; 技术创新是个单向的过程。除非人们失去记忆，否则生产效率必然会越来越高。因此，价格具有随着时间推移而降低的趋势。</p><p>=&gt; 现代经济学错误地认为：消费促进经济增长，因而一旦发生通货紧缩，人们就不愿意消费(这样价格就会继续下降)，而如果人们继续消费，价格下降的影响就会减弱。真是荒谬。</p><h3 id="◆第六章-为什么会有储蓄"><a href="#◆第六章-为什么会有储蓄" class="headerlink" title="◆第六章　为什么会有储蓄"></a>◆第六章　为什么会有储蓄</h3><p>=&gt;   高利率会抑制借贷，延缓经济增长。但同时，高利率也能刺激储蓄。最终，银行资产会再次积累起来，到那时利率又会下降。</p><p>=&gt; 这种周期性的利率机制有利于市场稳定。该机制的运作完全取决于以下三点：银行实现资产回报最大化的愿望、银行对高风险投资损失的担忧、个人消费的时间偏好。</p><p>=&gt; 积累储蓄的是民众，而且银行能否获利要取决于自身的管理水平。如果没有这种关联，借贷必然是低效的。</p><p>=&gt; 美联储的决定总是基于政治考量而非经济因素</p><p>=&gt; 乐于看到髙利率的社会成员——尤其是储蓄者——没有形成有组织的利益集团，没人听取他们的声音。因此，社会上就形成了这种偏见，即利率应该很低，而不是很高。</p><p>=&gt; 相对于储蓄供给来说，过低的利率会向借款人传达错误的信号，即经济状况良好、投资可行。因为消费并没有真正延后(如果利率顺应市场下滑，消费就应该延后)，用于满足未来需求的投资就很难成功</p><h3 id="◆第七章-基础设施与贸易"><a href="#◆第七章-基础设施与贸易" class="headerlink" title="◆第七章　基础设施与贸易"></a>◆第七章　基础设施与贸易</h3><p>=&gt;    国际贸易与个人劳动分工没有什么区别。每个个人或者国家都用自己多余的或者擅长生产的物品，换取自己所缺乏的或者不擅长生产的东西。</p><p>=&gt; 正如数学原理不会因问题的大小而改变，基本经济原理也不会因经济的大小而改变。</p><p>医疗，电力，石油，交通，铁路行业是合法的垄断<br>=&gt; 其实我们更能确定的是，政府对于公共设施和服务的垄断几乎必然会造成效率低下和贪污腐败。</p><p>=&gt; 其实我们更能确定的是，政府对于公共设施和服务的垄断几乎必然会造成效率低下和贪污腐败。</p><p>=&gt; 提供就业并非经济的目的。经济的目的是不断提髙生产力。</p><p>=&gt; 保留无效率的劳动力和资本使用方式对整个社会是没有好处的</p><h3 id="◆第八章-一个共和国就这样诞生了"><a href="#◆第八章-一个共和国就这样诞生了" class="headerlink" title="◆第八章　一个共和国就这样诞生了"></a>◆第八章　一个共和国就这样诞生了</h3><p>我票呢？我钱呢？😨<br>=&gt; 岛民们知道政府的支出就是纳税人缴纳的税款，因此他们认为应该由纳税人决定税款怎么花。因此，只有纳税人可以投票。</p><p>=&gt; 岛民们知道政府的支出就是纳税人缴纳的税款，因此他们认为应该由纳税人决定税款怎么花。因此，只有纳税人可以投票。</p><p>=&gt;   美国宪法有意将权力分配到联邦政府的不同部门之中，并把中央的权力下放到各州。更重要的是，宪法可以防止联邦政府从人民手中剥夺任何权利。</p><p>=&gt; 我们渴望消除经济紧缩的痛苦，但是我们忘记了自由本身就是有风险的。如果政府有责任消除一切苦痛，那么就没有人是自由的。无法自由地失败，也就是无法自由地成功。</p><h3 id="◆第九章-政府的职能开始转变了"><a href="#◆第九章-政府的职能开始转变了" class="headerlink" title="◆第九章　政府的职能开始转变了"></a>◆第九章　政府的职能开始转变了</h3><p>=&gt; 为什么要让储户知道他们的储蓄在缩水而不是增值呢？”</p><p>=&gt; 美联储现在存在的唯一目的就是产生足够的通货膨胀，从而使政府的支出大于税收收入。</p><p>=&gt; 美国人手里只剩下一种没有实际价值而且可以随意增发的货币。这使得美国政府再也不必在支出和税收之间作出艰难抉择，也把美国经济引上了一条不归路，总有一天美元剩余的那点可怜的价值也会失去。</p><h3 id="◆第十章-不断缩水的鱼就像货币一样"><a href="#◆第十章-不断缩水的鱼就像货币一样" class="headerlink" title="◆第十章 不断缩水的鱼就像货币一样"></a>◆第十章 不断缩水的鱼就像货币一样</h3><p>=&gt; 但是，物价上涨只是通货膨胀的结果！通货膨胀实际上是货币供应量的增加！</p><p>=&gt; 经济不景气时，物价需要下跌才能平衡经济局势。经济不景气时需要通货紧缩。物价下跌能够缓和低就业率的影响。</p><p>=&gt; 当代经济学家却认为，物价下跌会导致经济陷入需求崩溃的万丈深渊。他们忘记了一旦物价下跌到一定程度，人们就会开始消费。这个过程淘汰了不必要的产能，把物价调低到符合内在供求关系的水平。</p><h3 id="◆第十一章-中岛帝国：远方的生命线"><a href="#◆第十一章-中岛帝国：远方的生命线" class="headerlink" title="◆第十一章 中岛帝国：远方的生命线"></a>◆第十一章 中岛帝国：远方的生命线</h3><p>=&gt; 美国人占了便宜：他们不用生产就可以得到商品，不必储蓄就可以得到贷款。而对于中国人来说，他们辛勤工作却不能消费自己生产的产品，他们努力储蓄却得不到贷款。有什么好处呢？</p><p>=&gt; 美国的低利率很大程度上是由国外的高储蓄率造成的，大多数当代经济学权威都没有意识到这一点</p><p>=&gt; 当然，既然这种关系不可能永远持续下去，结束得越早痛苦就越小，对美国人来说尤其如此。白食吃得越久，有朝一日没得吃时，就越是不容易自食其力。</p><h3 id="◆第十二章-服务业是如何崛起的"><a href="#◆第十二章-服务业是如何崛起的" class="headerlink" title="◆第十二章 服务业是如何崛起的"></a>◆第十二章 服务业是如何崛起的</h3><p>=&gt; 24小时工作制，三班轮岗</p><p>=&gt; 一座岛主要负责生产，另一座岛主要负责消费。</p><p>暴击，破大防了<br>=&gt; 当然，中岛帝国人相信他们最后总会得到回报，到时候他们就可以不用捕鱼，靠储蓄就能安然度日了。然而，中岛帝国人却没有意识到，美索尼亚连养活自己百姓的能力都没有，怎么可能为他们兑换钞票呢？</p><p>=&gt; 当然，中岛帝国人相信他们最后总会得到回报，到时候他们就可以不用捕鱼，靠储蓄就能安然度日了。然而，中岛帝国人却没有意识到，美索尼亚连养活自己百姓的能力都没有，怎么可能为他们兑换钞票呢？</p><p>最喜欢的一章<br>=&gt; 正常来讲，贸易逆差能够自我调节。<br>=&gt; 如果一个国家处于贸易顺差状态，也就是说其出口量大于进口量，就会在国际上形成对其货币的需求。如果你想要该国的产品，你就需要该国的货币。所以，强势的贸易地位会使一国货币坚挺。反过来，弱势的贸易地位会导致该国货币疲软。如果没有人想购买你的产品，也就没有人需要你的货币。<br>=&gt; 但是，一旦一国的货币升值，该国的产品也会相应涨价。这就给处于弱势贸易地位的国家提供了进入该国市场的机会。他们的商品销售得越多，国际市场对其货币的需求就越大。这股货币平衡力量会使脱缰野马般的贸易失衡得到控制。<br>=&gt; 然而，美元的储备货币地位以及中国政府保持人民币与美元挂钩的决定破坏了这一机制，局势越发不可收拾。</p><p>=&gt; 如果一个国家处于贸易顺差状态，也就是说其出口量大于进口量，就会在国际上形成对其货币的需求。如果你想要该国的产品，你就需要该国的货币。所以，强势的贸易地位会使一国货币坚挺。反过来，弱势的贸易地位会导致该国货币疲软。如果没有人想购买你的产品，也就没有人需要你的货币。</p><p>=&gt; 但是，一旦一国的货币升值，该国的产品也会相应涨价。这就给处于弱势贸易地位的国家提供了进入该国市场的机会。他们的商品销售得越多，国际市场对其货币的需求就越大。这股货币平衡力量会使脱缰野马般的贸易失衡得到控制。</p><p>=&gt; 美元的储备货币地位以及中国政府保持人民币与美元挂钩的决定破坏了这一机制，局势越发不可收拾。</p><h3 id="◆第十三章-“鱼本位”的破灭"><a href="#◆第十三章-“鱼本位”的破灭" class="headerlink" title="◆第十三章 “鱼本位”的破灭"></a>◆第十三章 “鱼本位”的破灭</h3><p>=&gt; 但是现在我们处于一个“镜中世界”，在过去的40年中，没有任何国家发行过真实货币。这是有史以来最大的货币实验。没人知道这个实验何时会结束，结果又如何。但是可以肯定的是，这场实验总会有结束的一天。</p><h3 id="◆第十四章-房价是如何涨上去的"><a href="#◆第十四章-房价是如何涨上去的" class="headerlink" title="◆第十四章 房价是如何涨上去的"></a>◆第十四章 房价是如何涨上去的</h3><p>=&gt; 与那些借给前途未卜的企业家的商业贷款不同，棚屋房贷有天然的抵押物，也就是所购买的棚屋。如果借款人不能还款，银行还可以没收棚屋，把它卖掉，以偿还贷款。</p><p>=&gt; ：房价开始飙升。其中的原因一方面是由于存在以小换大贷款、低首付(或零首付)和房产利润免税的政策。另一方面则是银行在“两棚”的担保下大量放贷的结果。</p><p>民主政府和独裁政府殊途同归🤭<br>=&gt; 政治家想要用虚假的繁荣来维持选民髙涨的自信心，企业想让消费者花钱购买他们负担不起的产品和服务，有线新闻网想通过描绘太平盛世赢得高收视率，银行、按揭贷款发放机构以及房地产经纪人想继续赚取费用和利息。这些利益集团雇用了大批的人来粉饰这个最大最丑陋的骗局。而且，令人吃惊的是，人们真的接受了他们的解释。</p><p>=&gt; 政治家想要用虚假的繁荣来维持选民髙涨的自信心，企业想让消费者花钱购买他们负担不起的产品和服务，有线新闻网想通过描绘太平盛世赢得高收视率，银行、按揭贷款发放机构以及房地产经纪人想继续赚取费用和利息。这些利益集团雇用了大批的人来粉饰这个最大最丑陋的骗局。而且，令人吃惊的是，人们真的接受了他们的解释。</p><h3 id="◆第十五章-快了！快了！房市要崩溃了"><a href="#◆第十五章-快了！快了！房市要崩溃了" class="headerlink" title="◆第十五章 快了！快了！房市要崩溃了"></a>◆第十五章 快了！快了！房市要崩溃了</h3><p>=&gt;  想当年，只要拥有住房就可以轻而易举地赚钱，现如今卖房子却变成了赔本的买卖。由于房价不再上涨，棚屋净值不再增加，短期炒房也就无利可图。没有了利益的诱惑，过高的贷款额度成了无法承受的负担。</p><p>在中国无法这样做还有地方财政严重依赖土地财政的原因<br>=&gt; 但是如果任由房价下跌，同时停止建造新的棚屋，反而对岛上的经济有好处，至少在真正的需求出现之前是这样。这样一来，人们就不会花那么多钱买房，而是把钱花在那些经济中缺乏的东西上</p><p>=&gt; 但是如果任由房价下跌，同时停止建造新的棚屋，反而对岛上的经济有好处，至少在真正的需求出现之前是这样。这样一来，人们就不会花那么多钱买房，而是把钱花在那些经济中缺乏的东西上</p><p>=&gt; 他们手里已经有很多钞票了。如果他们不接受，那些钞票贬值只会更加严重。他们现在只能任由</p><p>=&gt; 我们摆布。要是情况有变，我们就提醒他们，我们还有‘强鱼政策’。”        </p><p>=&gt; “强鱼政策只是说说而已。我们实际上什么也不用做。我们只需要反复清楚而大声地强调‘强鱼政策’。另外，在你说这几个字时，搂紧拳头敲桌子效果会更好。”</p><p>=&gt;  但是，当经济开始收紧时，立法者和经济学家不仅不认为这一过程是多年来银根松动以及过度消费的结果，反而把它当成了问题本身。换句话说，他们错把解药当成了毒药。</p><p>=&gt; 最终美国政府只有两个选择：拒绝还款(告诉债主美国没钱，并商议一个解决办法)，或者通货膨胀(印钱来还债)。任何一个选择的后果都很严重。拒绝还款还有可能彻底清算从头来过，是相对较好的选择。不幸的是，虽然通货膨胀在经济上影响相对较差，但是在政治上有好处。</p><h3 id="◆第十六章-情形怎么变得如此糟糕"><a href="#◆第十六章-情形怎么变得如此糟糕" class="headerlink" title="◆第十六章 情形怎么变得如此糟糕"></a>◆第十六章 情形怎么变得如此糟糕</h3><p>=&gt; 如果企业因为误读市场而蒙受损失，投资者就会及时抽身。如果企业顺应市场要求并获得利润，就会吸引更多的资金，从而扩大产能。</p><p>=&gt;  1.  减少消费，用储蓄还债。        2.  增大产量，卖掉多余的货物还债。</p><p>=&gt; 3.  追加贷款，继续保持现有的消费水平。</p><p>=&gt; 在前两个选择中，美索尼亚人都要吃苦。要么努力工作，要么减少消费，再不然就是双管齐下。而第三种选择可以把一切痛苦转嫁给外国人。</p><p>=&gt; 一国的经济不会因为人们的消费而增长，而是经济增长带动人们的消费</p><p>=&gt; 目前，这些国家的处境与中岛帝国相似。一旦它们认识到不断向一个付不起账的顾客借钱是件浪费资源的事，就会改弦更张。那时它们就会把生产力集中到国内消费者身上，它们就能完全享受自己的劳动果实了。</p><p>=&gt; 等到那一天到来，美国有两种选择：拒绝还款或通货膨胀。不论选哪一个，由于购买力下降和利率升高，美国人的生活水平都会急剧下降。</p><h3 id="◆第十七章-无鱼不起浪"><a href="#◆第十七章-无鱼不起浪" class="headerlink" title="◆第十七章 无鱼不起浪"></a>◆第十七章 无鱼不起浪</h3><p>=&gt; 中岛帝国储备的鱼邦储备券变成了一堆废纸。很多企业倒闭，经济陷入混乱。不过，正如那位农民所预见的那样，其他的企业很快就发展起来，利用闲置的产能制造中岛帝国人真正需要的东西。</p><p>=&gt; 面对急于知道答案的人们，奥库达说出了一个政治家所能想到的最真诚的话：“还有谁知道怎么制作渔网吗？我想我们应该自己捕鱼了。</p><p>=&gt; 选项一，政府通过提髙税收，增加收入。这一条路从来不受人民的欢迎，在一个民主国家中很难通过。即便在集权主义国家(那里没有烦人的选举)，增加税收也会带来很多问题。高税率总是会抑制生产，降低经济活力。税率是有上限的。税率过高，人们就会停止工作。如果继续提髙，就有可能发生暴乱。        削减政府支出这个选项要好得多。        然而，这样做往往比提高税收更困难。        利益受损的人可能会投反对票，或者到街上闹事，那些认为自己理应获得利益的人尤为明显。政客们为了赢得选举许下无数承诺，而选民们也从来不去考虑纳税人能否为这些承诺埋单。</p><p>=&gt; 为了避免这一窘境，很多政客索性选择印刷钞票，引起通货膨胀，使债务贬值，等于换一种方式偿还债务。通货膨胀一向是最容易作出的选择，通常也是最后的选择。然而，选择这一方案虽然开始时好像很容易，最终却要付出最惨痛的代价。</p><p>=&gt; 如果遇到超级通货膨胀，存款就会变得一文不值，负债却一笔勾销</p><p>=&gt; 美元的储备货币地位一直是美国手中的王牌。也就是说，基本面再差，世界各国还是会接受美元。然而，一旦失去储备货币地位，美元的下场就会和其他已经崩溃的货币一样。</p><h3 id="◆后-记"><a href="#◆后-记" class="headerlink" title="◆后  记"></a>◆后  记</h3><p>=&gt; 人为造成的低利率(使经济显得很健康)激活了可调利率的按揭贷款市场，还催生了诱惑利率。诱惑利率使原本高不可攀的房子显得唾手可得</p><p>=&gt; 本应倒闭的公司又在政府的支持下站了起来，本应解放出来</p><p>=&gt; 的资金和劳动力被困在了无效的经济活动之中，无法发挥更高的经济效益。</p><p>=&gt; 如果他们选择寄希望于借贷、印钞机以及政府承诺的毫无痛苦的解决办法，那他们都要回到徒手捕鱼的状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.fosu.gq/Autovy/ImageExpand/master/img202211280948141.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="经济" scheme="https://autovy.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
      <category term="货币" scheme="https://autovy.github.io/tags/%E8%B4%A7%E5%B8%81/"/>
    
      <category term="凯恩斯主义" scheme="https://autovy.github.io/tags/%E5%87%AF%E6%81%A9%E6%96%AF%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>Java|渐进式本地缓存开发总结</title>
    <link href="https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-20T15:45:00.000Z</published>
    <updated>2022-10-27T07:56:48.928Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205211137136.png" alt="img"></p><span id="more"></span><h3 id="一-固定大小缓存实现"><a href="#一-固定大小缓存实现" class="headerlink" title="一.固定大小缓存实现"></a>一.固定大小缓存实现</h3><h4 id="缓存接口定义"><a href="#缓存接口定义" class="headerlink" title="缓存接口定义"></a>缓存接口定义</h4><p>为了兼容 Map，我们定义缓存接口继承自 Map 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><p>我们主要看一下 put 时的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 尝试驱除</span></span><br><span class="line">    CacheEvictContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheEvictContext&lt;&gt;();</span><br><span class="line">    context.key(key).size(sizeLimit).cache(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// context包含新的键和旧的缓存，放入驱除类中按规则淘汰</span></span><br><span class="line">    cacheEvict.evict(context);</span><br><span class="line">    <span class="comment">//2. 判断驱除后的信息</span></span><br><span class="line">    <span class="keyword">if</span>(isSizeLimit()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 执行添加</span></span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以让用户动态指定大小，但是指定大小肯就要有对应的淘汰策略。</p><p>否则，固定大小的 map 肯定无法放入元素。</p><h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>淘汰策略可以有多种，比如 LRU/LFU/FIFO 等等，我们此处实现一个最基本的 FIFO。</p><p>所有实现以接口的方式实现，便于后期灵活替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictFIFO</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * queue 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;K&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，执行移除</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            K evictKey = queue.remove();</span><br><span class="line">            <span class="comment">// 移除最开始的元素</span></span><br><span class="line">            cache.remove(evictKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新加的元素放入队尾</span></span><br><span class="line">        <span class="keyword">final</span> K key = context.key();</span><br><span class="line">        queue.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FIFO 比较简单，我们使用一个队列，存储每一次放入的元素，当队列超过最大限制时，删除最早的元素。</p><h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>为了便于用户使用，我们实现类似于 guava 的引导类。</p><p>所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存引导类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBs</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CacheBs</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建对象实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">CacheBs&lt;K,V&gt; <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheBs&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K,V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驱除策略默认设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">map</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">        ArgUtil.notNull(map, <span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 size 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">size</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArgUtil.notNegative(size, <span class="string">&quot;size&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置驱除策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict 驱除策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 0.0.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">evict</span><span class="params">(ICacheEvict&lt;K, V&gt; evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.evict = evict;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICache&lt;K,V&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheContext&lt;&gt;();</span><br><span class="line">        context.cacheEvict(evict);</span><br><span class="line">        context.map(map);</span><br><span class="line">        context.size(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cache&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">2</span>)</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p>默认为先进先出的策略，此时输出 keys，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="二-LRU缓存淘汰策略"><a href="#二-LRU缓存淘汰策略" class="headerlink" title="二.LRU缓存淘汰策略"></a>二.LRU缓存淘汰策略</h3><p>上面默认使用FIFO淘汰策略即先进先淘汰，下我们来开发LRU缓存淘汰策略即淘汰最近最少使用</p><h4 id="LRU基本原理"><a href="#LRU基本原理" class="headerlink" title="LRU基本原理"></a>LRU基本原理</h4><h5 id="1-LRU-是什么"><a href="#1-LRU-是什么" class="headerlink" title="1.LRU 是什么"></a>1.LRU 是什么</h5><p>LRU 是由 Least Recently Used 的首字母组成，表示最近最少使用的含义，一般使用在对象淘汰算法上。</p><p>也是比较常见的一种淘汰算法。</p><p>其核心思想是<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>。</p><h5 id="2-连续性"><a href="#2-连续性" class="headerlink" title="2.连续性"></a>2.连续性</h5><p>在计算机科学中，有一个指导准则：连续性准则。</p><p>时间连续性：对于信息的访问，最近被访问过，被再次访问的可能性会很高。缓存就是基于这个理念进行数据淘汰的。</p><p>空间连续性：对于磁盘信息的访问，将很有可能访问连续的空间信息。所以会有 page 预取来提升性能。</p><h5 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h5><ol><li>新数据插入到链表头部；</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ol><p>其实比较简单，比起 FIFO 的队列，我们引入一个链表实现即可。</p><h5 id="5-LRU实现步骤疑点"><a href="#5-LRU实现步骤疑点" class="headerlink" title="5.LRU实现步骤疑点"></a>5.LRU实现步骤疑点</h5><p>我们针对上面的 3 句话，逐句考虑一下，看看有没有值得优化点或者一些坑。</p><p><strong>如何判断是新数据？</strong></p><p><strong>新数据插入到链表头部；</strong></p><p>我们使用的是链表。</p><p>判断新数据最简单的方法就是遍历是否存在，对于链表，这是一个 O(n) 的时间复杂度。</p><p>其实性能还是比较差的。</p><p>当然也可以考虑空间换时间，比如引入一个 set 之类的，不过这样对空间的压力会加倍。</p><p><strong>什么是缓存命中</strong></p><p><strong>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</strong></p><p>put(key,value) 的情况，就是新元素。如果已有这个元素，可以先删除，再加入，参考上面的处理。</p><p>get(key) 的情况，对于元素访问，删除已有的元素，将新元素放在头部。</p><p>remove(key) 移除一个元素，直接删除已有元素。</p><p>keySet() valueSet() entrySet() 这些属于无差别访问，我们不对队列做调整。</p><p><strong>移除</strong></p><p><strong>当链表满的时候，将链表尾部的数据丢弃。</strong></p><p>链表满只有一种场景，那就是添加元素的时候，也就是执行 put(key, value) 的时候。</p><p>直接删除对应的 key 即可。</p><h4 id="Java-代码实现"><a href="#Java-代码实现" class="headerlink" title="Java 代码实现"></a>Java 代码实现</h4><h5 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1.接口定义"></a>1.接口定义</h5><p>和 FIFO 的接口保持一致，调用地方也不变</p><p>为了后续 LRU/LFU 实现，新增 remove/update 两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驱除策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否执行驱除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> ICacheEvictContext&lt;K, V&gt; context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-LRU-实现"><a href="#2-LRU-实现" class="headerlink" title="2.LRU 实现"></a>2.LRU 实现</h5><p>直接基于 LinkedList 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 丢弃策略-LRU 最近最少使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLRU</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLRU.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;K&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            K evictKey = list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 移除对应的元素</span></span><br><span class="line">            cache.remove(evictKey);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(key);</span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="number">0</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现比较简单，相对 FIFO 多了三个方法：</p><p>update()：我们做一点简化，认为只要是访问，就是删除，然后插入到队首。</p><p>remove()：删除就是直接删除。</p><p>这三个方法是用来更新最近使用情况的。</p><p>那什么时候调用呢？</p><h5 id="3-注解属性"><a href="#3-注解属性" class="headerlink" title="3.注解属性"></a>3.注解属性</h5><p>为了保证核心流程，我们基于注解实现。</p><p>添加属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否执行驱除更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 主要用于 LRU/LFU 等驱除策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">evict</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br></pre></td></tr></table></figure><h5 id="4-注解使用"><a href="#4-注解使用" class="headerlink" title="4.注解使用"></a>4.注解使用</h5><p>有哪些方法需要使用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(refresh = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(evict = true)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 刷新所有过期信息</span></span><br><span class="line">    K genericKey = (K) key;</span><br><span class="line">    <span class="keyword">this</span>.expire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-注解驱除拦截器实现"><a href="#5-注解驱除拦截器实现" class="headerlink" title="5.注解驱除拦截器实现"></a>5.注解驱除拦截器实现</h5><p>执行顺序：放在方法之后更新，不然每次当前操作的 key 都会被放在最前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 驱除策略拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptorEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheInterceptorEvict.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">        ICacheEvict&lt;K,V&gt; evict = context.cache().evict();</span><br><span class="line"></span><br><span class="line">        Method method = context.method();</span><br><span class="line">        <span class="keyword">final</span> K key = (K) context.params()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;remove&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            evict.remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            evict.update(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只对 remove 方法做下特判，其他方法都使用 update 更新信息。</p><p>参数直接取第一个参数。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line"></span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><ul><li>日志信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><p>通过 removeListener 日志也可以看到 B 被移除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">21</span>:<span class="number">33</span>:<span class="number">44.578</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key:</span><br></pre></td></tr></table></figure><h3 id="三-LRU缓存策略的优化"><a href="#三-LRU缓存策略的优化" class="headerlink" title="三.LRU缓存策略的优化"></a>三.LRU缓存策略的优化</h3><h4 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h4><h5 id="1-基于数组"><a href="#1-基于数组" class="headerlink" title="1.基于数组"></a>1.基于数组</h5><p>方案：为每一个数据附加一个额外的属性——时间戳，当每一次访问数据时，更新该数据的时间戳至当前时间。</p><p>当数据空间已满后，则扫描整个数组，淘汰时间戳最小的数据。</p><p>不足：维护时间戳需要耗费额外的空间，淘汰数据时需要扫描整个数组。</p><p>这个时间复杂度太差，空间复杂度也不好。</p><h5 id="2-基于长度有限的双向链表"><a href="#2-基于长度有限的双向链表" class="headerlink" title="2.基于长度有限的双向链表"></a>2.基于长度有限的双向链表</h5><p>方案：访问一个数据时，当数据不在链表中，则将数据插入至链表头部，如果在链表中，则将该数据移至链表头部。当数据空间已满后，则淘汰链表最末尾的数据。</p><p>不足：插入数据或取数据时，需要扫描整个链表。</p><p>这个就是我们上一节实现的方式，缺点还是很明显，每次确认元素是否存在，都要消耗 O(n) 的时间复杂度去查询。</p><h5 id="3-基于双向链表和哈希表"><a href="#3-基于双向链表和哈希表" class="headerlink" title="3.基于双向链表和哈希表"></a>3.基于双向链表和哈希表</h5><p>方案：为了改进上面需要扫描链表的缺陷，配合哈希表，将数据和链表中的节点形成映射，将插入操作和读取操作的时间复杂度从O(N)降至O(1)</p><p>缺点：这个使我们上一节提到的优化思路，不过还是有缺点的，那就是空间复杂度翻倍。</p><h5 id="4-数据结构的选择总结"><a href="#4-数据结构的选择总结" class="headerlink" title="4.数据结构的选择总结"></a>4.数据结构的选择总结</h5><p>（1）基于数组的实现</p><p>这里不建议选择 array 或者 ArrayList，因为读取的时间复杂度为 O(1)，但是更新相对是比较慢的，虽然 jdk 使用的是 System.arrayCopy。</p><p>（2）基于双向链表的实现</p><p>如果我们选择链表，HashMap 中还是不能简单的存储 key, 和对应的下标。</p><p>因为链表的遍历，实际上还是 O(n) 的，双向链表理论上可以优化一半，但是这并不是我们想要的 O(1) 效果。</p><p>（3）基于双向链表 + Map实现</p><p>双向链表我们保持不变。</p><p>Map 中 key 对应的值我们放双向链表的节点信息。</p><p>那实现方式就变成了实现一个双向链表。</p><h4 id="基于自定义双向链表实现"><a href="#基于自定义双向链表实现" class="headerlink" title="基于自定义双向链表实现"></a>基于自定义双向链表实现</h4><h5 id="1-节点定义"><a href="#1-节点定义" class="headerlink" title="1.节点定义"></a>1.节点定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fluent get &amp; set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-核心代码实现"><a href="#2-核心代码实现" class="headerlink" title="2.核心代码实现"></a>2.核心代码实现</h5><p>我们保持和原来的接口不变，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLruDoubleListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLruDoubleListMap.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLruDoubleListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">            DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">            <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            K evictKey = tailPre.key();</span><br><span class="line">            V evictValue = cache.remove(evictKey);</span><br><span class="line">            result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行删除</span></span><br><span class="line">        <span class="keyword">this</span>.remove(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 新元素插入到头部</span></span><br><span class="line">        <span class="comment">//head&lt;-&gt;next</span></span><br><span class="line">        <span class="comment">//变成：head&lt;-&gt;new&lt;-&gt;next</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; newNode = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        newNode.key(key);</span><br><span class="line"></span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = <span class="keyword">this</span>.head.next();</span><br><span class="line">        <span class="keyword">this</span>.head.next(newNode);</span><br><span class="line">        newNode.pre(<span class="keyword">this</span>.head);</span><br><span class="line">        next.pre(newNode);</span><br><span class="line">        newNode.next(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 插入到 map 中</span></span><br><span class="line">        indexMap.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment">     * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment">     * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment">     * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        DoubleListNode&lt;K,V&gt; node = indexMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 list node</span></span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line"></span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.indexMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现起来不难，就是一个简易版本的双向列表。</p><p>只是获取节点的时候，借助了一下 map，让时间复杂度降低为 O(1)。</p><h5 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p>我们验证一下自己的实现：</p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lruDoubleListMap())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>日志</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> 09:<span class="number">37</span>:<span class="number">41.007</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><p>因为我们访问过一次 A，所以 B 已经变成最少被访问的元素。</p><h4 id="基于-LinkedHashMap-实现"><a href="#基于-LinkedHashMap-实现" class="headerlink" title="基于 LinkedHashMap 实现"></a>基于 LinkedHashMap 实现</h4><p>实际上，LinkedHashMap 本身就是对于 list 和 hashMap 的一种结合的数据结构，我们可以直接使用 jdk 中 LinkedHashMap 去实现。</p><h5 id="1-直接实现"><a href="#1-直接实现" class="headerlink" title="1.直接实现"></a>1.直接实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里将LinkedHashMap的accessOrder设为true</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt;= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认LinkedHashMap并不会淘汰数据，所以我们重写了它的removeEldestEntry()方法，当数据数量达到预设上限后，淘汰数据，accessOrder设为true意为按照访问的顺序排序。</p><p>整个实现的代码量并不大，主要都是应用LinkedHashMap的特性。</p><h5 id="2-简单改造"><a href="#2-简单改造" class="headerlink" title="2.简单改造"></a>2.简单改造</h5><p>我们对这个方法简单改造下，让其适应我们定义的接口。</p><h5 id="3-测试结果-1"><a href="#3-测试结果-1" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lruLinkedHashMap())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>日志</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">57.842</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><h4 id="LRU扩展算法"><a href="#LRU扩展算法" class="headerlink" title="LRU扩展算法"></a>LRU扩展算法</h4><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><h5 id="1-LRU-K"><a href="#1-LRU-K" class="headerlink" title="1. LRU-K"></a>1. LRU-K</h5><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。</p><p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。</p><p>当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p><p>数据第一次被访问时，加入到历史访问列表，如果数据在访问历史列表中没有达到K次访问，则按照一定的规则（FIFO,LRU）淘汰；</p><p>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列中删除，将数据移到缓存队列中，并缓存数据，缓存队列重新按照时间排序；</p><p>缓存数据队列中被再次访问后，重新排序，需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即“淘汰倒数K次访问离现在最久的数据”。</p><p>LRU-K具有LRU的优点，同时还能避免LRU的缺点，实际应用中LRU-2是综合最优的选择。</p><p>由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多。</p><h5 id="2-two-queue"><a href="#2-two-queue" class="headerlink" title="2. two queue"></a>2. two queue</h5><p>Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p><p>当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。</p><p>新访问的数据插入到FIFO队列中，如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p><p>如果数据在FIFO队列中再次被访问到，则将数据移到LRU队列头部，如果数据在LRU队列中再次被访问，则将数据移动LRU队列头部，LRU队列淘汰末尾的数据。</p><h5 id="3-Multi-Queue-MQ"><a href="#3-Multi-Queue-MQ" class="headerlink" title="3. Multi Queue(MQ)"></a>3. Multi Queue(MQ)</h5><p>MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：<strong>优先缓存访问次数多的数据</strong>。</p><p>详细的算法结构图如下，Q0，Q1….Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列：</p><p>新插入的数据放入Q0，每个队列按照LRU进行管理，当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列中删除，加入到高一级队列的头部；为了防止高优先级数据永远不会被淘汰，当数据在指定的时间里没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；需要淘汰数据时，从最低一级队列开始按照LRU淘汰，每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部。</p><p>如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列头部。</p><p>Q-history按照LRU淘汰数据的索引。</p><p>MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。</p><h5 id="4-LRU算法对比"><a href="#4-LRU算法对比" class="headerlink" title="4.LRU算法对比"></a>4.LRU算法对比</h5><table><thead><tr><th align="left">对比点</th><th align="left">对比</th></tr></thead><tbody><tr><td align="left">命中率</td><td align="left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr><tr><td align="left">复杂度</td><td align="left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr><tr><td align="left">代价</td><td align="left">LRU-2  &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr></tbody></table><p>实际上上面的几个算法，思想上大同小异。</p><p>核心目的：解决批量操作导致热点数据失效，缓存被污染的问题。</p><p>实现方式：增加一个队列，用来保存只访问一次的数据，然后根据次数不同，放入到 LRU 中。</p><p>只访问一次的队列，可以是 FIFO 队列，可以是 LRU，我们来实现一下 2Q 和 LRU-2 两种实现。</p><h4 id="2Q算法实现"><a href="#2Q算法实现" class="headerlink" title="2Q算法实现"></a>2Q算法实现</h4><h5 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h5><p>实际上就是我们以前的 FIFO + LRU 二者的结合。</p><h5 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2.基本属性"></a>2.基本属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLru2Q</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLru2Q.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小限制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 降低 O(n) 的消耗，避免耗时过长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT_QUEUE_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次访问的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;K&gt; firstQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; lruIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLru2Q</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.lruIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-数据淘汰"><a href="#3-数据淘汰" class="headerlink" title="3.数据淘汰"></a>3.数据淘汰</h5><p>数据淘汰的逻辑：</p><p>当缓存大小，已经达到最大限制时执行：</p><p>（1）优先淘汰 firstQueue 中的数据</p><p>（2）如果 firstQueue 中数据为空，则淘汰 lruMap 中的数据信息。</p><p>这里有一个假设：我们认为被多次访问的数据，重要性高于被只访问了一次的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">    ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">    <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">        K evictKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. firstQueue 不为空，优先移除队列中元素</span></span><br><span class="line">        <span class="keyword">if</span>(!firstQueue.isEmpty()) &#123;</span><br><span class="line">            evictKey = firstQueue.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">            DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">            <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            evictKey = tailPre.key();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行移除操作</span></span><br><span class="line">        V evictValue = cache.remove(evictKey);</span><br><span class="line">        result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-数据删除"><a href="#4-数据删除" class="headerlink" title="4.数据删除"></a>4.数据删除</h5><p>当数据被删除时调用：</p><p>这个逻辑和以前类似，只是多了一个 FIFO 队列的移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment"> * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment"> * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment"> * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    DoubleListNode&lt;K,V&gt; node = lruIndexMap.get(key);</span><br><span class="line">    <span class="comment">//1. LRU 删除逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isNotNull(node)) &#123;</span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.lruIndexMap.remove(node.key());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. FIFO 删除逻辑（O(n) 时间复杂度）</span></span><br><span class="line">        firstQueue.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数据的更新"><a href="#5-数据的更新" class="headerlink" title="5.数据的更新"></a>5.数据的更新</h5><p>当数据被访问时，提升数据的优先级。</p><p>（1）如果在 lruMap 中，则首先移除，然后放入到头部</p><p>（2）如果不在 lruMap 中，但是在 FIFO 队列，则从 FIFO 队列中移除，添加到 LRU map 中。</p><p>（3）如果都不在，直接加入到 FIFO 队列中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放入元素</span></span><br><span class="line"><span class="comment"> * 1. 如果 lruIndexMap 已经存在，则处理 lru 队列，先删除，再插入。</span></span><br><span class="line"><span class="comment"> * 2. 如果 firstQueue 中已经存在，则处理 first 队列，先删除 firstQueue，然后插入 Lru。</span></span><br><span class="line"><span class="comment"> * 1 和 2 是不同的场景，但是代码实际上是一样的，删除逻辑中做了二种场景的兼容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 如果不在1、2中，说明是新元素，直接插入到 firstQueue 的开始即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 是否在 LRU MAP 中</span></span><br><span class="line">    <span class="comment">//1.2 是否在 firstQueue 中</span></span><br><span class="line">    DoubleListNode&lt;K,V&gt; node = lruIndexMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isNotNull(node)</span><br><span class="line">        || firstQueue.contains(key)) &#123;</span><br><span class="line">        <span class="comment">//1.3 删除信息</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line">        <span class="comment">//1.4 加入到 LRU 中</span></span><br><span class="line">        <span class="keyword">this</span>.addToLruMapHead(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 直接加入到 firstQueue 队尾</span></span><br><span class="line">    <span class="comment">//        if(firstQueue.size() &gt;= LIMIT_QUEUE_SIZE) &#123;</span></span><br><span class="line"><span class="comment">//            // 避免第一次访问的列表一直增长，移除队头的元素</span></span><br><span class="line"><span class="comment">//            firstQueue.remove();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    firstQueue.add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我想到了一个优化点，限制 firstQueue 的一直增长，因为遍历的时间复杂度为 O(n)，所以限制最大的大小为 1024。</p><p>如果超过了，则把 FIFO 中的元素先移除掉。</p><p>不过只移除 FIFO，不移除 cache，会导致二者的活跃程度不一致；</p><p>如果同时移除，但是 cache 的大小还没有满足，可能会导致超出用户的预期，这个可以作为一个优化点，暂时注释掉。</p><h5 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h5><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru2Q())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">13</span>:<span class="number">15</span>:<span class="number">50.670</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><h4 id="LRU-2算法实现"><a href="#LRU-2算法实现" class="headerlink" title="LRU-2算法实现"></a>LRU-2算法实现</h4><h5 id="1-实现LRU简介"><a href="#1-实现LRU简介" class="headerlink" title="1.实现LRU简介"></a>1.实现LRU简介</h5><p>FIFO 中的缺点还是比较明显的，需要 O(n) 的时间复杂度做遍历。</p><p>而且命中率和 LRU-2 比起来还是会差一点。</p><p>这里 LRU map 出现了多次，我们为了方便，将 LRU map 简单的封装为一个数据结构。</p><p>我们使用双向链表+HashMap 实现一个简单版本的。</p><h5 id="2-节点"><a href="#2-节点" class="headerlink" title="2.节点"></a>2.节点</h5><p>node 节点和以前一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fluent getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h5><p>我们根据自己的需要，暂时定义 3 个最重要的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU map 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILruMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除最老的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的明细</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICacheEntry&lt;K, V&gt; <span class="title">removeEldest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 key 的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除对应的 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h5><p>我们基于 DoubleLinkedList + HashMap 实现。</p><p>就是把上一节中的实现整理一下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于双向列表的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMapDoubleList</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ILruMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(LruMapDoubleList.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruMapDoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICacheEntry&lt;K, V&gt; <span class="title">removeEldest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">        <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        K evictKey = tailPre.key();</span><br><span class="line">        V evictValue = tailPre.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CacheEntry.of(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行删除</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 新元素插入到头部</span></span><br><span class="line">        <span class="comment">//head&lt;-&gt;next</span></span><br><span class="line">        <span class="comment">//变成：head&lt;-&gt;new&lt;-&gt;next</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; newNode = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        newNode.key(key);</span><br><span class="line"></span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = <span class="keyword">this</span>.head.next();</span><br><span class="line">        <span class="keyword">this</span>.head.next(newNode);</span><br><span class="line">        newNode.pre(<span class="keyword">this</span>.head);</span><br><span class="line">        next.pre(newNode);</span><br><span class="line">        newNode.next(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 插入到 map 中</span></span><br><span class="line">        indexMap.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment">     * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment">     * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment">     * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        DoubleListNode&lt;K,V&gt; node = indexMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 list node</span></span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line"></span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.indexMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexMap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-基本属性"><a href="#5-基本属性" class="headerlink" title="5.基本属性"></a>5.基本属性</h5><p>LRU 的实现保持不变。我们直接将 FIFO 替换为 LRU map 即可。</p><p>为了便于理解，我们将 FIFO 对应为 firstLruMap，用来存放用户只访问了一次的元素。</p><p>将原来的 LRU 中存入访问了 2 次及其以上的元素。</p><p>其他逻辑和 2Q 保持一致。</p><p>定义两个 LRU，用来分别存储访问的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLru2</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLru2.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次访问的 lru</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILruMap&lt;K,V&gt; firstLruMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2次及其以上的 lru</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILruMap&lt;K,V&gt; moreLruMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLru2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstLruMap = <span class="keyword">new</span> LruMapDoubleList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.moreLruMap = <span class="keyword">new</span> LruMapDoubleList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-淘汰实现"><a href="#6-淘汰实现" class="headerlink" title="6.淘汰实现"></a>6.淘汰实现</h5><p>和 lru 2Q 模式类似，这里我们优先淘汰 firstLruMap 中的数据信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">    ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">    <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">        ICacheEntry&lt;K,V&gt;  evictEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. firstLruMap 不为空，优先移除队列中元素</span></span><br><span class="line">        <span class="keyword">if</span>(!firstLruMap.isEmpty()) &#123;</span><br><span class="line">            evictEntry = firstLruMap.removeEldest();</span><br><span class="line">            log.debug(<span class="string">&quot;从 firstLruMap 中淘汰数据：&#123;&#125;&quot;</span>, evictEntry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 否则从 moreLruMap 中淘汰数据</span></span><br><span class="line">            evictEntry = moreLruMap.removeEldest();</span><br><span class="line">            log.debug(<span class="string">&quot;从 moreLruMap 中淘汰数据：&#123;&#125;&quot;</span>, evictEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行缓存移除操作</span></span><br><span class="line">        <span class="keyword">final</span> K evictKey = evictEntry.key();</span><br><span class="line">        V evictValue = cache.remove(evictKey);</span><br><span class="line">        result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-删除"><a href="#7-删除" class="headerlink" title="7.删除"></a>7.删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 多次 lru 中存在，删除</span></span><br><span class="line"><span class="comment"> * 2. 初次 lru 中存在，删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 多次LRU 删除逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(moreLruMap.contains(key)) &#123;</span><br><span class="line">        moreLruMap.removeKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 从 moreLruMap 中移除&quot;</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLruMap.removeKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 从 firstLruMap 中移除&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-更新"><a href="#8-更新" class="headerlink" title="8.更新"></a>8.更新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新信息</span></span><br><span class="line"><span class="comment"> * 1. 如果 moreLruMap 已经存在，则处理 more 队列，先删除，再插入。</span></span><br><span class="line"><span class="comment"> * 2. 如果 firstLruMap 中已经存在，则处理 first 队列，先删除 firstLruMap，然后插入 Lru。</span></span><br><span class="line"><span class="comment"> * 1 和 2 是不同的场景，但是代码实际上是一样的，删除逻辑中做了二种场景的兼容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 如果不在1、2中，说明是新元素，直接插入到 firstLruMap 的开始即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 元素已经在多次访问，或者第一次访问的 lru 中</span></span><br><span class="line">    <span class="keyword">if</span>(moreLruMap.contains(key)</span><br><span class="line">        || firstLruMap.contains(key)) &#123;</span><br><span class="line">        <span class="comment">//1.1 删除信息</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line">        <span class="comment">//1.2 加入到多次 LRU 中</span></span><br><span class="line">        moreLruMap.updateKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 多次访问，加入到 moreLruMap 中&quot;</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 加入到第一次访问 LRU 中</span></span><br><span class="line">        firstLruMap.updateKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 为第一次访问，加入到 firstLruMap 中&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上使用 LRU-2 的代码逻辑反而变得清晰了一些，主要是因为我们把 lruMap 作为独立的数据结构抽离了出去</p><h5 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h5><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru2Q())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>日志</strong></p><p>为了便于定位分析，源代码实现的时候，加了一点日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.966</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: A 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.967</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: B 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.968</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: C 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.970</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.removeKey] - key: A 从 firstLruMap 中移除</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.970</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: A 多次访问，加入到 moreLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.972</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.doEvict] - 从 firstLruMap 中淘汰数据：EvictEntry&#123;key=B, value=<span class="keyword">null</span>&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.974</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.974</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: D 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><h5 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h5><p>对于 LRU 算法的改进我们主要做了两点：</p><p>（1）性能的改进，从 O(N) 优化到 O(1)</p><p>（2）批量操作的改进，避免缓存污染</p><h3 id="四-过期功能的实现"><a href="#四-过期功能的实现" class="headerlink" title="四.过期功能的实现"></a>四.过期功能的实现</h3><h4 id="缓存接口定义-1"><a href="#缓存接口定义-1" class="headerlink" title="缓存接口定义"></a>缓存接口定义</h4><p>我们首先来定义一下接口。</p><p>主要有两个：一个是多久之后过期，一个是在什么时候过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> timeInMills)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的时间过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeInMills 时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> timeInMills)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存接口实现"><a href="#缓存接口实现" class="headerlink" title="缓存接口实现"></a>缓存接口实现</h4><p>为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。</p><p>核心的代码，主要还是看 cacheExpire 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireTime = System.currentTimeMillis() + timeInMills;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.expireAt(key, expireTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheExpire.expire(key, timeInMills);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存过期接口"><a href="#缓存过期接口" class="headerlink" title="缓存过期接口"></a>缓存过期接口</h4><p>这里为了便于后期拓展，对于过期的处理定义为接口，便于后期灵活替换</p><p>其中 <code>expire(final K key, final long expireAt);</code> 就是我们方法中调用的地方。</p><p>refershExpire 属于惰性删除，需要进行刷新时才考虑，我们后面讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheExpire</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定过期信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireAt 什么时候过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expire</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> expireAt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 惰性删除中需要处理的 keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyList keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(<span class="keyword">final</span> Collection&lt;K&gt; keyList)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="expire-实现原理"><a href="#expire-实现原理" class="headerlink" title="expire 实现原理"></a>expire 实现原理</h4><p>其实过期的实思路也比较简单：我们可以开启一个定时任务，比如 1 秒钟做一次轮训，将过期的信息清空。</p><h5 id="1-过期信息的存储"><a href="#1-过期信息的存储" class="headerlink" title="1.过期信息的存储"></a>1.过期信息的存储</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过期 map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 空间换时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Long&gt; expireMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> expireAt)</span> </span>&#123;</span><br><span class="line">    expireMap.put(key, expireAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 map，key 是对应的要过期的信息，value 存储的是过期时间。</p><h5 id="2-轮询清理"><a href="#2-轮询清理" class="headerlink" title="2.轮询清理"></a>2.轮询清理</h5><p>我们固定 100ms 清理一次，每次最多清理 100 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单次清空的数量限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheExpire</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> ExpireThread(), <span class="number">100</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个单线程，用于执行清空任务。</p><h5 id="3-清空任务"><a href="#3-清空任务" class="headerlink" title="3.清空任务"></a>3.清空任务</h5><p>这个非常简单，遍历过期数据，判断对应的时间，如果已经到期了，则执行清空操作。</p><p>为了避免单次执行时间过长，最多只处理 100 条</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(MapUtil.isEmpty(expireMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取 key 进行处理</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= LIMIT) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expireKey(entry);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行过期操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entry 明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expireKey</span><span class="params">(Map.Entry&lt;K, Long&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key = entry.getKey();</span><br><span class="line">    <span class="keyword">final</span> Long expireAt = entry.getValue();</span><br><span class="line">    <span class="comment">// 删除的逻辑处理</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class="line">        expireMap.remove(key);</span><br><span class="line">        <span class="comment">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><h5 id="1-出现的原因"><a href="#1-出现的原因" class="headerlink" title="1.出现的原因"></a>1.出现的原因</h5><p>类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。</p><p>那当我们查询时，可能获取到到是脏数据。</p><p>于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。</p><p>算是一种折中方案。</p><h5 id="2-需要惰性删除的方法"><a href="#2-需要惰性删除的方法" class="headerlink" title="2.需要惰性删除的方法"></a>2.需要惰性删除的方法</h5><p>一般就是各种查询方法，比如我们获取 key 对应的值时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 刷新所有过期信息</span></span><br><span class="line">    K genericKey = (K) key;</span><br><span class="line">    <span class="keyword">this</span>.cacheExpire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在获取之前，先做一次数据的刷新。</p><h5 id="3-刷新的实现"><a href="#3-刷新的实现" class="headerlink" title="3.刷新的实现"></a>3.刷新的实现</h5><p>实现原理也非常简单，就是一个循环，然后作删除即可。</p><p>这里加了一个小的优化：选择数量少的作为外循环。</p><p>循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(Collection&lt;K&gt; keyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断大小，小的作为外循环。一般都是过期的 keys 比较小。</span></span><br><span class="line">    <span class="keyword">if</span>(keyList.size() &lt;= expireMap.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : keyList) &#123;</span><br><span class="line">            expireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.expireKey(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>上面的代码写完之后，我们就可以验证一下了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.expire(<span class="string">&quot;1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line"></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, cache.size());</span><br><span class="line"></span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p>结果也符合我们的预期</p><h3 id="五-过期功能的优化"><a href="#五-过期功能的优化" class="headerlink" title="五.过期功能的优化"></a>五.过期功能的优化</h3><p>上面的过期功能的实现中存在两个问题：</p><p>（1）keys 的选择不够随机，可能会导致每次循环 100 个结束时，真正需要过期的没有被遍历到</p><p>（2）keys 的遍历可能大部分都是无效的</p><p>所以下面以过期时间为维度对过期功能进行优化</p><h4 id="基于时间的遍历"><a href="#基于时间的遍历" class="headerlink" title="基于时间的遍历"></a>基于时间的遍历</h4><h5 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h5><p>我们换一种思路，让过期的时间做 key，相同时间的需要过期的信息放在一个列表中，作为 value</p><p>然后对过期时间排序，轮询的时候就可以快速判断出是否有过期的信息了。</p><p>我们每次 put 放入过期元素时，根据过期时间对元素进行排序，相同的过期时间的 Keys 放在一起。</p><p>优点：定时遍历的时候，如果时间不到当前时间，就可以直接返回了，大大降低无效遍历。</p><p>缺点：考虑到惰性删除问题，还是需要存储以删除信息作为 key 的 map 关系，这样内存基本翻倍。</p><h5 id="2-基本属性定义"><a href="#2-基本属性定义" class="headerlink" title="2.基本属性定义"></a>2.基本属性定义</h5><p>我们这里使用 <code>TreeMap</code> 帮助我们进行过期时间的排序，这个集合后续有时间可以详细讲解了，我大概看了下 jdk1.8 的源码，主要是通过红黑树实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheExpireSort</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheExpire</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单次清空的数量限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序缓存存储</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用按照时间排序的缓存处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, List&lt;K&gt;&gt; sortMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (o1 - o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期 map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间换时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Long&gt; expireMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-放入元素时"><a href="#3-放入元素时" class="headerlink" title="3.放入元素时"></a>3.放入元素时</h5><p>每次存入新元素时，同时放入 sortMap 和 expireMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> expireAt)</span> </span>&#123;</span><br><span class="line">    List&lt;K&gt; keys = sortMap.get(expireAt);</span><br><span class="line">    <span class="keyword">if</span>(keys == <span class="keyword">null</span>) &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    keys.add(key);</span><br><span class="line">    <span class="comment">// 设置对应的信息</span></span><br><span class="line">    sortMap.put(expireAt, keys);</span><br><span class="line">    expireMap.put(key, expireAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时任务的执行"><a href="#定时任务的执行" class="headerlink" title="定时任务的执行"></a>定时任务的执行</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><p>我们定义一个定时任务，100ms 执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheExpireSort</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> ExpireThread(), <span class="number">100</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-执行任务"><a href="#2-执行任务" class="headerlink" title="2.执行任务"></a>2.执行任务</h5><p>实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(MapUtil.isEmpty(sortMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取 key 进行处理</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Long, List&lt;K&gt;&gt; entry : sortMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Long expireAt = entry.getKey();</span><br><span class="line">            List&lt;K&gt; expireKeys = entry.getValue();</span><br><span class="line">            <span class="comment">// 判断队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(CollectionUtil.isEmpty(expireKeys)) &#123;</span><br><span class="line">                sortMap.remove(expireAt);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= LIMIT) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除的逻辑处理</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class="line">                Iterator&lt;K&gt; iterator = expireKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    K key = iterator.next();</span><br><span class="line">                    <span class="comment">// 先移除本身</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    expireMap.remove(key);</span><br><span class="line">                    <span class="comment">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class="line">                    cache.remove(key);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接跳过，没有过期的信息</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接遍历 sortMap，对应的 key 就是过期时间，然后和当前时间对比即可。</p><p>删除的时候，需要删除 expireMap/sortMap/cache。</p><h4 id="惰性删除刷新"><a href="#惰性删除刷新" class="headerlink" title="惰性删除刷新"></a>惰性删除刷新</h4><p>惰性删除刷新时，就会用到 expireMap。</p><p>因为有时候刷新的 key 就一个，如果没有 expireMap 映射关系，可能要把 sortMap 全部遍历一遍才能找到对应的过期时间。</p><p>就是一个时间复杂度与空间复杂度衡量的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(Collection&lt;K&gt; keyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历判断过期信息</span></span><br><span class="line">    <span class="comment">// 这样维护两套的代价太大，后续优化，暂时不用。</span></span><br><span class="line">    <span class="comment">// 判断大小，小的作为外循环</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expireSize = expireMap.size();</span><br><span class="line">    <span class="keyword">if</span>(expireSize &lt;= keyList.size()) &#123;</span><br><span class="line">        <span class="comment">// 一般过期的数量都是较少的</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            <span class="comment">// 这里直接执行过期处理，不再判断是否存在于集合中。</span></span><br><span class="line">            <span class="comment">// 因为基于集合的判断，时间复杂度为 O(n)</span></span><br><span class="line">            <span class="keyword">this</span>.removeExpireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : keyList) &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeExpireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除过期信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeExpireKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    Long expireTime = expireMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(expireTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(currentTime &gt;= expireTime) &#123;</span><br><span class="line">            expireMap.remove(key);</span><br><span class="line">            List&lt;K&gt; expireKeys = sortMap.get(expireTime);</span><br><span class="line">            expireKeys.remove(key);</span><br><span class="line">            sortMap.put(expireTime, expireKeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六-RBD持久化功能的实现"><a href="#六-RBD持久化功能的实现" class="headerlink" title="六.RBD持久化功能的实现"></a>六.RBD持久化功能的实现</h3><p>缓存的持久化功能分为以下两个部分：</p><ul><li>Cache 的内容持久化到文件或者数据库</li><li>初始化的时候加载持久化数据</li></ul><h4 id="持久化操作"><a href="#持久化操作" class="headerlink" title="持久化操作"></a>持久化操作</h4><h5 id="1-持久化操作接口"><a href="#1-持久化操作接口" class="headerlink" title="1.持久化操作接口"></a>1.持久化操作接口</h5><p>为了便于灵活替换，我们定义一个持久化的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-持久化操作接口实现"><a href="#2-持久化操作接口实现" class="headerlink" title="2.持久化操作接口实现"></a>2.持久化操作接口实现</h5><p>我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePersistDbJson</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachePersistDbJson</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化</span></span><br><span class="line"><span class="comment">     * key长度 key+value</span></span><br><span class="line"><span class="comment">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = cache.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        FileUtil.createFile(dbPath);</span><br><span class="line">        <span class="comment">// 清空文件</span></span><br><span class="line">        FileUtil.truncate(dbPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry : entrySet) &#123;</span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            Long expireTime = cache.expire().expireTime(key);</span><br><span class="line">            <span class="comment">// 填充持久化数据</span></span><br><span class="line">            PersistEntry&lt;K,V&gt; persistEntry = <span class="keyword">new</span> PersistEntry&lt;&gt;();</span><br><span class="line">            persistEntry.setKey(key);</span><br><span class="line">            persistEntry.setValue(entry.getValue());</span><br><span class="line">            persistEntry.setExpire(expireTime);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 持久化数据转换为JSON数据</span></span><br><span class="line">            String line = JSON.toJSONString(persistEntry);</span><br><span class="line">            <span class="comment">// JSON数据追加到文件中</span></span><br><span class="line">            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-持久化操作的触发"><a href="#3-持久化操作的触发" class="headerlink" title="3.持久化操作的触发"></a>3.持久化操作的触发</h5><p>上面定义好了一种持久化的策略，但是没有提供对应的触发方式。</p><p>我们就采用对用户透明的设计方式：定时执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerCachePersist</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(InnerCachePersist.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存持久化策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICachePersist&lt;K,V&gt; persist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程执行类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerCachePersist</span><span class="params">(ICache&lt;K, V&gt; cache, ICachePersist&lt;K, V&gt; persist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">        <span class="keyword">this</span>.persist = persist;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;开始持久化缓存信息&quot;</span>);</span><br><span class="line">                    persist.persist(cache);</span><br><span class="line">                    log.info(<span class="string">&quot;完成持久化缓存信息&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;文件持久化异常&quot;</span>, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时执行的时间间隔为 10min。</p><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h5><p>我们只需要在创建 Cache 时，指定我们的持久化策略即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .load(<span class="keyword">new</span> MyCacheLoad())</span><br><span class="line">        .persist(CachePersists.&lt;String, String&gt;dbJson(<span class="string">&quot;1.rdb&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>为了确保文件持久化完成，我们沉睡了一会儿。</p><p>测试结果如下</p><p>生成1.rdb文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;key&quot;</span>:<span class="string">&quot;2&quot;</span>,<span class="attr">&quot;value&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;key&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;value&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存数据的加载"><a href="#缓存数据的加载" class="headerlink" title="缓存数据的加载"></a>缓存数据的加载</h4><h5 id="1-缓存初始化接口"><a href="#1-缓存初始化接口" class="headerlink" title="1.缓存初始化接口"></a>1.缓存初始化接口</h5><p>缓存初始化即从持久化中提取数据到缓存内存中</p><p>为了便于后期拓展，定义 ICacheLoad 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheLoad</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> ICache&lt;K,V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-缓存初始化接口实现"><a href="#2-缓存初始化接口实现" class="headerlink" title="2.缓存初始化接口实现"></a>2.缓存初始化接口实现</h5><p>我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载策略-文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLoadDbJson</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheLoad</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheLoadDbJson.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheLoadDbJson</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class="line">        log.info(<span class="string">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String line : lines) &#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="comment">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class="line">            PersistEntry&lt;K,V&gt; entry = JSON.parseObject(line, PersistEntry.class);</span><br><span class="line"></span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            V value = entry.getValue();</span><br><span class="line">            Long expire = entry.getExpire();</span><br><span class="line"></span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            <span class="keyword">if</span>(ObjectUtil.isNotNull(expire)) &#123;</span><br><span class="line">                cache.expireAt(key, expire);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在初始化时使用即可。</p><h3 id="七-AOF持久化功能的实现"><a href="#七-AOF持久化功能的实现" class="headerlink" title="七.AOF持久化功能的实现"></a>七.AOF持久化功能的实现</h3><h4 id="Redis-AOF-解析"><a href="#Redis-AOF-解析" class="headerlink" title="Redis AOF 解析"></a>Redis AOF 解析</h4><h5 id="1-为什么选择-AOF？"><a href="#1-为什么选择-AOF？" class="headerlink" title="1.为什么选择 AOF？"></a>1.为什么选择 AOF？</h5><p>AOF 模式的<strong>性能特别好</strong>：</p><p>用过 kafka 的同学肯定知道，kafka 也用到了顺序写这个特性。</p><p>顺序写添加文件内容，避免了文件 IO 的随机写问题，性能基本可以和内存媲美。</p><p>AOF 的<strong>实时性更好</strong>，这个是相对于 RDB 模式而言的：</p><p>我们原来使用 RDB 模式，将缓存内容全部持久化，这个是比较耗时的动作，一般是几分钟持久化一次。</p><p>AOF 模式主要是针对修改内容的指令，然后将所有的指令顺序添加到文件中。这样的话，实时性会好很多，可以提升到秒级别，甚至秒级别。可以将AOF模式理解为一个操作流水表</p><h5 id="2-AOF-的吞吐量"><a href="#2-AOF-的吞吐量" class="headerlink" title="2.AOF 的吞吐量"></a>2.AOF 的吞吐量</h5><p>AOF 模式可以每次操作都进行持久化，但是这样会导致吞吐量大大下降。</p><p>提升吞吐量最常用的方式就是<strong>批量</strong>，这个 kafka 中也是类似的，比如我们可以 1s 持久化一次，将 1s 内的操作全部放入 buffer 中。</p><p>这里其实就是一个 trade-off 问题，实时性与吞吐量的平衡艺术。</p><p>实际业务中，1s 的误差一般都是可以接受的，所以这个也是业界比较认可的方式。</p><h5 id="3-AOF-的异步-多线程"><a href="#3-AOF-的异步-多线程" class="headerlink" title="3.AOF 的异步+多线程"></a>3.AOF 的异步+多线程</h5><p>kafka 中所有的操作实际上都是异步+回调的方式实现的。</p><p>异步+多线程，确实可以提升操作的性能。</p><p>当然 redis 6 以前，其实一直是单线程的。那为什么性能依然这么好呢？</p><p>其实多线程也有代价，那就是线程上下文的切换是需要耗时的，保持并发的安全问题，也需要加锁，从而降低性能。</p><p>所以这里要考虑异步的收益，与付出的耗时是否成正比的问题。</p><h5 id="4-AOF-的落盘"><a href="#4-AOF-的落盘" class="headerlink" title="4.AOF 的落盘"></a>4.AOF 的落盘</h5><p>我们 AOF 与 RDB 模式，归根结底都是基于操作系统的文件系统做持久化的。</p><p>对于开发者而言，可能就是调用一个 api 就实现了，但是实际持久化落盘的动作并不见得就是一步完成的。</p><p>文件系统为了提升吞吐量，也会采用类似 buffer 的方式。这忽然有一点俄罗斯套娃的味道。</p><p>但是优秀的设计总是相似的，比如说缓存从 cpu 的设计中就有 L1/L2 等等，思路是一致的。</p><p>阿里的很多开源技术，都会针对操作系统的落盘做进一步的优化，这个我们后续做深入学习</p><h5 id="5-AOF-的缺陷"><a href="#5-AOF-的缺陷" class="headerlink" title="5.AOF 的缺陷"></a>5.AOF 的缺陷</h5><p>大道缺一，没有银弹。</p><p>AOF 千好万好，和 RDB 对比也存在一个缺陷，那就是指令</p><h4 id="AOF注解实现"><a href="#AOF注解实现" class="headerlink" title="AOF注解实现"></a>AOF注解实现</h4><h5 id="1-接口"><a href="#1-接口" class="headerlink" title="1.接口"></a>1.接口</h5><p>接口和 rdb 的保持一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化缓存接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-注解定义"><a href="#2-注解定义" class="headerlink" title="2.注解定义"></a>2.注解定义</h5><p>为了和耗时统计，刷新等特性保持一致，对于操作类的动作才添加到文件中（append to file）我们也基于注解属性来指定，而不是固定写死在代码中，便于后期拓展调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作是否需要 append to file，默认为 false</span></span><br><span class="line"><span class="comment">     * 主要针对 cache 内容有变更的操作，不包括查询操作。</span></span><br><span class="line"><span class="comment">     * 包括删除，添加，过期等操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">aof</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在原来的 <code>@CacheInterceptor</code> 注解中添加 aof 属性，用于指定是否对操作开启 aof 模式</p><h5 id="3-过期操作中启用AOF"><a href="#3-过期操作中启用AOF" class="headerlink" title="3.过期操作中启用AOF"></a>3.过期操作中启用AOF</h5><p>类似于 spring 的事务拦截器，我们使用代理类调用 expireAt。</p><p>expire 方法就不需要添加 aof 拦截了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key         key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireTime = System.currentTimeMillis() + timeInMills;</span><br><span class="line">    <span class="comment">// 使用代理调用</span></span><br><span class="line">    Cache&lt;K,V&gt; cachePoxy = (Cache&lt;K, V&gt;) CacheProxy.getProxy(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cachePoxy.expireAt(key, expireTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定过期信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeInMills 时间戳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expire.expire(key, timeInMills);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-变更操作中启用AOF"><a href="#4-变更操作中启用AOF" class="headerlink" title="4.变更操作中启用AOF"></a>4.变更操作中启用AOF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 尝试驱除</span></span><br><span class="line">    CacheEvictContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheEvictContext&lt;&gt;();</span><br><span class="line">    context.key(key).size(sizeLimit).cache(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> evictResult = evict.evict(context);</span><br><span class="line">    <span class="keyword">if</span>(evictResult) &#123;</span><br><span class="line">        <span class="comment">// 执行淘汰监听器</span></span><br><span class="line">        ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(value).type(CacheRemoveType.EVICT.code());</span><br><span class="line">        <span class="keyword">for</span>(ICacheRemoveListener&lt;K,V&gt; listener : <span class="keyword">this</span>.removeListeners) &#123;</span><br><span class="line">            listener.listen(removeListenerContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断驱除后的信息</span></span><br><span class="line">    <span class="keyword">if</span>(isSizeLimit()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 执行添加</span></span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    map.putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(refresh = true, aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AOF-持久化拦截实现"><a href="#AOF-持久化拦截实现" class="headerlink" title="AOF 持久化拦截实现"></a>AOF 持久化拦截实现</h4><h5 id="1-持久化对象定义"><a href="#1-持久化对象定义" class="headerlink" title="1.持久化对象定义"></a>1.持久化对象定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AOF 持久化明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistAofEntry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;（</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter &amp; setter &amp;toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只需要方法名，和参数对象。</p><p>暂时实现的简单一些即可</p><h5 id="2-持久化拦截器"><a href="#2-持久化拦截器" class="headerlink" title="2.持久化拦截器"></a>2.持久化拦截器</h5><p>我们定义拦截器，当 cache 中定义的持久化类为 <code>CachePersistAof</code> 时，将操作的信息放入到 CachePersistAof 的 buffer 列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptorAof</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheInterceptorAof.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 持久化类</span></span><br><span class="line">        ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        ICachePersist&lt;K,V&gt; persist = cache.persist();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(persist <span class="keyword">instanceof</span> CachePersistAof) &#123;</span><br><span class="line">            CachePersistAof&lt;K,V&gt; cachePersistAof = (CachePersistAof&lt;K,V&gt;) persist;</span><br><span class="line"></span><br><span class="line">            String methodName = context.method().getName();</span><br><span class="line">            PersistAofEntry aofEntry = PersistAofEntry.newInstance();</span><br><span class="line">            aofEntry.setMethodName(methodName);</span><br><span class="line">            aofEntry.setParams(context.params());</span><br><span class="line"></span><br><span class="line">            String json = JSON.toJSONString(aofEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接持久化</span></span><br><span class="line">            log.debug(<span class="string">&quot;AOF 开始追加文件内容：&#123;&#125;&quot;</span>, json);</span><br><span class="line">            cachePersistAof.append(json);</span><br><span class="line">            log.debug(<span class="string">&quot;AOF 完成追加文件内容：&#123;&#125;&quot;</span>, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-拦截器调用"><a href="#3-拦截器调用" class="headerlink" title="3.拦截器调用"></a>3.拦截器调用</h5><p>当 AOF 的注解属性为 true 时，调用上述拦截器即可。</p><p>这里为了避免浪费，只有当持久化类为 AOF 模式时，才进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. AOF 追加</span></span><br><span class="line"><span class="keyword">final</span> ICachePersist cachePersist = cache.persist();</span><br><span class="line"><span class="keyword">if</span>(cacheInterceptor.aof() &amp;&amp; (cachePersist <span class="keyword">instanceof</span> CachePersistAof)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(before) &#123;</span><br><span class="line">        persistInterceptors.before(interceptorContext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        persistInterceptors.after(interceptorContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h4><p>这里的 AOF 模式和以前的 RDB 持久化类只是不同的模式，实际上二者是相同的接口。</p><h5 id="1-接口-1"><a href="#1-接口-1" class="headerlink" title="1.接口"></a>1.接口</h5><p>这里我们统一定义了不同的持久化类的时间，便于 RDB 与 AOF 不同任务的不同时间间隔触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间间隔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">period</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeUnit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-持久化类实现"><a href="#2-持久化类实现" class="headerlink" title="2.持久化类实现"></a>2.持久化类实现</h5><p>实现一个 Buffer 列表，用于每次拦截器直接顺序添加</p><p>持久化的实现也比较简单，追加到文件之后，直接清空 buffer 列表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存持久化-AOF 持久化模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePersistAof</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">CachePersistAdaptor</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CachePersistAof.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; bufferList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据持久化路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachePersistAof</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化</span></span><br><span class="line"><span class="comment">     * key长度 key+value</span></span><br><span class="line"><span class="comment">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始 AOF 持久化到文件&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建文件</span></span><br><span class="line">        <span class="keyword">if</span>(!FileUtil.exists(dbPath)) &#123;</span><br><span class="line">            FileUtil.createFile(dbPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 持久化追加到文件中</span></span><br><span class="line">        FileUtil.append(dbPath, bufferList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 清空 buffer 列表</span></span><br><span class="line">        bufferList.clear();</span><br><span class="line">        log.info(<span class="string">&quot;完成 AOF 持久化到文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">period</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimeUnit <span class="title">timeUnit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TimeUnit.SECONDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文件内容到 buffer 列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json json 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> String json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(json)) &#123;</span><br><span class="line">            bufferList.add(json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久化测试"><a href="#持久化测试" class="headerlink" title="持久化测试"></a>持久化测试</h4><h5 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1.测试代码"></a>1.测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .persist(CachePersists.&lt;String, String&gt;aof(<span class="string">&quot;1.aof&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.expire(<span class="string">&quot;1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">cache.remove(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="2-测试日志"><a href="#2-测试日志" class="headerlink" title="2.测试日志"></a>2.测试日志</h5><p>expire 实际上调用的是 expireAt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.979</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.980</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.982</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.982</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.984</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.984</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.088</span>] [pool-<span class="number">1</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: <span class="number">1</span>, value: <span class="number">1</span>, type: expire</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.789</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.InnerCachePersist.run] - 开始持久化缓存信息</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.789</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.CachePersistAof.persist] - 开始 AOF 持久化到文件</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.798</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.CachePersistAof.persist] - 完成 AOF 持久化到文件</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.799</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.InnerCachePersist.run] - 完成持久化缓存信息</span><br></pre></td></tr></table></figure><h5 id="3-文件内容"><a href="#3-文件内容" class="headerlink" title="3.文件内容"></a>3.文件内容</h5><p><code>1.aof</code> 的文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>将每一次的操作，简单的存储到文件中</p><h4 id="AOF-加载实现"><a href="#AOF-加载实现" class="headerlink" title="AOF 加载实现"></a>AOF 加载实现</h4><h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h5><p>类似于 RDB 的加载模式，aof 的加载模式也是类似的。</p><p>我们需要根据文件的内容，还原以前的缓存的内容。</p><p>实现思路：遍历文件内容，反射调用原来的方法。</p><h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><p><strong>解析文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class="line">    log.info(<span class="string">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        <span class="comment">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class="line">        PersistAofEntry entry = JSON.parseObject(line, PersistAofEntry.class);</span><br><span class="line">        <span class="keyword">final</span> String methodName = entry.getMethodName();</span><br><span class="line">        <span class="keyword">final</span> Object[] objects = entry.getParams();</span><br><span class="line">        <span class="keyword">final</span> Method method = METHOD_MAP.get(methodName);</span><br><span class="line">        <span class="comment">// 反射调用</span></span><br><span class="line">        ReflectMethodUtil.invoke(cache, method, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法映射的预加载</strong></p><p>Method 反射是固定的，为了提升性能，我们做一下预处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法缓存</span></span><br><span class="line"><span class="comment"> * 暂时比较简单，直接通过方法判断即可，不必引入参数类型增加复杂度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Method&gt; METHOD_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Method[] methods = Cache.class.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        CacheInterceptor cacheInterceptor = method.getAnnotation(CacheInterceptor.class);</span><br><span class="line">        <span class="keyword">if</span>(cacheInterceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 暂时</span></span><br><span class="line">            <span class="keyword">if</span>(cacheInterceptor.aof()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                METHOD_MAP.put(methodName, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久化加载测试"><a href="#持久化加载测试" class="headerlink" title="持久化加载测试"></a>持久化加载测试</h4><h5 id="1-文件内容"><a href="#1-文件内容" class="headerlink" title="1.文件内容"></a>1.文件内容</h5><ul><li>default.aof</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><h5 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .load(CacheLoads.&lt;String, String&gt;aof(<span class="string">&quot;default.aof&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p>直接将 default.aof 文件加载到 cache 缓存中</p><h3 id="八-监听器的开发"><a href="#八-监听器的开发" class="headerlink" title="八.监听器的开发"></a>八.监听器的开发</h3><p>下面我们将一起学习一下如何实现类似 guava-cache 中的 removeListener 删除监听器，和类似 redis 中的慢日志监控的 slowListener</p><p><strong>删除监听器</strong>：将数据驱除或过期时删除的数据记录打印到删除日志中</p><p><strong>慢操作监听器</strong>：当操作变慢时，将警告信息或报警信息打印到慢日志中</p><h4 id="删除监听器的开发"><a href="#删除监听器的开发" class="headerlink" title="删除监听器的开发"></a>删除监听器的开发</h4><h5 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h5><p>我们在两种场景下删除数据是对用户透明的：</p><p>（1）size 满了之后，进行数据淘汰。</p><p>（2）expire 过期时，清除数据。</p><p>这两个特性对用户本来应该是无感的，不过用户如果关心的话，也可以通过添加删除监听器来获取到相关的变更信息</p><h5 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h5><p>为了实现删除的监听，我们需要找到删除的位置，然后调用监听器即可</p><ul><li>evict 驱除的场景</li></ul><p>​    每次 put 数据时，都会校验 size 是否达到最大的限制，如果达到，则进行 evict 淘汰</p><ul><li>expire 过期的场景</li></ul><p>​    用户指定 expire 时间之后，回后台异步执行刷新</p><p>​    也存在惰性删除的场景</p><h5 id="3-接口定义"><a href="#3-接口定义" class="headerlink" title="3.接口定义"></a>3.接口定义</h5><p>为了统一，我们将所有的删除都定义统一的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除监听器接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> ICacheRemoveListenerContext&lt;K,V&gt; context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-内置实现"><a href="#4-内置实现" class="headerlink" title="4.内置实现"></a>4.内置实现</h5><p>系统内置的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheRemoveListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheRemoveListenerContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Remove key: &#123;&#125;, value: &#123;&#125;, type: &#123;&#125;&quot;</span>,</span><br><span class="line">                context.key(), context.value(), context.type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个监听器是默认开启的，暂时无法关闭</p><h5 id="5-自定义"><a href="#5-自定义" class="headerlink" title="5.自定义"></a>5.自定义</h5><p>用户可以自己的需要，进行自定义实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheRemoveListenerContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【删除提示】可恶，我竟然被删除了！&quot;</span> + context.key());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-使用测试"><a href="#6-使用测试" class="headerlink" title="6.使用测试"></a>6.使用测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">1</span>)</span><br><span class="line">        .addRemoveListener(<span class="keyword">new</span> MyRemoveListener&lt;String, String&gt;())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们指定 cache 的大小为1，设置我们自定义的删除监听器</p><p>这里的删除监听器可以添加多个</p><h5 id="7-测试结果"><a href="#7-测试结果" class="headerlink" title="7.测试结果"></a>7.测试结果</h5><p>测试日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">19</span>:<span class="number">32</span>:<span class="number">54.617</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: <span class="number">2</span>, value: <span class="number">2</span>, type: evict</span><br><span class="line">【删除提示】可恶，我竟然被删除了！<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="慢操作监听器开发"><a href="#慢操作监听器开发" class="headerlink" title="慢操作监听器开发"></a>慢操作监听器开发</h4><h5 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h5><p>redis 中会存储慢操作的相关日志信息，主要是由两个参数构成：</p><p>（1）slowlog-log-slower-than 预设阈值,它的单位是毫秒(1秒=1000000微秒)默认值是10000</p><p>（2）slowlog-max-len 最多存储多少条的慢日志记录</p><p>不过 redis 是直接存储到内存中，而且有长度限制。</p><p>根据实际工作体验，如果我们可以添加慢日志的监听，然后有对应的存储或者报警，这样更加方便问题的分析和快速反馈。</p><p>所以我们引入类似于删除的监听器。</p><h5 id="2-实现思路-1"><a href="#2-实现思路-1" class="headerlink" title="2.实现思路"></a>2.实现思路</h5><p>我们处理所有的 cache 操作，并且记录对应的操作耗时。</p><p>如果耗时操作用户设置的时间阈值，则调用慢操作监听器。</p><h5 id="3-接口定义-1"><a href="#3-接口定义-1" class="headerlink" title="3.接口定义"></a>3.接口定义</h5><p>为了保证接口的灵活性，每一个实现都可以定义自己的慢操作阈值，这样便于分级处理。</p><p>比如超过 100ms，用户可以选择输出 warn 日志；超过 1s，可能影响到业务了，可以直接接入报警系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheSlowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> ICacheSlowListenerContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 慢日志的阈值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 慢日志的阙值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">slowerThanMills</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-自定义监听器"><a href="#4-自定义监听器" class="headerlink" title="4.自定义监听器"></a>4.自定义监听器</h5><p>实现接口 <code>ICacheSlowListener</code></p><p>这里每一个监听器都可以指定自己的慢日志阈值，便于分级处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySlowListener</span> <span class="keyword">implements</span> <span class="title">ICacheSlowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheSlowListenerContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【慢日志】name: &quot;</span> + context.methodName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">slowerThanMills</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-使用测试"><a href="#5-使用测试" class="headerlink" title="5.使用测试"></a>5.使用测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .addSlowListener(<span class="keyword">new</span> MySlowListener())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="6-测试结果"><a href="#6-测试结果" class="headerlink" title="6.测试结果"></a>6.测试结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.547</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: put</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.551</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: put, cost: 10ms</span><br><span class="line">【慢日志】name: put</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.554</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: get</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.554</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: get, cost: 1ms</span><br><span class="line">【慢日志】name: get</span><br></pre></td></tr></table></figure><p>实际工作中，我们可以针对慢日志数据存储，便于后期分析。</p><p>也可以直接接入报警系统，及时反馈问题</p><h3 id="九-Redis-渐进式-Rehash详解"><a href="#九-Redis-渐进式-Rehash详解" class="headerlink" title="九.Redis 渐进式 Rehash详解"></a>九.Redis 渐进式 Rehash详解</h3><h4 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h4><h5 id="1-HashMap-的-rehash"><a href="#1-HashMap-的-rehash" class="headerlink" title="1.HashMap 的 rehash"></a>1.HashMap 的 rehash</h5><p>读过 HashMap 源码的同学，应该都知道 map 在扩容的时候，有一个 rehash 的过程</p><h5 id="2-HashMap-的扩容简介"><a href="#2-HashMap-的扩容简介" class="headerlink" title="2.HashMap 的扩容简介"></a>2.HashMap 的扩容简介</h5><p>这里简单介绍下：</p><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素</p><p>当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶</p><h4 id="Redis-中的扩容设计"><a href="#Redis-中的扩容设计" class="headerlink" title="Redis 中的扩容设计"></a>Redis 中的扩容设计</h4><p>HashMap 的扩容需要对集合中大部分的元素进行重新计算，但是对于 redis 这种企业级应用，特别是单线程的应用，如果像传统的 rehash 一样把所有元素来一遍的话，估计要十几秒的时间。</p><p>十几秒对于常见的金融、电商等相对高并发的业务场景，是无法忍受的。</p><p>那么 redis 的 rehash 是如何实现的呢？</p><p>实际上 redis 的 rehash 动作并不是一次性、集中式地完成的， 而是<strong>分多次、渐进式地完成的</strong>。</p><p>这里补充一点，不单单是扩容，缩容也是一样的道理，二者都需要进行 rehash。</p><p>只增不降就是对内存的浪费，浪费就是犯罪，特别是内存还这么贵。</p><p>ps: 这种思想和 key 淘汰有异曲同工之妙，一口吃不了一个大胖子，一次搞不定，那就 1024 次，慢慢来总能解决问题</p><h4 id="Redis-的渐进式-rehash"><a href="#Redis-的渐进式-rehash" class="headerlink" title="Redis 的渐进式 rehash"></a>Redis 的渐进式 rehash</h4><p>这部分直接选自经典入门书籍《Redis 设计与实现》</p><h5 id="1-为什么要渐进式处理？"><a href="#1-为什么要渐进式处理？" class="headerlink" title="1.为什么要渐进式处理？"></a>1.为什么要渐进式处理？</h5><p>实际上 redis 内部有两个 hashtable，我们称之为 ht[0] 和 ht[1]。传统的 HashMap 中只有一个。</p><p>为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p><h5 id="2-详细步骤"><a href="#2-详细步骤" class="headerlink" title="2.详细步骤"></a>2.详细步骤</h5><p>哈希表渐进式 rehash 的详细步骤：</p><p>（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</p><p>（2）在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</p><p>（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增1。</p><p>（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</p><p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p><h5 id="3-rehash-间的操作怎么兼容呢？"><a href="#3-rehash-间的操作怎么兼容呢？" class="headerlink" title="3.rehash 间的操作怎么兼容呢？"></a>3.rehash 间的操作怎么兼容呢？</h5><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 那这期间的操作如何保证正常进行呢？</p><p>（1）查询一个信息</p><p>这个类似于我们的数据库信息等迁移，先查询一个库，没有的话，再去查询另一个库。</p><p>ht[0] 中没找到，我们去 ht[1] 中查询即可。</p><p>（2）新数据怎么办？</p><p>这个和数据迁移一样的道理。</p><p>当我们有新旧的两个系统时，新来的用户等信息直接落在新系统即可，</p><p>这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h5 id="1-什么时候判断？"><a href="#1-什么时候判断？" class="headerlink" title="1.什么时候判断？"></a>1.什么时候判断？</h5><p>redis 在每次执行 put 操作的时候，就可以检查是否需要扩容。</p><p>其实也很好理解，put 插入元素的时候，判断是否需要扩容，然后开始扩容，是直接的一种思路。</p><p>留一个思考题：我们可以在其他的时候判断吗？</p><h5 id="2-redis-判断是否需要扩容的源码"><a href="#2-redis-判断是否需要扩容的源码" class="headerlink" title="2.redis 判断是否需要扩容的源码"></a>2.redis 判断是否需要扩容的源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictExpandIfNeeded</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">// 如果正在进行渐进式扩容，则返回OK</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="comment">// 如果哈希表ht[0]的大小为0，则初始化字典</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果哈希表ht[0]中保存的key个数与哈希表大小的比例已经达到1:1，即保存的节点数已经大于哈希表大小</span></span><br><span class="line"><span class="comment">     * 且redis服务当前允许执行rehash，或者保存的节点数与哈希表大小的比例超过了安全阈值（默认值为5）</span></span><br><span class="line"><span class="comment">     * 则将哈希表大小扩容为原来的两倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的条件总结下来就是两句话：</p><p>（1）服务器目前没有在执行 BGSAVE/BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1；</p><p>（2）服务器目前正在执行 BGSAVE/BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5；</p><p>这里其实体现了作者的一种设计思想：如果负载因子超过5，说明信息已经很多了，管你在不在保存，都要执行扩容，优先保证服务可用性。如果没那么高，那就等持久化完成再做 rehash。</p><p>我们自己在实现的时候可以简化一下，比如只考虑情况2。</p><h5 id="3-扩容到原来的多少？"><a href="#3-扩容到原来的多少？" class="headerlink" title="3.扩容到原来的多少？"></a>3.扩容到原来的多少？</h5><p>知道了什么时候应该开始扩容，但是要扩容到多大也是值得思考的一个问题。</p><p>扩容的太小，会导致频繁扩容，浪费性能。</p><p>扩容的太大，会导致资源的浪费。</p><p>其实这个最好的方案是结合我们实际的业务，不过这部分对用户是透明的。</p><p>一般是扩容为原来的两倍。</p><h5 id="4-为什么需要扩容？"><a href="#4-为什么需要扩容？" class="headerlink" title="4.为什么需要扩容？"></a>4.为什么需要扩容？</h5><p>我们在实现 ArrayList 的时候需要扩容，因为数据放不下了。</p><p>我们知道 HashMap 的底层是数组 + 链表（红黑树）的数据结构。</p><p>那么会存在放不下的情况吗？</p><p>个人理解实际上不会。因为链表可以一直加下去。</p><p>那为什么需要扩容呢？</p><p>实际上更多的是处于性能的考虑。我们使用 HashMap 就是为了提升性能，如果一直不扩容，可以理解为元素都 hash 到相同的 bucket 上，这时就退化成了一个链表。</p><p>这会导致查询等操作性能大大降低。</p><h4 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h4><h5 id="1-什么时候判断？-1"><a href="#1-什么时候判断？-1" class="headerlink" title="1.什么时候判断？"></a>1.什么时候判断？</h5><p>看了前面的扩容，我们比较直观地方式是在用户 remove 元素的时候执行是否需要缩容。</p><p>不过 redis 并不完全等同于传统的 HashMap，还有数据的淘汰和过期，这些是对用户透明的。</p><p>redis 采用的方式实际上是一个定时任务。</p><p>个人理解内存缩容很重要，但是没有那么紧急，我们可以 1min 扫描一次，这样可以节省机器资源。</p><p>实际工作中，一般 redis 的内存都是逐步上升的，或者稳定在一个范围内，很少去大批量删除数据。（除非数据搞错了，我就遇到过一次，数据同步错地方了）。</p><p>所以数据删除，一般几分钟内给用户一个反馈就行。</p><p>知其然，知其所以然。</p><p>我们懂得了这个道理也就懂得了为什么有时候删除 redis 的几百万 keys，内存也不是直接降下来的原因。</p><h5 id="2-缩容的条件"><a href="#2-缩容的条件" class="headerlink" title="2.缩容的条件"></a>2.缩容的条件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL</span></span><br><span class="line"><span class="comment"> * we resize the hash table to save memory */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryResizeHashTables</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].dict))</span><br><span class="line">        dictResize(server.db[dbid].dict);</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].expires))</span><br><span class="line">        dictResize(server.db[dbid].expires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table parameters */</span></span><br><span class="line">#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和扩容类似，不过这里的缩容比例不是 5 倍，而是当哈希表保存的key数量与哈希表的大小的比例小于 10% 时需要缩容。</p><h5 id="3-缩容到多少？"><a href="#3-缩容到多少？" class="headerlink" title="3.缩容到多少？"></a>3.缩容到多少？</h5><p>最简单的方式是直接变为原来的一半，不过这么做有时候也不是那么好用。</p><p>redis 是<strong>缩容后的大小为第一个大于等于当前key数量的2的n次方。</strong></p><p>这个可能不太好理解，举几个数字就懂了：</p><table><thead><tr><th align="left">keys数量</th><th align="left">缩容大小</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">4</td></tr><tr><td align="left">4</td><td align="left">4</td></tr><tr><td align="left">5</td><td align="left">8</td></tr><tr><td align="left">9</td><td align="left">16</td></tr></tbody></table><p>主要保障以下3点：</p><p>（1）缩容之后，要大于等于 key 的数量</p><p>（2）尽可能的小，节约内存</p><p>（3）2 的倍数。</p><p>第三个看过 HashMap 源码讲解的小伙伴应该深有体会。</p><p>当然也不能太小，redis 限制的最小为 4。</p><p>实际上如果 redis 中只放 4 个 key，实在是杀鸡用牛刀，一般不会这么小。</p><p>我们在实现的时候，直接参考 jdk 好了，给个最小值限制 8。</p><h5 id="4-为什么需要缩容？"><a href="#4-为什么需要缩容？" class="headerlink" title="4.为什么需要缩容？"></a>4.为什么需要缩容？</h5><p>最核心的目的就是为了节约内存，其实还有一个原因，叫 small means fast（小即是快——老马）。</p><h4 id="渐进式-ReHash-实现的思考"><a href="#渐进式-ReHash-实现的思考" class="headerlink" title="渐进式 ReHash 实现的思考"></a>渐进式 ReHash 实现的思考</h4><p>好了，扩容和缩容就聊到这里，那么这个渐进式 rehash 到底怎么一个渐进法？</p><h5 id="1-扩容前"><a href="#1-扩容前" class="headerlink" title="1.扩容前"></a>1.扩容前</h5><p>不需要扩容时应该有至少需要初始化两个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = <span class="keyword">new</span> HashTable(size);</span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>hashtable 中存储着当前的元素信息，hashIndex=-1 标识当前没有在进行扩容。</p><h5 id="2-扩容准备"><a href="#2-扩容准备" class="headerlink" title="2.扩容准备"></a>2.扩容准备</h5><p>当需要扩容的时候，我们再去创建一个 hashtable[1]，并且 size 是原来的 2倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = <span class="keyword">new</span> HashTable(size);</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">new</span> HashTable(<span class="number">2</span> * size);</span><br><span class="line"></span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>主要是为了节约内存，使用惰性初始化的方式创建 hashtable。</p><h5 id="3-扩容时"><a href="#3-扩容时" class="headerlink" title="3.扩容时"></a>3.扩容时</h5><p>调整 hashIndex=0…size，逐步去 rehash 到新的 hashtable[1]</p><p>新的插入全部放入到 hashtable[1]</p><h5 id="4-扩容后"><a href="#4-扩容后" class="headerlink" title="4.扩容后"></a>4.扩容后</h5><p>扩容后我们应该把 hashtable[0] 的值更新为 hashtable[1]，并且释放掉 hashtable[1] 的资源。</p><p>并且设置 hashIndex=-1，标识已经 rehash 完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = hashtable[<span class="number">1</span>];</span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这样整体的实现思路就已经差不多了，光说不练假把式，我们下一节就来自己实现一个渐进式 rehash 的 HashMap</p><h3 id="十-实现渐进式ReHash-Map类定义"><a href="#十-实现渐进式ReHash-Map类定义" class="headerlink" title="十.实现渐进式ReHash Map类定义"></a>十.实现渐进式ReHash Map类定义</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己实现的渐进式 rehash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProgressiveReHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和简易版本类似。</p><h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(MyProgressiveReHashMap.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rehash 的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 rehashIndex != -1，说明正在进行 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rehashIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量</span></span><br><span class="line"><span class="comment"> * 默认为 8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处于 rehash 状态的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rehashCapacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计大小的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阈值</span></span><br><span class="line"><span class="comment"> * 阈值=容量*factor</span></span><br><span class="line"><span class="comment"> * 暂时不考虑最大值的问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当达到这个阈值的时候，直接进行两倍的容量扩充+rehash。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存放信息的 table 数组。</span></span><br><span class="line"><span class="comment"> * 数组：数组的下标是一个桶，桶对应的元素 hash 值相同。</span></span><br><span class="line"><span class="comment"> * 桶里放置的是一个链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以理解为 table 是一个 ArrayList</span></span><br><span class="line"><span class="comment"> * arrayList 中每一个元素，都是一个 DoubleLinkedList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Entry&lt;K, V&gt;&gt;&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渐进式 rehash 时，用来存储元素信息使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Entry&lt;K, V&gt;&gt;&gt; rehashTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否开启 debug 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> debugMode = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>rehashIndex/rehashCapacity/rehashTable 这三个值都是我们在进行渐进式实现的时候需要使用的值。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>主要是一些值的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> debugMode 是否开启 debug 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> debugMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 初始化最大为容量的个数，如果 hash 的非常完美的话。</span></span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">    <span class="comment">// 初始化为空列表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.table.add(i, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.debugMode = debugMode;</span><br><span class="line">    <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashCapacity = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashTable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h4><p>这个方法相对难度比较大：</p><p>put() 的过程可以见方法的注释。</p><p>需要考虑是否为 rehash 阶段，还需要考虑是否为更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put 一个值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果不处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.1 判断是否为 table 更新，如果是，则进行更新</span></span><br><span class="line"><span class="comment"> * 1.2 如果不是更新，则进行插入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 插入的时候可能触发 rehash</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （2）如果处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.0 执行一次渐进式 rehash 的动作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1 判断是否为更新，需要遍历 table 和 rehashTable</span></span><br><span class="line"><span class="comment"> * 如果是，执行更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.2 如果不是，则执行插入</span></span><br><span class="line"><span class="comment"> * 插入到 rehashTable 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInRehash = isInReHash();</span><br><span class="line">    <span class="keyword">if</span>(!isInRehash) &#123;</span><br><span class="line">        <span class="comment">//1. 是否为更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair = updateTableInfo(key, value, <span class="keyword">this</span>.table, <span class="keyword">this</span>.capacity);</span><br><span class="line">        <span class="keyword">if</span>(pair.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;不处于渐进式 rehash，此次为更新操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createNewEntry(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2.0 执行一个附加操作，进行渐进式 rehash 处理</span></span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 阶段，额外执行一次渐进式 rehash 的动作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rehashToNew();</span><br><span class="line">        <span class="comment">//2.1 是否为 table 更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair = updateTableInfo(key, value, <span class="keyword">this</span>.table, <span class="keyword">this</span>.capacity);</span><br><span class="line">        <span class="keyword">if</span>(pair.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;此次为更新 table 操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 是否为 rehashTable 更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair2 = updateTableInfo(key, value, <span class="keyword">this</span>.rehashTable, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        <span class="keyword">if</span>(pair2.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair2.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;此次为更新 rehashTable 操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.3 插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createNewEntry(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-是否为-rehash-阶段"><a href="#1-是否为-rehash-阶段" class="headerlink" title="1.是否为 rehash 阶段"></a>1.是否为 rehash 阶段</h5><p>这个实现比较简单，就是判断 rehashIndex 是否为 -1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInReHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rehashIndex != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-更新列表信息"><a href="#2-更新列表信息" class="headerlink" title="2.更新列表信息"></a>2.更新列表信息</h5><p>这里为了复用，对方法进行了抽象。可以同时使用到 table 和 rehashTable 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为更新信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> table table 信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableCapacity table 的容量（使用 size 也可以，因为都默认初始化了。）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 更新结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Pair&lt;Boolean, V&gt; <span class="title">updateTableInfo</span><span class="params">(K key, V value, <span class="keyword">final</span> List&lt;List&lt;Entry&lt;K,V&gt;&gt;&gt; table,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> <span class="keyword">int</span> tableCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 index 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = HashUtil.hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = HashUtil.indexFor(hash, tableCapacity);</span><br><span class="line">    <span class="comment">// 判断是否为替换</span></span><br><span class="line">    List&lt;Entry&lt;K,V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(index &lt; table.size()) &#123;</span><br><span class="line">        entryList = table.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; entry : entryList) &#123;</span><br><span class="line">        <span class="comment">// 二者的 key 都为 null，或者二者的 key equals()</span></span><br><span class="line">        <span class="keyword">final</span> K entryKey = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(key, entryKey)</span><br><span class="line">                || key.equals(entryKey)) &#123;</span><br><span class="line">            <span class="keyword">final</span> V oldValue = entry.getValue();</span><br><span class="line">            <span class="comment">// 更新新的 value</span></span><br><span class="line">            entry.setValue(value);</span><br><span class="line">            <span class="keyword">return</span> Pair.of(<span class="keyword">true</span>, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pair.of(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和以前基本是类似的。</p><p>返回结果时，为了同时保存是否为更新，以及更新的 value 值。所以使用了 Pair 工具类。</p><h5 id="3-插入新的元素"><a href="#3-插入新的元素" class="headerlink" title="3.插入新的元素"></a>3.插入新的元素</h5><p>插入方法也比较麻烦，需要区分是否处于渐进式 rehash 阶段。还要考虑是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的明细</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果处于渐进式 rehash 中，则设置到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （2）如果不是，则判断是否需要扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1 如果扩容，则直接放到 rehashTable 中。</span></span><br><span class="line"><span class="comment"> * 因为我们每次扩容内存翻倍，一次只处理一个 index 的信息，所以不会直接 rehash 结束，直接放到新的 rehashTable 中即可</span></span><br><span class="line"><span class="comment"> * 2.2 如果不扩容，则放入 table 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">createNewEntry</span><span class="params">(<span class="keyword">final</span> K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; entry = <span class="keyword">new</span> DefaultMapEntry&lt;&gt;(key, value);</span><br><span class="line">    <span class="comment">// 重新计算 tableIndex</span></span><br><span class="line">    <span class="keyword">int</span> hash = HashUtil.hash(key);</span><br><span class="line">    <span class="comment">//是否处于 rehash 中？</span></span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.rehashTable.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前处于 rehash 中，元素直接插入到 rehashTable 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.rehashTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要扩容 &amp;&amp; 不处于渐进式 rehash</span></span><br><span class="line">    <span class="comment">// rehash 一定是扩容 rehashTable</span></span><br><span class="line">    <span class="comment">// 如果发生了 rehash，元素是直接放到 rehashTable 中的</span></span><br><span class="line">    <span class="keyword">if</span>(isNeedExpand()) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">        <span class="comment">// 放入到 rehashTable 中</span></span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.rehashTable.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前处于 rehash 中，元素直接插入到 rehashTable 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.rehashTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.capacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.table.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前不处于 rehash 中，元素直接插入到 table 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.table);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否需要扩容的方法也比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比例满足，且不处于渐进式 rehash 中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNeedExpand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证比例</span></span><br><span class="line">    <span class="keyword">double</span> rate = size*<span class="number">1.0</span> / capacity*<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> rate &gt;= factor &amp;&amp; !isInReHash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们这次添加了一个不要处于渐进式 rehash 过程中。</p><p>其中 rehash 的实现也发生了很大的变化，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接 rehash 的流程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果处于 rehash 中，直接返回</span></span><br><span class="line"><span class="comment"> * （2）初始化 rehashTable，并且更新 rehashIndex=0;</span></span><br><span class="line"><span class="comment"> * （3）获取 table[0]，rehash 到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （4）设置 table[0] = new ArrayList();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 阶段，不重复进行 rehash!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 rehashTable</span></span><br><span class="line">    <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashCapacity = <span class="number">2</span>*capacity;</span><br><span class="line">    <span class="keyword">this</span>.rehashTable = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rehashCapacity; i++) &#123;</span><br><span class="line">        rehashTable.add(i, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素第一个元素，其他的进行渐进式更新。</span></span><br><span class="line">    rehashToNew();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渐进式更新的方法，可以在 get/put/remove 等操作时，执行附加操作时使用。</p><p>所以单独抽成了一个方法，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将信息从旧的 table 迁移到新的 table 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）table[rehashIndex] 重新 rehash 到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （2）设置 table[rehashIndex] = new ArrayList();</span></span><br><span class="line"><span class="comment"> * （3）判断是否完成渐进式 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehashToNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rehashIndex++;</span><br><span class="line"></span><br><span class="line">    List&lt;Entry&lt;K, V&gt;&gt; list = table.get(rehashIndex);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; entry : list) &#123;</span><br><span class="line">        <span class="keyword">int</span> hash = HashUtil.hash(entry);</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, rehashCapacity);</span><br><span class="line">        <span class="comment">//  添加元素</span></span><br><span class="line">        <span class="comment">// 获取列表，避免数组越界</span></span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; newList = rehashTable.get(index);</span><br><span class="line">        <span class="comment">// 添加元素到列表</span></span><br><span class="line">        <span class="comment">// 元素不存在重复，所以不需要考虑更新</span></span><br><span class="line">        newList.add(entry);</span><br><span class="line">        rehashTable.set(index, newList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 index 处的信息</span></span><br><span class="line">    table.set(rehashIndex, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断大小是否完成 rehash</span></span><br><span class="line">    <span class="comment">// 验证是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span>(rehashIndex == (table.size()-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="keyword">this</span>.rehashCapacity;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">this</span>.rehashTable;</span><br><span class="line">        <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rehashCapacity = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rehashTable = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;渐进式 rehash 已经完成。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.table);</span><br><span class="line">        &#125;p</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;渐进式 rehash 处理中, 目前 index：&#123;&#125; 已完成&quot;</span>, rehashIndex);</span><br><span class="line">            printAllTable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-操作"><a href="#get-操作" class="headerlink" title="get() 操作"></a>get() 操作</h4><p>渐进式 rehash 将动作分散到每一个操作中，我们对 get 方法进行重写，当做一个例子。其他的方法如果实现也是类似的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询方法</span></span><br><span class="line"><span class="comment"> * （1）如果处于渐进式 rehash 状态，额外执行一次 rehashToNew()</span></span><br><span class="line"><span class="comment"> * （2）判断 table 中是否存在元素</span></span><br><span class="line"><span class="comment"> * （3）判断 rehashTable 中是否存在元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 状态，额外执行一次操作&quot;</span>);</span><br><span class="line">            rehashToNew();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断 table 中是否存在</span></span><br><span class="line">    V result = getValue(key, <span class="keyword">this</span>.table);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 是否处于渐进式 rehash</span></span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getValue(key, <span class="keyword">this</span>.rehashTable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>我们历经千辛万苦，终于实现了一个简单版本的渐进式 hash map。</p><p>下面来测试一下功能是否符合我们的预期。</p><h5 id="1-put-操作"><a href="#1-put-操作" class="headerlink" title="1.put 操作"></a>1.put 操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> MyProgressiveReHashMap&lt;&gt;(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">30</span>:<span class="number">15.072</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">30</span>:<span class="number">15.076</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.put] - 不处于渐进式 rehash，此次为更新操作。key: <span class="number">1</span>, value: <span class="number">2</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>&#125; </span><br></pre></td></tr></table></figure><p>第一次是插入，第二次是更新。</p><p>这里都没有触发扩容，下面我们看一下触发扩容的情况。</p><h5 id="2-扩容测试"><a href="#2-扩容测试" class="headerlink" title="2.扩容测试"></a>2.扩容测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> MyProgressiveReHashMap&lt;&gt;(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;1&quot;</span>, map.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;2&quot;</span>, map.get(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;3&quot;</span>, map.get(<span class="string">&quot;3&quot;</span>));</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.559</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.560</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.563</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.rehashToNew] - 渐进式 rehash 处理中, 目前 index：<span class="number">0</span> 已完成</span><br><span class="line">原始 table 信息: </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">新的 table 信息: </span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.563</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前处于 rehash 中，元素直接插入到 rehashTable 中。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">3</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.564</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.get] - 当前处于渐进式 rehash 状态，额外执行一次操作</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.564</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.rehashToNew] - 渐进式 rehash 已经完成。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">3</span>&#125; </span><br></pre></td></tr></table></figure><p>当放入元素【3】的时候，已经触发了 rehash。</p><p>（1）第一次渐进式 rehash 将 table[0] 的元素 rehash 到了新的节点。</p><p>（2）插入的元素直接插入到 rehashTable 中</p><p>（3）get 操作时，额外触发一次 rehash，然后所有的 rehash 已经完成。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/4ffc613d6eaf">Fluent Interface 流式接口</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202205211137136.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
      <category term="Redis" scheme="https://autovy.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|低端中国</title>
    <link href="https://autovy.github.io/2022/02/27/BookNote/%E3%80%8A%E4%BD%8E%E7%AB%AF%E4%B8%AD%E5%9B%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://autovy.github.io/2022/02/27/BookNote/%E3%80%8A%E4%BD%8E%E7%AB%AF%E4%B8%AD%E5%9B%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-27T06:30:00.000Z</published>
    <updated>2023-03-26T14:35:33.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.fosu.gq/Autovy/ImageExpand/master/img202303262232750.jpg" alt="低端中國：黨、土地、農民工，與中國即將到來的經濟危機|讀書共和國網路書店"></p><span id="more"></span><p>《低端中国：党、土地、农民工，与中国即将到来的经济危机》<br>羅谷（Dexter Roberts）<br>249个笔记</p><p><img src="C:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20230326223058103.png" alt="image-20230326223058103"></p><h3 id="◆-点评"><a href="#◆-点评" class="headerlink" title="◆  点评"></a>◆  点评</h3><p>2023/2/27 认为好看<br>这本书通过对中国制造业和劳动力市场的深入调研，提供了一个全面而深入的视角，探讨了中国制造业的发展和工人权益问题。它描述了一些中国工人的生活和工作条件，指出了制造业中存在的种种问题，包括工作强度、低工资、劳动安全问题、环境污染等等。</p><p>此外，这本书还探讨了中国制造业在经济全球化中的地位和作用，对中国制造业未来的前景提出了一些看法。它认为，中国制造业面临着一些挑战，包括劳动力成本上升、技术升级、国内市场和国际竞争压力等等，但中国制造业的崛起和发展仍然是一个值得关注和研究的话题。</p><p>总的来说，《The Myth of Chinese Capitalism》提供了一个深入了解中国制造业和劳动力市场的视角，揭示了一些深层次的问题和挑战，并提供了一些前瞻性的观点和分析。它为我们更好地理解中国的制造业和工人问题提供了有价值的</p><h3 id="◆-台灣版作者自序-羅谷"><a href="#◆-台灣版作者自序-羅谷" class="headerlink" title="◆  台灣版作者自序/羅谷"></a>◆  台灣版作者自序/羅谷</h3><p>=&gt;  如果中國不找出一套辦法讓農民工融入城市，並確保他們不淪為二等公民，中國的經濟成長就不可能永續發展，不可能持久。如果戶口制度能改革成允許農民工自由地選擇在城市安家落戶，並像城市居民一樣享有醫療與教育權利，將能釋放出推動中國經濟成長好多年的生產力。</p><h3 id="◆-導-論-一個中國，兩個世界"><a href="#◆-導-論-一個中國，兩個世界" class="headerlink" title="◆  導　論　一個中國，兩個世界"></a>◆  導　論　一個中國，兩個世界</h3><p>=&gt;  共產黨高幹一方面保住了自己不可動搖的統治地位，但又能夠接受不得不然的重大變革</p><p>=&gt;  九七年九月，中國共產黨召開第十五次全國人民代表大會，共黨領導階層在會中宣布私有企業解禁，民營企業從此「成為中國經濟體重要的一部分」，但這其實只是反映中國經濟前此數年來已有快速的成長，不少中國人早在國家法條的禁錮之外創造了大筆財富</p><p>=&gt;  貴州這裡「天無三日晴，地無三里平，人無三兩銀」</p><p>=&gt;  這裡的「另一個中國」，指的是貴州等發展遲緩省分的工人、農民，而不是沿海那些物質財富越來越發達的樣板城市比較有錢的居民。</p><p>=&gt;  一間間兩層樓高，裝著鐵窗的廠房，屋頂積滿了厚厚的泥塵，沿著這條幹道一公里接著一公里連綿不絕。廠房與廠房之間，那些水泥牆後面，偶爾可見幾棟別墅，是台灣或香港籍老闆的住宅。整條國道一直維持著這樣的情景，最後來到深圳的大海港鹽田。這個地方，每次都要等到有颱風掃過，大量雨水清洗掉那些工業景象，遠方地平線外青山重現，你才會發覺原來廣東是亞熱帶地區。</p><p>=&gt;  在東莞，農民工開始上工的時候，都必須把身分證交給管理人員保管。所以他們常常坐「黑牢」。「黑牢」指的是警察任意拘留人犯的「拘留中心」</p><p>=&gt;  二○○七年中國通過「勞動合同法」，工人振奮之餘，對自己應有的權益更加堅持。不過官方的工會還是沒有什麼用</p><p>2023/2/4 发表想法<br>没见到具体行动，目前还忙着救营商环境呢，再苦一苦农民吧<br>=&gt;  人口老化與經濟轉型</p><p>中國如今已面臨一個轉捩點。多年來以投資主導的經濟成長使地方政府及公司承受了過多的債務，銀行也有很多呆帳。過去東莞等城市中一直依賴超低工資賺取利潤的工廠，現在漸漸開始找不到工人，很多都在倒閉邊緣。鄉村農民現在擁有的耕地還是很小塊，這是限制農民租、售農地的制度造成的結果。除了限制農民租、售農地之外，地方政府還沉溺於徵收農地轉為商用以從中獲利。建造高速鐵路、快速道路，一部分也要依靠這種制度。這一種制度偏袒國家，不利個人，容許政府以一點小錢奪走人民的土地，自然會激起社會的不滿。政府高官很清楚多年來的經濟成長模式已經持續不下去，國家必須轉換為一種依賴服務業以及人民消費力的經濟體。要做到這一點，必須讓千千萬萬農民及農民工 ── 為數將近中國人口的一半 ── 開始多賺錢，成為城市居民，亦即變成中產階級。麥肯錫公司之前預估中國到二○一二年將有足足兩億五千六百萬人成為中產階級。7</p><p>數十年來人口向城市流動的潮流，如今走到了盡頭。人口統計，以及城市農民工一直面對的歧視性政策，可以解釋這種重大的變化。工人年齡漸增，已經不太願意再為那麼一點工資做那麼粗重的工作，況且他們也會想念家人。很多城市都在打壓收容農民工子女的私立學校，並且為工人傷病就醫設立種種障礙。還有老家年邁的父母也需要有人照顧。二○一七年秋季，中國農業部長韓長賦說，當年的前半年，中國有七百萬工人回到了他們故鄉的村子。但這一股逆潮完全合乎決策官員的計畫。三十多年前，中國農民開始離開家鄉，遷往城市；現在，中國的經濟計劃官員卻希望他們大部分都回家去，定居在自己的村莊或中國政府認為人口需要成長的城市。在官員一廂情願的計畫中，這些返鄉人士回去之後會做一些小生意，會從事農產業、服務業，會買多年來過度建設造成的空置房產來住。不回去的，決策官員就給他們定了很高的標準，要他們好好接受教育，練得好技藝，從事高附加價值的服務業，譬如寫手機程式、從事電商等等。</p><p>至於製造業，當局憧憬的未來是工廠自動化，只雇用少數工人。中國官員有一項全國性大計畫，叫做「中國製造二○二五」，目標是推動製造業運用高科技生產產品。北京當局已經下令幾個省分和城市推動五年產業升級行動計畫，目標是生產線全面採用機器人。地方政府提供廠商補貼，鼓勵廠商盡速實施自動化。中國的鄰國日本人口同樣也在快速高齡化，中國的決策高官認為日本的製造業空洞化值得警惕，希望中國能夠避開這種命運，一方面繼續扮演「世界工廠」的角色，一方面成為全球的一股創新力量。製造業繼續用低薪雇請工人已經很難生存，這一個新的政策使他們只要致力於生產線自動化就好，不必再煩惱必須改善工人待遇、生活環境、工作環境等問題。</p><p>這一切政策全部都是為了要實現讓中國躍升為世界超級強權的計畫，其野心讓美國、日本、德國等許多國家為之駭然。美國總統川普屢次抨擊中國傷害美國企業及勞工。二○一七年美國商務部長羅斯（Wilbur Ross）訪問亞洲時曾說，中國對機器人及各種製造業的補貼損害了全球產業。</p><p>=&gt;  政府高官很清楚多年來的經濟成長模式已經持續不下去，國家必須轉換為一種依賴服務業以及人民消費力的經濟體。要做到這一點，必須讓千千萬萬農民及農民工 ── 為數將近中國人口的一半 ── 開始多賺錢，成為城市居民，亦即變成中產階級。</p><p>2023/2/4 发表想法<br>程序员新时代农民工是吧😢<br>=&gt;  在官員一廂情願的計畫中，這些返鄉人士回去之後會做一些小生意，會從事農產業、服務業，會買多年來過度建設造成的空置房產來住。不回去的，決策官員就給他們定了很高的標準，要他們好好接受教育，練得好技藝，從事高附加價值的服務業，譬如寫手機程式、從事電商等等。</p><p>=&gt;  在官員一廂情願的計畫中，這些返鄉人士回去之後會做一些小生意，會從事農產業、服務業，會買多年來過度建設造成的空置房產來住。不回去的，決策官員就給他們定了很高的標準，要他們好好接受教育，練得好技藝，從事高附加價值的服務業，譬如寫手機程式、從事電商等等。</p><p>=&gt;  製造業繼續用低薪雇請工人已經很難生存，這一個新的政策使他們只要致力於生產線自動化就好，不必再煩惱必須改善工人待遇、生活環境、工作環境等問題。</p><p>2023/2/4 发表想法<br>这是中国一直以来的竞争策略，由政府主导对产业的投资，确实闯出了一些厉害的产业但做了许多无效的投资，有功有过吧<br>=&gt;  中國對機器人及各種製造業的補貼損害了全球產業</p><p>=&gt;  中國對機器人及各種製造業的補貼損害了全球產業</p><p>=&gt;  隨著中國經濟發展放緩，政府對廠商提升技術的補貼措施、社會福利計畫等很容易就會取消。</p><p>=&gt;  這一套制度已經無法處理舊社會嚴重的不平等問題，反而把收入大部分都分配給比較富裕的都市人口。鄉村居民享有的社會服務確實已有相當改善，但還是遠遠低於城市居民享有的。</p><p>2023/2/4 发表想法<br>中国只有五到十年的时间了，靠房地产续命太久等大潮退去才知道谁在裸游<br>=&gt;  而是低端的，常常是有危險性的工作，譬如機車快遞員就是。令人擔憂的是，農業和工業的生產力雙雙下滑，表示中國的經濟即將停滯下來，陷入發展經濟學家所謂的「中等收入陷阱」，無法依靠以低薪工人為基礎的產業存續下去，但又無法轉型為依靠精密技術的高附加價值經濟。</p><p>=&gt;  而是低端的，常常是有危險性的工作，譬如機車快遞員就是。令人擔憂的是，農業和工業的生產力雙雙下滑，表示中國的經濟即將停滯下來，陷入發展經濟學家所謂的「中等收入陷阱」，無法依靠以低薪工人為基礎的產業存續下去，但又無法轉型為依靠精密技術的高附加價值經濟。</p><p>=&gt;  不過這項決策卻不像是務實追求經濟發展，而是為了國家的虛榮，所以用了大筆的補貼誘使外資前來貴州省這個偏遠的省城投資。</p><p>=&gt;  但是在這種資本密集型的經濟「榮景」之中，到底有什麼東西契合人民的需求，政府從來就沒說</p><p>2023/2/4 发表想法<br>可能是罗斯福也可能是昭和<br>=&gt;  中國的經濟成長將會嚴重遲緩下來，千百萬人民的期待將會落空，導致社會動亂。以經濟持續成長交換共產黨繼續保有統治地位，要結束這種交易，對中國的領導人而言當然是嚴重的挑戰。中國如何面對此一挑戰，對中國人民，對全世界都具有重大意義。</p><p>=&gt;  中國的經濟成長將會嚴重遲緩下來，千百萬人民的期待將會落空，導致社會動亂。以經濟持續成長交換共產黨繼續保有統治地位，要結束這種交易，對中國的領導人而言當然是嚴重的挑戰。中國如何面對此一挑戰，對中國人民，對全世界都具有重大意義。</p><h3 id="◆-第一章-沿海的工廠"><a href="#◆-第一章-沿海的工廠" class="headerlink" title="◆  第一章　沿海的工廠"></a>◆  第一章　沿海的工廠</h3><p>=&gt;  中國大量的農民工之所以會成為二等公民、生活之所以會那麼不安定，就是因為這個戶口登記制度。中國的工廠、工地、服務業等那麼多勞動者即使在城裡工作多年，最後仍然無法在當地定居，原因也是在這個戶口登記制。因為這個制度，他們享有的醫療保健品質非常低落。因為這個制度，他們常常骨肉分離，把孩子留在鄉下，在鄉下長大。這些小孩子的輟學率遠遠高於城市的小孩子。</p><p>=&gt;  毛澤東決定仿照蘇聯史達林的「大推進理論」（Big Push）設定中國的發展路徑，將重點放在工業化，不再追求農業與消費，這時他才發現必須要制定嚴格的制度，將龐大的農村人口保留在鄉村，不要進入城市</p><p>=&gt;  一九五九年，政府開始強制實施戶口登記制度。這一套制度非常嚴格，一方面自然抑遏了大部分的人口遷徙，一方面也確保了「農民起碼可以維生，又可以將鄉村資源挪作他用，以推動工業化」，</p><p>=&gt;  原本是關切國家主權和國家尊嚴，現在卻和經濟的民族主義掛鉤了</p><p>=&gt;  經由入世，中國不但同意向我們購買更多產品，而且也同意輸入民主最寶貴的價值之一，那就是經濟上的自由。個人要是不只有權夢想，而且有權實現夢想，他們就會要求更大的話語權</p><p>=&gt;  這一間展覽室是東莞台商和當地官員之間緊密關係的華麗「門面」。他們以各種方式表現這種關係，有時候很煩瑣，有時候很齷齪；</p><p>=&gt;  這種互相利用的關係能夠成立，主要是依靠源源不絕的溫馴農民工勞動力。在把台港澳商吸引到珠江三角洲的種種因素之中，其中最重要的就是低薪勞工，這一點當地高幹太清楚了。</p><p>=&gt;  我們必須確保我們的客戶廠裡有工人，不用給高得不合理的薪資。我們對他們的要求要合理</p><p>=&gt;  他們對工人設定了一套收費、扣錢、罰款的制度，目標無非就是盡量減少公司付給工人的薪資。這一來，工人的實薪原本就已經很微薄，現在又給扒了一層皮</p><p>=&gt;  我以前從來沒有聽過工人在工廠掙不到錢的！這真叫做『血汗工廠</p><p>2023/2/5 发表想法<br>野蛮生长的背后是某一阶层被夺取的养分，都知道西方原始资本的积累是抢劫落后地区人民，然而东方的原始资本积累却是抽刀砍向底层的同胞（虽然未必把底层当做是人更不用说同胞）<br>=&gt;  管理人員和工人之間的權力關係嚴重向前者傾斜，地方官員幾乎事事配合工廠管理幹部</p><p>=&gt;  管理人員和工人之間的權力關係嚴重向前者傾斜，地方官員幾乎事事配合工廠管理幹部</p><p>=&gt;  我們才剛開始插秧，她就走了。我想我的孩子要是在外面可以找到工作，那當然好；靠種田賺錢太難了</p><p>=&gt;  ；因為文吉還沒有來之前，工廠需要請兩名全職廚師，但是「現在他一個人全部搞定，而且從來沒有來不及開飯」。他的口氣十分肯定。「工人效率提高，我們就有辦法幫他調薪。」</p><p>=&gt;  這就是中國工人在工廠受到的待遇。政府官員覺得讓工廠老闆開心，他們就有聚寶盆。他們的態度是，找工人容易，找肯投資的老闆難。所以他們根本不管法令，才會這樣經常發生意外。</p><p>2023/2/5 发表想法<br>绷，不会要等到开始整顿公务员才会有一批声浪比较大的工人抗议吧<br>=&gt;  抗議大部分發生在受到朱鎔基整頓裁員政策影響的國有企業。但是國有企業以外的農民工，因為工資過低、工作環境危險，也跟著開始罷工</p><p>=&gt;  抗議大部分發生在受到朱鎔基整頓裁員政策影響的國有企業。但是國有企業以外的農民工，因為工資過低、工作環境危險，也跟著開始罷工</p><p>2023/2/6 发表想法<br>主人，奴才和奴隶才是这个社会的主要构成，放弃对明君清官幻想，一个没有纠错机制的系统毁灭与繁荣都与奴隶无关了<br>=&gt;  依照一九八二年制定的「城市流浪乞討人員收容遣送辦法」，警察拘留他是合法的。這一部法令實施以來，已經有無數民工被警察拘留，從未造成公眾騷動</p><p>=&gt;  依照一九八二年制定的「城市流浪乞討人員收容遣送辦法」，警察拘留他是合法的。這一部法令實施以來，已經有無數民工被警察拘留，從未造成公眾騷動</p><p>=&gt;  該名官員最不想要的，當然是有人要求總理說明他的政府要怎麼修改這個已經實施了幾十年的制度。他們根本不想改變這一種制度，因為這一種制度早已成了中國改革開放時代世界工廠製造業經濟的基石</p><h3 id="◆-第二章-工人的子女"><a href="#◆-第二章-工人的子女" class="headerlink" title="◆  第二章　工人的子女"></a>◆  第二章　工人的子女</h3><p>=&gt;  人民有信心，民族就有希望，國家就會強大</p><p>=&gt;  要讓孩子擠進城市學校幾乎是不可能的</p><p>2023/2/6 发表想法<br>积分制与积分落户<br>=&gt;  已經開始在實驗一種「記點制」，準備對一定數額的外地人提供「戶口」。按照計點制的規定，有意者若是累積到一定點數，就可以合法申請當地「居住許可」以及此項「許可」附帶的種種權益</p><p>=&gt;  已經開始在實驗一種「記點制」，準備對一定數額的外地人提供「戶口」。按照計點制的規定，有意者若是累積到一定點數，就可以合法申請當地「居住許可」以及此項「許可」附帶的種種權益</p><p>2023/2/6 发表想法<br>快乐教育是这样的<br>=&gt;  對美國人而言，這絕對是一記警鐘，其結果對我們每個人都構成了重大的挑戰，我們不能不處理這個殘酷的真相，以認真的態度面對美國人的教育</p><p>=&gt;  對美國人而言，這絕對是一記警鐘，其結果對我們每個人都構成了重大的挑戰，我們不能不處理這個殘酷的真相，以認真的態度面對美國人的教育</p><p>=&gt;  共產黨長久以來一直宣傳教育機會人人平等，但是中國教育制度不公平，其實早在建國之初就因刻意的政策而種下了根源。</p><p>=&gt;  要管住那些不聽話的省分，就必須加強控制他們的荷包</p><p>2023/2/6 发表想法<br>新中国的组织和集权方式只是几千年来封建帝国的延续罢了，可以说是将封建和资本缝在一起的官僚资本主义国家只是套上了共产主义和社会主义的皮，无论是其缔造者还是继任者都不是为了共产主义理想奋斗的人，更多是维护个人权威的独裁者和冷血的实用主义保守者<br>=&gt;  北京擔心對廣東等這種富裕的省分失去控制。這就是『中央再集權』的理論基礎。他們對地方財政施用的辦法就是讓歲入和歲出差距擴大。」13（在中國中央集權的政府體制之下，地方政府不得徵收自己的稅捐</p><p>=&gt;  北京擔心對廣東等這種富裕的省分失去控制。這就是『中央再集權』的理論基礎。他們對地方財政施用的辦法就是讓歲入和歲出差距擴大。」13（在中國中央集權的政府體制之下，地方政府不得徵收自己的稅捐</p><p>2023/2/6 发表想法<br>这个还真是冷知识<br>=&gt;  像「菸酒」和「研究」就同音不同義。據說中國的地方官員碰到人民申請批准開店開工廠時，常常會說：「（這個我們）研究研究！」他這個話的意思是說他要先研究看看再決定要不要批准，不過據說這也有可能是一句暗語，在向你示意說如果你送他菸酒，你申請批准的流程就會快一點。</p><p>=&gt;  像「菸酒」和「研究」就同音不同義。據說中國的地方官員碰到人民申請批准開店開工廠時，常常會說：「（這個我們）研究研究！」他這個話的意思是說他要先研究看看再決定要不要批准，不過據說這也有可能是一句暗語，在向你示意說如果你送他菸酒，你申請批准的流程就會快一點。</p><p>=&gt;  要讓這些住宿生不要製造問題，辦法之一就是把他們的時間排滿，不要讓他們有空閒</p><p>=&gt;  但是學生在城裡遭到驅逐，回流到鄉村學校之後，鄉村學校施教的卻還是以考試為導向的課程。顧靜華說，這一來就使返鄉學生處境更加不利19。前幾年在城裡上的寬鬆課程現在反過來變成了嚴重的問題</p><p>=&gt;  鄉村小孩不上學，其代價可能是中國經濟在二○三○年崩潰。只要還有四億人不認識字，不會寫字，中國就沒有辦法轉進為高工資高技術經濟</p><p>=&gt;  那一年，全中國各城市二十三歲的男性年輕人有百分之六十八完成了高中以上學業，但是在鄉村，這個數字只有百分之十三。但是，世界銀行經濟學家約翰．吉爾斯（John Giles）說，這麼多年來這種差距並沒有怎麼改變</p><p>=&gt;  最起碼的」教育，但這是因為他們想要培養好工人、好勞工，以利追求新經濟。但也就只有這樣了。政府教育是用來培養工人，不是培養公民的。</p><p>=&gt;  這就是當今中國農民工的父母那種失落之情的緣由，他們原本一直期待自己的孩子能夠生活好過一點。</p><p>=&gt;  根據中國國務院發布的實施準則，這些職業學校的經費由地方政府負責，但是職業學校可以申請低利貸款及優惠稅率。</p><p>=&gt;  中國的職業教育從來沒有做過評估，所以他們不知道這種事情。」校長也告訴我說：「這個問題非常嚴重，」有人來視察時，「他們就請人假裝學生，事後帶著補助款就不見了。</p><p>=&gt;  讓學生接受義務教育這一方面中國做得很好，但是，讓學生的教育程度齊平這一方面卻做得不好，尤其城鄉之間更是如此</p><p>=&gt;  不論是怎樣的改革，如果要成功，最基本的做法就是把那一道阻礙鄉村學生在城裡就學的圍牆推倒</p><p>2023/2/7 发表想法<br>😢<br>=&gt;  想到千千萬萬被萬惡的戶籍隔離政策永遠改變命運的孩子，想到一代又一代被萬惡的戶籍隔離制度傷害的中國人，想到那些無以計數的死在收容遣送路上的中國人，為消除中國特色的身分隔離政策，為中國數以千萬留守兒童爭取在父母身邊上學的權利，今天我站在被告席上，何止是無怨無悔，我是多麼的驕傲啊。推動教育平權，隨遷子女就地高考，呼籲官員財產公示，倡導大家堂堂正正做公民，在這荒誕的後極權社會，成了我的三大罪狀。如果執政者有一點點誠意把公民的憲法權利當真，我們當然無罪</p><p>=&gt;  想到千千萬萬被萬惡的戶籍隔離政策永遠改變命運的孩子，想到一代又一代被萬惡的戶籍隔離制度傷害的中國人，想到那些無以計數的死在收容遣送路上的中國人，為消除中國特色的身分隔離政策，為中國數以千萬留守兒童爭取在父母身邊上學的權利，今天我站在被告席上，何止是無怨無悔，我是多麼的驕傲啊。推動教育平權，隨遷子女就地高考，呼籲官員財產公示，倡導大家堂堂正正做公民，在這荒誕的後極權社會，成了我的三大罪狀。如果執政者有一點點誠意把公民的憲法權利當真，我們當然無罪</p><h3 id="◆-第三章-賤賣的土地"><a href="#◆-第三章-賤賣的土地" class="headerlink" title="◆  第三章　賤賣的土地"></a>◆  第三章　賤賣的土地</h3><p>=&gt;  中國共產黨本以打倒地主、還地於農起家，如今官員卻在土地「集體化」名義的掩護下，一面大肆霸佔民產、收刮農田，一面賤賣土地以圖開發。土地買賣之獲利占了全國地方政府每年收入的一半以上，同時，抵押土地導致的負債已趨近三十兆人民幣！荒唐的是，農民本身卻無法享有買賣土地的果實。</p><p>=&gt;  有鑑於貴州民性「謀反」的傾向，就有人發明了「三十年一小反，六十年一大反」這一句話來描述貴州人</p><p>=&gt;  貴州年輕人不再在家鄉偷竊、作亂，而是到廣東等繁榮的省分尋找希望。</p><p>=&gt;  中國當前的領導人也知道他們必須解決土地問題 ── 要處理好土地問題，提高土地生產力，讓農民有事做，要不然，中國的經濟發展不下去。</p><p>=&gt;  中國的農業供應量有限，但需求量卻開始在上升，所以他們只好往海外發展。但是我常常愛說這真的很諷刺，因為中國原本立國的原則是奪走地主的土地，但是現在卻要走出去，到世界各國去收購</p><p>=&gt;  毛澤東推動的農民革命，最後最大的受益人卻是城市和城市居民，不是鄉村。這種情形當時沒有人討論，一直到今天還是沒有人討論。一九四九年之後，鄉村群眾淪為二等公民，他們主要的功用就是在新的體制中養育城市。</p><p>=&gt;  要吃米，找萬里；要吃糧，找紫陽</p><p>=&gt;  你看到的都是表面。他們花錢把房子弄得漂漂亮亮，但是那個對農民沒有什麼幫助，也不會讓農民生活好過一點。那是表演用的，給你們這種人看，也讓領導來看看他們宣傳的東西。他們不管我們農民。那裡的事情和我們一點關係都沒有。我們很窮，日子很苦。</p><p>=&gt;  中國共產黨……實際上是中國唯一的地主。毛澤東在的時候，農民耕作的是『國有地』，所以農民就像是奴隸。到了後毛澤東時代，農民充其量也只是佃農</p><p>=&gt;  海南改革計畫主要分為兩個部分，一個是對眾多香蕉及芒果果農頒發使用證書，一個是將農民擁有使用權的年限從三十年延長到七十年。前者使地方政府較難將土地轉用於開發，後者則是使重獲信心的農業家願意投資能提高產量及收入的水利建設、新作物，與新耕做法。</p><p>=&gt;  今天，儘管農民不准買賣土地，但是土地買賣所得卻占全國數萬個縣、市、鎮、村政府每年歲入的至少一半以上。</p><p>2023/2/8 发表想法<br>公有制？国有制！<br>=&gt;  全世界沒有一個經濟體一直處在這種異常狀態中，一邊將土地收歸國有，一邊又轉賣出去，真的很虛偽。這是對國家經濟殺雞取卵的作法，永遠都不會持久。</p><p>=&gt;  全世界沒有一個經濟體一直處在這種異常狀態中，一邊將土地收歸國有，一邊又轉賣出去，真的很虛偽。這是對國家經濟殺雞取卵的作法，永遠都不會持久。</p><p>=&gt;  根據標普全球評等（S&amp;P Global Rating）計算，這筆負債總額，加上預算外赤字或隱藏性借款四十兆元（五點八兆美元），總共占中國GDP的百分之六十，「很驚人」。因為債務成長，因此就拿從土地方面來的歲入來付利息。物價下跌，財產值縮水又在全中國引發各地方政府一連串的債務違約。標普的一份報告說：「因為巨大的信用危機，潛在債務量形同一座冰山</p><p>=&gt;  一個體制這樣子剝削其中一半人口，中國的領導人也知道這個體制難以持久</p><p>=&gt;  人口是跟著一地區的工作機會及服務品質流動的</p><p>=&gt;  為了讓地方不再依賴土地收入，他們計劃另闢融資來源。城市將發行市政債券，提高水、電、取暖燃料費率，最後可能開始全國課徵財產稅（迄今為止，一些擁有多間房產的地方官員一直抗拒這項措施，成了這項措施實施的巨大障礙</p><p>=&gt;  土地換戶口」政策主要的目的並不是要滿足農民的心願。這個政策有兩個目的，一個是將農地轉為開發用地，讓很多地方官員、房地產公司發大財。這才是主要的關鍵目的。另外一個目的是，配合一項全國性的策略，將大嶺村改造成新「款」的大嶺村，將農民改造成城市人，躋身中產階級，日後好創造消費。</p><p>=&gt;  二十年來，中國的農村人口因其土地收益上的損失，總共短收兩兆元人民幣（三千兩百一十億三千四百萬美元），約占中國二○一三年GDP的百分之四。</p><p>2023/2/8 发表想法<br>世界上只有一种病那就是穷病<br>=&gt;  在中國農村，老人就連健康不佳，受到的醫療照護一樣比較少。」董祥祝說：「受得了痛，就不上醫院，太貴了。</p><p>=&gt;  在中國農村，老人就連健康不佳，受到的醫療照護一樣比較少。」董祥祝說：「受得了痛，就不上醫院，太貴了。</p><h3 id="◆-第四章-政權的打壓"><a href="#◆-第四章-政權的打壓" class="headerlink" title="◆  第四章　政權的打壓"></a>◆  第四章　政權的打壓</h3><p>=&gt;  我們的專政，叫做以工人階級領導的以工農聯盟為基礎的人民民主專政</p><p>=&gt;  工廠提供的勞動條件不管多差都得接受，然後卑微地利用現有任何手段要求老闆給予良好待遇。</p><p>=&gt;  對於勞動階級如此冷漠，相較於之前中國革命時共產黨對工人的態度，真是莫大的轉變。</p><p>=&gt;  中國的勞動階級絕大部分是由農民工組成，但是中國社會卻很看不起他們。有時候偶爾有些人虛情假意流露一點憐憫，但是絕大多數城市人對農民工只有鄙夷、憎恨。</p><p>=&gt;  光是有嚴格法規還是不夠，必須要能夠有效執行才有用</p><p>=&gt;  面對嚴格法令規定，他們開始鑽法律漏洞，繼續壓榨勞工。這樣想盡辦法，目標只有一個，就是保持原有的利潤</p><p>=&gt;  官員表面上要求廠商遵守新的法規，可是其實他們自己也是三心兩意。在地方上，政府官員不想讓投資者難過，因為他們畢竟帶來了稅收和就業機會。</p><p>=&gt;  認命的工人有助於維繫黨和城內人所做的交易，那就是，讓你所得增加，但是我要更加限制人權，禁止人民公開批評中國領導階層。聽話的工人曾經協助毛澤東進行中國的工業化，現在，他們卑微的身分則是快速推升經濟成長，提高新中產階級城市人生活水平的必需品。</p><p>2023/2/22 发表想法<br>燃料，耗材，人矿这就是历代以来中国老百姓的命运，与其祈求圣上开恩，不如去斗争去争夺本应属于自己的利益。当我们没什么可以失去的时候，我们将获得一切<br>=&gt;  他只說了一句：「他工作太累了，才會死掉。」這種聽天由命的態度就是共產黨要的。</p><p>=&gt;  他只說了一句：「他工作太累了，才會死掉。」這種聽天由命的態度就是共產黨要的。</p><p>2023/2/22 发表想法<br>有工可选这很重要，你不优待我有的是厂优待我。可如今各行业凋敝，很多人失去了选择，那个混乱的，黑暗的年代又会重新回来。所以，尽情享受巨轮沉没前的夕阳吧，大胆去爱大胆去恨大胆去选择，沉没后所有人一无所有<br>=&gt;  但是這種情形在二○○五年突然反轉，珠江三角洲、長江三角洲的工業區開始出現嚴重缺工現象。這有一部分是一胎化政策造成的結果。一胎化政策確實大大降低了中國人的生育率。不過還有一部分原因卻是需求遽增，也就是進入中國的製造商越來越多，不斷集中，其中包括在兩個三角洲以外地區設立工廠，這些製造廠全部都在競逐農民工。這就表示工人開始能夠有所選擇，薪資過低就換工作</p><p>=&gt;  但是這種情形在二○○五年突然反轉，珠江三角洲、長江三角洲的工業區開始出現嚴重缺工現象。這有一部分是一胎化政策造成的結果。一胎化政策確實大大降低了中國人的生育率。不過還有一部分原因卻是需求遽增，也就是進入中國的製造商越來越多，不斷集中，其中包括在兩個三角洲以外地區設立工廠，這些製造廠全部都在競逐農民工。這就表示工人開始能夠有所選擇，薪資過低就換工作</p><p>=&gt;  這一部勞動合同法有個漏洞，就是不管「派遣工」。因此地方政府一開始執行勞動合同法，各家公司就開始把全職工換成派遣工。</p><p>=&gt;  工廠老闆都很聰明。他們要是認為勞動合同看起來實在很花錢，一定會另外想辦法規避</p><p>=&gt;  中國政府大量裁撤國有企業之後，東北爆發了改革開放時代中國第一樁工人大規模抗議</p><p>=&gt;  這些策略包括找出抗議活動籌畫人，予以重刑懲罰，藉此嚇阻未來的抗議運動人士；譴責地方官員沒有適時排解雙方紛爭；丟一點錢給抗議群眾，聊表安慰之意。這樣的手法後來都依樣畫葫蘆，用在無數抗議事件之上。</p><p>2023/2/22 发表想法<br>为众人抱薪者，不可使其冻毙于风雪<br>=&gt;  我覺得他們真的很卑鄙。他們說我前途光明，不需要做這種工作。他們警告我要謹慎選擇工作和生活方式。你不希望做事情會後悔。他們還告訴我說張先生在做非法的事情，但是卻披著法律的外衣騙人</p><p>=&gt;  我覺得他們真的很卑鄙。他們說我前途光明，不需要做這種工作。他們警告我要謹慎選擇工作和生活方式。你不希望做事情會後悔。他們還告訴我說張先生在做非法的事情，但是卻披著法律的外衣騙人</p><p>=&gt;  他們花了很多時間要我不要幫裕元的工人，但是我告訴他們我沒有做錯什麼事，我其實是在協助解決罷工。</p><p>2023/2/23 发表想法<br>我们会坚持我们的权利<br>=&gt;  因為工廠管理員、地方官員、警察一起在看管工人。我們不管在廠裡做事還是在外面吃飯，都有人看著。前面有人看，後面也有人看，一直不離開。工廠門口也有人看。他們說要是我們不上工，就把我們抓走。但是（北京的）中央政府明明承諾我們會獲得適當對待。我們會堅持我們的權利</p><p>=&gt;  因為工廠管理員、地方官員、警察一起在看管工人。我們不管在廠裡做事還是在外面吃飯，都有人看著。前面有人看，後面也有人看，一直不離開。工廠門口也有人看。他們說要是我們不上工，就把我們抓走。但是（北京的）中央政府明明承諾我們會獲得適當對待。我們會堅持我們的權利</p><p>2023/2/23 发表想法<br>上面本意是好的，都是下面执行歪了😡<br>=&gt;  人民認為地方政府很腐敗，總是和工廠勾結，聯手壓榨勞工，謀取金錢利益。中央官員遠在北京，但肯定是站在工人這一邊的。他們要是知道工人受到這種待遇，一定會出面阻止。他們頒訂的法律不是說得很清楚嗎？但是，這種信心喊話，不管說多少次，始終讓我感到悲傷</p><p>=&gt;  人民認為地方政府很腐敗，總是和工廠勾結，聯手壓榨勞工，謀取金錢利益。中央官員遠在北京，但肯定是站在工人這一邊的。他們要是知道工人受到這種待遇，一定會出面阻止。他們頒訂的法律不是說得很清楚嗎？但是，這種信心喊話，不管說多少次，始終讓我感到悲傷</p><p>=&gt;  沒有一些『輸送帶』把先鋒隊和先進階級群眾連結起來，再把先進階級群眾和勞動群眾連結起來，就無法實現專政。</p><p>=&gt;  工業社會化之後，在很多工人眼中，工會（已經）變得沒有用處。」他說工會官員「和企業管理一個鼻孔出氣</p><p>=&gt;  中國大陸以外有很多機構會以贊助經費、策略訓練等方式支援中國境內的勞工運動</p><p>2023/2/23 发表想法<br>人民政府不服务人民，人大代表也不代表人民，工会也不对工人负责，他们只对赋予他们权利的人负责<br>=&gt;  工會必須帶領勞動群眾接受黨的領導。</p><p>=&gt;  工會必須帶領勞動群眾接受黨的領導。</p><p>=&gt;  警方指控我們企圖改變中華全國總工會。但是，這個所謂的『工會』有盡到自己的責任嗎？當然沒有！總工會不但沒有解決問題，只會跑出來作秀！我們訓練工人，幫助他們保護自己的權利，政府不做的事情我們來做。工會應該屬於勞工，為勞工做事。工會不是保護老闆利益的機關。</p><p>=&gt;  我去這裡的一個勞工組織找工作，才知道國保已經把我列入黑名單。他們告訴大家不可以雇用我。他們趕走了所有NGO的領導者，組織還在，但是集體談判這種重要的事情就沒辦法做，所以今天只好教一些飲食衛生課程。</p><p>2023/2/25 发表想法<br>不患寡而患不均<br>=&gt;  按照托克維爾所說，人民會起來不是因為貧窮，而是因為發現別人比我過得好而憤恨不平。你也知道我們的勞工是個大問題。他們覺得新中國遺棄了他們</p><p>=&gt;  按照托克維爾所說，人民會起來不是因為貧窮，而是因為發現別人比我過得好而憤恨不平。你也知道我們的勞工是個大問題。他們覺得新中國遺棄了他們</p><h3 id="◆-第五章-機器人是解藥還是毒藥？"><a href="#◆-第五章-機器人是解藥還是毒藥？" class="headerlink" title="◆  第五章　機器人是解藥還是毒藥？"></a>◆  第五章　機器人是解藥還是毒藥？</h3><p>=&gt;  武當山現在有九宮、八觀、三十六庵堂、七十二岩廟，三十九座橋貫通於峰谷之間，有時候稱之為「道教的搖籃」</p><p>=&gt;  這種生產力的分散反映了整個計畫中軍事方面的考量，建廠位置這樣的安排是希望把遭受空襲的損失降到最低</p><p>=&gt;  東風想製造比較好的卡車、汽車，就必須引進資本、技術、管理技能。要引進這些東西，最好的方法就是和外國汽車廠合作</p><p>=&gt;  中國當時所有的國有大公司存在的作用並非只是擔當「雇主」而已，東風自不例外。東風自己有醫院、學校，還有自己的報紙，甚至是電視台，還有東風警察局、消防隊。這些機構員工很多，但是從來沒有上過生產線替公司賺到一毛錢。苗圩說：「東風原來就是個小社會。」</p><p>=&gt;  把人和財產分開會造成社會不穩定。社會變動，每個人的利益都會受到影響，都要調整，自然會有的人滿意，有的人不滿</p><p>=&gt;  鴻海全球有百萬大軍，人也是動物，要管理一百萬動物，頭痛得要死</p><p>=&gt;  並不是薪水多少的問題，也不是工作環境，而是工作性質。不幸的是，不管我們怎樣努力，都沒辦法讓製造業變成輕鬆體面的工作，但是新一代的勞工卻希望這樣。</p><p>=&gt;  中國現在已經來到已故諾貝爾經濟學獎得主亞瑟．路易斯爵士（Sir Arthur Lewis）所謂的「路易斯拐點」」（Lewis turning point），它指的是來自農村的農民工越來越少所造成的勞動力短缺。</p><p>=&gt;  中國應對這項挑戰如果失敗，將會使中國陷入「中等收入陷阱」，亦即在低端產業已無競爭力，但又無法轉型為高附加價值產業</p><p>=&gt;  不過他的「供給側結構改革」卻和美國共和黨的版本不太一樣，偏重於關閉「殭屍」公司，給予有利的產業補貼</p><p>=&gt;  那時候的中國認為日本是個技術完全成功的國家，可是現在看這個島嶼鄰國，卻認為曾經主導全世界製造業的日本，現在已經因為工資上漲、勞動力老化而失去了這種權威，經濟也受到了打擊</p><p>2023/2/27 发表想法<br>他们所谓的用发展来解决发展中的问题，即通过机器淘汰低端劳工人口，制造一批不会再受生产社会压榨却也无法被消费社会认可的新穷人。这估计也是他们不重视公平的缘由，高估了技术研发的能力也低估了技术研发的难度，再加上三年疫情，这种大跃进式的工业变革自然是破产了。再加上劳工问题贫富差距的矛盾持续尖锐，他们10年前所担心的中等收入陷阱问题还是来了<br>=&gt;  短期而言，中國將面對多次震盪。但是再過二十年，年輕人會越來越少。利用機器人做產業升級，（目標）就是要克服這一點。我們和劉鶴碰面時，他就說他的看法是，自動化使中國得以征服未來。</p><p>=&gt;  短期而言，中國將面對多次震盪。但是再過二十年，年輕人會越來越少。利用機器人做產業升級，（目標）就是要克服這一點。我們和劉鶴碰面時，他就說他的看法是，自動化使中國得以征服未來。</p><p>=&gt;  到了二○二五年之時，「中國會完成的工業化基本上將相當於德國和日本工業化初期的水準。</p><p>=&gt;  二○○七至二○○八年全球金融危機之後，廣東省的出口經濟有將近五年時間一直苦於工資上漲之痛，本來已經危殆的經濟更加損耗。</p><p>=&gt;  他提出了一個名稱十分花俏的政策，叫做「騰籠換鳥」。在這項政策之下，他和一批副手開始鼓勵工廠放棄勞力密集、耗能、汙染性的產業，轉換成軟體、新能源、生技等乾淨的新產業。「騰籠換鳥」政策以減稅措施鼓勵新產業，以較為嚴格的勞動、環保法規對低利潤產業施壓</p><p>=&gt;  廣東省面臨的問題就是中國面臨的問題。我們必須尋找新的競爭力資源</p><p>=&gt;  一些產業顧問常說中國至今在機器人的「採用」方面還落在很多國家後面。眾多工廠長久以來已經習慣依靠廉價勞動力，現在要他們在自動機器方面投資，自然動作就很慢</p><p>=&gt;  迄於二○一七年為止，平均每一萬名工人只有九十七個機器人，相較於日本每一萬名工人有三百零八個，德國三百二十二，南韓七百一十，中國的九十七個實在很少。南韓是目前全世界自動化比率最高的國家。不過中國現在也在急起直追。二○一七年，中國購置了十三萬八千具機器人，比起前一年增加了百分之五十九，占全球總銷售量三分之一強</p><p>=&gt;  這個目標最大的挑戰在於要有公司能夠製造伺服馬達、驅動器、控制面板這三樣機器人核心零組件。目前中國為數約八百家機器人製造商大多數都是向發那科（Funac）、西門子等海外廠商購買。柴耀廷說：「中國機器人製造廠很多，但是技術都是來自日本、美國。中國人自己的機器人技術還很有限。</p><p>=&gt;  大家擔心的是中國公司。強打興奮劑會毀掉利潤，而且毀掉的不只是公司利潤，也毀掉整個產業的利潤。</p><p>=&gt;  中國這種推展自動化的速度將在二○三○年危及全中國四分之三的就業機會</p><p>=&gt;  「我們必須抑制機器人發展的速度，限制其方向，人類才能免於受到壞的影響。從人口學觀點說，現在的中國正在和時間進行兩種競賽。」確實，一方面勞動力持續在衰減，所以需要機器人來提高生產力；但是另一方面，中國卻必須「搞清楚人類優於機器人的部分，譬如情緒商數、判斷力或創意思考等等。這樣我們才能夠訂定計畫來補償最弱勢的一群人，也就是被機器人取代，無法再找到工作的那些人。</p><p>=&gt;  你一定要記住一件事。這些工人根本不想待在這裡。他們沒有想要那些工作。工人最不想要的就是做工廠工人。</p><h3 id="◆-第六章-回家的困難"><a href="#◆-第六章-回家的困難" class="headerlink" title="◆  第六章　回家的困難"></a>◆  第六章　回家的困難</h3><p>=&gt;  炳花村人幾百年來一直以農業為生，現在卻要開始轉型為以「現代服務業」為主的經濟型態。官方將貴州的旅遊業或貴州人自稱的「山地旅遊業」歸類為「現代服務業」</p><p>2023/2/27 发表想法<br>2022年中国人口开始负增长，人口最高点为14.12亿人<br>=&gt;  中國人口將在二○二九年達到最高峰十四億四千兩百萬人。這比原本的預期早了三年。中國人口預期將在二○五○年減至十三億六千萬人，一直到二○六五年將減至十一億七千萬人</p><p>=&gt;  中國人口將在二○二九年達到最高峰十四億四千兩百萬人。這比原本的預期早了三年。中國人口預期將在二○五○年減至十三億六千萬人，一直到二○六五年將減至十一億七千萬人</p><p>=&gt;  發展比較超前的華東固然一直是農民工離家外出最常去的目的地，但如今華西已經趕上來了。二○一七年，在內地省分就業的農民工占全部農民工的百分之二十點一，比前一年增加了百分之四點九；在華東工作的占百分之五十五點八，比去年僅僅上升百分之○點二。華中地區的成長率也超過了華東，在這裡工作的農民工占比二十點六，比前一年成長百分之二點九。在蓬勃發展的珠江三角洲，農民工人數則是減少了四十五萬人，相當於減少了百分之零點九。</p><p>=&gt;  服務業一般耗費的能源比較少，不像工廠那樣會破壞環境。相較於資本密集的製造業、建築營造業，在等量的GDP之下，服務業提供的就業機會比較多。依據大家都接受的經濟學理論，第三部門職業的薪酬也比較高（不過，中國後來實際的情形卻不是這樣）。果真如此的話，那麼一個偏重於服務業的經濟體將有助於國家達成「提振個人消費」這個目標。目前中國的個人消費還是偏低，約占GDP的百分之四十上下，和美國的百分之七十左右差距頗大。</p><p>=&gt;  這個政策和中國共產黨的很多政策一樣，又想要全面實施，卻又含糊籠統，一味認定城市化可以提振個人消費。</p><p>=&gt;  他們說他們要的是社會穩定，但是他們採取的大規模行動本質上就會造成社會不穩定。</p><p>=&gt;  在中國，人民之所以要遷居，原因在於要賺錢維生。哪裡的薪資好，有經濟利益，有就業機會，人就會往哪裡去。不過現在政府卻要阻止農民工遷移。政府不希望這些人分走經濟利益，所以就用戶口制度阻礙農民工，不讓他們自由遷居。</p><p>=&gt;  習近平在中共第十九次全國代表大會宣布「鄉村振興戰略」，其中最具體的政策就是將農村土地放租期延長三十年。這很明顯就是要誘導農民工回歸農村。</p><p>=&gt;  他一方面宣示說必須保衛「農村人民的財產權和利益」，但是另一方面卻又說「必須強化集體經濟」，實際上等於排除了所有賦予農民真正土地所有權的可能。</p><p>=&gt;  「我們要疏解北京非首都功能。」這就是宣示他仍然贊同削減城市人口</p><p>=&gt;  工人返鄉之後會創業，會購屋，進而振興遭人遺忘已久的社區，推動停滯已久的地方經濟。同時，正因為這些農民工不在城市了，中國各個擁擠的城市公路、醫院、學校的負荷將立即緩解。不過，農民工突然離開城市，城市居民一開始非常高興，但是不久就發現自己這個城市和居民有多麼需要農民工。城市裡很多餐館廚師、服務生、洗碗工、快遞員、「滴滴出行」（即中國版的Uber）司機、小商店老闆、髮廊業主、居家清潔員、保姆等等都需要農民工擔當。</p><p>=&gt;  中國國務院總理李克強從這本書獲得靈感，開始推行一個他稱之為「大眾創業、萬眾創新」的理論，其核心意旨是說只要鼓勵人民勇於冒險，自己創業，中國將會創造出一種可長可久的經濟成長模式，足以取代前此由國家支持，巨量投資的經濟型態以及現今極度衰敗的農業經濟型態。20若是適當搭配減稅、低利貸款、訓練課程等支持性措施，中國的農民工將會立刻開始在農村創業，為那些返鄉而急於享有城市生活水平的人服務。這樣就會形成良性循環，農民工回返農村，開始產生對貨品、服務的需求，後續又有人回來創業，為他們服務，地方經濟開始繁榮，然後又吸引更多人回來。</p><p>2023/2/27 发表想法<br>有没有这种可能以后中国的格局是欠发达地方生产，发达地区消费的内循环格局，外向型经济风光不再但是一旦可以提振国内消费将居民消费潜力释放出来未必不如外向型经济时代（前提是别让房地产出来作妖了）<br>=&gt;  「淘寶村」往往出現在城市外圍，幾間工廠群聚在一起，製造一樣的產品，通常是服飾、鞋、包。城市的工資上漲使得鄉村競爭力勝過沿海城市。網路的靈活性也使產地不一定要接近客源所在。訂單規模常常比較小，但整備時間比較快，證明這種小型生產工廠很適合電商企業。</p><p>=&gt;  「淘寶村」往往出現在城市外圍，幾間工廠群聚在一起，製造一樣的產品，通常是服飾、鞋、包。城市的工資上漲使得鄉村競爭力勝過沿海城市。網路的靈活性也使產地不一定要接近客源所在。訂單規模常常比較小，但整備時間比較快，證明這種小型生產工廠很適合電商企業。</p><p>=&gt;  「淘寶村」蔓延速度很快，具有振興中國廣大鄉村地區的潛能。</p><p>=&gt;  梯田製作過程很簡單，但很辛苦：先將山坡爆破，將那些岩石壓碎，堆成田埂，填土，開始種玉米（季間則是種植小麥、西瓜、菸草），然後挖蓄水池保存下雨時徑流水。一名地方官員解釋說：「我們用的是祖先的技術。」在貴州，要對抗貧窮，就必須和山丘進行殘酷的戰鬥。</p><p>=&gt;  貴州自然環境的特性以前一直使高端科技聞貴州而卻步，但是現在它們卻成了貴州得天獨厚之處。貴州經常下雨，連同雨水造成的湍急河水，成了豐富的水力發電資源。這表示貴州電力很便宜。這對必須以低溫保存資料的伺服器很有利。貴州地處偏鄉，所以土地也很便宜。當地的氣溫低意味著資訊廠房比較不需要空調。那些石灰岩山丘，雖然地質特殊，但現在卻有了用途。包括騰訊在內，一些IT公司買了巨大的伺服器要安裝在貴陽市外新開發的商業園區時，往往發現他們可以把那些天然的喀斯特山洞當作自然冷卻系統，把伺服器廠蓋在裡面。</p><p>=&gt;  農民工返鄉就業一方面有助於地方經濟成長，擴大稅基，促進市鎮發展，而且能夠幫助村人就業，帶領大家脫離貧窮。他們能夠及時照顧老人和小孩，有助於促進家庭和樂，小孩子就能夠健康快樂地長大。</p><p>=&gt;  由於現在貴州省政府正在推動計畫，要將貴州變成綠色旅遊區，所以要開工廠的話，將會很難獲得批准。不過路春卻在政府開始緊縮之前獲得了批准。他想要藉鋸木業多賺一點錢，然後把賺來的錢用在真正關心的事情上面，那就是炳花村的發展。</p><p>=&gt;  他們返鄉來讀初中、高中，但是卻受不了生活發生那麼大的變化，置身自己的故鄉感覺卻像異鄉人，常常中途輟學，沒有幾個人可以倖免。</p><p>=&gt;  「我已經夠窮了，像我這樣的人想回家鄉做生意的話，危險的地方在於生意失敗，然後變得更窮。」</p><p>2023/2/27 发表想法<br>在小型社会中人情关系决定你所处在的位置<br>=&gt;  農民工最大的問題是他們沒有技術沒有能力控制市場。在城市待了那麼久，在家鄉已經沒有什麼『關係』，碰到麻煩，他們不知道該去找什麼人。鄉下只能容納少部分人，工人回到家鄉不一定有辦法找到事做</p><p>=&gt;  農民工最大的問題是他們沒有技術沒有能力控制市場。在城市待了那麼久，在家鄉已經沒有什麼『關係』，碰到麻煩，他們不知道該去找什麼人。鄉下只能容納少部分人，工人回到家鄉不一定有辦法找到事做</p><p>=&gt;  跡象顯示這些「歸雁」並未完全順利安置。從貴陽要到炳花村的路上，我們經過了當地跨國技術公司漂亮的辦公室，看到巨大的廣告牌宣揚著「創新的光明未來，電商的新夢想」，之後路面開始縮小，路邊又開始出現破敗的農舍，成堆的垃圾，路上的狗骨瘦如柴，路旁牆壁上寫了一些標語勸告返鄉的人不要懶惰</p><h3 id="◆-第七章-即將到來的危機"><a href="#◆-第七章-即將到來的危機" class="headerlink" title="◆  第七章　即將到來的危機"></a>◆  第七章　即將到來的危機</h3><p>2023/2/27 发表想法<br>权利只对其权利来源负责，中国官员只需要对上级负责<br>=&gt;  一個人民所不能控制的權力能為人民服務是一個奇跡。奇跡可以有，但不能視作當然，所以為了要保證一個權力不能不向人民服務，還得先由人民控制住這權力，這才是政治上的常軌。</p><p>=&gt;  一個人民所不能控制的權力能為人民服務是一個奇跡。奇跡可以有，但不能視作當然，所以為了要保證一個權力不能不向人民服務，還得先由人民控制住這權力，這才是政治上的常軌。</p><p>=&gt;  北京五環路以內區域，二○一七年以來過年就禁止燃放鞭炮。上海、廣州後來也實施這種禁令，把中國最大節日弄得很沒有氣氛、了無生氣，感覺很奇怪。經濟衰退尤其加深了這種蒼涼感。</p><p>=&gt;  很幸運（這裡加了一個『笑臉』表情圖示）一切如常，『喝茶已經成了習慣』</p><p>=&gt;  事情的起源是二○一八年「佳士科技」（Jasic Technology）所屬的焊割機械製造廠拖欠工資，廠裡工人發動抗議，並且組織獨立工會，力圖保護自身利益。</p><p>=&gt;  十二月二十六日和五月一日這兩次擄人，前者是毛澤東生辰一百二十五週年，後者是中國及一些社會主義國家的國際勞動節，當局都沒有發現到這種很諷刺的巧合</p><p>=&gt;  。二○一七年，中國發生一千兩百二十五起工人抗議事件。二○一八年增加到一千七百多起，其中有很多是發生於服務業，包括成長很快，但很危險的新興產業快遞業。</p><p>=&gt;  大家驚愕於那樣的天文數字之餘，沒有討論到的卻是那公然的「同類相殘」效應。那就是，電商平台這一天銷售量的暴衝，不但奪走了平日的銷售量，而且還把其他購物中心、家庭式雜貨店等零售通路「開腸破肚」，使他們不得不解雇員工</p><p>=&gt;  大家看到的卻是雙十一的陰暗面。這一天，電商的送貨工人要傾全力送貨，送貨量是平日的五倍以上，而且常常要繳交三十元到兩百元不等的「送貨遲到」或「客訴服務不良」罰款10</p><p>=&gt;  他們這些司機其實和大電商公司沒有關係，因為他們是經由第三方公司雇請的司機，或者根本就是自由流動司機，所以不受勞動法規的保護，而且往往沒有簽勞動合同</p><p>=&gt;  但他們的勞動條件差也不是新鮮事，因為這種情形只是反映了中國新興的服務業大部分的職務都是「低薪、低技術」的職務。這是中國服務業的大趨勢</p><p>=&gt;  他們一開始就依照這種想像訂定全面職訓教育計畫。李克強二○一四年就曾經這樣說：「想像一下，如果中國的九億多勞動力大部分都學會了中端到高端技術，中國製產品的規模和水平會高到什麼程度。」</p><p>2023/2/27 发表想法<br>计算机技术赋能服务业？<br>=&gt;  電信、資訊技術、電腦、金融、企服等高端技術部門至今在整個服務業當中占比仍然不大；有一部分有在成長，但是成長速度不快。」</p><p>=&gt;  電信、資訊技術、電腦、金融、企服等高端技術部門至今在整個服務業當中占比仍然不大；有一部分有在成長，但是成長速度不快。」</p><p>=&gt;  劉鶴用「五六七八九」這一系列數字提綱挈領來描述民營企業在中國的重要性。這一個「五六七八九」說法指的是，現在全中國已經有百分之五十的稅收、百分之六十的全國GDP、百分之七十的創新產品、百分之八十的城市就業機會，乃至於百分之九十的全國有照公司，來於民營企業。</p><p>=&gt;  ，中小型民企雖說是很重要，但始終還是受制於不公平的制度。長久以來，銀行信貸、政府合同大部分都流向國有企業。這一點並不意外，因為銀行本身就是政府所有，很自然會貸款給國有公司。官員通常不願意看到國有公司破產，所以國有公司碰到難關時會來為他們紓困，使國有公司顯得較有吸引力。</p><p>=&gt;  李克強說，穩定的就業必須依靠數百萬家小型企業，金融機構的支持對於小型企業的發展不可或缺。他呼籲國有銀行為小型企業提供良好的服務，維持市場活力。</p><p>2023/2/27 发表想法<br>其实早在疫情前中国经济就已显疲态<br>=&gt;  中國經濟成長的速度，於二○一八年底來到了近十年來的最低點16</p><p>=&gt;  中國經濟成長的速度，於二○一八年底來到了近十年來的最低點16</p><p>=&gt;  世界銀行總裁金墉極力誇讚的「淘寶村」 ── 其中多數還是復歸為一九九○年代的「血汗工廠」型態：工人沒有簽勞動合同，強制長時間勞動，勞動條件有礙健康及安全。有個這種血汗工廠的老闆跟我說，新的生存策略就是「不要引起注意」。不引起注意，那些擠壓利潤的環保法規、勞動法規就管不到他們</p><p>=&gt;  中國不是全世界最不平等的社會之一，就是全世界最不均等的大經濟體</p><p>=&gt;  中國的財富不平等問題之嚴重程度約略相當於寡頭政治統治下的俄國，介乎法國和美國之間</p><p>=&gt;  中國的基尼係數（Gini coefficient，義大利統計學家柯拉多．基尼於一九一二年制定的「不平等」量測法）已經達到零點六一，是所有大經濟體當中最高的國家。一般認為一個國家基尼係數若是達到零點四，社會就會開始動亂</p><p>=&gt;  中國現在面臨的問題，主要是在貧富差距會不會拖垮該國的未來</p><p>=&gt;  。「庫茲涅茨曲線」是說，財富一開始會兩極化，但是等到富有者所創造的經濟利益散布到整個社會之後，兩極之間就會漸漸變得相等。</p><p>2023/2/27 发表想法<br>“社会火山之谜”是一种比喻，指的是一种社会现象，即当许多不满、愤怒、压抑的情绪积聚到一定程度时，就像一座火山即将爆发一样，社会也可能发生剧烈的动荡和变革。<br>这种现象通常与社会不公、贫富差距、政治腐败、权力集中、民主缺失等问题有关。当这些问题得不到解决，导致越来越多的人感到愤怒和不满，他们的情绪会逐渐积聚，最终可能引发社会的动荡和变革。<br>=&gt;  中國的弱勢者不會採取行動反抗「不平等」。這種情形，他用「社會火山之謎」（myth of the social volcano）這句話來形容其中的轉折、奧妙27</p><p>=&gt;  中國的弱勢者不會採取行動反抗「不平等」。這種情形，他用「社會火山之謎」（myth of the social volcano）這句話來形容其中的轉折、奧妙27</p><p>=&gt;  中國人會和同儕、友人比「命」好不好，但是不會和社會背景不一樣的人比「命」好不好。中國儘管始終是有錢人越來越有錢，但是窮人的生活確實也漸漸在改善，毋庸置疑。</p><p>=&gt;  人民的生活水平、教育程度提高之後，自然而然對政府的要求也將跟著嚴格起來。多年來，一些研究中國的社會學家、駐中的外籍記者都贊同這個理論，也預測說，中國如果發生革命，必定是起因於一批新興中產階級要求共產黨改革或讓位</p><p>=&gt;  中國的中產階級並沒有一些人以為的那麼激進，他們其實是一股保守力量，但這並不奇怪。她在一篇論文中論及她發現的觀點：「在專制獨裁國家，『報復』成本總是比較高。這意思就是說，收入、教育程度較高的人損失的會比收入、教育程度低的人多。換句話說，抗議行為在專制國家是高風險行為，一個人在社會階級上爬得越高，參與抗議活動的機會成本就越高。</p><p>=&gt;  一國公民加強問責（或開始出來抗議，有所要求）之時，這個國家就會開始民主化。但如果真是這樣，那麼這個理論顯然不適用於中國。我們發現的是，教育程度越高，越有錢，就越不會出來抗議。</p><p>=&gt;  但如果是換成極低薪勞工，甚至是遭解雇的工人出來抗議，這些人就不會有什麼好損失的。他們身為農民工，看得到城市人的生活方式，自己也親歷了遭受歧視的景況。</p><p>=&gt;  城市農民工的收入雖然平均是鄉村人的兩倍有餘，但是幸福感卻低於鄉村人。</p><p>=&gt;  勞動學者解釋說，抗議行動若要達到永久的效果，就必須各廠各地區串聯起來，以群體的力量展開真正全國性的運動。馬克思就說過，勞工一開始只是「階級自在」（class in itself），知道自己受到虧待而覺得忿忿不平。但是他們必須轉變為「階級自為」（class for itself），知道自己受到了歧視，和社會中其他人有別，然後戮力合作，一起努力改變自身集體的命運</p><p>=&gt;  中國的領導階層和人民一直有個默契，那就是，他們保證提高人民生活水平，普羅大眾則是容忍不民主、忽視民眾心聲的中共統治。</p><p>=&gt;  人民和領導階層原先的默契已經產生了致命的裂痕。不平等現象越來越嚴重，表示會有很大一部分的人口認為黨不再履行官、民默契中的另一半條款，因而起來要求改革</p><p>=&gt;  改革開放」無他，一言蔽之，只要政府不介入即可</p><p>=&gt;  二○一九年，中國經濟持續放緩，中國政府採取的措施和二○○八年全球金融危機以來，每逢經濟衰退所採取的措施如出一轍：他們下令國有銀行放款挹注經濟。</p><p>=&gt;  中國常年依賴現金資本流維持經濟活動，表示他們不斷把錢投入到一些不知道該如何用這些錢、不需要用這些錢的公司、經濟計畫上面。</p><p>2023/2/27 发表想法<br>总要素生产率」是一个经济学术语，它指的是在一定的生产要素（包括劳动力、资本、技术等）下，单位时间内生产的产品数量<br>=&gt;  總要素生產率」是一種估算經濟經營效率的方法。中國的總要素生產率在二○○七年前的十年間，平均每一年為百分之二點六，之後卻跌落至幾乎為零。原本生產率下降是經濟體成熟之後常見的事，但中國的生產率跌落卻來得很突兀，而且是跌落到比美國還低。美國在同一個時期從百分之一跌落到百分之零點五左右</p><p>=&gt;  總要素生產率」是一種估算經濟經營效率的方法。中國的總要素生產率在二○○七年前的十年間，平均每一年為百分之二點六，之後卻跌落至幾乎為零。原本生產率下降是經濟體成熟之後常見的事，但中國的生產率跌落卻來得很突兀，而且是跌落到比美國還低。美國在同一個時期從百分之一跌落到百分之零點五左右</p><p>=&gt;  改革開放使中國受益三、四十年，其中包括一九八○年代市鎮及鄉村小型企業開始繁榮，九○年代國有企業市場化，二○○一年加入世貿之後大量外資湧入中國</p><p>=&gt;  「中國如果要延續其生產力，必須在政策上做一番改革。</p><p>=&gt;  政府不斷利用國有企業刺激短期經濟活動，影響到了民企部門，造成生產力無力成長。」結果就是中國的「未來鎖進『經濟成長遲緩』景況將越來越緊」</p><p>2023/2/27 发表想法<br>开放的经济体制通常有利于创造高附加值经济，因为这种体制提供了更多的机会和资源，以支持企业和个人开发新的产品、服务和商业模式。以下是一些支持这个观点的原因：</p><p>更多的市场机会：开放的经济体制通常有更广阔的市场，这为企业和个人提供了更多的机会来销售他们的产品和服务。这使得他们能够更好地实现规模经济和范围经济，并且有更多的资本、技术和人才可以投入到生产和创新中。</p><p>更好的技术创新：开放的经济体制通常有更多的技术创新，这意味着企业和个人可以更轻松地访问新技术和知识，从而提高他们的生产效率和产品质量。开放的经济体制也有利于知识共享和技术转移，从而加速技术创新的速度。</p><p>更好的人才流动：开放的经济体制有利于人才的流动，使得企业和个人可以更轻松地吸引和留住高素质人才。这些人才能够为企业和个人提供更好的创新和竞争优势，从而帮助他们实现高附加值经济。</p><p>更好的投资环境：开放的经济体制通常具有更稳定的法律制度、更好的营商环境和更透明的市场规则，这为企业和个人提供了更好的投资环境。这使得他们更有信心在当地进行长期的投资，并在创造高附加值经济方面取得更大的成功。<br>=&gt;  中國想要擺脫勞力密集及低成本經濟，研發自有技術；這是創造高附加價值經濟的關鍵。但這必須要有個非常開放的體制才行。唯有體制開放，才會讓中國不再受制於嚴酷的檢查體制，開始和外界進行學術交流</p><p>=&gt;  中國想要擺脫勞力密集及低成本經濟，研發自有技術；這是創造高附加價值經濟的關鍵。但這必須要有個非常開放的體制才行。唯有體制開放，才會讓中國不再受制於嚴酷的檢查體制，開始和外界進行學術交流</p><p>=&gt;  缺乏高端技術工人已確認是中國發展『聰明製造』的主要障礙。」41中國以「戶口」制度限制人民遷移，加上經濟發展制度仍然有利於國有企業或國家附屬企業，不利於民營企業；這些都拖累了生產力。</p><p>=&gt;  美中貿易戰並非僅僅涉及關稅和貿易赤字，而根本是一場生存戰爭，因為中國想要取代美國，成為經濟及技術強權，所以華盛頓特區方面決心起來制止。但是中國面臨的挑戰並不只是讓外國企業繼續來中國投資，帶來技術，而且他們還要設法止住已經發生的企業外移情況</p><p>=&gt;  他們所持的理由，最大的一個就是美中貿易戰，其餘的還有土地和工資上漲、環保法規趨嚴等等。</p><p>=&gt;  中國如果要成為全世界的出口強國，高端電子供應鏈卻是關鍵所在</p><p>=&gt;  富士康會考慮到美國做重大投資，表示對於這一家台灣公司，以及許多世界性大廠而言，中國將會越來越不重要</p><p>=&gt;  中國的鄉村未來如果要有所發展，就必須賦予那些飽受歧視的赤貧農民自主選擇權。同時他認為，中國的學者如果真的要了解鄉村及其發展後路，中國的學術界就不該一體借用西方的理論，應該開闢自己的研究路徑</p><p>=&gt;  國的農村經濟一直是發展停滯。中國必須改革土地所有制，在農村一部分藉由小型家庭企業和小規模工業化 ── 或許再進一步組成合作社 ── 來發展地方經濟。他希望，藉由創立新企業而使農村經濟活絡起來，並因此把之前離鄉接受教育的村民吸引回來</p><p>2023/2/27 发表想法<br>该观点认为人们的行为是出于满足自己的需求，而不是出于社会责任感或对社会事务的贡献。然而，这种观点与中国共产党领导人的观点完全相反，因为中国共产党强调个人行为应该为了国家和社会的利益而服务。这表明该观点与中国共产党的价值观和理念不相符合<br>=&gt;  人的行為是為了滿足自己的需求，而非為了社會事務。這種觀點，後來發現果然和中國共黨領導人的觀點完全相悖。</p><p>=&gt;  人的行為是為了滿足自己的需求，而非為了社會事務。這種觀點，後來發現果然和中國共黨領導人的觀點完全相悖。</p><p>=&gt;  種差距很大一部分最後都可以追溯到仍然嚴格實施的戶口制度和土地所有制。這兩種制度一個限制了人民的居住地，一個限制了人民的土地使用權。</p><p>2023/2/27 发表想法<br>中國的领导层确实一直非常关注大规模、由上而下的政府建设项目，这种执政风格的辩证看待可以从以下几个方面进行分析：</p><p>优点和成功之处</p><p>这种由上而下、政府强制执行的建设模式在某些情况下是非常有效的。例如，中国政府在过去几十年中成功地实施了一系列大型基础设施建设项目，包括高速公路、高速铁路、桥梁、隧道、机场等。这些建设项目为中国的经济发展和城市化进程做出了重要贡献。此外，这种政府主导的建设模式也有助于确保建设项目的质量和安全，以及统一规划和协调。</p><p>缺点和挑战之处</p><p>然而，这种由上而下、政府强制执行的建设模式也存在着一些缺点和挑战。首先，这种模式容易忽略民间意见和需求，可能导致一些建设项目的实际效果与社会需求脱节。其次，由于政府对建设项目的控制过于集中，可能会导致腐败和浪费的问题。第三，这种模式可能会破坏生态环境和文化遗产等方面的价值，给当地居民带来负面影响。</p><p>探索多元化的治理模式</p><p>面对这些挑战，中国的领导层需要更多地探索多元化的治理模式，尤其是在环境、社会和文化等方面的可持续发展问题上。这需要政府更多地倾听公众意见，更加注重民间参与和社区治理，建立更加开放、透明和负责任的决策机制。同时，也需要更多地探索市场化和民间资本参与的方式，鼓励社会资本的投入和创新，实现政府和市场的有机结合。<br>=&gt;  中國的領導階層始終很執著於巨大的、由上而下，政府強制執行的建設方案。</p><p>=&gt;  中國的領導階層始終很執著於巨大的、由上而下，政府強制執行的建設方案。</p><p>=&gt;  這個「大灣區」據說將成為全世界最大的經濟發展特區，最後且將在創新及技術輸出方面超越美國矽谷。至於整個區域之內各種法規、法令、海關檢查、貨幣等等要如何整合，經濟計畫官員卻沒有說（</p><p>=&gt;  些遷置措施，有的是出於利益動機，因為地方官員想把空出來的土地改建為工業區或商業住宅區。但是新的遷置區是不是生活方便、經濟會不會衰退，沒有人知道</p><p>=&gt;  中國西部可能到處都是一些大型的密集安置地，其中多數都沒有就業機會，所以很可能還是回復成過去的窮途潦倒。他們以前住在偏遠地區稀疏的村落當中，不論如何都還可以依靠農作維生，但是現在住在這些新建的社區，除了依靠國家救濟，完全沒有謀生手段</p><p>=&gt;  要是機器人取代了工人，然而工人又沒有土地可以回歸，中國的城市很快就會出現貧民窟和嚴重社會問題。</p><p>=&gt;  著戶口身分改變而來的向上流動會提升公民對政府的信任。這表示，只要向上流動的途徑還是開放的，中國近年經濟成長趨緩的情勢就不至於立即引發政治動亂</p><p>=&gt;  中國經濟發展停滯或發生更嚴重的情況，對全世界都不是好事。有人說，中國的不幸就是其他國家的好運，這種說法常常到最後是兩邊落空。中國的就業機會枯竭，東南亞國家也許就跟著出現新的就業機會，但是西方國家不會。強大的中國對自由價值構成了威脅，但是中國如果受傷，全世界的經濟成長也將跟著受到拖累。已開發國家的經濟發展趨緩之際，美、歐、日等國跨國公司對迅速崛起的中國就依賴日甚</p><p>2023/2/27 发表想法<br>我们没有消费<br>=&gt;  這種看漲不看跌的預測，背後的假設就是中國會有越來越多的鄉村人變成都市人，生活改善，變成了永遠增長，快樂消費的資產階級。</p><p>=&gt;  這種看漲不看跌的預測，背後的假設就是中國會有越來越多的鄉村人變成都市人，生活改善，變成了永遠增長，快樂消費的資產階級。</p><p>2023/2/27 发表想法<br>本书大部分的预测都一一验证了，一旦内部经济崩溃中国会走上和俄国一样的侵略之路<br>=&gt;  要是大部分中國人民都看到自己生活水平驟然下跌，會在已經無所不在的階級鴻溝上雪上加霜，引發更大的動亂。沒有新聞報導自由、沒有反對黨、沒有正常的選舉，人民除了上街，沒有宣洩的出口。鑑於中國共產黨長久以來的表現就是一感受到威脅，就不惜殘酷鎮壓，所以它也有可能認為光是內部鎮壓還不夠。面對國內各界發出的異議，擁有強大軍力的中國共產黨可能會設法分散其公民的注意力，出兵攻打區域內的香港、台灣、南海等熱點。</p><p>=&gt;  要是大部分中國人民都看到自己生活水平驟然下跌，會在已經無所不在的階級鴻溝上雪上加霜，引發更大的動亂。沒有新聞報導自由、沒有反對黨、沒有正常的選舉，人民除了上街，沒有宣洩的出口。鑑於中國共產黨長久以來的表現就是一感受到威脅，就不惜殘酷鎮壓，所以它也有可能認為光是內部鎮壓還不夠。面對國內各界發出的異議，擁有強大軍力的中國共產黨可能會設法分散其公民的注意力，出兵攻打區域內的香港、台灣、南海等熱點。</p><p>2023/2/27 发表想法<br>這段話背景是指馬克思的一個著名預言，即如果中國社會的矛盾和壓力得不到解決，就會爆發社會動亂。具體來說，馬克思認為，中國是一個傳統社會，其社會矛盾和壓力來自於貧富差距、地主階級和農民階級的矛盾、中央政府和地方政府的矛盾等。如果這些問題得不到解決，就會導致社會動亂，甚至革命。</p><p>在此背景下，這句話的意思是指，如果中國發生動亂，就會對現行的產業制度造成沉重的負擔。這是因為，中國是一個重要的生產和出口國家，其產業制度已經和全球市場密切結合，如果中國發生動亂，將會對全球產業鏈和貿易體系造成重大的影響。同時，中國的經濟發展和穩定也是全球經濟穩定的重要因素之一，如果中國發生動亂，也會對全球經濟造成不利影響。<br>因此，這句話的含義是，如果中國不能解決其內部矛盾和問題，就可能導致社會動亂，進而對全球產業和貿易體系產生重大影響，進一步影響全球經濟的穩定和發展。<br>=&gt;  馬克思早就預言，一個輸出「動亂」的中國將會「把火花丟進現行產業制度負荷過重的地雷當中。」</p><p>=&gt;  馬克思早就預言，一個輸出「動亂」的中國將會「把火花丟進現行產業制度負荷過重的地雷當中。」</p><p>=&gt;  放鞭炮一方面是滿足傳統上驅鬼求運的意思，一方面農民工也在藉此向家鄉的親友以及其他返鄉者表現自己在外面混得不錯。你放炮放得多，表示你有錢 ── 這是一個大家都沒有說出口的意思；</p><h3 id="◆-後-記-精準扶貧還是精準控制？"><a href="#◆-後-記-精準扶貧還是精準控制？" class="headerlink" title="◆  後　記　精準扶貧還是精準控制？"></a>◆  後　記　精準扶貧還是精準控制？</h3><p>=&gt;  不過，真的到了二○四九年之時，共產黨是不是還存在並不清楚。前蘇聯就是一例。前蘇聯原來也是一直顯得很穩定，像是將會長長久久，但是卻在其七十五週年前不久瞬間解體。</p><p>=&gt;  中國若想安度下一個十年，中共必須在「壓制和回應」（repression and responsiveness）之間尋求一種平衡。中國官吏長久以來就一直接使用「壓制與回應」為統治手段，一手安撫人民，一手控制人民。所以中國政府常常一方面設法提高人民生活水平，另一方面則嚴酷鎮壓異議言論及抗議活動。但中國政府以這種手法對付農民工的歷史尤其長久</p><p>=&gt;  一方面公開譴責工廠幾個資深管理人員，承諾查辦腐敗失職的地方官員，補發工資以及失業救濟給失業的工人，另一方面卻以嚴酷徒刑懲罰罷工領導人，藉此對另外一些想要推動抗議活動，爭取自身權益的工人發出警告。這種「胡蘿蔔加棍子」的兩面手法始終是官方處理勞工問題「操作手冊」中的一部分</p><p>=&gt;  政府大量收集人民個人資料的結果，漸漸的，村莊裡每一戶人家的門口開始貼上了條碼，任何人若是想知道這一家人的事情，只要用手機掃一下這個條碼，就可以看到該戶全部資料。7也有貧戶因為不願意向官員透露自己不光彩的事情，或是不願意鄰居知道，只好選擇退掉救濟資格</p><p>2023/2/27 发表想法<br>民粹主義運動的出現往往與一些較長期的社會和經濟趨勢密切相關，例如全球化和技術進步帶來的經濟不平等、移民潮和文化衝擊所帶來的社會不安全感等等。在這些趨勢的背景下，一些政治人物和團體開始利用民粹主義的話語和手段來滿足民眾的情感需求，進而獲得選民的支持。<br>然而，民粹主義運動也存在著一些負面的影響。例如，這些運動往往強調民族主義和排外思想，會對社會的多元性和包容性造成威脅。同時，民粹主義者往往缺乏長遠的政策和視野，容易陷入短視和情緒化的決策中，導致政策的不穩定和不可持續性。<br>=&gt;  由於經濟與社會的不公平，當前全世界各地民粹運動正方興未艾，造成了一些大家意想不到的結果，譬如英國脫歐、右翼政客在北歐贏得選舉、川普主義（Trumpism）造成美國社會及政界的分裂及退化等等。</p><p>=&gt;  由於經濟與社會的不公平，當前全世界各地民粹運動正方興未艾，造成了一些大家意想不到的結果，譬如英國脫歐、右翼政客在北歐贏得選舉、川普主義（Trumpism）造成美國社會及政界的分裂及退化等等。</p><p>=&gt;  中國的領導階層占盡「一黨統治」的便宜，為了加強控制，推出的政策即使充滿爭議亦無所謂。但也正是一黨統治，所以也很脆弱，老百姓不管碰到什麼問題都怪罪共產黨。中國多年來經濟的快速成長要歸功於他們，生活水平降低一樣要抨擊他們治理無方</p><p>=&gt;  中國共產黨給的紅蘿蔔不夠，棍子卻不堪忍受呢？那中共要怎麼辦？黨要如何面對持續不墜的反黨統治運動？黨最後還會在嗎？會不會影響中國日後經濟及政治的崛起？中國共產黨憑藉「人民」的名義統治中國，前此數十年的經濟發展模式使中國強盛起來，但是卻未能為全國半數「人民」提供公平的機會，還把他們排除在其所憧憬的未來中國藍圖之外。值此中國共產黨正在努力改變此一經濟發展模式之際，他們不能不正視上述這些迫切的問題</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.fosu.gq/Autovy/ImageExpand/master/img202303262232750.jpg&quot; alt=&quot;低端中國：黨、土地、農民工，與中國即將到來的經濟危機|讀書共和國網路書店&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://autovy.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="经济" scheme="https://autovy.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
      <category term="中国" scheme="https://autovy.github.io/tags/%E4%B8%AD%E5%9B%BD/"/>
    
      <category term="工人" scheme="https://autovy.github.io/tags/%E5%B7%A5%E4%BA%BA/"/>
    
      <category term="城市" scheme="https://autovy.github.io/tags/%E5%9F%8E%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|MySQL最佳实践</title>
    <link href="https://autovy.github.io/2022/02/25/DevPrinciple/MySQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://autovy.github.io/2022/02/25/DevPrinciple/MySQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-02-25T15:45:00.000Z</published>
    <updated>2022-10-25T08:48:30.249Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203041310207.png" alt="image-20220304131032975" style="zoom: 33%;"><p>MySQL  ❎</p><p>OurSQL ✅</p><span id="more"></span><h3 id="Debain安装MySQL"><a href="#Debain安装MySQL" class="headerlink" title="Debain安装MySQL"></a>Debain安装MySQL</h3><h4 id="添加-MySQL-存储库"><a href="#添加-MySQL-存储库" class="headerlink" title="添加 MySQL 存储库"></a>添加 MySQL 存储库</h4><p>MySQL 服务器包可通过其官方存储库获得。 因此，我们现在将下载并安装 MySQL 存储库安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.18-1_all.deb</span><br></pre></td></tr></table></figure><p>使用 <code>dpkg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config_0.8.18-1_all.deb</span><br></pre></td></tr></table></figure><p>进入mysql安装页面选择ok即可</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203021941621.png" alt="image-20220302194144873"></p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><p>等待存储库配置完成，然后使用 apt 命令更新存储库索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>安装mysql服务器</p><p>使用apt-get install mysql-server安装时，如果出现报错Package ‘mysql-server’ has no installation candidate，可以使用下面的命令进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>理论上这时候的mysql服务已经安装完成了，我们可以通过命令service –status-all 查看到服务列表中有mariadb</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203021949399.png" alt="image-20220302194955961"></p><p>但是使用mysql命令时，会出现以下报错，这是因为mariadb服务还未启动</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203021952567.png" alt="image-20220302195236210"></p><p>使用以下命令启动即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mariadb start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203021955103.png" alt="image-20220302195514826"></p><h3 id="命令行准备数据库"><a href="#命令行准备数据库" class="headerlink" title="命令行准备数据库"></a>命令行准备数据库</h3><h4 id="root账号进入数据库"><a href="#root账号进入数据库" class="headerlink" title="root账号进入数据库"></a>root账号进入数据库</h4><p>mysql命令进入mysql服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br></pre></td></tr></table></figure><p>修改root账号密码</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022003140.png" alt="image-20220302200352926"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password for root@localhost &#x3D; password(&quot;123456&quot;)</span><br></pre></td></tr></table></figure><p>退出mysql服务，并使用root账号登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022006437.png" alt></p><h4 id="新用户与新数据库"><a href="#新用户与新数据库" class="headerlink" title="新用户与新数据库"></a>新用户与新数据库</h4><p>创建新数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database testdb;</span><br></pre></td></tr></table></figure><p>查看已有数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022010700.png" alt="image-20220302201054361"></p><p>创建新用户</p><p>@localhost设置只允许用户本地登录，并设置其密码为123456</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user aut@localhost identifide by &#39;123456&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022015408.png" alt="image-20220302201501975"></p><p>查看用户列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user for mysql.user</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022018844.png" alt="image-20220302201847575"></p><p>分配新数据库给新用户</p><p>注意这里是指将testdb库的所有表（testdb.*）的所有权限（all）给aut本地使用（localhost）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on testdb.* to aut@localhost;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022027073.png" alt="image-20220302202739833"></p><p>查看用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for aut@localhost;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022031370.png" alt="image-20220302203155016"></p><h4 id="测试数据准备"><a href="#测试数据准备" class="headerlink" title="测试数据准备"></a>测试数据准备</h4><p>使用新用户aut连接mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u aut -p</span><br></pre></td></tr></table></figure><p>切换数据库到新数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use testdb;</span><br></pre></td></tr></table></figure><p>创建一个只含一个字段的数据表</p><p>test表只含有一个整型不为空的字段money</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table test (money int not null)</span><br></pre></td></tr></table></figure><p>添加一条数据到表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test(money) values(5000) </span><br></pre></td></tr></table></figure><h3 id="MySQL事务隔离实验"><a href="#MySQL事务隔离实验" class="headerlink" title="MySQL事务隔离实验"></a>MySQL事务隔离实验</h3><p>新开一个终端使用连接上新数据库testdb（可以aut，也可以自己新建一个用户）</p><h4 id="读未提交级别"><a href="#读未提交级别" class="headerlink" title="读未提交级别"></a>读未提交级别</h4><p>出现脏读问题</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022050355.jpeg" alt="img"></p><h4 id="读已提交级别"><a href="#读已提交级别" class="headerlink" title="读已提交级别"></a>读已提交级别</h4><p>避免脏读，但是不可重复读</p><h5 id="1-避免脏读测试"><a href="#1-避免脏读测试" class="headerlink" title="1.避免脏读测试"></a>1.避免脏读测试</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022051306.jpeg" alt="img"></p><h5 id="2-不可重复读测试"><a href="#2-不可重复读测试" class="headerlink" title="2.不可重复读测试"></a>2.不可重复读测试</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022051474.jpeg" alt="img"></p><h4 id="可重复读级别"><a href="#可重复读级别" class="headerlink" title="可重复读级别"></a>可重复读级别</h4><p>可以重复读，并且可以防止幻读</p><h5 id="1-可重复读测试"><a href="#1-可重复读测试" class="headerlink" title="1.可重复读测试"></a>1.可重复读测试</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022052001.jpeg" alt="img"></p><h5 id="2-防止幻读测试"><a href="#2-防止幻读测试" class="headerlink" title="2.防止幻读测试"></a>2.防止幻读测试</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022052706.jpeg" alt="img"></p><h3 id="MySQL优化实验"><a href="#MySQL优化实验" class="headerlink" title="MySQL优化实验"></a>MySQL优化实验</h3><p>上面的实验全程在Linux环境中，在日常开发中我们可以使用数据库可视化工具如Navicat或IDEA自带的数据库工具，下面我主要使用Navicat进行操作</p><p>此章节的优化实例来自一次对学校校团委物资管理系统的维护，鉴于此项目糟心的数据库设计，给我留下了深刻的印象，难以想象的是这样的项目竟然从16年运行至今</p><h4 id="T-SQL脚本分表优化"><a href="#T-SQL脚本分表优化" class="headerlink" title="T-SQL脚本分表优化"></a>T-SQL脚本分表优化</h4><h5 id="1-相关表的结构"><a href="#1-相关表的结构" class="headerlink" title="1.相关表的结构"></a>1.相关表的结构</h5><p>此处展示的表结构为维护前</p><p>物资申请表：共4817条数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031543098.png" alt="image-20220303154338625"></p><p>物资信息表：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031545235.png" alt="image-20220303154513022"></p><p>goods_count：当前仓库物品数（物理的）</p><p>good_leftCount：当前物品可借数（网络的：存在部分未借出，但已被预订仍在审核中的物品）</p><h5 id="2-优化思路：物资申请表分表"><a href="#2-优化思路：物资申请表分表" class="headerlink" title="2.优化思路：物资申请表分表"></a>2.优化思路：物资申请表分表</h5><p>从上面的tw_apply表就可以知道：</p><ul><li><p>在用户提出申请后，物资申请信息被后端拼成了一个字符串存储在apply_content（同时利用了前端的数据执行了物品可借数的预扣除，所以这部分没有用到物资申请信息字符串的解析）</p></li><li><p>通过审核后，物品正式借出，这时候只留有物资申请信息的字符串存储在数据库，所以需要后端对该字符串解析提取出申请物资与其借用数量，再去操作数据库</p></li></ul><p>还好后端大哥没有把物资申请信息的字符串直接发给前端，我真的哭死，设计数据库的那个出来挨打（前端不需要解析，但是要拼接展示字符串）</p><p>数据库设计十分不合理，甚至不符合第一范式，<strong>浪费数据库大量存储空间</strong>不说，而且后端拼接字符串解析字符串这一过程<strong>十分耗时且占用内存</strong>，而且最新的需求是需要增加一个审核过程申请物资调整功能</p><p>所以我将物资申请表进行分表（水平分表），分出物资申请详情表并联系物资信息表，其结构如下</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031646110.png" alt="image-20220303164602406"></p><p>删除掉apply_content字段，节省数据库空间</p><p>分表后，通过tw_applydetail表，我们对物资申请信息的所以内容进行操作，省去了物资审核接口对字符串解析的耗时过程并且方便审核过程申请物资调整功能的开发（通过tw_appdetail找到物品信息和物品数量）</p><h5 id="3-优化操作：存储过程脚本"><a href="#3-优化操作：存储过程脚本" class="headerlink" title="3.优化操作：存储过程脚本"></a>3.优化操作：存储过程脚本</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象</p><p>这里值得注意的是在遍历游标的循环中，如果查询不存在或为空会跳出循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`Autovy`@`localhost` <span class="keyword">PROCEDURE</span> `demo`()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 定义变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n TINYTEXT;</span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"> # 求分割符号<span class="string">&#x27;,&#x27;</span>的位置</span><br><span class="line"><span class="keyword">DECLARE</span> _index <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息</span><br><span class="line"><span class="keyword">DECLARE</span> str TINYTEXT;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息长度</span><br><span class="line"><span class="keyword">DECLARE</span> strLength <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"># 物品名称</span><br><span class="line"><span class="keyword">DECLARE</span> goodName <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"># 物品数量</span><br><span class="line"><span class="keyword">DECLARE</span> goodCount <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"># 物品id</span><br><span class="line"><span class="keyword">DECLARE</span> goodId <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义游标，并将sql结果集赋值给游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> apply_id1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id, apply_content <span class="keyword">FROM</span> tw_apply <span class="keyword">WHERE</span> apply_content <span class="keyword">LIKE</span> &quot;本部%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明当游标遍历完后将标志变量置成1</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> s<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> apply_id1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将游标中的值赋值给变量，注意：变量名不要和返回列名同名，变量顺序要和sql结果顺序一致</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当s != 1,一直循环</span></span><br><span class="line">while s<span class="operator">&lt;&gt;</span><span class="number">1</span> do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过;分割单个物品的申请信息：北院—帐篷物品1个;北院—椅子物品1个;北院—桌子物品1个;</span></span><br><span class="line">while _index <span class="operator">&gt;</span> <span class="number">0</span>  do</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到单个物品申请信息：本部——桌子物品1个</span></span><br><span class="line"><span class="keyword">SET</span> str <span class="operator">=</span> <span class="keyword">LEFT</span>(n, _index<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> strLength <span class="operator">=</span> LENGTH(str) <span class="operator">/</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品名称</span></span><br><span class="line"><span class="keyword">SET</span> goodName <span class="operator">=</span> <span class="keyword">LEFT</span>(str, strLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品个数(类型转换为整数)</span></span><br><span class="line"><span class="keyword">SET</span> goodCount <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="keyword">LEFT</span>(<span class="keyword">RIGHT</span>(str, <span class="number">2</span>), <span class="number">1</span>) <span class="keyword">AS</span> signed) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> goodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按物品名称查到物品id并存储到goodId中</span></span><br><span class="line"><span class="comment">-- 这里如果查询不存在或为空会跳出游标循环，值得注意</span></span><br><span class="line"><span class="keyword">SELECT</span> goods_id <span class="keyword">into</span> goodId <span class="keyword">FROM</span> tw_goods <span class="keyword">WHERE</span> goods_show <span class="keyword">LIKE</span> goodName <span class="keyword">ORDER</span> <span class="keyword">BY</span> goods_count <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> tw_applydetail(apply_id, good_id, count) <span class="keyword">VALUES</span> (m, goodId, goodCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移动到下个分界点</span></span><br><span class="line"><span class="keyword">SET</span> n <span class="operator">=</span> SUBSTR(n <span class="keyword">FROM</span> _index<span class="operator">+</span><span class="number">1</span>);</span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行业务逻辑</span></span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取下一条数据，读取完成置变量s=1</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">close</span> apply_id1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>当时经过一天的对存储过程的学习，我总结出了以下经验：存储过程非常不方便调试，而且报错信息只定位不报错误类型（sql是这样的）。如果能重来，对数据库的批量操作，首选Python或Shell</p><h5 id="4-优化结果"><a href="#4-优化结果" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>截至目前物资申请表已有4817条数据，考虑到后面数据会长期积累，这样的优化是有必要的</li><li>去掉后端耗时耗内存的字符串解析工作</li><li>节省数据库存储空间，优化前申请表内存占0.79MB，优化后占0.56MB</li></ul><p>另外附加一个容量查询小工具，可查询数据库各表容量大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">table_schema as &#39;数据库&#39;,</span><br><span class="line">table_name as &#39;表名&#39;,</span><br><span class="line">table_rows as &#39;记录数&#39;,</span><br><span class="line">truncate(data_length&#x2F;1024&#x2F;1024, 2) as &#39;数据容量(MB)&#39;,</span><br><span class="line">truncate(index_length&#x2F;1024&#x2F;1024, 2) as &#39;索引容量(MB)&#39;</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema&#x3D;&#39;bgs&#39;</span><br><span class="line">order by data_length desc, index_length desc;</span><br></pre></td></tr></table></figure><h4 id="索引优化查询"><a href="#索引优化查询" class="headerlink" title="索引优化查询"></a>索引优化查询</h4><h5 id="1-相关表结构"><a href="#1-相关表结构" class="headerlink" title="1.相关表结构"></a>1.相关表结构</h5><p>日志记录表：共33687条数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031910440.png" alt="image-20220303191047146"></p><h5 id="2-优化思路：添加索引"><a href="#2-优化思路：添加索引" class="headerlink" title="2.优化思路：添加索引"></a>2.优化思路：添加索引</h5><p>关于索引的知识点这里不细说，推荐阅读：<a href="https://javaguide.cn/database/mysql/mysql-index/">MySQL 索引详解</a></p><p>由于日志表数据庞大，有3万条数据，为了达到快速通过用户名模糊查找到日志操作内容和操作时间，就需要用到索引，另外在模糊查询中，<strong>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用</strong></p><p>所以我将查询的模糊匹配由“%xxxx%”改为“xxxx%”，只模糊匹配前面部分</p><h5 id="3-优化操作"><a href="#3-优化操作" class="headerlink" title="3.优化操作"></a>3.优化操作</h5><p>这里直接使用Navicat可视化添加索引，因为后台查询日志是需要用用户名模糊查找到日志操作内容和操作时间，所以需要添加的索引为log_realnam</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031939750.png" alt="image-20220303193939350"></p><p>更改mybatis的sql映射，解决sql注入和索引失效问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE &quot;%$&#123;log_name&#125;%&quot;;  </span><br></pre></td></tr></table></figure><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE concat(‘%’,#&#123;log_name&#125;, ‘%’)   </span><br></pre></td></tr></table></figure><h5 id="4-优化结果-1"><a href="#4-优化结果-1" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>添加索引前使用用户名模糊查询日志，耗时大约0.045s，添加索引后耗时大约0.032s，减少了磁盘IO，提高了查询速度</li><li>修改mybatis中模糊查询的sql语句，解决索引失效的问题，并解决了模糊查询中拼接字符串的sql注入问题</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://bynss.com/linux/476637.html">怎样在 Debian 11 / Debian 10 上安装 MySQL 8.0 / 5.7</a></p><p><a href="https://stackoverflow.com/questions/20259036/mysql-package-mysql-server-has-no-installation-candidate">install.packages - MySQL: Package ‘mysql-server’ has no installation candidate - Stack Overflow</a></p><p><a href="https://javaguide.cn/database/mysql/a-thousand-lines-of-mysql-study-notes/">一千行 MySQL 学习笔记</a></p><p><a href="https://javaguide.cn/database/mysql/transaction-isolation-level/">事务隔离级别(图文详解)</a></p><p><a href="https://juejin.cn/post/6844903688553627661">你的like语句为啥没索引？</a></p><p><a href="https://juejin.cn/post/6911101492497743879#heading-3">MySQL是如何优化模糊匹配like的SQL</a></p><p><a href="https://www.cnblogs.com/hoojo/archive/2011/07/15/2107740.html">Transact-SQL 编程</a></p><p><a href="https://segmentfault.com/a/1190000039248897">针对新手的MYSQL存储过程详解</a></p><p>/1190000039248897)</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202203041310207.png&quot; alt=&quot;image-20220304131032975&quot; style=&quot;zoom: 33%;&quot;&gt;

&lt;p&gt;MySQL  ❎&lt;/p&gt;
&lt;p&gt;OurSQL ✅&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="数据库" scheme="https://autovy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://autovy.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java|Java多线程案例</title>
    <link href="https://autovy.github.io/2022/02/04/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
    <id>https://autovy.github.io/2022/02/04/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/</id>
    <published>2022-02-04T06:30:00.000Z</published>
    <updated>2022-10-25T08:48:30.268Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203022103663.jpeg" alt="Multithreading | threading-memes, multithreading-memes | ProgrammerHumor.io" style="zoom:80%;"><p>卷！</p><span id="more"></span><h3 id="线程的创建及状态"><a href="#线程的创建及状态" class="headerlink" title="线程的创建及状态"></a>线程的创建及状态</h3><h4 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1.线程的生命周期"></a>1.线程的生命周期</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202260851266.png" alt="Java 线程的状态 "></p><h4 id="2-创建一个线程"><a href="#2-创建一个线程" class="headerlink" title="2.创建一个线程"></a>2.创建一个线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(<span class="string">&quot;1- &quot;</span> + thread.getState());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;2- &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 主线程睡眠等待线程执行结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;3- &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建有任务线程"><a href="#3-创建有任务线程" class="headerlink" title="3.创建有任务线程"></a>3.创建有任务线程</h4><p>创建有任务线程有以下三种方式：</p><ul><li>重写Thread的run()方法</li><li>实现Runnable接口，在创建Thread对象时传入</li><li>使用FutureTask，在创建Thread对象的时候传入</li></ul><h5 id="重写run-方法"><a href="#重写run-方法" class="headerlink" title="重写run()方法"></a>重写run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;一个子线程任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Runnable实现"><a href="#Runnable实现" class="headerlink" title="Runnable实现"></a>Runnable实现</h5><p>Runnable是一个函数式接口，可以作为Thread构造函数的参数</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202260915940.png" alt="image-20220226091533448"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202260916952.png" alt="image-20220226091616762"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="comment">// lambda表达式可以为函数式接口创建匿名对象(类型是Runnable)</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;一个子线程任务&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="FutureTask实现"><a href="#FutureTask实现" class="headerlink" title="FutureTask实现"></a>FutureTask实现</h5><p>上面两者方式中，子线程没有返回值也没有抛出异常（这是由其中的run方法决定的），所以主线程对子线程的状况一无所知，而接下来的FutureTask可以解决这两个问题</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202260928525.png" alt="image-20220226092833201"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202260926628.png" alt="image-20220226092625296"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadFutureTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现Callable接口，写入任务，放入FutureTask中</span></span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;一个子线程任务&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;sub task done&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造FutureTask类（其实质是Runnable的一个实现）</span></span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程获得子线程返回值并捕捉异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// get()获得子线程返回值</span></span><br><span class="line">            String subResult = task.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程返回值：&quot;</span> + subResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">            <span class="comment">// getCause获得子线程发生的异常</span></span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程调用get方法后，会不断询问子线程的情况，直到子线程执行完毕。FutureTask适用于多个任务需要同时完成的情况（主线程做完自己的任务后，一直等待子线程直到它完成任务，然后一起结束）</p><h3 id="CompleteFuture"><a href="#CompleteFuture" class="headerlink" title="CompleteFuture"></a>CompleteFuture</h3><p>CompleteFuture和FutureTask都是Future接口的实现类，但是CompleteFuture的使用姿势更加优雅。建议及时抛弃FutureTask，拥抱CompleteFuture🥰</p><h4 id="1-必备工具类"><a href="#1-必备工具类" class="headerlink" title="1.必备工具类"></a>1.必备工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程小工具</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallTool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 让当前线程睡眠n毫秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleepMillis</span><span class="params">(<span class="keyword">long</span> millis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间戳+线程信息+消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTimeAndThread</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">        String res = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;\t|\t&quot;</span>)</span><br><span class="line">                .add(String.valueOf(System.currentTimeMillis()))</span><br><span class="line">                .add(String.valueOf(Thread.currentThread().getId()))</span><br><span class="line">                .add(Thread.currentThread().getName())</span><br><span class="line">                .add(tag)</span><br><span class="line">                .toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-CompletableFuture入门"><a href="#2-CompletableFuture入门" class="headerlink" title="2.CompletableFuture入门"></a>2.CompletableFuture入门</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261121903.png" alt="image-20220226112153973"></p><ul><li>开启：supplyAsync</li><li>连接：thenCompose</li><li>合并：thenCombine</li></ul><h5 id="异步任务的开启"><a href="#异步任务的开启" class="headerlink" title="异步任务的开启"></a>异步任务的开启</h5><p>supplyAsync方法开启一个异步任务</p><p><strong>场景模拟</strong></p><ul><li>顾客进入餐厅</li><li>顾客点菜</li><li>顾客刷手机等待 <ul><li>（线程2）厨师炒菜</li><li>（线程2）厨师打饭</li></ul></li><li>顾客开始干饭</li></ul><p>这里的等待队列是 顾客任务 -&gt; 厨师任务</p><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureSupplyAsync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客进入餐厅&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客点菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplyAsync方法需要一个supplier作为参数</span></span><br><span class="line">        <span class="comment">// 为函数式接口，无入参，这里只有一个String类型的返回值（作为CompletableFuture的泛型）</span></span><br><span class="line">        <span class="comment">// 调用supplyAsync，supplier中的代码会跑到子线程中执行</span></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">                    <span class="comment">// 炒菜耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师打饭&quot;</span>);</span><br><span class="line">                    <span class="comment">// 打饭耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;饭菜已备好&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        <span class="comment">// join方法返回值类型为CompletableFuture泛型的类型</span></span><br><span class="line">        <span class="comment">// join方法返回值即为supplier的返回值</span></span><br><span class="line">        <span class="comment">// join方法会等待子线程执行结束，并获得其返回值</span></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，顾客开始干饭&quot;</span>, sub.join()));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261031080.png" alt="image-20220226103120810"></p><h5 id="异步任务的连接"><a href="#异步任务的连接" class="headerlink" title="异步任务的连接"></a>异步任务的连接</h5><p>thenCompose连接两个任务当做一个线程提交到线程池，thenComposeAsync连接两个任务分别单独提交到线程池处理</p><p><strong>场景模拟</strong></p><ul><li>顾客进入餐厅</li><li>顾客点菜</li><li>顾客刷手机等待 <ul><li>（线程2）厨师炒菜，将菜交给服务员</li><li>（线程3）服务员拿到菜并去打饭</li></ul></li><li>顾客开始干饭</li></ul><p>这里的等待队列是 顾客任务 -&gt; 厨师任务 -&gt; 服务员任务</p><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenCompose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客进入餐厅&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客点菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplyAsync方法需要一个supplier作为参数</span></span><br><span class="line">        <span class="comment">// 为函数式接口，无入参，这里只有一个String类型的返回值（作为CompletableFuture的泛型）</span></span><br><span class="line">        <span class="comment">// 调用supplyAsync，supplier中的代码会跑到子线程中执行</span></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">               <span class="comment">// 厨师任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">                    <span class="comment">// 炒菜耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;鱼香肉丝&quot;</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// dish即传入厨师任务的返回值</span></span><br><span class="line">                <span class="comment">// 菜做好后，开启服务员线程拿得饭菜并打饭</span></span><br><span class="line">                <span class="comment">// thenCompose会在前一个线程完成后，开启另一个线程</span></span><br><span class="line">        ).thenCompose(dish -&gt; CompletableFuture.supplyAsync(</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务员任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">                    <span class="comment">// 打饭耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> dish + <span class="string">&quot; 米饭已备好&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        <span class="comment">// join方法返回值类型为CompletableFuture泛型的类型</span></span><br><span class="line">        <span class="comment">// join方法返回值即为supplier的返回值</span></span><br><span class="line">        <span class="comment">// join方法会等待子线程执行结束，并获得其返回值</span></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，顾客开始干饭&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261134832.png" alt="image-20220226113453404"></p><h5 id="异步任务的结合"><a href="#异步任务的结合" class="headerlink" title="异步任务的结合"></a>异步任务的结合</h5><p>thenCombine合并两个任务，同时执行他们</p><p><strong>场景模拟</strong></p><ul><li>顾客进入餐厅</li><li>顾客点菜</li><li>顾客刷手机等待 <ul><li>（线程2）厨师炒菜</li><li>（线程3）服务员蒸饭</li><li>（线程3）菜和饭都备好了，服务员打饭上菜</li></ul></li><li>顾客开始干饭</li></ul><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenCombine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客进入餐厅&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客点菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplyAsync方法需要一个supplier作为参数</span></span><br><span class="line">        <span class="comment">// 为函数式接口，无入参，这里只有一个String类型的返回值（作为CompletableFuture的泛型）</span></span><br><span class="line">        <span class="comment">// 调用supplyAsync，supplier中的代码会跑到子线程中执行</span></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                <span class="comment">// 厨师任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">                    <span class="comment">// 炒菜耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;鱼香肉丝&quot;</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// thenCombine将两个线程一起执行</span></span><br><span class="line">        ).thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务员任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员蒸饭&quot;</span>);</span><br><span class="line">                    <span class="comment">// 蒸饭耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;米饭&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ), (dish, rice) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 两个并行的线程都完成任务后，合并两个结果后结束两个任务</span></span><br><span class="line">           SmallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">           SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">           <span class="keyword">return</span> String.format(<span class="string">&quot;%s + %s 已备好&quot;</span>, dish, rice);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        <span class="comment">// join方法返回值类型为CompletableFuture泛型的类型</span></span><br><span class="line">        <span class="comment">// join方法返回值即为supplier的返回值</span></span><br><span class="line">        <span class="comment">// join方法会等待子线程执行结束，并获得其返回值</span></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，顾客开始干饭&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261117831.png" alt="image-20220226111744105"></p><h4 id="3-CompletableFuture进阶"><a href="#3-CompletableFuture进阶" class="headerlink" title="3.CompletableFuture进阶"></a>3.CompletableFuture进阶</h4><h5 id="任务的后置处理"><a href="#任务的后置处理" class="headerlink" title="任务的后置处理"></a>任务的后置处理</h5><p><strong>场景模拟</strong></p><ul><li>顾客就餐完毕</li><li>顾客结账并要求开发票</li><li>顾客刷手机等待<ul><li>（线程2）服务员收款500元</li><li>（线程3）服务员开发票</li></ul></li><li>顾客拿到发票</li></ul><p><strong>thenApply的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenApply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客就餐完毕&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客结账并要求开发票&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员收款500元&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;500&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thenApply将前面异步任务的结果交给后面的Function</span></span><br><span class="line">        <span class="comment">// 前后两个任务都是一个服务员完成的（在同一线程中）        </span></span><br><span class="line">        ).thenApply(money -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            SmallTool.printTimeAndThread(String.format(<span class="string">&quot;服务员开发票，面额%s元&quot;</span>, money));</span><br><span class="line">            SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s元发票&quot;</span>, money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;顾客拿到%s&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261152150.png" alt="image-20220226115245885"></p><p>可以看到使用thenApply，收款和开发票都在同一个线程不符合要求，我们只需要将thenApply更改为thenApplyAsync即可实现开启另一个线程运行</p><p><strong>thenApplyAsync的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenApply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客就餐完毕&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客结账并要求开发票&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员收款500元&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;500&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thenApplyAsync将前面异步任务的结果交给后面的Function，并开启一个新的线程</span></span><br><span class="line">        ).thenApplyAsync(money -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            SmallTool.printTimeAndThread(String.format(<span class="string">&quot;服务员开发票，面额%s元&quot;</span>, money));</span><br><span class="line">            SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s元发票&quot;</span>, money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;顾客拿到%s&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获得最先完成的任务"><a href="#获得最先完成的任务" class="headerlink" title="获得最先完成的任务"></a>获得最先完成的任务</h5><p><strong>场景模拟</strong></p><ul><li>老王走出餐厅，来到公交车站</li><li>等待700路或800路公交到来<ul><li>（线程2）700路公交正在赶来</li><li>（线程3）800路公交正在赶来</li></ul></li><li>老王坐最先到的公交回家</li></ul><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureToEither</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;老王走出餐厅，来到公交车站&quot;</span>);</span><br><span class="line">        <span class="comment">// 700路公交和800路公交哪一个先到，就先上哪一辆车</span></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;等待700路或800路公交到来&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; bus = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;700路公交正在赶来&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;700路公交已到站&quot;</span>;</span><br><span class="line">                    <span class="comment">// applyToEither连接两个任务，哪个任务先完成就传到Function（即firstComeBus中）</span></span><br><span class="line">                    <span class="comment">// 返回输出到bus</span></span><br><span class="line">                &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;800路公交正在赶来&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;800路公交已到站&quot;</span>;</span><br><span class="line">                &#125;), firstComeBus -&gt; firstComeBus);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，老王坐车回家&quot;</span>, bus.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261335892.png" alt="image-20220226133508092"></p><h5 id="处理发生的异常情况"><a href="#处理发生的异常情况" class="headerlink" title="处理发生的异常情况"></a>处理发生的异常情况</h5><p><strong>场景模拟</strong></p><ul><li><p>老王走出餐厅，来到公交车站</p></li><li><p>等待700路或800路公交到来</p><ul><li>（线程2）700路公交正在赶来</li><li>（线程3）800路公交正在赶来</li></ul></li><li><p>老王坐最先到的公交回家</p></li><li><p>700路公交出现故障，老王叫出租车回家</p></li></ul><p><strong>代码案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line">public class CompleteFutureToEither &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SmallTool.printTimeAndThread(&quot;老王走出餐厅，来到公交车站&quot;);</span><br><span class="line">        &#x2F;&#x2F; 700路公交和800路公交哪一个先到，就先上哪一辆车</span><br><span class="line">        SmallTool.printTimeAndThread(&quot;等待700路或800路公交到来&quot;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; bus &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(&quot;700路公交正在赶来&quot;);</span><br><span class="line">                    SmallTool.sleepMillis(100);</span><br><span class="line">                    return &quot;700路公交已到站&quot;;</span><br><span class="line">                    &#x2F;&#x2F; applyToEither连接两个任务，哪个任务先完成就传到Function（即firstComeBus中）</span><br><span class="line">                    &#x2F;&#x2F; 返回输出到bus</span><br><span class="line">                &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(&quot;800路公交正在赶来&quot;);</span><br><span class="line">                    SmallTool.sleepMillis(200);</span><br><span class="line">                    return &quot;800路公交已到站&quot;;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 先到的车如果是700路，其中途会抛出异常</span><br><span class="line">                &#125;), firstComeBus -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(firstComeBus);</span><br><span class="line">                    if(firstComeBus.startsWith(&quot;700&quot;))</span><br><span class="line">                    &#123;</span><br><span class="line">                        throw new RuntimeException(&quot;公交车发生故障&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    return firstComeBus;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 上面任任意的链式调用中出现异常都会触发这里的事件</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            SmallTool.printTimeAndThread(e.getMessage());</span><br><span class="line">            SmallTool.printTimeAndThread(&quot;老王叫出租车&quot;);</span><br><span class="line">            return &quot;出租车到了&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(&quot;%s，老王坐车回家&quot;, bus.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261347003.png" alt="image-20220226134731888"></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-线程池的创建"><a href="#1-线程池的创建" class="headerlink" title="1.线程池的创建"></a>1.线程池的创建</h4><h5 id="使用构造函数创建"><a href="#使用构造函数创建" class="headerlink" title="使用构造函数创建"></a>使用构造函数创建</h5><p>我们可以使用ThreadPoolExecutor的构造函数创建一个线程池，其构造函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>拒绝策略如下：</p><p><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出异常</p><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：谁提交谁执行</p><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：直接丢弃</p><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 替换掉工作队列中最后一个</p><h5 id="使用工具类创建"><a href="#使用工具类创建" class="headerlink" title="使用工具类创建"></a>使用工具类创建</h5><p>一般不推荐使用，因为它无法适应多变的业务需求，而且容易导致OOM</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261635984.png" alt="通过Executor 框架的工具类Executors来实现"></p><h4 id="2-线程中断"><a href="#2-线程中断" class="headerlink" title="2.线程中断"></a>2.线程中断</h4><p>在一个线程中可以通过中断唤醒另一个在睡眠中的线程，达到线程间通信的目的。不建议使用中断</p><p><strong>场景模拟</strong></p><p>两车过独木桥场景</p><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoCarCrossBridge</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread carTwo  = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"></span><br><span class="line">            SmallTool.printTimeAndThread(<span class="string">&quot;二号车辆准备过桥&quot;</span>);</span><br><span class="line">            SmallTool.printTimeAndThread(<span class="string">&quot;发现一号车正在过桥，开始等待&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 二号车线程进入TIMED_WAITING状态</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一号车发出中断通知，可以通过捕捉IE异常接收</span></span><br><span class="line">            <span class="comment">// sleep和wait方法会抛出InterruptedException异常</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                SmallTool.printTimeAndThread(<span class="string">&quot;二号车开始过桥&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            SmallTool.printTimeAndThread(<span class="string">&quot;二号车过桥完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread carOne = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           SmallTool.printTimeAndThread(<span class="string">&quot;一号车开始过桥&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> timeSpend = <span class="keyword">new</span> Random().nextInt(<span class="number">500</span>) + <span class="number">1000</span>;</span><br><span class="line">           SmallTool.sleepMillis(timeSpend);</span><br><span class="line">           SmallTool.printTimeAndThread(<span class="string">&quot;二号车过桥完毕，耗时：&quot;</span> + timeSpend);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 一号车过桥完毕后，利用中断通知二号车</span></span><br><span class="line">            carTwo.interrupt();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一号车，二号车同时起步</span></span><br><span class="line">        carOne.start();</span><br><span class="line">        carTwo.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但线程处于blocked，waiting，timed_waiting状态，或者从上述三个状态转为runnable状态的过程中，如果被中断就会收到InterruptedException异常</p><p><strong>运行结果</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202261712019.png" alt="image-20220226171200852"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://space.bilibili.com/51950540/channel/collectiondetail?sid=20808">Java并发编程合集</a></p><p><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary/">Java 线程池详解</a></p><p>l-summary/)</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202203022103663.jpeg&quot; alt=&quot;Multithreading | threading-memes, multithreading-memes | ProgrammerHumor.io&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;p&gt;卷！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://autovy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java|Socket编程指南</title>
    <link href="https://autovy.github.io/2022/01/20/Java/Java-Socket%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://autovy.github.io/2022/01/20/Java/Java-Socket%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</id>
    <published>2022-01-20T15:45:00.000Z</published>
    <updated>2022-10-27T07:56:48.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202252305878.png" alt="That is a good excuse"></p><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Socket编程是指编写在多台计算机上执行的程序，其中的设备都使用网络相互连接</p><p>Socket常用的通信协议有UDP和TCP，本文主要介绍通过TCP/IP网络协议进行Socket编程</p><h3 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a>Socket通信流程</h3><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202251212126.png" alt="img"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭；</li></ul><p>服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>Socket是网络上不同计算机运行的两个程序之间双向通信链路的一个端点。Socket需要绑定端口号，一遍传输层可以标识数据要发送到的应用程序</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端会用到两个socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong></p><p>目前的服务器不能保证通信的连续性，它会在发送完消息后关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// （监听socket）</span></span><br><span class="line">            <span class="comment">// 绑定指定端口，使服务器的Socket在指定端口号上运行</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// （已连接socket）</span></span><br><span class="line">            <span class="comment">// 服务器遇到accept进入阻塞，等待客户端发出连接</span></span><br><span class="line">            <span class="comment">// 连接成功后，服务器将获得绑定到同一本地端口6666的新socket，用于传输数据</span></span><br><span class="line">            clientSocket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出流，可发送消息到客户端</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 输入流，可接收客户端消息</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String greeting = in.readLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(greeting.equals(<span class="string">&quot;hello server&quot;</span>))&#123;</span><br><span class="line">                out.println(<span class="string">&quot;hello client&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                out.println(<span class="string">&quot;unrecognised greeting&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        <span class="comment">// 开启服务器</span></span><br><span class="line">        server.start(<span class="number">6666</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端只需要创建一个socket以保持连接，最终客户端的输入流连接到服务端的输出流，服务器的输入流连接到客户端的输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.javafx.iio.ios.IosDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConnection</span><span class="params">(String ip, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 客户端需要知道服务端的ip和其正在监听的端口号，才能发起连接</span></span><br><span class="line">            <span class="comment">// 服务器接收连接后创建客户端socket</span></span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取socket的输入输出流，以便与服务端通信</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端输出请求消息</span></span><br><span class="line">        out.println(msg);</span><br><span class="line">        String resp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 客户端接收响应消息</span></span><br><span class="line">            resp = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>先手动启动服务端，然后运行以上测试案例即可完成一次连接和一次消息发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="comment">// 客户端对服务端发起连接</span></span><br><span class="line">        client.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 客户端发送消息到服务端并接收响应结果</span></span><br><span class="line">        String response = client.sendMessage(<span class="string">&quot;hello server&quot;</span>);</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若启动服务端时出现以下报错，是出现了端口占用，可以修改端口也可以关闭占用端口的进程</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202251257783.png" alt="image-20220225125717019"></p><p>Windows下使用命令行关闭占用端口的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 参看端口号含6666的条目</span><br><span class="line">netstat -ano|findstr &quot;6666&quot;</span><br><span class="line"></span><br><span class="line">// 根据pid查询对应的应用程序</span><br><span class="line">tasklist|findstr &quot;1828&quot;</span><br><span class="line"></span><br><span class="line">// 杀死进程</span><br><span class="line">taskkill /f /pid 1828</span><br></pre></td></tr></table></figure><h3 id="持续连接优化"><a href="#持续连接优化" class="headerlink" title="持续连接优化"></a>持续连接优化</h3><p>在前一个案例中，服务器会阻塞直到客户端连接它。在单个消息后，连接就会关闭，客户端和服务端无法持续沟通，因此仅仅会出现在ping请求中</p><p>如果要实现一个聊天服务器，客户端和服务端之间就需要连续的来回通信</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p>在优化中我在服务端创建一个while循环来连续观察传来消息的服务器输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// （监听socket）</span></span><br><span class="line">            <span class="comment">// 绑定指定端口，使服务器的Socket在指定端口号上运行</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// （已连接socket）</span></span><br><span class="line">            <span class="comment">// 服务器遇到accept进入阻塞，等待客户端发出连接</span></span><br><span class="line">            <span class="comment">// 连接成功后，服务器将获得绑定到同一本地端口4444的新socket，用于传输数据</span></span><br><span class="line">            clientSocket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出流，可发送消息到客户端</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 输入流，可接收客户端消息</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String inputLine;</span><br><span class="line">            <span class="comment">// while循环连续观察从客户端传来消息的服务器输入流</span></span><br><span class="line">            <span class="comment">// 直到读取到exit断开连接</span></span><br><span class="line">            <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(inputLine.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                    out.println(<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(inputLine.replace(<span class="string">&quot;req&quot;</span>, <span class="string">&quot;res&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoServer server = <span class="keyword">new</span> EchoServer();</span><br><span class="line">        <span class="comment">// 开启服务器</span></span><br><span class="line">        server.start(<span class="number">4444</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>客户端不需要进行优化修改，这里为了方区分创建一个新的类EchoClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConnection</span><span class="params">(String ip, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 客户端需要知道服务端的ip和其正在监听的端口号，才能发起连接</span></span><br><span class="line">            <span class="comment">// 服务器接收连接后创建客户端socket</span></span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取socket的输入输出流，以便与服务端通信</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端输出请求消息</span></span><br><span class="line">        out.println(msg);</span><br><span class="line">        String resp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 客户端接收响应消息</span></span><br><span class="line">            resp = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>在初始示例中，我们只在服务器关闭连接之前进行一次通信。现在，我们发送一个终止信号，以便在会话完成时告诉服务器，以此关闭服务器的socket进程</p><p>开启EchoServer服务器运行以下测试案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EchoClient client = <span class="keyword">new</span> EchoClient();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        client.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        client.stopConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String resp1 = client.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>@BeforeClass – 表示在类中的任意public static void方法执行之前执行</li><li>@AfterClass – 表示在类中的任意public static void方法执行之后执行</li><li>@Before – 表示在任意使用@Test注解标注的public void方法执行之前执行</li><li>@After – 表示在任意使用@Test注解标注的public void方法执行之后执行</li><li>@Test – 使用该注解标注的public void方法会表示为一个测试方法</li></ul><h3 id="多客户端优化"><a href="#多客户端优化" class="headerlink" title="多客户端优化"></a>多客户端优化</h3><p>在实际情况中，服务端常常要处理多个客户端的请求，为此我们要在服务端为每一个客户端请求创建一个新的socket线程，即提供服务的客户端数将等于服务端正在运行的线程数</p><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><p>仍然用一个<strong>监听socket</strong>在主线程监听端口，而需要多线程存储<strong>已连接socket</strong>以保持与多个客户端的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoMultiSever</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 仍然使用一个socket在主线程中监听端口</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 每次循环中，accept会阻塞调用，直到新的客户端调用</span></span><br><span class="line">                <span class="comment">// 连接成功后，EchoMultiServer会将已连接的socket委托给 EchoClientHandler</span></span><br><span class="line">                <span class="keyword">new</span> EchoClientHandler(serverSocket.accept()).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个单独的线程EchoClientHandler</span></span><br><span class="line">    <span class="comment">// 保存已连接的socket与客户端交流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">        <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">        <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EchoClientHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程执行start直到运行run方法，与目标客户端进行交流</span></span><br><span class="line">        <span class="comment">// 其内部发生的情况与EchoSever相同</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">                in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(inputLine.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                        out.println(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.println(inputLine.replace(<span class="string">&quot;req&quot;</span>, <span class="string">&quot;res&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                clientSocket.close();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoMultiSever server = <span class="keyword">new</span> EchoMultiSever();</span><br><span class="line">        <span class="comment">// 开启服务器</span></span><br><span class="line">        server.start(<span class="number">5555</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p>客户端不需要进行优化修改，与上面的相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoMultiClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConnection</span><span class="params">(String ip, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 客户端需要知道服务端的ip和其正在监听的端口号，才能发起连接</span></span><br><span class="line">            <span class="comment">// 服务器接收连接后创建客户端socket</span></span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取socket的输入输出流，以便与服务端通信</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        out.println(msg);</span><br><span class="line">        String resp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>测试类中需要发起多个客户端请求</p><p>运行EchoMultiSever后，运行以下案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试方法开启多个客户端请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoMultiTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClient1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EchoClient client1 = <span class="keyword">new</span> EchoClient();</span><br><span class="line">        client1.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">        String resp1 = client1.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client1.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client1.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClient2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EchoClient client2 = <span class="keyword">new</span> EchoClient();</span><br><span class="line">        client2.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">        String resp1 = client2.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client2.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client2.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClient3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EchoClient client3 = <span class="keyword">new</span> EchoClient();</span><br><span class="line">        client3.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">        String resp1 = client3.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client3.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client3.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.baeldung.com/a-guide-to-java-sockets">Java 套接字</a></p><p><a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">TCP/IP图解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202202252305878.png&quot; alt=&quot;That is a good excuse&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="开发实战" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|深入理解TCP/IP</title>
    <link href="https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/"/>
    <id>https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/</id>
    <published>2021-12-22T15:45:00.000Z</published>
    <updated>2022-10-25T08:48:30.252Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222123110.png" alt="Packets incoming "></p><span id="more"></span><h3 id="深入TCP连接"><a href="#深入TCP连接" class="headerlink" title="深入TCP连接"></a>深入TCP连接</h3><p>参考资料：<a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg</a></p><h4 id="1-TCP基本认识"><a href="#1-TCP基本认识" class="headerlink" title="1.TCP基本认识"></a>1.TCP基本认识</h4><h5 id="（1）TCP头部结构"><a href="#（1）TCP头部结构" class="headerlink" title="（1）TCP头部结构"></a>（1）TCP头部结构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172102110.png" alt="image-20211117210224727"></p><p>下面介绍其中较为重要的部分：</p><ul><li><strong>序列号</strong>：建立连接时计算生成的随机数作为其初始值，通过SYN包传给接收端主机。每发送一次数据就会<strong>累加</strong>一次该<strong>数据字节数</strong>的大小，所以可以用来<strong>解决网络包乱序</strong>的问题</li><li><strong>确认应答号</strong>：即下一次<strong>期望</strong>收到的数据序列号，发送端接收到这个确认应答就可以认为这个序号之前的数据已被正常接收，用以解决<strong>不丢包的问题</strong></li><li><strong>控制位（状态位）</strong>：该字段中的每个比特分别表示以下通信控制含义<ul><li>ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></li><li>RST：<strong>强制断开</strong>连接，用于异常中断的情况</li><li>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作</li><li>FIN：表示<strong>断开</strong>连接</li></ul></li><li><strong>窗口大小</strong>：接收方告知发送方窗口大小（窗口大小即缓存大小，标识当前处理能力，用于<strong>流量控制</strong>，<strong>拥塞控制</strong>）</li></ul><h5 id="（2）TCP基本定义"><a href="#（2）TCP基本定义" class="headerlink" title="（2）TCP基本定义"></a>（2）TCP基本定义</h5><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的</strong></p><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p><ul><li>面向连接：十分专一，只支持一对一连接</li><li>可靠的：不管网络链路出现怎样的链路变化，TCP都可以保证一个报文一定能到达中断</li><li>字节流：消息无论多大都可以传输，而且一定是<strong>有序的</strong>，<strong>顺序不对</strong>的，<strong>重复</strong>的报文会被自动丢弃</li></ul><p>TCP连接即<strong>用于保证可靠性和流量控制维护</strong>的某些状态信息包括：</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><p>TCP四元组可以唯一确定一个连接：</p><ul><li><p>源地址</p></li><li><p>源端口</p></li><li><p>目标地址</p></li><li><p>目标端口</p></li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172153405.png" alt="img"></p><p>地址储存在IP头部中，作用是通过IP协议发送报文给对方主机</p><p>端口存储在TCP头部，作用是告诉TCP协议应该把报文发给哪个进程</p><p>服务器通常固定在某个本地端口监听（如80，443等），等待客户端的连接请求</p><p>TCP理论上的最大连接数与客户端的IP数和客户端的端口数有关<br>$$<br>最大TCP连接数 = 客户端的IP数 × 客户端的端口数<br>$$<br>当实际上服务端最大TCP连接还会受到<strong>文件描述符</strong>和<strong>内存</strong>限制</p><h5 id="（3）TCP与UDP的区别"><a href="#（3）TCP与UDP的区别" class="headerlink" title="（3）TCP与UDP的区别"></a>（3）TCP与UDP的区别</h5><p>TCP与UDP的结构对比：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091935607.png" alt="img" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172209140.png" alt="image-20211117220850428" style="zoom: 67%;"></p><ul><li>首部长度：TCP有首部长度，UDP则没有。因为TCP有可变长的<strong>选项</strong>字段，所以需要首部长度来记录；UDP的头部长度是不会变化的，所以需要去记录首部长度</li></ul><ul><li>包长度：UDP有首部长度，UDP则没有。TCP和UDP的数据长度都可以通过下面公式计算出来，所以包长度是不需要的，这里的UDP可能纯属是补全UDP的首部长度为4字节<br>$$<br>TCP/UDP数据长度 = IP总长度 - IP首部长度 - TCP/UDP首部长度<br>$$</li></ul><p>TCP和UDP协议的应用：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090832758.jpeg" alt="TCP/UDP常见应用"></p><p>TCP/UDP比较：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p><p>咳咳，正经详细的比较如下：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131209573.png" alt="image-20211013120922107"></p><p>TCP/UDP编程模型对比：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090836254.jpeg" alt="TCP/UDP编程模型"></p><h4 id="2-TCP连接建立"><a href="#2-TCP连接建立" class="headerlink" title="2.TCP连接建立"></a>2.TCP连接建立</h4><h5 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h5><p>TCP三次握手其实就是<strong>建立一个TCP连接</strong>，客户端和服务器之间需要<strong>3个数据包</strong>，握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091957945.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></p><ul><li>初始状态下，客户端和服务端都处在<strong>CLOSED</strong>状态，先是服务端主动监听某个端口，处于<strong>LISTEN</strong>状态</li></ul><ul><li>第一次握手：客户端发送<strong>SYN</strong>报文，并进入<strong>SYN-SENT</strong>状态，等待服务器确认</li></ul><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181640784.png" alt="img" style="zoom: 67%;"><ul><li>第二次握手：服务器收到<strong>SYN</strong>报文后，需要向客户端发送<strong>ACK</strong>确认<strong>收到</strong>的报文；同时服务端也向客户端发送一个<strong>SYN报文</strong>（也就是说服务端向客户端发送了<strong>SYN+ACK</strong>报文），然后服务端进入<strong>SYN_RCVD</strong>状态</li></ul><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181640604.png" alt="img" style="zoom: 67%;"><ul><li><p>第三次握手：客户端收到<strong>SYN+ACK</strong>报文后，向服务端发送<strong>ACK</strong>确认<strong>收到</strong>的报文，客户端进入<strong>ESTABLISHED</strong>状态； 服务端收到客户端的<strong>ACK</strong>包后也会进入<strong>ESTABLISHED</strong>状态，完成三次握手</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130593.png" alt="img" style="zoom: 67%;"></li></ul><p><strong>第三次握手是可以携带数据的，前面两次握手是不可以携带数据的</strong>，完成三次握手后，双方都处于<strong>ESTABLISHED</strong>状态，至此连接就已经建立完成了</p><p>在Linux系统可以通过<code>netstat -napt</code>命令查看TCP连接状态</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092029731.png" alt="img"></p><h5 id="（2）需要三次握手的原因"><a href="#（2）需要三次握手的原因" class="headerlink" title="（2）需要三次握手的原因"></a>（2）需要三次握手的原因</h5><p>我们需要三次握手才能初始化Socket，序列号和窗口大小并建立TCP连接，才能保证双方具有接收和发送的能力</p><p>需要三次握手的原因如下：</p><ul><li>三次握手才能阻止历史重复连接的初始化</li><li>三次握手才能同步双方的初始序列化</li><li>三次握手才可以避免资源浪费</li></ul><p><strong>避免历史连接</strong>：防止旧的重复连接初始化造成混乱</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130449.png" alt="img" style="zoom: 67%;"><p>网络环境错综复杂，在网络拥堵的情况下，一个「旧 SYN 报文」可能会比「最新的 SYN 」 报文早到达了服务端</p><p>第三次握手可以用来判断是否收到了自己期望的ACK：</p><ul><li>如果是历史连接（序列号过期或超时）就发送<strong>RST报文</strong>中止历史连接</li><li>如果不是历史连接则第三次发送的报文是<strong>ACK报文</strong>，通信双方就会成功建立连接</li></ul><p>如果是两次握手将无法判断出历史连接</p><p><strong>同步双方初始序列号</strong>：TCP协议通信双方，都必须维护一个序列号，只有客户端和服务端之间通过<strong>SYN和ACK</strong>一来一回的确认，才能确保双方的初始化序列号能被可靠的同步</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181742784.png" alt="img" style="zoom:67%;"><p>如果是两次握手只能保证一方的初始序列号可以被对方接收，没办法保证双方的初始序列号都能被确认接受</p><p><strong>避免资源浪费</strong>：二次握手会建立多个冗杂的无效的连接，造成不必要的资源浪费</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130170.png" alt="img" style="zoom:67%;"><p>两次握手会造成消息滞留的情况，服务器接收到无用的SYN报文，因为没有ACK确认信号，服务器就会造成重复的资源分配</p><h5 id="（3）初始化序列号ISN"><a href="#（3）初始化序列号ISN" class="headerlink" title="（3）初始化序列号ISN"></a>（3）初始化序列号ISN</h5><p>客户端和服务端的初始序列号ISN是不相同的，因为网络的<strong>报文会延迟，会复制重发，也可能丢失</strong>。为了避免相互影响，客户端和服务端的初始序列号是随机且不同的</p><p>初始序列号ISN的随机生成算法是基于时钟的，如下<br>$$<br>ISN = M + F (localhost, localport, remotehost, remoteport)<br>$$</p><ul><li><code>M</code> 是一个<strong>计时器</strong>，这个计时器每隔 4 毫秒加 1</li><li><code>F</code> 是一个 Hash 算法，根据<strong>源 IP、目的 IP、源端口、目的端口生成一个随机数值</strong>。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择</li></ul><h5 id="（4）MTU与MSS"><a href="#（4）MTU与MSS" class="headerlink" title="（4）MTU与MSS"></a>（4）MTU与MSS</h5><p>IP层分片的大小为MTU，TCP层分段的大小为MSS</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092031256.png" alt="image-20211009203103835"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>既然IP层可以将大于MTU数据进行分片，为什么还需要TCP层将大于MSS的数据分段呢？</p><p>因为IP层本身并没有超时重传机制，如果一个IP分片丢失了，那么整个IP报文的<strong>所有分片都要进行重传</strong></p><p>所有为了达到最佳的传输效能，TCP协议在<strong>建立连接时通常要协商双方的MSS值</strong>，当TCP发现数据超过MSS时就会对数据进行分段，这样它生成的IP包长度就不会大于MTU了，当然也不需要IP层进行分片。</p><p>如果一个TCP分片丢失，就可以以MSS为单位重发数据</p><h5 id="（5）TCP接收队列"><a href="#（5）TCP接收队列" class="headerlink" title="（5）TCP接收队列"></a>（5）TCP接收队列</h5><p>​    在TCP三次握手中，我们如何分辨：哪些连接是半连接，哪些连接是全连接呢？</p><p>​    Linux通过维护两个队列来解决问题：</p><ul><li>半连接队列（SYN队列）</li><li>全连接队列（accepet队列）</li></ul><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110261926809.png" alt="img" style="zoom:80%;"><ul><li>服务端收到客户端发起的<strong>SYN</strong>后，内核会将连接存储到<strong>半连接队列</strong></li><li>服务端向客户端发送<strong>SYN+ACK</strong></li><li>客户端收到<strong>SYN+ACK</strong>后，发送<strong>ACK</strong>到服务端</li><li>服务端收到客户端的<strong>ACK</strong>后，内核会把连接从<strong>半连接队列</strong>移除，将其添加到<strong>全连接队列</strong>，等待进程调用<strong>accept函数</strong>时把连接取出来</li><li>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接<strong>丢弃</strong>，或<strong>返回 RST 包</strong></li></ul><h5 id="（6）SYN攻击与避免方式"><a href="#（6）SYN攻击与避免方式" class="headerlink" title="（6）SYN攻击与避免方式"></a>（6）SYN攻击与避免方式</h5><p>SYN攻击实际上就是对服务端一直发送SYN包，但是不回第三次握手ACK，这样会使服务端有大量的处于 <code>SYN_RECV</code> 状态的 TCP 连接（即<strong>半连接状态</strong>），久而久之就会导致<strong>TCP半连接队列溢出</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111221558394.jpeg" alt="img"></p><p><strong>避免SYN方法</strong>如下</p><p>方法一：调整Linux相关参数</p><p>通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</p><ul><li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog</span><br></pre></td></tr></table></figure><ul><li>SYN_RCVD 状态连接的最大个数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><ul><li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p>方法二：<strong>开启tcp_syncookies</strong></p><p>当syncookies=1时，服务端开启 syncookies 功能，其可以在不使用 SYN 半连接队列的情况下成功建立连接（默认配置）</p><p>SYN队列即半连接队列        Accept队列即全连接队列</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130712.png" alt="img" style="zoom: 50%;">                                <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130242.png" alt="img" style="zoom: 50%;"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130175.png" alt="img" style="zoom:50%;">                                <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130600.png" alt="img" style="zoom: 50%;"> </p><p>syncookies的运行原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功。其处理流程如下：</p><ul><li>「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接</li></ul><h4 id="3-TCP连接断开"><a href="#3-TCP连接断开" class="headerlink" title="3.TCP连接断开"></a>3.TCP连接断开</h4><h5 id="（1）四次挥手"><a href="#（1）四次挥手" class="headerlink" title="（1）四次挥手"></a>（1）四次挥手</h5><p>当我们的应用不再需要数据通信，就会发起断开TCP连接，建立一个连接需要<strong>三次握手</strong>，而终止一个连接需要经过<strong>四次挥手</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111551532.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong>；    FIN：表示<strong>断开</strong>连接</p><ul><li>第一次挥手：客户端发起<strong>FIN</strong>包，客户端进入<strong>FIN_WAIT_1</strong>状态（虽然FIN包不携带数据，也需要消耗一个序号u）</li><li>第二次挥手：服务端收到<strong>FIN</strong>包，发出确认包<strong>ACK</strong>（ack=u+1），并带上自己的序号seq=v，服务端进入<strong>CLOSE_WAIT</strong>状态（这个时候客户端仍需要接收服务器发送的数据）；客户端接收到服务端发送的<strong>ACK</strong>后，进入<strong>FIN_WAIT_2</strong>状态</li><li>第三次挥手：服务端数据发送完毕后，向客户端发送<strong>FIN</strong>包（seq=w，ack=u+1），<strong>半连接状态</strong>下服务器可能又发送一些数据，服务端此时进入<strong>LAST_ACK</strong>状态</li><li>第四次挥手：客户端收到服务端的<strong>FIN</strong>包后，发出确认包ACK（ACK=1， ack=w+1），此时客户端进入<strong>TIME_WAIT</strong>状态；服务端收到客户端确认包后进入<strong>CLOSED</strong>状态，而客户端需要等待2MSL后才进入<strong>CLOSED</strong>状态</li></ul><p>四次挥手的本质是——客户端和服务器通过<strong>两对FIN-ACK报文</strong>通知对方自己要关闭了</p><p>三次握手中，在第二次握手时，接收端将一个<strong>ACK</strong>包和一个<strong>SYN</strong>包合并一起发送，所以减少了一次包的发送</p><p>四次挥手中，在主动关闭方（客户端）发送FIN包后，接收方（服务端）可能还要发送数据，不能立即关闭数据通道，所以服务端要先确认ACK，然后等到自己把数据发无可发后再发送<strong>FIN</strong>包</p><h5 id="（2）需要四次挥手的原因"><a href="#（2）需要四次挥手的原因" class="headerlink" title="（2）需要四次挥手的原因"></a>（2）需要四次挥手的原因</h5><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能<strong>还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接</li></ul><p>服务端的<strong>ACK</strong>和<strong>FIN</strong>需要分开发送，是因为通常需要等待完成数据的发送和处理，所以会比三次握手多一次</p><h5 id="（3）TIME-WAIT状态功能"><a href="#（3）TIME-WAIT状态功能" class="headerlink" title="（3）TIME_WAIT状态功能"></a>（3）TIME_WAIT状态功能</h5><p>为什么客户端在关闭连接时需要一个TIME_WAIT的状态呢？</p><p>其主要有以下两个原因：</p><ul><li>防止旧连接的数据包</li><li>保证「被动关闭连接」的一方能被正确的关闭</li></ul><p><strong>防止旧连接的数据包</strong>：</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222021036.png" alt="img" style="zoom:67%;"><p>如果没有TIME_WAIT或TIME_WAIT的时间过短，那么图中被延迟的过期的数据包可能会被客户端正常接收</p><p>而经过TIME_WAIT的<code>2MSL</code> 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</p><p><strong>保证连接正确关闭</strong>：</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130617.png" alt="img" style="zoom:67%;"><p>TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</p><p>一旦客户端最后的ACK报文在网络丢失，如果没有TIME_WAIT或TIME_WAIT的时间过短，客户端很快就会进入了则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。这时如果客户端要发起新的连接，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止</p><p>如果 TIME-WAIT 等待足够长时，一旦服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文</p><h5 id="（4）TIME-WAIT深入讲解"><a href="#（4）TIME-WAIT深入讲解" class="headerlink" title="（4）TIME_WAIT深入讲解"></a>（4）TIME_WAIT深入讲解</h5><p><strong>为什么TIME_WAIT等待的时间是两秒</strong>？</p><p>MSL：<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p><p>TTL： <strong>IP 数据报可以经过的最大路由数</strong>，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机</p><p>如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， <strong>一来一去正好 2 MSL</strong></p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong></p><p><strong>TIME_WAIT 过多有什么危害？</strong></p><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是内存资源占用；</li><li>第二是对端口资源的占用，如果<strong>TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接</strong></li></ul><p><strong>TIME_WAIT 优化</strong></p><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项：可以复用<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>，引入时间戳后，重复的数据包会因为时间戳过期而被自然丢弃，同时<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong></li><li>net.ipv4.tcp_max_tw_buckets：这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置</strong></li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭（也是一个危险行为，不推荐使用）</li></ul><h5 id="（5）TCP保活机制"><a href="#（5）TCP保活机制" class="headerlink" title="（5）TCP保活机制"></a>（5）TCP保活机制</h5><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>这时候就要提到TCP的<strong>保活机制</strong>了</p><p>在一个<strong>规定的时间段</strong>（tcp_keepalive_time：保活时间）内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<strong>每隔一个时间间隔</strong>（tcp_keepalive_intvl：每次检测间隔），发送一个「探测报文」，该探测报文包含的数据非常少，如果<strong>连续几个探测报文</strong>（tcp_keepalive_probes：检测次数）都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p><p>  相关参数如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271337578.png" alt="image-20211023214647732">    </p><p>按照系统默认的设置来计算在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232154413.png" alt="img"></p><p>开启了TCP保活可以考虑以下三种情况：</p><ul><li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来</li><li>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置</li><li>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong></li></ul><p><strong>前方施工中。。。</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222117832.webp" alt></p><h3 id="深入TCP机制"><a href="#深入TCP机制" class="headerlink" title="深入TCP机制"></a>深入TCP机制</h3><p>参考资料：<a href="https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA">https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA</a></p><h4 id="1-重传机制"><a href="#1-重传机制" class="headerlink" title="1.重传机制"></a>1.重传机制</h4><h4 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h4><h4 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3.流量控制"></a>3.流量控制</h4><h4 id="4-拥堵控制"><a href="#4-拥堵控制" class="headerlink" title="4.拥堵控制"></a>4.拥堵控制</h4><h3 id="TCP关键参数与优化"><a href="#TCP关键参数与优化" class="headerlink" title="TCP关键参数与优化"></a>TCP关键参数与优化</h3><p>参考文章：<a href="https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw">https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw</a></p><h4 id="1-TCP三次握手参数"><a href="#1-TCP三次握手参数" class="headerlink" title="1.TCP三次握手参数"></a>1.TCP三次握手参数</h4><h4 id="2-TCP四次挥手参数"><a href="#2-TCP四次挥手参数" class="headerlink" title="2.TCP四次挥手参数"></a>2.TCP四次挥手参数</h4><h4 id="3-TCP数据传输参数"><a href="#3-TCP数据传输参数" class="headerlink" title="3.TCP数据传输参数"></a>3.TCP数据传输参数</h4><h3 id="IP基本知识"><a href="#IP基本知识" class="headerlink" title="IP基本知识"></a>IP基本知识</h3><h3 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h3><h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><h3 id="Ping工作原理"><a href="#Ping工作原理" class="headerlink" title="Ping工作原理"></a>Ping工作原理</h3><h3 id="Ping工作原理-1"><a href="#Ping工作原理-1" class="headerlink" title="Ping工作原理"></a>Ping工作原理</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202111222123110.png&quot; alt=&quot;Packets incoming &quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="https://autovy.github.io/tags/TCP/"/>
    
      <category term="IP" scheme="https://autovy.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>开发工具|Git的使用与工作原理</title>
    <link href="https://autovy.github.io/2021/11/16/Tool/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://autovy.github.io/2021/11/16/Tool/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-16T14:57:00.000Z</published>
    <updated>2022-10-25T08:48:30.291Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122115839.jpeg" alt="img"></p><span id="more"></span><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/45510461">深入理解Git实现原理 </a></p><p><a href="https://jingsam.github.io/2018/06/03/git-objects.html">Git内部原理之Git对象 </a></p><p><a href="https://zhuanlan.zhihu.com/p/42929114">Git 误操作救命良方</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a></p><h3 id="Git基本知识"><a href="#Git基本知识" class="headerlink" title="Git基本知识"></a>Git基本知识</h3><h4 id="1-Git定义"><a href="#1-Git定义" class="headerlink" title="1.Git定义"></a>1.Git定义</h4><p>git的本质就是要实现<strong>对文件变更过程的存储</strong></p><p>Git是一种分布式版本控制系统：</p><ul><li>版本控制：git可以对文件<strong>变更过程</strong>进行管理，随时可以拿出所需要的版本</li><li>分布式：Git的数据不仅存在<strong>远程仓库</strong>（即Git平台的服务器），也存在<strong>本地仓库</strong>（即项目开发者的本地计算机），所以称为<strong>分布式</strong></li></ul><h4 id="2-Git功能列表"><a href="#2-Git功能列表" class="headerlink" title="2.Git功能列表"></a>2.Git功能列表</h4><ul><li>我们可以为每一次变更提交版本更新并且备注更新的内容</li><li>我们可以在项目的各个历史版本之间自如切换</li><li>我们可以一目了然的比较出两个版本之间的差异</li><li>我们可以从当前的修改中撤销一些操作</li><li>我们可以自如的创建分支、合并分支</li><li>我们可以和多人协作开发</li><li>我们可以采取自由多样的开发模式</li></ul><h4 id="3-Git基本术语"><a href="#3-Git基本术语" class="headerlink" title="3.Git基本术语"></a>3.Git基本术语</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122058851.webp" alt="img"></p><ul><li><p>工作区：在编辑器内可增加或修改文件等位置</p></li><li><p>缓存区：提交代码，解决冲突的<strong>中转站</strong></p></li><li><p>版本库：本地<code>.git/</code>目录，内含<strong>缓存区</strong></p></li><li><p>本地仓库：连接本地代码和远程代码的<strong>枢纽</strong>，在没有联网状态下，本地代码可先提交至该处</p></li><li><p>远程仓库：托管远程代码的<strong>中央服务器</strong></p></li></ul><h4 id="4-Git托管平台"><a href="#4-Git托管平台" class="headerlink" title="4.Git托管平台"></a>4.Git托管平台</h4><h5 id="（1）Github"><a href="#（1）Github" class="headerlink" title="（1）Github"></a>（1）Github</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171119482.png" alt="img" style="zoom:50%;"><p>网址：<a href="https://github.com/">https://github.com/</a></p><p>Gihub是全球最流行的代码托管平台，拥有大量非常知名的开源项目。github的服务器部署在国外，国内访问不友好，适合用于学习和开发开源项目</p><h5 id="（2）Gitlab"><a href="#（2）Gitlab" class="headerlink" title="（2）Gitlab"></a>（2）Gitlab</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171119389.png" alt="img" style="zoom:67%;"><p>网址：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p><p>Gitlab支持免费搭建私有库，功能强大，对企业级的内部开发友好，较为笨重不适合用于简单项目的搭建</p><h5 id="（3）Gitee"><a href="#（3）Gitee" class="headerlink" title="（3）Gitee"></a>（3）Gitee</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122135738.png" alt="logo_gitee_light (1)"></p><p>网址：<a href="https://gitee.com/">https://gitee.com/</a></p><p>俗称码云，国内知名的在线代码托管平台，基于gitlab</p><h5 id="（4）Coding"><a href="#（4）Coding" class="headerlink" title="（4）Coding"></a>（4）Coding</h5><img src="https://assets.codehub.cn/resources/logo2-png.png" alt="img" style="zoom: 150%;"><p>网址：<a href="https://coding.net/">https://coding.net/</a></p><p>Coding 是一个面向开发者的云端开发平台，提供git/svn 代码托管,并且面向个人提供私有库。</p><p>对国内小团队开发较为友好，个人比较推荐，下面的一些操作都会基于Coding平台</p><h3 id="Git快速入门"><a href="#Git快速入门" class="headerlink" title="Git快速入门"></a>Git快速入门</h3><h4 id="1-Git安装"><a href="#1-Git安装" class="headerlink" title="1.Git安装"></a>1.Git安装</h4><p>git官网地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122216111.png" alt="image-20200629224316821"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217579.png" alt="image-20200629224329147"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217315.png" alt="image-20200629224339198"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217952.png" alt="image-20200629224349811"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217176.png" alt="image-20200629224400914"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217277.png" alt="image-20200629224411947"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217903.png" alt="image-20200629224425378"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217019.png" alt="image-20200629224436646"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122217284.png" alt="image-20200629224446392"></p><h4 id="2-Git密钥"><a href="#2-Git密钥" class="headerlink" title="2.Git密钥"></a>2.Git密钥</h4><p>本地仓库与远程仓库通过SSH公私钥进行身份确认，</p><h5 id="（1）生成公钥"><a href="#（1）生成公钥" class="headerlink" title="（1）生成公钥"></a>（1）生成公钥</h5><p>终端输入命令生成公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure><p>连续三次回车使用默认设置</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122334723.png" alt="image-20211112233436546"></p><h5 id="（2）查看公钥"><a href="#（2）查看公钥" class="headerlink" title="（2）查看公钥"></a>（2）查看公钥</h5><p>旁边的id_rsa存的就是私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 【公钥保存位置】/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122342467.png" alt="image-20211112234254250"></p><h5 id="（3）上传公钥"><a href="#（3）上传公钥" class="headerlink" title="（3）上传公钥"></a>（3）上传公钥</h5><p>打开coding的个人设置页面即可上传公钥</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122349256.png" alt="image-20211112234911836"></p><h5 id="（4）Git连接测试"><a href="#（4）Git连接测试" class="headerlink" title="（4）Git连接测试"></a>（4）Git连接测试</h5><p>通过以下命令即可测试ssh连接是否成功（第一次连接需要一个输入yes的步骤）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122355195.png" alt="image-20211112235520804"></p><h4 id="3-Git项目创建实战"><a href="#3-Git项目创建实战" class="headerlink" title="3.Git项目创建实战"></a>3.Git项目创建实战</h4><h5 id="（1）Coding上创建项目"><a href="#（1）Coding上创建项目" class="headerlink" title="（1）Coding上创建项目"></a>（1）Coding上创建项目</h5><p>点击创建项目</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111122358086.png" alt="image-20211112235849036"></p><p>选择模板2中的代码托管即可</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130004964.png" alt="image-20211113000450682"></p><p>填写项目基本信息，即可完成创建</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130008061.png" alt="image-20211113000842644"></p><h5 id="（2）创建代码仓库"><a href="#（2）创建代码仓库" class="headerlink" title="（2）创建代码仓库"></a>（2）创建代码仓库</h5><p>在项目下创建代码仓库</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130012170.png" alt="image-20211113001242845"></p><p>基本设置如下：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130016365.png" alt="image-20211113001619059"></p><h5 id="（3）将项目克隆到本地"><a href="#（3）将项目克隆到本地" class="headerlink" title="（3）将项目克隆到本地"></a>（3）将项目克隆到本地</h5><p>复制仓库的ssh链接，将一个仓库内的代码使用ssh下载到本地</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130019611.png" alt="image-20211113001922314"></p><p>电脑上执行git clone命令，将远程仓库克隆为本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 【SSH链接】</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130044923.png" alt="image-20211113004407422"></p><p>有时会出现下载时权限不足的情况，但是ssh的连接测试又能成功，这时候可以尝试一下重新提交公钥</p><p>进入项目文件夹</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130047475.png" alt="image-20211113004735237"></p><p>在git bash下可以看到Test文件有master的符号</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130048748.png" alt="image-20211113004836580"></p><h5 id="（4）设置签名"><a href="#（4）设置签名" class="headerlink" title="（4）设置签名"></a>（4）设置签名</h5><p>设置签名以区分不同开发者的身份（与代码托管中心的账号，密码无关）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;Autovy&quot;</span><br><span class="line">git config user.email &quot;autovys@gmail.com&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130053370.png" alt="image-20211113005344281"></p><p>设置完成后，即可在配置文件看到相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./.git/config</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130055517.png" alt="image-20211113005519211"></p><h5 id="（5）代码提交流程"><a href="#（5）代码提交流程" class="headerlink" title="（5）代码提交流程"></a>（5）代码提交流程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130117765.png" alt="img"></p><p>修改项目文件</p><p>创建一个html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test&quot; &gt; index.html</span><br></pre></td></tr></table></figure><p>修改md文件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131044670.png" alt="image-20211113104443895"></p><p>将工作区改动内容提交到缓存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br></pre></td></tr></table></figure><p>查看工作区和缓存区状态</p><p>可以看到文件改动情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130109179.png" alt="image-20211113010859895"></p><p>将缓存区的内容提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;v1.1：添加index文件&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130111345.png" alt="image-20211113011106112"></p><p>查看历史记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130112029.png" alt="image-20211113011224760"></p><p>将本地仓库的内容推送到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130113789.png" alt="image-20211113011323568"></p><p>最后可以看到Coding仓库变化</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130120323.png" alt="image-20211113012003368"></p><h3 id="Git高级使用"><a href="#Git高级使用" class="headerlink" title="Git高级使用"></a>Git高级使用</h3><h4 id="1-Git版本管理"><a href="#1-Git版本管理" class="headerlink" title="1.Git版本管理"></a>1.Git版本管理</h4><h5 id="（1）更新1-2为最新版"><a href="#（1）更新1-2为最新版" class="headerlink" title="（1）更新1.2为最新版"></a>（1）更新1.2为最新版</h5><p>重复上面步骤，修改并更新index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130856940.png" alt="image-20211113085631627"></p><p>修改md中的版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130858725.png" alt="image-20211113085813333"></p><p>将1.2版本的代码按步骤提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;v1.2：增加index文件标题&quot;</span><br></pre></td></tr></table></figure><p>这里先不推送远端仓库，方便后续切换版本</p><h5 id="（2）查看日志"><a href="#（2）查看日志" class="headerlink" title="（2）查看日志"></a>（2）查看日志</h5><p>git log 查看提交日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130908924.png" alt="image-20211113090846535"></p><p>commit后面一大段的字符串是commit id（版本号），这里<code>HEAD</code>是Git指向当前版本的指针，所以要切换版本就要移动<code>HEAD</code>到指定版本</p><h5 id="（3）修改未添加缓冲区"><a href="#（3）修改未添加缓冲区" class="headerlink" title="（3）修改未添加缓冲区"></a>（3）修改未添加缓冲区</h5><p>修改index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131239773.png" alt="image-20211113123920560"></p><p>在对文件使用<code>add ./</code>将项目添加缓存区之前，我反悔了，决定丢弃工作区的修改</p><p>查看当前状态,可以看到提示使用<code>git restore</code>丢弃修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131243158.png" alt="image-20211113124311037"></p><p>丢弃修改工作区的修改，文件恢复到最近一次<code>git commit</code>或<code>git add</code>时的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore ./</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131245744.png" alt="image-20211113124505502"></p><h5 id="（4）修改添加到缓存区"><a href="#（4）修改添加到缓存区" class="headerlink" title="（4）修改添加到缓存区"></a>（4）修改添加到缓存区</h5><p>修改index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131239773.png" alt="image-20211113123920560"></p><p>添加修改到缓冲区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add ./</span><br></pre></td></tr></table></figure><p>查看当前状态,可以看到提示使用<code>git restore --staged</code>丢弃缓存内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131253728.png" alt="image-20211113125325665"></p><p>丢弃缓存内容后，再按上一种情况的流程恢复工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged ./</span><br><span class="line">git status</span><br><span class="line">git restore ./</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131257426.png" alt="image-20211113125708241"></p><h5 id="（5）修改提交到本地仓库"><a href="#（5）修改提交到本地仓库" class="headerlink" title="（5）修改提交到本地仓库"></a>（5）修改提交到本地仓库</h5><p>将版本回退到上一个版本即1.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130918240.png" alt="image-20211113091804033"></p><p>这时本地仓库就回退到了1.1版本</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130921002.png" alt="image-20211113092137541"></p><p>这时候查看git log，可以发现1.2的提交记录就移除</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131027386.png" alt="image-20211113102703410"></p><p>如果又需要回到1.2版本</p><p>先通过<code>git reflog</code>查看历史命令，可以找到1.2版本的id</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131029910.png" alt="image-20211113102934666"></p><p>同样可以使用git reset切换版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 【commit id】</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131034955.png" alt="image-20211113103418305"></p><p>这里的commit id不用填完整，填到后面的字母部分</p><p>这时本地仓库又切回了1.2</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131035167.png" alt="image-20211113103512977"></p><p>【注意】</p><p>如果已经将最新的代码推送过远端仓库（即远端仓库有最新的版本，要保持本地和远端的资源一致），会报以下错误、</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131037463.png" alt="image-20211113103733311"></p><h5 id="（6）修改推送到远程仓库"><a href="#（6）修改推送到远程仓库" class="headerlink" title="（6）修改推送到远程仓库"></a>（6）修改推送到远程仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD --edit //并修改提交信息</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130958874.png" alt="image-20211113095811776"></p><p>这时后查看记录git log，可以看到撤销的操作也被记录其中</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111130958447.png" alt="image-20211113095828085"></p><p>这时本地仓库就是回退到了版本1.1</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131003562.png" alt="image-20211113100356269"></p><p>直接推送到远程仓库，远程仓库也回退到1.1版本</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131006709.png" alt="image-20211113100641582"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131008429.png" alt="image-20211113100811889"></p><p>如果提交了1.1版本后，又需要回到1.2版本，这时候只要撤销掉对1.2的撤销即可</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131017882.png" alt="image-20211113101733694"></p><p>再git push推送到远程仓库即可</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131020252.png" alt="image-20211113102000137"></p><h5 id="（7）总结"><a href="#（7）总结" class="headerlink" title="（7）总结"></a>（7）总结</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131304234.webp" alt="img"></p><ul><li>工作区修改后：<code>git restore ./</code>恢复工作区</li><li><code>git add ./</code>添加到缓冲区后：<code>git restore --staged ./</code> 恢复缓存区</li><li><code>git commit</code>提交到本地仓库后：<code>git reset --hard HEAD^</code>恢复上个版本到缓存区</li><li><code>git push</code>推送到远程仓库后：<code>git revert HEAD --edit</code>撤销上一个推送操作，并恢复到缓存区</li></ul><h4 id="2-Git分支管理"><a href="#2-Git分支管理" class="headerlink" title="2.Git分支管理"></a>2.Git分支管理</h4><h5 id="（1）分支解决的问题"><a href="#（1）分支解决的问题" class="headerlink" title="（1）分支解决的问题"></a>（1）分支解决的问题</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131648459.png" alt="image-20200728190230431"></p><p>同时并行推进多个功能开发，提高开发效率</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</p><p>最后再将分支合并到master上</p><p>分支：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131704793.png" alt="git-br-dev-fd"></p><p>分支的合并（默认快速模式）：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131704428.png" alt="git-br-ff-merge"></p><p>分支的合并（普通模式）：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131923880.png" alt="git-no-ff-mode"></p><h5 id="（2）分支基本操作"><a href="#（2）分支基本操作" class="headerlink" title="（2）分支基本操作"></a>（2）分支基本操作</h5><p>创建dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure><p><code>git checkout -b dev</code>可以创建并切换到dev分支</p><p>查看当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131739936.png" alt="image-20211113173909862"></p><p>可以看到dev分支已经创建成功了，而当前位于master分支</p><p>切换到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131741071.png" alt="image-20211113174105689"></p><p>修改文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131743765.png" alt="image-20211113174328787"></p><p>将最新修改的内容提交到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;dev new test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131744195.png" alt="image-20211113174453991"></p><p>切换回master分支，并查看文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch master</span><br><span class="line">cat README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131747443.png" alt="image-20211113174734151"></p><p>可以看到主分支上没有dev的内容</p><p>合并分支</p><p>在master分支上合并dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131907625.png" alt="image-20211113190746514"></p><p>可以看到在dev上的修改在master上生效了</p><h5 id="（3）分支合并冲突问题"><a href="#（3）分支合并冲突问题" class="headerlink" title="（3）分支合并冲突问题"></a>（3）分支合并冲突问题</h5><p>前面的情况中，dev是在master基础上的，合并前master并没有修改，如果master再合并前与dev修改了同一行的内容就会出现冲突</p><p>先撤销一下合并</p><p>查看命令记录，可以看到合并记录中合并的方式是快速模式（即直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131917856.png" alt="image-20211113191710611"></p><p>撤销合并（未推送）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131928808.png" alt="image-20211113192813592"></p><p>修改master内容，并提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131936127.png" alt="image-20211113193624097"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;master new test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131933331.png" alt="image-20211113193330217"></p><p>再次合并dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>这时就会出现合并冲突的问题</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131937333.png" alt="image-20211113193742100"></p><p>解决冲突</p><p>编辑README.md文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p>删除特殊符号，修改内容</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131948656.png" alt="image-20211113194812446"></p><p>然后正常提交到master分支即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;master+dev&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131950140.png" alt="image-20211113195019152"></p><p>一般来说不会再本地仓库库对分支进行合并，而是在远程的代码平台进行分支的合并</p><p>推送内容到master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131954980.png" alt="image-20211113195444076"></p><p>由于远程仓库还没有创建dev分支，所以推送时要创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin dev</span><br></pre></td></tr></table></figure><p>这时即可在Coding上看到两个分支了</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111131959633.png" alt="image-20211113195934598"></p><p>代码平台上也可以合并分支，当如果有冲突就无法合并</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132004299.png" alt="image-20211113200419162"></p><h5 id="（3）分支中的多人协作"><a href="#（3）分支中的多人协作" class="headerlink" title="（3）分支中的多人协作"></a>（3）分支中的多人协作</h5><p>准备wsl模拟另一台电脑，一个新的coding账号，新的coding账号提交wsl中的ssh，然后使用两个浏览器登录分别登录两个账号</p><p>将第二个账号（二号机）邀请到主账号的团队中</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132151963.png" alt="image-20211113215154747"></p><p>将二号机拉入项目中</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132153673.png" alt="image-20211113215314621"></p><p>二号机wsl看到项目后克隆项目到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@e.coding.net:autovys/demo/Test.git</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132157453.png" alt="image-20211113215727175"></p><p>进入目录后查看分支，可以发现只能看到master分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132201201.png" alt="image-20211113220115181"></p><p>二号机要在dev基础上进行开发，就要创建远程<code>origin</code>的<code>dev</code>分支到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132204477.png" alt="image-20211113220445123"></p><p>二号机在dev基础上修改了文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132210496.png" alt="image-20211113221049407"></p><p>并且二号机还推送到了远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m&quot;edit something&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132214127.png" alt="image-20211113221447824"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132216488.png" alt="image-20211113221631576"></p><p>这时一号机也要对同样的文件修改一些内容，并尝试推送到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132236484.png" alt="image-20211113223622153"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;add someting&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132238492.png" alt="image-20211113223826310"></p><p>可以发现远程推送失败了，因为二号机的最新提交和我推送的提交有冲突</p><p>这时就需要先<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132242133.png" alt="image-20211113224245383"></p><p>这时候解决的方法和分支管理中的解决冲突完全一样</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132245482.png" alt="image-20211113224352026"></p><p>编辑README.md文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p>删除特殊符号，修改内容</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132246382.png" alt></p><p>然后正常提交到dev分支即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;dev lastest&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111132248140.png" alt="image-20211113224806916"></p><h3 id="IDEA中的Git"><a href="#IDEA中的Git" class="headerlink" title="IDEA中的Git"></a>IDEA中的Git</h3><h4 id="1-基本代码提交流程"><a href="#1-基本代码提交流程" class="headerlink" title="1.基本代码提交流程"></a>1.基本代码提交流程</h4><h5 id="（1）创建空项目"><a href="#（1）创建空项目" class="headerlink" title="（1）创建空项目"></a>（1）创建空项目</h5><p>在Coding上创建新的空的代码仓库</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151520287.png" alt="image-20211115152050857"></p><p>idea克隆项目到本地</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151538447.png" alt="image-20211115153822099"></p><p>填写远程仓库的SSH地址和下载的本地位置完成下载</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151539643.png" alt="image-20211115153943646"></p><h5 id="（2）IDEA打开项目文件"><a href="#（2）IDEA打开项目文件" class="headerlink" title="（2）IDEA打开项目文件"></a>（2）IDEA打开项目文件</h5><p>IDEA打开项目文件后，可以看到IDEA自动识别了git，出现了以下的一些工具</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151525037.png" alt="image-20211115152526919"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151525272.png" alt="image-20211115152549962"></p><h5 id="（3）代码提交流程"><a href="#（3）代码提交流程" class="headerlink" title="（3）代码提交流程"></a>（3）代码提交流程</h5><p>修改README.md文件如下，即在工作区改动了代码</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151547945.png" alt="image-20211115154732860"></p><p>将代码添加到缓冲区（<strong>git add ./</strong>），这一步可以省略，直接提交idea会帮你做这一步操作</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151552952.png" alt="image-20211115155242753"></p><p>提交代码到本地仓库，注意填写提交信息（<code>git commit -m &quot;message&quot;</code>）</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171119189.png" alt="image-20211115155909225" style="zoom:67%;"><p>最后推送到远程仓库，即完成一次代码提交（<code>git push</code>）</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171120093.png" alt="image-20211115160154599" style="zoom:67%;"><p>关于提交的一些信息我们都可以在git工具栏的控制台进行查看，可以看到git工具的控制台帮我们输入的命令内容</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151604019.png" alt="image-20211115160454918"></p><h4 id="2-Git版本管理"><a href="#2-Git版本管理" class="headerlink" title="2.Git版本管理"></a>2.Git版本管理</h4><h5 id="（1）更新版本到1-2"><a href="#（1）更新版本到1-2" class="headerlink" title="（1）更新版本到1.2"></a>（1）更新版本到1.2</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151607155.png" alt="image-20211115160753928"></p><h5 id="（2）查看提交日志"><a href="#（2）查看提交日志" class="headerlink" title="（2）查看提交日志"></a>（2）查看提交日志</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151609447.png" alt="image-20211115160933261"></p><p>可以看到idea使用git不需要设置签名，而是默认使用了远程仓库平台的注册信息</p><h5 id="（3）修改未添加缓冲区-1"><a href="#（3）修改未添加缓冲区-1" class="headerlink" title="（3）修改未添加缓冲区"></a>（3）修改未添加缓冲区</h5><p>代码未添加到缓冲区，需要恢复工作区的内容（简单呀，疯狂ctrl + Z 😎）</p><p>可以使用回滚，即可恢复到最近一次<code>git commit</code>或<code>git add</code>时的状态</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151615806.png" alt="image-20211115161519696"></p><h5 id="（4）修改添加到缓存区-1"><a href="#（4）修改添加到缓存区-1" class="headerlink" title="（4）修改添加到缓存区"></a>（4）修改添加到缓存区</h5><p>版本1.2已经添加到了缓存区，同样可以通过上面的方法恢复工作区</p><h5 id="（5）修改提交到本地仓库-1"><a href="#（5）修改提交到本地仓库-1" class="headerlink" title="（5）修改提交到本地仓库"></a>（5）修改提交到本地仓库</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171120642.png" alt="image-20211115162500521" style="zoom:67%;"><p>这时候可以看到回滚的按钮变灰了，这时我们可以打开git工具区对master分支进行操作，idea提供了三种还原的方法，都可以让我们恢复1.1版本</p><p>还原提交，是多加一步撤销的操作，恢复内容到本地仓库，可以直接提交</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151635193.png" alt="image-20211115163502070"></p><p>撤销提交，是让1.2版本恢复到缓存区，这时候可以通过回滚恢复到1.1版本</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151638218.png" alt="image-20211115163801094"></p><p>删除提交，直接恢复1.1版本到工作区</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151642751.png" alt="image-20211115164217388"></p><p>所以推荐使用<strong>还原提交</strong>，如果要丢弃的版本就使用<strong>删除提交</strong>，否则idea无法恢复已<strong>撤销</strong>或<strong>删除</strong>的提交（命令行可以恢复）</p><h5 id="（6）修改推送到远程仓库-1"><a href="#（6）修改推送到远程仓库-1" class="headerlink" title="（6）修改推送到远程仓库"></a>（6）修改推送到远程仓库</h5><p>推送到远程仓库后，我们可以看到我们只剩下还原提交可以使用了，效果和上面的一样</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151654101.png" alt="image-20211115165440862"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111151655427.png" alt="image-20211115165553230"></p><p>idea还提供了将<strong>当前分支重置到此处</strong>的功能，其相当于进行多次的<strong>删除提交</strong>操作。在修改已提交到本地仓库的情况下，可以开始回溯到选择的版本；在修改已推送到远程的情况下可能会造成<strong>冲突</strong>问题，所以该功能慎重使用</p><p>​    <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171119727.png" alt="image-20211115172549467">)<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171119566.png" alt="image-20211115173345841"></p><h5 id="（7）还原提交的问题"><a href="#（7）还原提交的问题" class="headerlink" title="（7）还原提交的问题"></a>（7）还原提交的问题</h5><p>还原提交也可以还原更远的版本，但是会出现冲突问题，</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152003466.png" alt="image-20211115200310949"></p><p>接收他们的则回滚到对应版本，合并则解决两个修改的冲突</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171119845.png" alt="image-20211115200355899"></p><p>合并的页面如下，点击箭头即可自动修改冲突点</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152005861.png" alt="image-20211115200459979"></p><h4 id="3-Git分支管理"><a href="#3-Git分支管理" class="headerlink" title="3.Git分支管理"></a>3.Git分支管理</h4><h5 id="（1）分支基本操作"><a href="#（1）分支基本操作" class="headerlink" title="（1）分支基本操作"></a>（1）分支基本操作</h5><p>创建分支dev</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152012354.png" alt="image-20211115201204089"></p><p>git工作区右键选择分支<strong>签出</strong>（checkout,什么铸币翻译）即可切换分支，注意记得先切换好分支再对提交的路径图进行操作，否则它提交的到的是当前的分支，即便是在另一条分支上做的操作</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152025323.png" alt="image-20211115202549168"></p><p>这里在dev上操作的还原提交会被提交给master，所以要记得切换分支（这算不算一个小bug呢？），另外要删除一个分支时也要先切换到其他分支</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111171120317.png" alt="image-20211115203232293" style="zoom:67%;"><p>修改文件提交到dev</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152014852.png" alt="image-20211115201418871"></p><p>直接选择推送，远程仓库就可以发现dev分支被创建好了</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152156328.png" alt="image-20211115215649882"></p><p>合并master和dev分支，当前选择的是master分支，所以选择将<strong>当前合并到已选择</strong>（渣翻ks8）即为将dev合并到master</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152143774.png" alt="image-20211115214311537"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152145633.png" alt="image-20211115214548426"></p><h5 id="（2）分支合并冲突问题"><a href="#（2）分支合并冲突问题" class="headerlink" title="（2）分支合并冲突问题"></a>（2）分支合并冲突问题</h5><p>先删除合并的提交恢复master，修改master的文件并提交</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152148111.png" alt="image-20211115214855710"></p><p>这时候合并就会出现合并冲突现象</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152151512.png" alt="image-20211115215121774"></p><p>前面两个是对master修改的内容与dev修改的内容做一个选择，选择合并则需要手动修改解决冲突</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152153800.png" alt="image-20211115215351531"></p><p>点击箭头即可合并修改</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152154978.png" alt="image-20211115215421974"></p><h5 id="（3）分支中的多人协作-1"><a href="#（3）分支中的多人协作-1" class="headerlink" title="（3）分支中的多人协作"></a>（3）分支中的多人协作</h5><p>推送上面修改的master分支和dev分支，然后删除本地项目文件（即删除了本地仓库），进行一次remake</p><p>重新使用idea克隆项目到本地，可以看到本地只拉取了master分支</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152204429.png" alt="image-20211115220444280"></p><p>这时候就需要右键点击远程的分支，新建dev分支到本地</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152207194.png" alt="image-20211115220650353"></p><p>在Coding平台上改动dev分支的文件，模拟另一个开发人员在协同开发的情况下修改了文件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152210219.png" alt="image-20211115221009031"></p><p>这时候我们在本地也修改了dev分支文件并推送</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152212003.png" alt="image-20211115221205796"></p><p>这时候idea会有弹窗提醒<strong>推送被拒绝</strong>，并在控制台提醒你用<code>git pull</code></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152213026.png" alt="image-20211115221318639"></p><p>idea是有git pull 这个按钮的</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152216055.png" alt="image-20211115221609871"></p><p>但是点击更新到dev时，会提示你本地的dev没有追踪远程的分支</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152217453.png" alt="image-20211115221717207"></p><p>点击提示选择上游分支同步远程的dev分支即可</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152218528.png" alt="image-20211115221849343"></p><p>如果其他开发者新的更新和我更新的有冲突，这时候就是我们熟悉的冲突页面啦</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111152219333.png" alt="image-20211115221925143"></p><p>解决冲突后我们就可以推送最新版到远程仓库了，这样的机制保证了git协同开发的可能性</p><h3 id="Git原理"><a href="#Git原理" class="headerlink" title="Git原理"></a>Git原理</h3><p><strong>Git本质是一个内容寻址的文件系统，其次才是一个版本控制系统</strong></p><p>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作是将被改写的文件保存为<strong>数据对象</strong>，更新暂存区，记录<strong>树对象</strong>，最后创建一个指明了顶层树对象和父提交的<strong>提交对象</strong></p><p>Git的核心是它的对象数据库（<strong>.git/objects</strong>文件），其中保存着git的对象：</p><ul><li><strong>blob对象</strong>：实现了对文件内容的记录</li><li><strong>tree对象</strong>：实现了对文件名、文件目录结构的记录</li><li><strong>commit对象</strong>：实现了对版本提交时间、版本作者、版本序列、版本说明等附加信息的记录</li></ul><h4 id="1-Git数据库"><a href="#1-Git数据库" class="headerlink" title="1.Git数据库"></a>1.Git数据库</h4><h5 id="（1）Git文件结构"><a href="#（1）Git文件结构" class="headerlink" title="（1）Git文件结构"></a>（1）Git文件结构</h5><p>新建文件夹并将其初始化为一个空的git仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Test</span><br><span class="line">git init Test</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161632587.png" alt="image-20211116163217085"></p><p>进入git文件使用以下命令查看git仓库的文件结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Test/.git</span><br><span class="line">tree/F</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161634477.png" alt="image-20211116163406004"></p><ul><li><strong>config</strong>是git基本配置文件</li><li><strong>description</strong>是GitWeb专用的文件</li><li><strong>info</strong>文件夹是全局性排除文件（与.gitignore互补）</li><li><strong>hooks</strong>存放钩子脚本</li><li><strong>HEAD</strong>记录当前checkout的分支</li><li><strong>refs</strong>提交对象的指针</li><li><strong>objects</strong>存放所有数据，这就是我们要找的数据库了</li></ul><h5 id="（2）Git数据库写入操作"><a href="#（2）Git数据库写入操作" class="headerlink" title="（2）Git数据库写入操作"></a>（2）Git数据库写入操作</h5><p>Git会根据文件内容计算出一个hash值，以hash值作为文件索引存储在Git文件系统中</p><p><code>git hash-object</code>可以用来计算文件内容的hash值，并将生成的数据对象存储到Git文件系统中</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161933764.png" alt="image-20211116193321631"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;version 1&quot; | git hash-object -w --stdin</span><br></pre></td></tr></table></figure><p><code>-w</code>表示将数据对象写入到Git文件系统中，<code>--stdin</code>表示从标准输入中获取文件内容</p><p>命令执行完成后返回一个哈希值，它就是git数据库中的<strong>键值（key）</strong>，通过键值我们可以再次检索到插入数据库的内容<strong>（value）</strong>，实际上git数据库就是一个简单的<strong>键值对</strong>数据库</p><p>查看object文件，可以看到新生成的文件，这个文件存储以新存入数据<strong>对应hash值前2位</strong>命名的文件夹内</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161934272.png" alt="image-20211116193416942"></p><h5 id="（3）Git数据库查询操作"><a href="#（3）Git数据库查询操作" class="headerlink" title="（3）Git数据库查询操作"></a>（3）Git数据库查询操作</h5><p>既然我们拿到了键值，那肯定可以查询到其对应的内容，复制hash值进行查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t d73e3875a8db6b402e2ce905c4a2222603c1f090</span><br><span class="line"></span><br><span class="line">git cat-file -p d73e3875a8db6b402e2ce905c4a2222603c1f090</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161935233.png" alt="image-20211116193551166"></p><p><code>-p</code>表示查看Git对象的内容，<code>-t</code>表示查看Git对象的类型</p><p>blob对象是git数据库中的<strong>数据对象</strong>，此外数据库中还有<strong>树对象</strong>（tree）和<strong>提交对象</strong>（commit）</p><h4 id="4-使用Git跟踪文件变更"><a href="#4-使用Git跟踪文件变更" class="headerlink" title="4.使用Git跟踪文件变更"></a>4.使用Git跟踪文件变更</h4><p>接下来我们将模拟一次文件变更过程，看看git的对象数据库能不能实现“跟踪文件变更”的功能</p><h5 id="（1）创建文件"><a href="#（1）创建文件" class="headerlink" title="（1）创建文件"></a>（1）创建文件</h5><p>创建一个txt文件写入内容“v1.1”，并写入到git数据库中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;version 1&quot; &gt; file.txt</span><br><span class="line">git hash-object -w file.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161937621.png" alt="image-20211116193749552"></p><h5 id="（2）修改文件"><a href="#（2）修改文件" class="headerlink" title="（2）修改文件"></a>（2）修改文件</h5><p>修改file.txt的内容，并再次提交到git数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;version 2&quot; &gt; file.txt</span><br><span class="line">git hash-object -w file.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161938803.png" alt="image-20211116193813071"></p><p>可以看到这次的hash值已经发生改变了，而objetcs内会多出一个文件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161938498.png" alt="image-20211116193846013"></p><p>查询它们对应的内容如下</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161939714.png" alt="image-20211116193930700"></p><p>说明我们对同一个文件修改后的内容也会经过git数据库的哈希处理再数据库生成新的数据对象，以此记录文件的不同版本</p><h5 id="（3）恢复文件"><a href="#（3）恢复文件" class="headerlink" title="（3）恢复文件"></a>（3）恢复文件</h5><p>所以我们想要把文件恢复到文件修改前版本，只需要在数据库取回即可，这就是<strong>git版本回滚的实质</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br><span class="line">git cat-file -p 83baa &gt; file.txt</span><br><span class="line">cat file.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111161945593.png" alt="image-20211116194508507"></p><p>数据对象只是解决了文件内容存储的问题，而文件名的存储则需要通过树对象来解决</p><h4 id="5-Git的树对象"><a href="#5-Git的树对象" class="headerlink" title="5.Git的树对象"></a>5.Git的树对象</h4><p>Git通过树对象（tree）将数据（blob）对象组织起来——其类型于一种文件系统：blob对应文件内容，tree对象对应的目录和节点</p><p>有了数对象，我们就可以将文件系统任何时间点的状态保存在git数据库中</p><h5 id="（1）创建树对象（文件已提交数据库）"><a href="#（1）创建树对象（文件已提交数据库）" class="headerlink" title="（1）创建树对象（文件已提交数据库）"></a>（1）创建树对象（文件已提交数据库）</h5><p>Git根据某一个<strong>暂存区</strong>所表示的状态记录一个对应的树对象，git的暂存区是一个文件：<code>.git/index</code></p><p>这里要注意将file文件放在<code>.git</code>文件外，否则无法创建暂存区（上面的操作我都把file.txt放在了.git内🤧）,大概错误如下</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162013837.png" alt="image-20211116201312604"></p><p>创建暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git update-index --add file.txt</span><br><span class="line">cat .git\index</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162016844.png" alt="image-20211116201640442"></p><p>查看<strong>暂存区</strong>的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --stage</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162019086.png" alt="image-20211116201945864"></p><p>将<strong>暂存区</strong>的内容写入一个树对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git write-tree</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162023263.png" alt="image-20211116202313249"></p><p>这时候再查看git数据库，树对象也被存入git数据库内了</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162024659.png" alt="image-20211116202420483"></p><p>再查看该记录存储的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 79335</span><br><span class="line">git cat-file -p 79335</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162026758.png" alt="image-20211116202635361"></p><p>可以看到树对象中存储着<strong>文件名</strong>与<strong>文件内容对应的哈希值</strong>等</p><h5 id="（2）创建对象（文件未提交数据库）"><a href="#（2）创建对象（文件未提交数据库）" class="headerlink" title="（2）创建对象（文件未提交数据库）"></a>（2）创建对象（文件未提交数据库）</h5><p>上面我们是添加一个已经存在再git数据库的文件到暂存区，如果我们新建一个未曾保存到git数据库的文件到暂存区，进而保存为tree对象</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162053546.png" alt="image-20211116205331283"></p><ul><li>我们会发现新文件提交到暂存区后也会自动添加到数据库</li><li>添加文件到暂存区是追加操作，变更提交后，<strong>暂存区并没有清空</strong></li></ul><h5 id="（3）子文件夹保存到树对象"><a href="#（3）子文件夹保存到树对象" class="headerlink" title="（3）子文件夹保存到树对象"></a>（3）子文件夹保存到树对象</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_dir</span><br><span class="line">git update-index --add new_dir</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162056889.png" alt="image-20211116205602679"></p><p>可以发现，我们无法将一个空文件夹添加到暂存区，并且提示我们应该将文件夹中的文件加入<strong>暂存区</strong></p><p>接下来我们就试一下将文件夹中的文件添加进缓存区</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162100367.png" alt="image-20211116210040965"></p><p>可以发现文件夹是以一个tree对象添加进树中的</p><p>所以git的树对象的组织方式大致如下</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162102494.png" alt="img"></p><p>树对象相当于源代码的一次次快照，因此我们可以用树对象作为源代码版本管理，接下来我们还需要解决记录谁提交了代码、什么时候提交的、提交的说明信息等的问题，这就需要用到提交对象</p><h4 id="6-Git的提交对象"><a href="#6-Git的提交对象" class="headerlink" title="6.Git的提交对象"></a>6.Git的提交对象</h4><h5 id="（1）创建提交对象"><a href="#（1）创建提交对象" class="headerlink" title="（1）创建提交对象"></a>（1）创建提交对象</h5><p>将创建的树对象提交为commit对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git write-tree</span><br><span class="line">git commit-tree 15da -m &quot;frist commit&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162235396.png" alt="image-20211116223537292"></p><p>查看提交对象的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p dd7b6</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162236318.png" alt="image-20211116223657063"></p><p>我们可以看到一个提交对象包含提交版本的<strong>树对象hash键值</strong>，author和commiter，以及修改和提交时间，以及提交的注释信息</p><h5 id="（2）提交新版本"><a href="#（2）提交新版本" class="headerlink" title="（2）提交新版本"></a>（2）提交新版本</h5><p>生成新的文件的对象树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;new version&quot; &gt; file.txt</span><br><span class="line">git update-index file.txt</span><br><span class="line">git write-tree</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162248307.png" alt="image-20211116224816724"></p><p>在上一次提交的基础上提交对象树作为提交对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit-tree a4098 -p dd7b6 -m &quot;second commit&quot;</span><br><span class="line">98b0754a75a763db80ac689cd16e2665ced92589</span><br></pre></td></tr></table></figure><p><code>-p</code>对应上次提交对象的hash值</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162248268.png" alt="image-20211116224828288"></p><p>查看提交对象，可以看到多了一个父提交的记录</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162249974.png" alt="image-20211116224957926"></p><h5 id="（3）提交对象记录"><a href="#（3）提交对象记录" class="headerlink" title="（3）提交对象记录"></a>（3）提交对象记录</h5><p>通过git log 查看提交对象记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 98b0</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162253027.png" alt="image-20211116225317939"></p><p>至此我们可以看到git对象之间联系的全貌了</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162303582.png" alt="img"></p><h4 id="7-Git的引用"><a href="#7-Git的引用" class="headerlink" title="7.Git的引用"></a>7.Git的引用</h4><p>以上的操作，我们对版本和数据对象的操作都是基于hash键值的，但是这些字符串是毫无意义的，所以git引入了<strong>引用（reference）</strong>使用有意义的字符串<strong>对应</strong>哈希值来解决这个问题，其主要应用于<strong>分支</strong></p><h5 id="（1）创建引用"><a href="#（1）创建引用" class="headerlink" title="（1）创建引用"></a>（1）创建引用</h5><p>为最新的提交对象创建一个引用名为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log 98b0</span><br><span class="line">git update-ref refs/heads/master 98b0</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162328532.png" alt="image-20211116232811501"></p><h5 id="（2）查看"><a href="#（2）查看" class="headerlink" title="（2）查看"></a>（2）查看</h5><p>创建成功后，我们就可以使用master来代替hash值查看提交对象记录</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111162329835.png" alt="image-20211116232919198"></p><p>这就是git分支的本质：一个指向某一系列提交之首的<strong>指针</strong></p><p>(<a href="https://raw.githubusercontents.com/Autovy/Image/master/img/202111162329835.png">https://raw.githubusercontents.com/Autovy/Image/master/img/202111162329835.png</a>)</p><p>这就是git分支的本质：一个指向某一系列提交之首的<strong>指针</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202111122115839.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="git" scheme="https://autovy.github.io/tags/git/"/>
    
      <category term="Coding" scheme="https://autovy.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|TCP可视化实验</title>
    <link href="https://autovy.github.io/2021/10/27/DevPrinciple/TCP%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E9%AA%8C/"/>
    <id>https://autovy.github.io/2021/10/27/DevPrinciple/TCP%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-10-27T15:45:00.000Z</published>
    <updated>2022-10-25T08:48:30.250Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271342730.webp" alt="I’m going to tell a joke | excel-memes, tcp-memes, udp-memes | ProgrammerHumor.io" style="zoom: 50%;"><p>TCP好复杂🤧，主要使用了Kali Linux上的一些网络工具来进行分析，希望能直观地解析TCP（备考中，更新缓慢…）</p><span id="more"></span><p>参考资料：<a href="https://wizardforcel.gitbooks.io/network-basic/content/0.html">网络基本功系列</a></p><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h4><h5 id="（1）Kali-Linux虚拟机安装"><a href="#（1）Kali-Linux虚拟机安装" class="headerlink" title="（1）Kali Linux虚拟机安装"></a>（1）Kali Linux虚拟机安装</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110181946991.png" alt="image-20211018194604769"></p><p>在<code>Kail Linux</code>的官网下载对应的系统镜像文件：<a href="https://www.kali.org/get-kali/">Get Kali </a>，这里我选择中间这个版本（2021.3-installer-amd64）</p><p>具体的虚拟机安装过程这里不赘述，我使用的是<code>VMware Workstation</code>，可以参照这篇文章进行安装：<a href="https://blog.csdn.net/Fengfeng__y/article/details/107376064">Vmware安装Kali Linux2020.2</a></p><p>之所以选择<strong>Kali Linux</strong>系统是因为其内置了<strong>Nginx</strong>，<strong>tcpdump</strong>，<strong>Wireshark</strong>这些我们需要用到的实验工具</p><h5 id="（2）VM与Hype-V不可共存"><a href="#（2）VM与Hype-V不可共存" class="headerlink" title="（2）VM与Hype-V不可共存"></a>（2）VM与Hype-V不可共存</h5><p>我使用的是VM15.5会与Windows的Hype-V发生冲突，所以需要关闭Hype-V</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231543739.png" alt="image-20211023154303399"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>重启电脑后，VM的虚拟机可以正常运行，但是wsl和docker就寄了</p><p>如果需要恢复的话，可以使用下面命令然后重启电脑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><h5 id="（3）准备客户端和服务端"><a href="#（3）准备客户端和服务端" class="headerlink" title="（3）准备客户端和服务端"></a>（3）准备客户端和服务端</h5><p>参考资料：<a href="https://blog.csdn.net/qq_44657899/article/details/107130729">linux修改ip地址</a></p><ul><li><p>克隆虚拟机</p><p>搭建好一个Kali虚拟机后，通过VM的克隆功能生成另一台虚拟机，为了节省空间可以直接克隆为链接虚拟机</p></li></ul><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192052996.png" alt="image-20211019205256464"></p><ul><li><p>修改网络模式</p><p>将两台虚拟机的网络模式设置为NAT模式</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192056463.png" alt="image-20211019205636065"></p></li></ul><ul><li>虚拟网络编辑器修改</li></ul><p>​    </p><p>​    <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192058546.png" alt="image-20211019205855124"></p><p>​    </p><p>​    使用管理员开始修改，并取消“使用本地DHCP服务将IP地址分配给虚拟机”的勾</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192100641.png" alt="image-20211019210009660"></p><ul><li><p>查看子网IP和网关IP</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192104783.png" alt="image-20211019210418389"></p></li></ul><ul><li><p>修改客户端和服务端的IP地址</p><p>分别进入客户端和服务器打开终端</p><p>打开网络配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces</span><br></pre></td></tr></table></figure></li></ul><p>  修改客户端配置文件，设定客户端IP为<strong>192.168.234.100</strong></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"><span class="comment">#静态设置ip</span></span><br><span class="line">iface eth0 inet static</span><br><span class="line"><span class="comment">#设置ip地址</span></span><br><span class="line">address 192.168.234.100</span><br><span class="line"><span class="comment">#设置子网掩码</span></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"><span class="comment">#设置网关</span></span><br><span class="line">gateway 192.168.234.2</span><br></pre></td></tr></table></figure><p>  修改服务端配置文件，设定服务端IP为<strong>192.168.234.200</strong></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"><span class="comment">#静态设置ip</span></span><br><span class="line">iface eth0 inet static</span><br><span class="line"><span class="comment">#设置ip地址</span></span><br><span class="line">address 192.168.234.200</span><br><span class="line"><span class="comment">#设置子网掩码</span></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"><span class="comment">#设置网关</span></span><br><span class="line">gateway 192.168.234.2</span><br></pre></td></tr></table></figure><p>  分别重启网卡</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure><p>  分别查看IP信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192244070.png" alt="image-20211019224416761"></p><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192245918.png" alt="image-20211019224510781"></p><h5 id="（4）测试相关服务"><a href="#（4）测试相关服务" class="headerlink" title="（4）测试相关服务"></a>（4）测试相关服务</h5><ul><li><p>测试服务端端口占用</p><p>检测80端口是否被占用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:80</span><br></pre></td></tr></table></figure><p>如果被占用了使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure><p>关闭对应的进程</p></li></ul><ul><li><p>修改服务端nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在http块中添加server块</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server块</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>开启服务端nginx服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>默认在<strong>80端口</strong>开启</p></li></ul><ul><li><p>查看nginx状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192303593.png" alt="image-20211019230343549"></p></li></ul><ul><li><p>客户端访问服务端IP，即可看到部署在服务端的nginx页面</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110192306180.png" alt="image-20211019230646780"></p></li></ul><h4 id="2-基本工具介绍"><a href="#2-基本工具介绍" class="headerlink" title="2.基本工具介绍"></a>2.基本工具介绍</h4><h5 id="（1）tcpdump"><a href="#（1）tcpdump" class="headerlink" title="（1）tcpdump"></a>（1）tcpdump</h5><p>参考材料：<a href="https://www.eet-china.com/mp/a35364.html">https://www.eet-china.com/mp/a35364.html</a></p><p>tcpdump是常用的网络抓包和分析工具，常用于在Linux服务器</p><ul><li><p>tcp提供了以下<strong>选项</strong></p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTMxMjY1LzE1OTAwNjY0MzIwNTQtNzYwM2MzNmEtMDdhNC00MzVkLTk0NmYtMWM1MDE0YTk4OWNkLnBuZw?x-oss-process=image/format,png" alt="image.png" style="zoom: 50%;"></li></ul><ul><li><p>tcp提供了以下<strong>过滤表达式</strong></p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110200830168.png" alt="image.png" style="zoom:50%;"></li></ul><ul><li><p>在客户端终端进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i eth0 表示抓取eth1网口的数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip 表示抓取ip协议的数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> host 表示主机过滤，抓取对应域名/ip的数据报</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -nn 表示不解析ip地址和端口号的名称</span></span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 ip and host www.baidu.com  -nn</span><br></pre></td></tr></table></figure><p>通过curl或者浏览器请求 <a href="http://www.baidu.com">www.baidu.com</a> 即可获得数据包（百度——网络测试的神）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110200850299.png" alt="image-20211020085021073"></p></li></ul><p>tcpdump只是用来抓取数据包，并不用来分析数据包，所以我们还需要Wireshark工具进行数据包分析</p><h5 id="（2）Wireshark"><a href="#（2）Wireshark" class="headerlink" title="（2）Wireshark"></a>（2）Wireshark</h5><ul><li><p>先使用tcpdump抓取数据保存为pcap文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 ip and host www.baidu.com -c 8 -w baidu.pacp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>终端开启Wireshark</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wireshark</span><br></pre></td></tr></table></figure><p>注意开启Wireshark后，不要关闭该终端，而是开启新的终端</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110200904635.png" alt="image-20211020090446325"></p></li></ul><ul><li><p>Wireshark分析baidu.pacp文件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110200906800.png" alt="image-20211020090612028"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110200907536.png" alt="img"></p></li></ul><p>当然了Wireshark自身也有抓包功能，但是它有自己的一套过滤方法，我还是采用tcpdump的方法进行抓包操作</p><h4 id="3-解密TCP连接"><a href="#3-解密TCP连接" class="headerlink" title="3.解密TCP连接"></a>3.解密TCP连接</h4><h5 id="（1）建立一次连接"><a href="#（1）建立一次连接" class="headerlink" title="（1）建立一次连接"></a>（1）建立一次连接</h5><ul><li><p>客户端抓取请求服务端的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 192.168.234.200 and port 80 -w tcp.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端请求服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.234.200</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>退出tcpdump抓包</p><p>Ctrl+C退出tcpdump抓包</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110201924467.png" alt="image-20211020192429846"></p></li></ul><h5 id="（2）Wireshark分析tcp"><a href="#（2）Wireshark分析tcp" class="headerlink" title="（2）Wireshark分析tcp"></a>（2）Wireshark分析tcp</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110202041879.png" alt="image-20211020204055955"></p><ul><li><p>一次连接的传输流程</p><ol><li>最开始的3个包就是<strong>TCP三次握手</strong>建立连接的包</li><li>中间是HTTP请求和响应的包</li><li>最后的3个包则是<strong>TCP三次挥手</strong>断开连接的包</li></ol></li></ul><ul><li><p>时序图显示数据包交互</p><p>在Wireshark点击统计 -&gt; 流量图，在流量类型选择TCP Flows</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110202051934.png" alt="image-20211020205139464"></p></li></ul><ul><li><p>显示真实seq值</p><p>事实上上面的序列号seq是相对值，并不是真实值（关于序列号的算法下文会介绍）</p><p>在<strong>协议首选项</strong>取消<strong>Relative Seq</strong>即可看到真实值</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110201953144.png" alt="img"></p></li></ul><p>再次查看流量图，可以看到真实的seq值</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110201957208.png" alt="image-20211020195708923"></p><h5 id="（3）TCP连接流程分析"><a href="#（3）TCP连接流程分析" class="headerlink" title="（3）TCP连接流程分析"></a>（3）TCP连接流程分析</h5><ul><li>TCP连接完整流程</li></ul><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110202003394.jpeg" alt="这里写图片描述" style="zoom: 67%;"><ul><li><p>三次握手</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110202105763.png" alt="image-20211020210505247"></p></li></ul><ul><li><p>传输数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110202105540.png" alt="image-20211020210523657"></p></li></ul><ul><li><p>四次挥手</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110202105988.png" alt="image-20211020210546911"></p><p>这里只有三次是因为服务器端收到客户端的 <code>FIN</code> 后，服务器端同时也要关闭连接，这样就可     以把 <code>ACK</code> 和 <code>FIN</code> 合并到一起发送，节省了一个包，变成了“三次挥手”</p><p>服务器端收到客户端的 <code>FIN</code> 后，很可能还没发送完数据，所以就会先回复客户端一个      <code>ACK</code> 包，稍等一会儿，完成所有数据包的发送后，才会发送 <code>FIN</code> 包，这也就是四次挥手了</p></li></ul><h4 id="4-TCP连接异常情况分析"><a href="#4-TCP连接异常情况分析" class="headerlink" title="4.TCP连接异常情况分析"></a>4.TCP连接异常情况分析</h4><p>参考资料：</p><p><a href="http://blog.51yip.com/linux/1404.html">iptables 添加，删除，查看，修改</a></p><p><a href="https://juejin.cn/post/6844904181795389454">TCP三次握手丢包实验记录</a></p><h5 id="（1）TCP第一次握手SYN丢包"><a href="#（1）TCP第一次握手SYN丢包" class="headerlink" title="（1）TCP第一次握手SYN丢包"></a>（1）TCP第一次握手SYN丢包</h5><p>向一个不存在的主机地址发起连接即可模拟TCP第一次握手SYN丢包的状况</p><ul><li><p>开启tcpdump监控47.48.49.50（不存在的地址）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 47.48.49.50  and port 80 -w tcp_sys_timeout.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发起对47.48.49.50的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date;curl 47.48.49.50;date</span><br></pre></td></tr></table></figure><p><strong>date</strong>显示当前时间用于记录tcp用时</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110210916070.png" alt="image-20211021091606451"></p></li></ul><ul><li><p>开启wireshark分析tcp_sys_timeout.pcap</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231551164.png" alt="image-20211023155134728"></p></li></ul><p>​        </p><ul><li><p>分析TCP重传过程</p><p>当客户端发起TCP第一次握手SYN包，在超时间没有收到ACK就会重传SYN数据包，而且时间会逐渐翻倍，</p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZciat6yMSZJ2QYWIldpAXY6VA5Y8s7UWYLIjx7TsaNBNX46H5BQSGVBzX8clDJLvz4X5IhEX9O4tNg/640?wx_fmt=png" alt="img" style="zoom:67%;"></li></ul><p>kali Liunx这里重传了4次SYN后，服务端就会发送<strong>RST复位报文</strong>给客户端表示终止这个握手过程和这个连接</p><ul><li><p>相关参数调整</p><p>重传的次数与tcp_syn_retries参数有关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231617350.png" alt="image-20211023161746849"></p></li></ul><p>  可以看到kali linux需要重传6次（所以为什么这里只重传了4次？🧐，我也妹开tcp_abort_on_overflow呀，不是队列满的问题吧）</p><p>  我们可以调小tcp_syn_retries重新测试</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231627059.png" alt="image-20211023162734954"></p><p>​    <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231632601.png" alt="image-20211023163211916"></p><p>可以看到SYN重传了2次</p><h5 id="（2）TCP第二次握手SYN、ACK丢包"><a href="#（2）TCP第二次握手SYN、ACK丢包" class="headerlink" title="（2）TCP第二次握手SYN、ACK丢包"></a>（2）TCP第二次握手SYN、ACK丢包</h5><ul><li><p>客户端添加防火墙</p><p>模拟客户端接收不到服务端的响应，可以在客户端添加防火墙设置，把<code>192.168.234.200</code>服务器ban掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.234.200 -j DROP</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可以查看清单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231652438.png" alt="image-20211023165234228"></p><ul><li><p>客户端开启tcpdump监控192.168.234.200</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 192.168.234.200 and port 80 -w tcp_two.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发起对192.168.234.200的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.234.200</span><br></pre></td></tr></table></figure><p>在这里kali linux就会卡住了，建议直接手动关闭该命令</p></li></ul><ul><li><p>wireshark分析数据包</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231718787.png" alt="image-20211023171847580"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110231720057.png" alt="image-20211023172006864"></p><p>​        客户端视角：客户端发起SYN请求后，由于防火墙屏蔽了服务器所有的数据包，所有无法接受到SYN，ACK包，所以和上一种情        况一样要重发SYN包</p><p>​            </p><p>​        服务器角度：服务端收到客户的SYN包后，就会回SYN、ACK包，但是客户端一直没有回ACK，服务端在超时后，重传了  SYN、        ACK 包，接着一会，客户端超时重传的SYN包又抵达了服务端，服务端收到后，<strong>超时定时器就重新计时</strong>，然后回SYN、ACK包</p></li></ul><p>  ​        当第二次握手的SYN、ACK丢包时，客户端会超时重发SYN包，服务端也会超时重传SYN、ACK包</p><ul><li><p>相关参数</p><p><code>tcp_syn_retries</code>：客户端SYN重传次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure></li></ul><p>  <code>tcp_synack_retries</code>：服务端重传ACK，SYN次数</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure><p>  更改次数</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置SYN重传次数为1</span></span><br><span class="line">echo 1 &gt;  /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置ACK,SYN重传次数为2</span></span><br><span class="line">echo 2 &gt;  /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure><p>   ​重新抓包分析</p><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232038388.png" alt="image-20211023203803972"></p><ul><li><p>移除防火墙规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 1</span><br></pre></td></tr></table></figure></li></ul><h5 id="（3）TCP第三次握手ACK丢包"><a href="#（3）TCP第三次握手ACK丢包" class="headerlink" title="（3）TCP第三次握手ACK丢包"></a>（3）TCP第三次握手ACK丢包</h5><ul><li><p>服务器添加防火墙屏蔽来自客户端的ACK包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.234.100 -p tcp --tcp-flag ACK ACK -j DROP</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端开启tcpdump监控192.168.234.200</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 192.168.234.200 and port 80 -w tcp_ack_timeout.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端向服务端发起telnet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.234.200</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232049340.png" alt="image-20211023204935552"></p><p>等待很长一段时间客户端的telent才断开连接…..</p><p>​    </p></li><li><p>查看客户端服务端状态</p><p>客户端已完成TCP连接建立处于处于 <code>ESTABLISHED</code> 状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt | grep 192.168.234.100</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232112825.png" alt="image-20211023211201535"></p></li></ul><p>  服务器收不到第三次握手的ACK包，所以一开始处于<code>SYN_RECV</code> 状态</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt | grep 192.168.234.200</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232117706.png" alt="image-20211023211703628"></p><p>  ​    </p><p>  过了一段时间后在查询服务端状态，tcp连接就消失了</p><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232117422.png" alt="image-20211023211752357"></p><p>​        而客户端还是处于 <code>ESTABLISHED</code> 状态（在不传输数据的情况下会持续大概两个小时😰）</p><ul><li><p>在客户端建立的telnet会话，输入字符消息进行发送</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232121444.png" alt="image-20211023212138121"></p></li></ul><p>  ​    这里要持续很长一段时间客户端telnet才断开连接</p><ul><li><p>Wireshark分析数据包</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232128604.png" alt="image-20211023212430427"></p></li></ul><p>​        <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232128478.png" alt="image-20211023212818747"></p><ul><li>客户端发送 SYN 包给服务端，服务端收到后，回了个 SYN、ACK 包给客户端，此时服务端的 TCP 连接处于 <code>SYN_RECV</code> 状态；</li><li>客户端收到服务端的  SYN、ACK 包后，给服务端回了个 ACK 包，此时客户端的 TCP 连接处于 <code>ESTABLISHED</code> 状态</li><li>服务端配置防火墙屏蔽了客户端的ACK包，以服务端会有一段时间处于 <code>SYN_RECV</code> 状态，没有进入  <code>ESTABLISHED</code> 状态</li><li>接着，服务端超时重传了 SYN、ACK 包，重传了 5 次后，也就是<strong>超过 tcp_synack_retries 的值，然后就没有继续重传了，此时服务端的 TCP 连接主动中止了，所以刚才处于 SYN_RECV 状态的 TCP 连接断开了</strong>，而客户端依然处于<code>ESTABLISHED</code> 状态</li><li>客户端依然处于<code>ESTABLISHED</code> 状态，于是就在客户端的 telnet 会话输入了 123456 字符</li><li>由于服务端已经断开连接，<strong>客户端发送的数据报文，一直在超时重传，每一次重传，RTO 的值是指数增长的，所以持续了好长一段时间，客户端的 telnet 才报错退出了，此时会重传了 15 次</strong></li></ul><ul><li><p>相关参数</p><p>TCP 建立连接后的数据包传输，客户端发送数据报文最大超时重传次数是由 <code>tcp_retries2</code> 指定，默认值是 15 次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_retries2</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232136629.png" alt="image-20211023213656516"></p><p>按照时间倍增原理重传了15次后终于是结束了</p></li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232137394.png" alt="image-20211023213751365"></p><p> 如果这种情况下客户端不发送数据，客户端什么时候才会断开处于 ESTABLISHED 状态的连接这里需要提到TCP的<strong>保活机制</strong>，在一个<strong>规定的时间段</strong>（tcp_keepalive_time：保活时间）内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<strong>每隔一个时间间隔</strong>（tcp_keepalive_intvl：每次检测间隔），发送一个「探测报文」，该探测报文包含的数据非常少，如果<strong>连续几个探测报文</strong>（tcp_keepalive_probes：检测次数）都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p><p>  相关参数如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271337578.png" alt="image-20211023214647732">    </p><p>按照系统默认的设置来计算在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232154413.png" alt="img"></p><h4 id="5-解密TCP快速建立连接"><a href="#5-解密TCP快速建立连接" class="headerlink" title="5.解密TCP快速建立连接"></a>5.解密TCP快速建立连接</h4><p>参考资料：<a href="https://juejin.cn/post/6951378103000268836">tcp fast open分析</a>（里面有详细的实验过程）</p><h5 id="（1）普通连接与快速连接的差别"><a href="#（1）普通连接与快速连接的差别" class="headerlink" title="（1）普通连接与快速连接的差别"></a>（1）普通连接与快速连接的差别</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110242022723.png" alt="img" style="zoom:67%;"><p>RTT即一个数据包往返的时间，所有一个握手过程为0.5RTT（第三次握手是可以携带数据的，所以ACK和HTTP请求一起发送）</p><p><strong>普通连接</strong>每次发起HTTP请求都要重新进行上次握手过程，经历的RTT都是一样的</p><p><strong>快速连接</strong>第一次建立连接时，第二次握手会产生一个<strong>Cookie</strong>（其中维护着TCP相关信息）发给客户端，客户端就会缓存着这个<strong>Cookie</strong>；下次请求时，客户端在SYN包带上<strong>Cookie</strong>，服务端可以直接通过<strong>Cookie</strong>获得TCP相关信息，从而跳过三次握手的过程</p><h5 id="（2）Fast-Open相关参数"><a href="#（2）Fast-Open相关参数" class="headerlink" title="（2）Fast Open相关参数"></a>（2）Fast Open相关参数</h5><p>tcp_fastopn参数可以设置Fast Open的模式：</p><ol><li>0 关闭</li><li>1 作为客户端使用 Fast Open 功能</li><li>2 作为服务端使用 Fast Open 功能</li><li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能</li></ol><p>查看kali linux的tcp_fastopn，可以看到kali已默认开启作为客户端使用 Fast Open 功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_fastopen</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110242042576.png" alt="image-20211024204230242"></p><h5 id="（3）wireshark分析数据包"><a href="#（3）wireshark分析数据包" class="headerlink" title="（3）wireshark分析数据包"></a>（3）wireshark分析数据包</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110242145575.png" alt="img"></p><h4 id="6-解密TCP重复确认和快速重传"><a href="#6-解密TCP重复确认和快速重传" class="headerlink" title="6.解密TCP重复确认和快速重传"></a>6.解密TCP重复确认和快速重传</h4><h5 id="（1）TCP乱序数据包处理方式"><a href="#（1）TCP乱序数据包处理方式" class="headerlink" title="（1）TCP乱序数据包处理方式"></a>（1）TCP乱序数据包处理方式</h5><p>​    但接收方收到<strong>乱序数据包</strong>时，会发送<strong>重复的ACK</strong>，以告知发送方要重发该数据包，当发送方收到3个重复ACK时就会触发<strong>快速重传</strong>，立即<strong>重发丢失的数据包</strong></p><p>​    <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251519335.png" alt="img"></p><h5 id="（2）wireshark分析数据包"><a href="#（2）wireshark分析数据包" class="headerlink" title="（2）wireshark分析数据包"></a>（2）wireshark分析数据包</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251521249.png" alt="img"></p><ul><li>数据包1期望下一个返回的的数据包seq为1，但是返回的数据包2的seq为10945，说明收到了乱序数据包</li><li>数据包3重发seq = 1， ack=1，表明这是重复的ACK</li><li>数据包4，6返回的仍然是乱序的数据包，于是5，7还是重发seq = 1， ack=1的重复ACK</li><li>当对方收到三次重复的ACK后，快速重传seq=1，len=168的数据包8</li><li>当收到重传的数据包后，发现seq=1是期望的数据包，预设发送确认报文ACK</li></ul><h5 id="（3）相关参数"><a href="#（3）相关参数" class="headerlink" title="（3）相关参数"></a>（3）相关参数</h5><p><strong>tcp_sack</strong>参数可以开启<strong>选择性SACK</strong>，一旦数据包丢失并收到重复ACK，即使在丢失数据包之后还成功接收了其他数据包，也只需要重    传丢失的数据包（简单来说，如果不开启SACK，丢失包之后的每个数据包都要进行重传）</p><p>查看kali linux的tcp_sack参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_sack</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251547408.png" alt="image-20211025154717887"></p><h4 id="7-解密TCP流量控制"><a href="#7-解密TCP流量控制" class="headerlink" title="7.解密TCP流量控制"></a>7.解密TCP流量控制</h4><h5 id="（1）TCP滑动窗口机制"><a href="#（1）TCP滑动窗口机制" class="headerlink" title="（1）TCP滑动窗口机制"></a>（1）TCP滑动窗口机制</h5><p>​    TCP有两大关键功能：</p><p>​    <strong>可靠传输</strong>：保证数据确实到达目的地，如果未到达，能够发现并重传</p><p>​    <strong>数据流控</strong>：管理数据的发送速率，以使接收设备不致于过载</p><p>​    TCP数据流控的关键是滑动窗口机制，它利用接收方的<strong>接收窗口</strong>控制发送方要发送数据量，发送方的<strong>接收窗口</strong>可以告诉发送方自己TCP    缓冲空间区大小</p><p>​    在客户端与服务器的连接中，客户端告知服务器它一次希望从服务器接收多少字节数据，这是客户端的<strong>接收窗口</strong>，即服务器的<strong>发送窗口</strong></p><ul><li>理想情况下的窗口大小    </li></ul><p>​    假如应用层很快地从缓冲区读取了数据，那么窗口大小会一直保持不变</p><p>​    <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251617330.png" alt="img"></p><p>​    </p><ul><li>现实情况下的窗口大小</li></ul><p>现实中服务器会出现繁忙的情况，当应用程序读取速度慢时，那么缓存空间会慢慢被占满，这时服务器会调整<strong>窗口大小</strong>的值，通过ACK    报文通知对方</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251620324.png" alt="img">    </p><h5 id="（2）零窗口通知与窗口探测"><a href="#（2）零窗口通知与窗口探测" class="headerlink" title="（2）零窗口通知与窗口探测"></a>（2）零窗口通知与窗口探测</h5><ul><li><strong>零窗口</strong>：当接收方的缓存被占满后，会发送值为0的接收窗口，当发送方接收到<strong>零窗口通知</strong>时，就会停止发送数据</li></ul><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251623436.png" alt="img"></p><ul><li><p><strong>窗口探测</strong>：发送方接收到<strong>零窗口通知</strong>后，会定时发送<strong>窗口大小探测报文</strong>，以便知道接收方窗口大小变化</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251630822.png" alt="img"></p><p>发送<strong>窗口大小探测报文</strong>的时间间隔与TCP的报文重传机制一样都是<strong>翻倍递增</strong>的</p></li></ul><h5 id="（3）发送窗口的分析"><a href="#（3）发送窗口的分析" class="headerlink" title="（3）发送窗口的分析"></a>（3）发送窗口的分析</h5><p>报文<code>win</code>字段表明的是自己的<strong>接收窗口</strong>，而不是<strong>发送窗口</strong></p><p>可以通过查看报文字段：Windos size value 和 Window size scaling factor 确认发送窗口的值，计算公式如下</p><p><code>「Window size value」 * 「Window size scaling factor」 = 「Caculated window size 」</code></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251655116.png" alt="img"></p><p><strong>发送窗口</strong>虽然是由<strong>接收窗口</strong>决定的，但是它是可以被网络因素影响的，所以实际上发送窗口的值是<code>min(拥塞窗口, 接收窗口)</code></p><p>TCP 有<strong>累计确认机制</strong>，所以当收到多个数据包时，只需要应答<strong>最后一个数据包</strong>的 ACK 报文就可以了</p><h4 id="8-TCP减少小报文传输"><a href="#8-TCP减少小报文传输" class="headerlink" title="8.TCP减少小报文传输"></a>8.TCP减少小报文传输</h4><p>当TCP报文承载的数据非常小的时候，整个网络效率就会很低（例如一个报文TCP头部为20字节，IP头部也是20个字节，但数据只有2字节，就相当于用大货车运一个小包裹）</p><p>TCP使用两种策略来减少小报文的传输：</p><ul><li><p>Nagle算法</p></li><li><p>延迟确认</p></li></ul><h5 id="（1）Nagle算法"><a href="#（1）Nagle算法" class="headerlink" title="（1）Nagle算法"></a>（1）Nagle算法</h5><p>Nagle算法数据发送策略：</p><ul><li><strong>没有已发送未确认报文</strong>时，立刻发送数据</li><li>存在未确认报文时，直到<strong>没有已发送未确认报文</strong>或<strong>数据长度达到MSS大小</strong>，再发送数据</li></ul><p>如果不满足任意一条，发送方会一直<strong>囤积数据</strong>，直到满足发送条件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251730068.png" alt="img"></p><ul><li>一开始没有<strong>已发送未确认</strong>的报文，H字符就会立即发出</li><li>在没有收到对H字符的确认报文时，发送方一直囤积数据，直到收到确认报文，此时就没有已发送未确认的报文，于是就把囤积后的 ELL 字符一起发给了接收方</li><li>待收到ELL字符的确认报文后，就把最后一个之后O发出</li></ul><p>Nagle算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法</p><p>关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭，如 Socket可以通过设置 <code>TCP_NODELAY</code> 选项来关闭这个算法</p><h5 id="（2）延迟确认"><a href="#（2）延迟确认" class="headerlink" title="（2）延迟确认"></a>（2）延迟确认</h5><p>延迟确认数据发送策略：</p><ul><li>当有响应数据要发送时，ACK会跟着一起发送给对方</li><li>当没有响应数据要发送时，ACK将延迟一段时间，以等待是否有响应数据一起发送</li><li>如果在ACK延迟等待发送期间，对方第二个数据报文到达了，这时就立即发送ACK</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251746044.png" alt="img"></p><p>延迟等待的时间在Linux内核中定义的，我们可以通过查看HZ（系统时钟频率）来确认</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251754102.png" alt="image-20211025175433959"></p><p>这里注意不同内核的配置文件名称不同，我的就是<code>config-5.10.0-kali9-amd64</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-5.10.0-kali9-amd64 | grep &#x27;CONFIG_HZ=&#x27; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110251752591.png" alt="image-20211025175239492"></p><p>我的这台机器的HZ=250，所以最大延迟确认时间为50ms，最小延迟确认时间为10ms</p><p>关闭延迟确认也没有全局参数，需要根据每个应用自己的特点来关闭，如TCP 延迟确认可以在 Socket 设置 <code>TCP_QUICKACK</code> 选项来关闭这个算法</p><h4 id="9-TCP全连接队列"><a href="#9-TCP全连接队列" class="headerlink" title="9.TCP全连接队列"></a>9.TCP全连接队列</h4><p>参考资料：<a href="https://segmentfault.com/a/1190000022792489">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</a></p><h5 id="（1）TCP半连接队列与全连接队列"><a href="#（1）TCP半连接队列与全连接队列" class="headerlink" title="（1）TCP半连接队列与全连接队列"></a>（1）TCP半连接队列与全连接队列</h5><p>​    在TCP三次握手中，我们如何分辨：哪些连接是半连接，哪些连接是全连接呢？</p><p>​    Linux通过维护两个队列来解决问题：</p><ul><li>半连接队列（SYN队列）</li><li>全连接队列（accepet队列）</li></ul><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110261926809.png" alt="img" style="zoom:80%;"><ul><li>服务端收到客户端发起的<strong>SYN</strong>后，内核会将连接存储到<strong>半连接队列</strong></li><li>服务端向客户端发送<strong>SYN+ACK</strong></li><li>客户端收到<strong>SYN+ACK</strong>后，发送<strong>ACK</strong>到服务端</li><li>服务端收到客户端的<strong>ACK</strong>后，内核会把连接从<strong>半连接队列</strong>移除，将其添加到<strong>全连接队列</strong>，等待进程调用<strong>accept函数</strong>时把连接取出来</li><li>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接<strong>丢弃</strong>，或<strong>返回 RST 包</strong></li></ul><h5 id="（2）全连接队列状态查询"><a href="#（2）全连接队列状态查询" class="headerlink" title="（2）全连接队列状态查询"></a>（2）全连接队列状态查询</h5><p>在服务端（192.168.234.200）查看全连接队列状况</p><p>查看<strong>LISTEN 状态</strong>的连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -l 显示状态为listen的socket</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 不解析服务名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 只显示tcp socket</span></span><br><span class="line">ss -lnt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110261944427.png" alt="image-20211026194430102"></p><ul><li>Recv-Q：当前<strong>全连接队列的大小</strong>，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接个数；</li><li>Send-Q：当前<strong>全连接最大队列长度</strong>，上面的输出结果说明监听 80 端口的 TCP 服务进程，<strong>最大全连接长度为 511</strong></li></ul><p>查看<strong>非 LISTEN 状态</strong>的连接：</p><p>先在客户端对服务端发起请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.234.200 80</span><br></pre></td></tr></table></figure><p>这时可以在服务端查看<strong>非 LISTEN 状态</strong>的连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -n 不解析服务名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 只显示tcp socket</span></span><br><span class="line">ss -nt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110261953764.png" alt="image-20211026195348911"></p><p>这时<code>Recv-Q/Send-Q</code> 表示的含义与<strong>LISTEN 状态</strong>的不同</p><ul><li>Recv-Q：已收到但未被应用进程读取的字节数；</li><li>Send-Q：已发送但未收到确认的字节数；</li></ul><h5 id="（3）全连接队列溢出"><a href="#（3）全连接队列溢出" class="headerlink" title="（3）全连接队列溢出"></a>（3）全连接队列溢出</h5><p>本次模拟实验，客户端（192.168.234.100）使用<strong>wrk工具</strong>（HTTP 压测工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，通过多线程和事件模式，对目标机器产生大量的负载）对服务端（192.168.234.100）发起大量请求，以此模拟TCP<strong>全连接队列溢出</strong>的状态</p><ul><li><p>客户端安装wrk工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install wrk</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端对服务端进行抗压测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 6 表示6个线程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 30000 表示3万个连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 60s 表示持续压测60秒</span></span><br><span class="line">wrk -t 6 -c 30000 -d 60s http://192.168.234.200</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262014446.png" alt="image-20211026201412323"></p></li></ul><ul><li><p>服务端多次执行ss命令查看全连接队列的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -lnt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262021751.png" alt="image-20211026202152288"></p><p>可以看到TCP全链接队列逐渐上升到<strong>最大全连接长度为511</strong>，当全连接队列为<strong>512</strong>时即为<strong>全连接队列溢出</strong>，<strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接</strong>，所以下一个状态<strong>全连接队列</strong>又恢复了<strong>511</strong></p></li></ul><ul><li><p>查看被丢弃的连接个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep overflowed</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262031051.png" alt="image-20211026203156762"></p></li></ul><ul><li><p>结论</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262034104.png" alt="全连接队列溢出"></p></li></ul><p>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象</p><h5 id="（4）全连接队列溢出策略"><a href="#（4）全连接队列溢出策略" class="headerlink" title="（4）全连接队列溢出策略"></a>（4）全连接队列溢出策略</h5><ul><li><p>应对全连接队列溢出有以下两种应对策略：</p><ol><li>队列满了以后丢弃后续连接（Liunx默认策略）</li><li>向客户端发送RST复位报文，告诉客户端连接已经建立失败</li></ol></li></ul><ul><li><p>查看服务端<code>tcp_abort_on_overflow</code>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262047259.png" alt="image-20211026204705056"></p><ol><li>tcp_abort_on_overflow为0：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack</li><li>如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接</li></ol></li></ul><ul><li><p>将服务端的<code>tcp_abort_on_overflow</code>设为1进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure></li></ul><p>  客户端再次对服务端进行抗压测试</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 6 表示6个线程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 30000 表示3万个连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 60s 表示持续压测60秒</span></span><br><span class="line">wrk -t 6 -c 30000 -d 60s http://192.168.234.200</span><br></pre></td></tr></table></figure><p>​    客户端异常中会查看到很多的<code>connection reset by peer</code>错误</p><p>通常情况下，应当把 <code>tcp_abort_on_overflow</code> 设置为 0，因为这样更有利于应对突发流量</p><h5 id="（5）增大全连接队列"><a href="#（5）增大全连接队列" class="headerlink" title="（5）增大全连接队列"></a>（5）增大全连接队列</h5><p>TCP全连接队列最大值取决于<strong>somaxconn</strong>（Linux内核参数）和<strong>backlog</strong>（Nginx中配置）之间的最小值</p><ul><li><p>查看服务端<strong>somaxconn</strong>的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262132994.png" alt="image-20211026213244511"></p></li></ul><ul><li><p>修改<strong>backlog</strong>的默认值</p><p>nginx的backlog默认值为511（配置文件可以不写出），现在修改为4000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在listen端口后面加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backlog=4000</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262301329.png" alt="image-20211026230115019"></p></li></ul><p>  重启nginx服务</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload  nginx</span><br></pre></td></tr></table></figure><p>  服务端再次执行ss命令，查看TCP全连接队列大小</p><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262304069.png" alt="image-20211026230418393"></p><ul><li><p>再次进行测压</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110262308892.png" alt="image-20211026230850636"></p></li></ul><p>如果看到溢出的次数不再增加，说明TCP全连接队列最大值为4000时可以抗住3万连接的并发请求</p><h4 id="10-TCP半连接队列"><a href="#10-TCP半连接队列" class="headerlink" title="10.TCP半连接队列"></a>10.TCP半连接队列</h4><h5 id="（1）查看TCP半连接队列长度"><a href="#（1）查看TCP半连接队列长度" class="headerlink" title="（1）查看TCP半连接队列长度"></a>（1）查看TCP半连接队列长度</h5><p>客户端运行wrk请求服务端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t 6 -c 30000 -d 60s http://192.168.234.200</span><br></pre></td></tr></table></figure><p>服务端运行以下命令查看当前TCP半连接队列长度</p><p>（ps：注意要将nginx的backlog调整回默认值，否则半连接队列会处理太快）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -natp | grep SYN_RECV | wc -l</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110270815566.png" alt="image-20211027081537300"></p><h5 id="（2）半连接队列溢出"><a href="#（2）半连接队列溢出" class="headerlink" title="（2）半连接队列溢出"></a>（2）半连接队列溢出</h5><p>模拟TCP半连接溢出的场景，实际上就是对服务端一直发送SYN包，但是不回第三次握手ACK，这样会使服务端有大量的处于 <code>SYN_RECV</code> 状态的 TCP 连接（即半连接状态），这也就是所谓的 SYN 洪泛、SYN 攻击、DDos 攻击</p><ul><li><p>首先要先关闭服务端的<strong>tcp_syncookies</strong>，tcp_syncookies 是Linux缓解 SYN 攻击其中一个手段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt;  &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syncookies</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端使用hping3工具模拟SYN攻击</p><p>kali linux已内置安装了hping3无须再次安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -S 指定TCP包的标志位SYN</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 80 指定探测的目的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---flood 以泛洪的方式攻击</span></span><br><span class="line">hping3 -S -p 80 --flood 192.168.234.200</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端循环查看当前TCP半连接队列大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while true; </span><br><span class="line">do </span><br><span class="line">sleep 0.5; </span><br><span class="line">echo &quot;当前半连接队列数：&quot;;</span><br><span class="line">    netstat -natp | grep SYN_RECV | wc -l;</span><br><span class="line">    echo &quot; &quot;;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端循环使用 <code>netstat -s</code> 查看半连接队列溢出情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while true; </span><br><span class="line">do </span><br><span class="line">sleep 1; </span><br><span class="line">echo &quot;半连接队列溢出数&quot;;</span><br><span class="line">    netstat -s | grep &quot;SYNs to LISTEN&quot;;</span><br><span class="line">    echo &quot; &quot;;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110270909570.png" alt="image-20211027090955138"></p><p>上面的数值是<strong>累计值</strong>，如果有上升的趋势，说明当前存在半连接队列溢出的现象</p></li></ul><h5 id="（3）增大半连接队列"><a href="#（3）增大半连接队列" class="headerlink" title="（3）增大半连接队列"></a>（3）增大半连接队列</h5><p>半连接队列最大值（max_qlen_log）不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271303894.png" alt="img"></p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = max_syn_backlog * 2;</li><li>即 max_syn_backlog，somaxconn，backlog最小的一个数乘以2为半连接队列最大值</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271322835.png" alt="image-20211027132147887"></p><p>因为nginx的backlog默认为511，所以该系统max_qlen_log的值为256</p><p>max_qlen_log 是<strong>理论</strong>半连接队列最大值，并不一定代表服务端处于 SYN_REVC 状态的最大个数</p><h5 id="（4）半连接队列溢出策略"><a href="#（4）半连接队列溢出策略" class="headerlink" title="（4）半连接队列溢出策略"></a>（4）半连接队列溢出策略</h5><p>半连接队列溢出有两种应对策略：</p><ul><li>当syncookies=0时，TCP会丢弃连接</li><li>当syncookies=1时，服务端开启 syncookies 功能，其可以在不使用 SYN 半连接队列的情况下成功建立连接（默认配置）</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271326186.png" alt="img"></p><p>syncookies的运行原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功</p><p>我们可以使用下面的命令查看系统syncookies的值</p><p>为了应对SYN攻击，其默认为1（上面的实验我们改为了0）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure><p>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它</li><li>2 值，表示无条件开启功能</li></ul><h5 id="（5）SYN攻击应对方法"><a href="#（5）SYN攻击应对方法" class="headerlink" title="（5）SYN攻击应对方法"></a>（5）SYN攻击应对方法</h5><ul><li>增大半连接队列</li></ul><p>要注意需要同时增大<strong>tcp_max_syn_backlog</strong> ，<strong>somaxconn</strong> 和 <strong>backlog</strong>，其中最小值的两倍即为<strong>半连接队列</strong>的最大值，同时somaxconn 和 backlog的最小值为<strong>全连接队列</strong>的最大值</p><ul><li>开启 tcp_syncookies 功能（一般默认开启）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure><ul><li>减少 SYN+ACK 重传次数</li></ul><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接</p><p>所以我们也可以减少SYN+ACK的重传次数，以加快SYN_REVC状态的TCP连接端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置ACK,SYN重传次数为1</span></span><br><span class="line">echo 1 &gt;  /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure><p>,SYN重传次数为1<br>echo 1 &gt;  /proc/sys/net/ipv4/tcp_synack_retries</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202110271342730.webp&quot; alt=&quot;I’m going to tell a joke | excel-memes, tcp-memes, udp-memes | ProgrammerHumor.io&quot; style=&quot;zoom: 50%;&quot;&gt;



&lt;p&gt;TCP好复杂🤧，主要使用了Kali Linux上的一些网络工具来进行分析，希望能直观地解析TCP（备考中，更新缓慢…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="https://autovy.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java|项目深度解析</title>
    <link href="https://autovy.github.io/2021/10/25/Java/Java-%E9%A1%B9%E7%9B%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://autovy.github.io/2021/10/25/Java/Java-%E9%A1%B9%E7%9B%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</id>
    <published>2021-10-25T15:45:00.000Z</published>
    <updated>2022-10-28T00:21:53.362Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202209011353612.jpeg" alt="img"></p><span id="more"></span><h3 id="常用集合解析"><a href="#常用集合解析" class="headerlink" title="常用集合解析"></a>常用集合解析</h3><p>必看资料：</p><p><a href="https://autovy.github.io/2022/04/20/Java/Java-渐进式本地缓存框架开发总结/">渐进式本地缓存开发总结</a></p><p><a href="https://interview.javaguide.cn/#/./docs/b-2Java集合">Java集合面试题</a></p><p><a href="https://javaguide.cn/java/collection/arraylist-source-code.html#项目相关">Java集合源码分析</a></p><p><a href="https://www.cnblogs.com/javastack/p/13397621.html">Java 编译期与运行期</a></p><h3 id="JVM调试与栈溢出"><a href="#JVM调试与栈溢出" class="headerlink" title="JVM调试与栈溢出"></a>JVM调试与栈溢出</h3><p><strong>必看资料：</strong></p><p><a href="https://www.jianshu.com/p/a2f98f6d6fbd">循环依赖的解决方案</a></p><p><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-命令行工具">JDK 监控和故障处理工具总结</a></p><p><a href="https://www.v2ex.com/t/701513">JVM 堆溢出抽丝剥茧定位的过程</a></p><p><a href="https://heapdump.cn/article/276879">JVM源码分析之栈溢出完全解读</a></p><p><a href="https://interview.javaguide.cn/#/./docs/b-4jvm">JVM核心知识</a></p><h4 id="一-栈溢出应用场景：循环依赖"><a href="#一-栈溢出应用场景：循环依赖" class="headerlink" title="一.栈溢出应用场景：循环依赖"></a>一.栈溢出应用场景：循环依赖</h4><p>在Springboot + JPA的架构中，容易出现循环依赖问题，一般会出现在一对多的场景下，总结来说是一对多实体中都要引用对方来维持OnetoMany的关系，所以极容易出现循环依赖:(</p><h5 id="1-经典场景"><a href="#1-经典场景" class="headerlink" title="1.经典场景"></a>1.经典场景</h5><p>订单项中引用订单，以构成多对一关系（可以使用订单id查到订单项）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个订单可以有多个订单项（不同产品/不同用户，同一订单）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;oid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Order order;</span><br></pre></td></tr></table></figure><p>订单中引用订单项存储在集合中，用来存储从数据库查询来的结构（往往是因为要利用这些字段进行计算）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单项列表</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line"><span class="comment">// 订单总金额</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> total;</span><br><span class="line"><span class="comment">// 订单物品总数量</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalNumber;</span><br></pre></td></tr></table></figure><p>这样的结构就是循环依赖，导致数据重复加载，因为orderItems要调用方法填充，所以会为空（一般情况下会栈溢出）最终造成的数据是：Order含有orderItems，orderItems含有Order，Order的orderItem列表为空，所以这里的Order重复了一次</p><h5 id="2-方案一：-JsonBackReference注解"><a href="#2-方案一：-JsonBackReference注解" class="headerlink" title="2.方案一：@JsonBackReference注解"></a>2.方案一：@JsonBackReference注解</h5><p>JsonBackReference注解用在一（一对多的一）的一方，可以阻止其被序列化，前提是对应的接口不需要调用到它，而只是需要用它来查询</p><p>如：一个产品有多张图片，我们不需要在图片列表接口使用到产品信息，而只是需要用产品id查询其图片</p><p><strong>产品类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="comment">// 产品首图</span></span><br><span class="line"><span class="keyword">private</span> ProductImage firstProductImage;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productSingleImages;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productDetailImages;</span><br></pre></td></tr></table></figure><p><strong>产品图片类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="meta">@JsonBackReference</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ul><li>关系是双向的，使用了JsonBackReference，就无法使用根据图片找到其属于的产品的方法，只能单方向查询即根据产品查找到其图片列表</li><li>JsonBackReference标记的字段与Redis的整合会有冲突</li></ul><h5 id="3-方案二：及时清除法"><a href="#3-方案二：及时清除法" class="headerlink" title="3.方案二：及时清除法"></a>3.方案二：及时清除法</h5><p>在服务层定义清除方法，在控制层调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Orderitem中有Order字段，标注多对一关系</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，用于存储订单项列表</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，而Orderitem中又有Order字段，产生无穷的递归</span></span><br><span class="line"><span class="comment">// 所以这里需要设置Orderitem的Order设为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(List &lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">removeOrderFromOrderItem(order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">List&lt;OrderItem&gt; orderItems= order.getOrderItems();</span><br><span class="line"><span class="keyword">for</span> (OrderItem orderItem : orderItems) &#123;</span><br><span class="line">orderItem.setOrder(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充Order的orderItem列表</span></span><br><span class="line">orderItemService.fill(page.getContent());</span><br><span class="line"><span class="comment">// 清除orderItem中的Order字段</span></span><br><span class="line">orderService.removeOrderFromOrderItem(page.getContent());</span><br></pre></td></tr></table></figure><h4 id="二-JVM"><a href="#二-JVM" class="headerlink" title="二.JVM"></a>二.JVM</h4><p>参考资料：<a href="https://interview.javaguide.cn/#/./docs/b-4jvm">JVM核心知识</a></p><h3 id="多线程解析"><a href="#多线程解析" class="headerlink" title="多线程解析"></a>多线程解析</h3><p>必看资料：</p><p><a href="https://interview.javaguide.cn/#/./docs/b-3Java多线程">Java多线程核心知识</a></p><p><a href="http://gitbook.chenqiong.net/part10/1/9.html">多线程应用场景</a></p><p><a href="https://blog.csdn.net/u014044812/article/details/64919813">Spring多线程批量发送邮件</a></p><h3 id="Spring-AOP解析"><a href="#Spring-AOP解析" class="headerlink" title="Spring AOP解析"></a>Spring AOP解析</h3><p>必看资料：</p><p><a href="https://www.qetool.com/scripts/view/7573.html">Spring @Cacheable注解类内部调用失效的解决方案 </a></p><p><a href="https://zhuanlan.zhihu.com/p/83204146">Spring AOP应用</a></p><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop">AOP面试题</a></p><h4 id="一-缓存AOP拦截失效问题"><a href="#一-缓存AOP拦截失效问题" class="headerlink" title="一.缓存AOP拦截失效问题"></a>一.缓存AOP拦截失效问题</h4><p><a href="https://www.qetool.com/scripts/view/7573.html">Spring @Cacheable注解类内部调用失效的解决方案 </a></p><h5 id="1-问题出现原因"><a href="#1-问题出现原因" class="headerlink" title="1.问题出现原因"></a>1.问题出现原因</h5><p>因为Springboot的缓存机制是通过切面编程aop来实现，从fill方法中调用listByCategory即内部调用，aop是拦截不到的，自然不会走缓存，这里我们可以通过SpringContextUtil工具类诱发aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充分类中的产品集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过SpringContextUtil调用listByCategory上的缓存方法</span></span><br><span class="line">    <span class="comment">// 即 @Cacheable(key=&quot;&#x27;products-cid-&#x27;+ #p0.id&quot;)</span></span><br><span class="line">    <span class="comment">// 这样在方法内部的查询也能够使用缓存</span></span><br><span class="line">    ProductService productService = SpringContextUtil.getBean(ProductService.class);</span><br><span class="line">    List&lt;Product&gt; products = productService.listByCategory(category);</span><br><span class="line">    productImageService.setFirstProdutImages(products);</span><br><span class="line">    category.setProducts(products);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-问题解决方案"><a href="#2-问题解决方案" class="headerlink" title="2.问题解决方案"></a>2.问题解决方案</h5><p>SpringContextUtil工具类诱发aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringContextUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二-AOP与日志处理"><a href="#二-AOP与日志处理" class="headerlink" title="二.AOP与日志处理"></a>二.AOP与日志处理</h4><p><a href="https://zhuanlan.zhihu.com/p/83204146">Spring AOP应用</a></p><h4 id="三-SpringBoot原理"><a href="#三-SpringBoot原理" class="headerlink" title="三.SpringBoot原理"></a>三.SpringBoot原理</h4><h5 id="1-SpringBoot自动配置过程"><a href="#1-SpringBoot自动配置过程" class="headerlink" title="1.SpringBoot自动配置过程"></a>1.SpringBoot自动配置过程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/image-20220923081735147.png" alt="image-20220923081735147"></p><h5 id="2-SpringBoot启动过程"><a href="#2-SpringBoot启动过程" class="headerlink" title="2.SpringBoot启动过程"></a>2.SpringBoot启动过程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/image-20220923081811756.png" alt="image-20220923081811756"></p><h3 id="MySQL解析"><a href="#MySQL解析" class="headerlink" title="MySQL解析"></a>MySQL解析</h3><p><strong>必看资料</strong>：</p><p><a href="https://interview.javaguide.cn/#/./docs/d-1-mysql?id=_42-mysql">MySQL常见面试题总结</a></p><p><a href="https://segmentfault.com/a/1190000024445924">谈谈 MySQL 的 JSON 数据类型 </a></p><p><a href="https://blog.csdn.net/qq_24468953/article/details/120758408">简单总结 mysql json类型的利与弊</a></p><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#一-mysql-基础架构分析">MySQL索引详解</a></p><p><a href="https://www.jianshu.com/p/4dbbaaa200c4">数据库索引为什么使用B+树</a></p><h4 id="一-物资申请系统数据库信息"><a href="#一-物资申请系统数据库信息" class="headerlink" title="一.物资申请系统数据库信息"></a>一.物资申请系统数据库信息</h4><p><a href="https://interview.javaguide.cn/#/./docs/d-1-mysql?id=_42-mysql">MySQL常见面试题总结</a></p><h5 id="1-物资申请表"><a href="#1-物资申请表" class="headerlink" title="1.物资申请表"></a>1.物资申请表</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041045668.png" alt="image-20220504104541342"></p><ul><li>用户id : 物资申请条目 = 1 : n</li><li>机构id : 物资申请条目 = 1 : n</li></ul><h5 id="2-物资申请详情表"><a href="#2-物资申请详情表" class="headerlink" title="2.物资申请详情表"></a>2.物资申请详情表</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041053586.png" alt="image-20220504105313339"></p><ul><li>物资申请条目id : 物资申请详情条目 = n : n</li><li>物资id : 物资申请详情条目 = n : n</li><li>(物资申请条目id,物资id) : 物资申请详情条目 = 1 : n</li></ul><h5 id="3-物资表"><a href="#3-物资表" class="headerlink" title="3.物资表"></a>3.物资表</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041059831.png" alt="image-20220504105953610"></p><h5 id="4-用户表"><a href="#4-用户表" class="headerlink" title="4.用户表"></a>4.用户表</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041102927.png" alt="image-20220504110242618"></p><ul><li>用户信息条目 : 权限id = 1 : 1</li></ul><h5 id="5-权限表"><a href="#5-权限表" class="headerlink" title="5.权限表"></a>5.权限表</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041104629.png" alt="image-20220504110408506"></p><h4 id="二-数据库分表"><a href="#二-数据库分表" class="headerlink" title="二.数据库分表"></a>二.数据库分表</h4><p><a href="https://segmentfault.com/a/1190000024445924">谈谈 MySQL 的 JSON 数据类型 </a></p><p><a href="https://blog.csdn.net/qq_24468953/article/details/120758408">简单总结 mysql json类型的利与弊</a></p><h5 id="1-相关表的结构"><a href="#1-相关表的结构" class="headerlink" title="1.相关表的结构"></a>1.相关表的结构</h5><p>此处展示的表结构为维护前</p><p>物资申请表：共4817条数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031543098.png" alt="image-20220303154338625"></p><p>物资信息表：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031545235.png" alt="image-20220303154513022"></p><p>goods_count：当前仓库物品数（物理的）</p><p>good_leftCount：当前物品可借数（网络的：存在部分未借出，但已被预订仍在审核中的物品）</p><h5 id="2-优化思路：物资申请表分表"><a href="#2-优化思路：物资申请表分表" class="headerlink" title="2.优化思路：物资申请表分表"></a>2.优化思路：物资申请表分表</h5><p>改版前的系统使用的数据库是5.4版本，其默认的引擎是MyISAM 引擎，为了让数据库有更好的性能，我们将系统的数据库升级到了5.7.26版本，InnoDB 是 气的默认存储引擎</p><p>从上面的tw_apply表就可以知道：</p><ul><li><p>在用户提出申请后，物资申请信息被后端拼成了一个字符串存储在apply_content（同时利用了前端的数据执行了物品可借数的预扣除，所以这部分没有用到物资申请信息字符串的解析）</p></li><li><p>通过审核后，物品正式借出，这时候只留有物资申请信息的字符串存储在数据库，所以需要后端对该字符串解析提取出申请物资与其借用数量，再去操作数据库</p></li></ul><p>由于Mysql对JSON类型的支持是5.7以后的版本才有的，所以之前版本的物品申请内容字符串是以物品 + 申请数量并用逗号隔开多个物品申请内容这样的格式构成，我一开始也考虑其转换为JSON格式，但是在考虑到应用场景后，决定对其进行分表，将多对多关系分为了两个一对多关系</p><p>数据库设计十分不合理，甚至不符合第一范式，<strong>浪费数据库大量存储空间</strong>不说，而且后端拼接字符串解析字符串这一过程<strong>十分耗时且占用内存</strong>，而且最新的需求是需要增加一个审核过程申请物资调整功能</p><p>所以我将物资申请表进行分表（水平分表），分出物资申请详情表并联系物资信息表，其结构如下</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031646110.png" alt="image-20220303164602406"></p><p>删除掉apply_content字段，节省数据库空间</p><p>分表后，通过tw_applydetail表，我们对物资申请信息的所以内容进行操作，省去了物资审核接口对字符串解析的耗时过程并且方便审核过程申请物资调整功能的开发（通过tw_appdetail找到物品信息和物品数量）</p><h5 id="3-优化操作：存储过程脚本"><a href="#3-优化操作：存储过程脚本" class="headerlink" title="3.优化操作：存储过程脚本"></a>3.优化操作：存储过程脚本</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象</p><p>这里值得注意的是在遍历游标的循环中，如果查询不存在或为空会跳出循环</p><p>当时经过一天的对存储过程的学习，我总结出了以下经验：存储过程非常不方便调试，而且报错信息只定位不报错误类型（sql是这样的）。如果能重来，对数据库的批量操作，首选Python或Shell</p><h5 id="4-优化结果"><a href="#4-优化结果" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>截至目前物资申请表已有4817条数据，考虑到后面数据会长期积累，这样的优化是有必要的</li><li>去掉后端耗时耗内存的字符串解析工作</li><li>节省数据库存储空间，优化前申请表内存占0.79MB，优化后占0.56MB</li></ul><p>另外附加一个容量查询小工具，可查询数据库各表容量大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">table_schema as &#39;数据库&#39;,</span><br><span class="line">table_name as &#39;表名&#39;,</span><br><span class="line">table_rows as &#39;记录数&#39;,</span><br><span class="line">truncate(data_length&#x2F;1024&#x2F;1024, 2) as &#39;数据容量(MB)&#39;,</span><br><span class="line">truncate(index_length&#x2F;1024&#x2F;1024, 2) as &#39;索引容量(MB)&#39;</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema&#x3D;&#39;bgs&#39;</span><br><span class="line">order by data_length desc, index_length desc;</span><br></pre></td></tr></table></figure><h4 id="三-数据库索引的使用"><a href="#三-数据库索引的使用" class="headerlink" title="三.数据库索引的使用"></a>三.数据库索引的使用</h4><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#一-mysql-基础架构分析">MySQL索引详解</a></p><p><a href="https://www.jianshu.com/p/4dbbaaa200c4">数据库索引为什么使用B+树</a></p><p>由于日志表数据庞大，有3万条数据，为了达到快速通过用户名模糊查找到日志操作内容和操作时间，我一开始的方案是选择了使用索引，以操作人作为索引模糊查询操作日志</p><h5 id="1-相关表结构"><a href="#1-相关表结构" class="headerlink" title="1.相关表结构"></a>1.相关表结构</h5><p>日志记录表：共33687条数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031910440.png" alt="image-20220303191047146"></p><h5 id="2-优化思路：添加索引"><a href="#2-优化思路：添加索引" class="headerlink" title="2.优化思路：添加索引"></a>2.优化思路：添加索引</h5><p>另外在模糊查询中，<strong>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用</strong></p><p>所以我将查询的模糊匹配由“%xxxx%”改为“xxxx%”，只模糊匹配前面部分</p><h5 id="3-优化操作"><a href="#3-优化操作" class="headerlink" title="3.优化操作"></a>3.优化操作</h5><p>这里直接使用Navicat可视化添加索引，因为后台查询日志是需要用用户名模糊查找到日志操作内容和操作时间，所以需要添加的索引为log_realnam</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031939750.png" alt="image-20220303193939350"></p><p>更改mybatis的sql映射，解决sql注入和索引失效问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE &quot;%$&#123;log_name&#125;%&quot;;  </span><br></pre></td></tr></table></figure><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE concat(‘%’,#&#123;log_name&#125;, ‘%’) </span><br></pre></td></tr></table></figure><h5 id="4-优化结果-1"><a href="#4-优化结果-1" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>添加索引前使用用户名模糊查询日志，耗时大约0.045s，添加索引后耗时大约0.032s，减少了磁盘IO，提高了查询速度</li><li>修改mybatis中模糊查询的sql语句，解决索引失效的问题，并解决了模糊查询中拼接字符串的sql注入问题</li></ul><p>但是加索引这种方案没有被采纳，因为在系统上操作日志包括了，注册登录申请审批等操作，插入是非常频繁的，而日志查询只会被管理员少量使用，所以后续使用了ES来提高查询效率</p><h3 id="大数据框架解析"><a href="#大数据框架解析" class="headerlink" title="大数据框架解析"></a>大数据框架解析</h3><p><strong>必看资料：</strong></p><p><a href="https://www.cnblogs.com/ifme/p/12005026.html">Spring Data Elasticsearch基本使用</a></p><p><a href="https://onblogs.net/2019/05/29/史上最全面的Elasticsearch使用指南/">史上最全面的Elasticsearch使用指南</a></p><h3 id="一-ES搜索操作日志"><a href="#一-ES搜索操作日志" class="headerlink" title="一.ES搜索操作日志"></a>一.ES搜索操作日志</h3><p><a href="https://onblogs.net/2019/05/29/史上最全面的Elasticsearch使用指南/">史上最全面的Elasticsearch使用指南</a></p><h5 id="1-ES准备"><a href="#1-ES准备" class="headerlink" title="1.ES准备"></a>1.ES准备</h5><p><strong>ES是什么</strong></p><p>elasticsearch简写es，es是一个高扩展、开源的全文检索和分析引擎，它可以准实时地快速存储、搜索、分析海量的数据，而这正好符合我们的需求，物资申请系统的操作日志刚好是一个存储频繁，又需要对大量数据进行查询统计的场景</p><p><strong>什么是全文检索</strong></p><p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。全文搜索搜索引擎数据库中的数据。</p><p><strong>配置ES</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span> = <span class="string">127.0.0.1:9300</span></span><br></pre></td></tr></table></figure><p><strong>ES注解实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Document注解Category实体类，一个Category对象即为一个Document（相当于数据库的一行）</span></span><br><span class="line"><span class="comment">// 连接到es的tmall_springboot索引（相当于数据库），produt类（相当于表）上</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;tmall_springboot&quot;,type = &quot;product&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="2-esDAO的创建"><a href="#2-esDAO的创建" class="headerlink" title="2.esDAO的创建"></a>2.esDAO的创建</h5><p>由于整合了ES的JPA和操作数据库使用的JPA有冲突，所以不能放在同一个包下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.pojo.Product;</span><br><span class="line"><span class="comment">// 用于链接es的DAO</span></span><br><span class="line"><span class="comment">// esDAO和其他DAO不能放在一个包下否则会启动异常</span></span><br><span class="line"><span class="comment">// 主要使用es实现对产品的模糊查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductESDAO</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-ES与数据库同步"><a href="#3-ES与数据库同步" class="headerlink" title="3.ES与数据库同步"></a>3.ES与数据库同步</h5><p><strong>增删改操作</strong></p><p>增删改操作的数据需要同步ES和数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ProductDAO对数据库有影响的</span></span><br><span class="line"><span class="comment">// 都要通过productESDAO同步到es</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">productDAO.delete(id);</span><br><span class="line">productESDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ES初始化</strong></p><p>ES内数据为空，就将数据库中的数据同步到es</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据到es</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatabase2ES</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">Page&lt;Product&gt; page =productESDAO.findAll(pageable);</span><br><span class="line"><span class="comment">// 查询es中是否有数据</span></span><br><span class="line"><span class="keyword">if</span>(page.getContent().isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果数据为空，将数据从数据库同步到es中</span></span><br><span class="line">List&lt;Product&gt; products= productDAO.findAll();</span><br><span class="line"><span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">productESDAO.save(product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-ES查询"><a href="#4-ES查询" class="headerlink" title="4.ES查询"></a>4.ES查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过es进行查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">search</span><span class="params">(String keyword, <span class="keyword">int</span> start, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化es</span></span><br><span class="line">initDatabase2ES();</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryBuilders提供了大量静态方法，用于生成各种不同类型的查询对象</span></span><br><span class="line"><span class="comment">// 构建查询条件（多条件查询）</span></span><br><span class="line">FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()</span><br><span class="line"><span class="comment">// 为提供的字段名和文本创建一个通用查询</span></span><br><span class="line">.add(QueryBuilders.matchPhraseQuery(<span class="string">&quot;name&quot;</span>, keyword),</span><br><span class="line">ScoreFunctionBuilders.weightFactorFunction(<span class="number">100</span>))</span><br><span class="line"><span class="comment">// 设置权重分为求和模式</span></span><br><span class="line">.scoreMode(<span class="string">&quot;sum&quot;</span>)</span><br><span class="line"><span class="comment">// 设置权重分最低分</span></span><br><span class="line">.setMinScore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分页参数</span></span><br><span class="line">Sort sort  = <span class="keyword">new</span> Sort(Sort.Direction.DESC,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size,sort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分页参数和查询条件</span></span><br><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">.withPageable(pageable)</span><br><span class="line">.withQuery(functionScoreQueryBuilder).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询获取结果</span></span><br><span class="line">Page&lt;Product&gt; page = productESDAO.search(searchQuery);</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> page.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis解析"><a href="#Redis解析" class="headerlink" title="Redis解析"></a>Redis解析</h3><p><strong>必看资料：</strong></p><p><a href="https://www.yuque.com/books/share/04ac99ea-7726-4adb-8e57-bf21e2cc7183/fg8lgc">缓存基础常见面试题总结</a></p><p><a href="https://interview.javaguide.cn/#/./docs/d-2-redis">Redis常见面试题总结</a></p><p><a href="https://autovy.github.io/2022/04/20/Java/Java-渐进式本地缓存框架开发总结/">渐进式本地缓存开发总结</a></p><p><a href="https://blog.csdn.net/bocai_xiaodaidai/article/details/124010396">缓存一致性问题解决基本方案</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存一致性问题解决进阶方案</a></p><h4 id="一-Redis需求分析"><a href="#一-Redis需求分析" class="headerlink" title="一.Redis需求分析"></a>一.Redis需求分析</h4><p><strong>我们为了避免用户在请求数据的时候获取速度过于缓慢，同时也为了承受大量的并发请求，所以我们在数据库之上增加了缓存这一层来弥补</strong>，本系统主要使用的是Redis，将常用的数据存储在缓存中（如物品，用户信息等）</p><p>另外推荐使用RedisClient，数据一般都在db0中</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102017619.png" alt="image-20220310201748019"></p><h4 id="二-Redis配置"><a href="#二-Redis配置" class="headerlink" title="二.Redis配置"></a>二.Redis配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h4 id="三-缓存的使用"><a href="#三-缓存的使用" class="headerlink" title="三.缓存的使用"></a>三.缓存的使用</h4><p>缓存的使用一般在服务层使用</p><h5 id="1-有序集合管理"><a href="#1-有序集合管理" class="headerlink" title="1.有序集合管理"></a>1.有序集合管理</h5><p>通过在服务层中注解@CacheConfig，创建一个有序集合类型的缓存，管理该服务下所有的keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类服务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// redis缓存一般都在服务层进行操作</span></span><br><span class="line"><span class="comment">// 分类服务下的所有keys都由categories来管理（数据存储与categories是平行关系）</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames=&quot;categories&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102026158.png" alt="image-20220310202613389"></p><h5 id="2查询插入缓存"><a href="#2查询插入缓存" class="headerlink" title="2查询插入缓存"></a>2查询插入缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得单条分类服务</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-one- + 参数id为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Category对象</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-one-&#x27;+ #p0&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Category c= categoryDAO.findOne(id);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出单页分类表（提供分页组索引）</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-page- + 参数start + 参数size 为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Page4Navigator&lt;Category&gt;数组</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-page-&#x27;+#p0+ &#x27;-&#x27; + #p1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page4Navigator&lt;Category&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> size, <span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">   Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size, sort);</span><br><span class="line">Page pageFromJPA =categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Page4Navigator&lt;&gt;(pageFromJPA,navigatePages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的java对象或集合都会变成JSON字符串</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102031241.png" alt="image-20220310203123882"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102032065.png" alt="image-20220310203207786"></p><h5 id="3-更新删除缓存"><a href="#3-更新删除缓存" class="headerlink" title="3.更新删除缓存"></a>3.更新删除缓存</h5><p>为了应对并发的申请请求提高，我们在Mysql数据库前加了一层Redis，所以在我开发后台物资储存量调整接口时遇到了缓存和数据库中物品数量不一致的问题</p><p>准确来说是插入，删除，更新删除缓存以保持数据一致性</p><p>使用@CacheEvict(allEntries=true)删除category~keys的所有keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加删除更新时</span></span><br><span class="line"><span class="comment">// 增加分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">categoryDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-缓存一致问题解决"><a href="#四-缓存一致问题解决" class="headerlink" title="四.缓存一致问题解决"></a>四.缓存一致问题解决</h4><p>基本：<a href="https://blog.csdn.net/bocai_xiaodaidai/article/details/124010396">缓存一致性问题解决基本方案</a></p><p>进阶：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存一致性问题解决进阶方案</a></p><h3 id="分布式微服务解析"><a href="#分布式微服务解析" class="headerlink" title="分布式微服务解析"></a>分布式微服务解析</h3><p>参考资料：</p><p><a href="https://interview.javaguide.cn/#/./docs/g-4rpc">RPC与Dubbo</a></p><p><a href="https://posts.careerengine.us/p/6239366b61a53a0ab80e3c5c">SpringCloud Alibaba 及其组件</a></p><p><a href="https://interview.javaguide.cn/#/./docs/h-2消息队列">消息队列</a></p><p><a href="https://maiimg.com/dec/a90264156252@pdf">SpringCloud Alibaba详解</a></p><h3 id="高并发高可用解析"><a href="#高并发高可用解析" class="headerlink" title="高并发高可用解析"></a>高并发高可用解析</h3><p><a href="https://interview.javaguide.cn/#/./docs/i-0高可用系统设计指南">高可用系统设计指南</a></p><p><a href="https://interview.javaguide.cn/#/./docs/i-2限流">限流相关算法</a></p><h3 id="系统设计与性能测试解析"><a href="#系统设计与性能测试解析" class="headerlink" title="系统设计与性能测试解析"></a>系统设计与性能测试解析</h3><p><a href="https://www.yuque.com/books/share/04ac99ea-7726-4adb-8e57-bf21e2cc7183/unri6r">系统设计</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202209011353612.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java|物资申请系统开发总结</title>
    <link href="https://autovy.github.io/2021/10/20/Java/Java-%E7%89%A9%E8%B5%84%E7%94%B3%E8%AF%B7%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://autovy.github.io/2021/10/20/Java/Java-%E7%89%A9%E8%B5%84%E7%94%B3%E8%AF%B7%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-20T15:45:00.000Z</published>
    <updated>2022-10-25T08:48:30.272Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041947181.png" alt="image-20220504104541342"></p><span id="more"></span><h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><h3 id="数据库结构图"><a href="#数据库结构图" class="headerlink" title="数据库结构图"></a>数据库结构图</h3><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041042079.jpg" alt></p><h3 id="主要数据表信息"><a href="#主要数据表信息" class="headerlink" title="主要数据表信息"></a>主要数据表信息</h3><h4 id="一-物资申请表"><a href="#一-物资申请表" class="headerlink" title="一.物资申请表"></a>一.物资申请表</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041045668.png" alt="image-20220504104541342"></p><ul><li>用户id : 物资申请条目 = 1 : n</li><li>机构id : 物资申请条目 = 1 : n</li></ul><h4 id="二-物资申请详情表"><a href="#二-物资申请详情表" class="headerlink" title="二.物资申请详情表"></a>二.物资申请详情表</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041053586.png" alt="image-20220504105313339"></p><ul><li>物资申请条目id : 物资申请详情条目 = n : n</li><li>物资id : 物资申请详情条目 = n : n</li><li>(物资申请条目id,物资id) : 物资申请详情条目 = 1 : n</li></ul><h4 id="三-物资表"><a href="#三-物资表" class="headerlink" title="三.物资表"></a>三.物资表</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041059831.png" alt="image-20220504105953610"></p><h4 id="四-用户表"><a href="#四-用户表" class="headerlink" title="四.用户表"></a>四.用户表</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041102927.png" alt="image-20220504110242618"></p><ul><li>用户信息条目 : 权限id = 1 : 1</li></ul><h4 id="五-权限表"><a href="#五-权限表" class="headerlink" title="五.权限表"></a>五.权限表</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202205041104629.png" alt="image-20220504110408506"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><h4 id="一-前端"><a href="#一-前端" class="headerlink" title="一.前端"></a>一.前端</h4><ul><li>Vue.js：前端逻辑处理数据</li><li>Bootstrap：使用模板样式</li><li>Jquery</li><li>axios</li><li>Thymeleaf：主要使用其HTML包含技术，整合页面共用部分（Springboot官方推荐的视图）</li></ul><h4 id="二-后端"><a href="#二-后端" class="headerlink" title="二.后端"></a>二.后端</h4><ul><li>SpringBoot 1.5.9 RELEASE</li><li>Shiro安全框架</li><li>Maven</li><li>Hibernate</li><li>Elasticsearch搜索引擎</li></ul><h4 id="三-数据库"><a href="#三-数据库" class="headerlink" title="三.数据库"></a>三.数据库</h4><ul><li>MySQL数据库</li><li>Redis</li></ul><h3 id="相关依赖准备"><a href="#相关依赖准备" class="headerlink" title="相关依赖准备"></a>相关依赖准备</h3><p>pom.xml文件导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springboot web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springboot tomcat 支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 热部署 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- jpa：java持久层api，用于操作数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- redis：基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，一般说来，会被当作缓存使用。 因为它比数据库(mysql)快 --&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springboot test --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- thymeleaf： Thymeleaf 是一种模板语言，可以达到和JSP一样的效果，但是比起JSP 对于前端测试更加友好--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- elastic search：Elasticsearch是一个基于Lucene库的搜索引擎。它提供了一个分布式、支持多租户的全文搜索引擎 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用了 elasticsearch 就要加这么一个，不然要com.sun.jna.Native 错误 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- thymeleaf legacyhtml5 模式支持 --&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.nekohtml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nekohtml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 测试支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- tomcat的支持.--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mysql：数据库支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- junit：java自动测试工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span> 4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- commons-lang：提供常用工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- shiro：Java 当下常见的安全框架，主要用于用户验证和授权操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- hsqldb是一款Java内置的数据库，非常适合在用于快速的测试和演示的Java程序中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springfox-swagger依赖添加：文档化工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="开发内容"><a href="#开发内容" class="headerlink" title="开发内容"></a>开发内容</h2><h3 id="MySQL优化过程"><a href="#MySQL优化过程" class="headerlink" title="MySQL优化过程"></a>MySQL优化过程</h3><h4 id="一-T-SQL脚本分表优化"><a href="#一-T-SQL脚本分表优化" class="headerlink" title="一.T-SQL脚本分表优化"></a>一.T-SQL脚本分表优化</h4><h5 id="1-相关表的结构"><a href="#1-相关表的结构" class="headerlink" title="1.相关表的结构"></a>1.相关表的结构</h5><p>此处展示的表结构为维护前</p><p>物资申请表：共4817条数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031543098.png" alt="image-20220303154338625"></p><p>物资信息表：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031545235.png" alt="image-20220303154513022"></p><p>goods_count：当前仓库物品数（物理的）</p><p>good_leftCount：当前物品可借数（网络的：存在部分未借出，但已被预订仍在审核中的物品）</p><h5 id="2-优化思路：物资申请表分表"><a href="#2-优化思路：物资申请表分表" class="headerlink" title="2.优化思路：物资申请表分表"></a>2.优化思路：物资申请表分表</h5><p>从上面的tw_apply表就可以知道：</p><ul><li><p>在用户提出申请后，物资申请信息被后端拼成了一个字符串存储在apply_content（同时利用了前端的数据执行了物品可借数的预扣除，所以这部分没有用到物资申请信息字符串的解析）</p></li><li><p>通过审核后，物品正式借出，这时候只留有物资申请信息的字符串存储在数据库，所以需要后端对该字符串解析提取出申请物资与其借用数量，再去操作数据库</p></li></ul><p>还好后端大哥没有把物资申请信息的字符串直接发给前端，我真的哭死，设计数据库的那个出来挨打（前端不需要解析，但是要拼接展示字符串）</p><p>数据库设计十分不合理，甚至不符合第一范式，<strong>浪费数据库大量存储空间</strong>不说，而且后端拼接字符串解析字符串这一过程<strong>十分耗时且占用内存</strong>，而且最新的需求是需要增加一个审核过程申请物资调整功能</p><p>所以我将物资申请表进行分表（水平分表），分出物资申请详情表并联系物资信息表，其结构如下</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031646110.png" alt="image-20220303164602406"></p><p>删除掉apply_content字段，节省数据库空间</p><p>分表后，通过tw_applydetail表，我们对物资申请信息的所以内容进行操作，省去了物资审核接口对字符串解析的耗时过程并且方便审核过程申请物资调整功能的开发（通过tw_appdetail找到物品信息和物品数量）</p><h5 id="3-优化操作：存储过程脚本"><a href="#3-优化操作：存储过程脚本" class="headerlink" title="3.优化操作：存储过程脚本"></a>3.优化操作：存储过程脚本</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象</p><p>这里值得注意的是在遍历游标的循环中，如果查询不存在或为空会跳出循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`Autovy`@`localhost` <span class="keyword">PROCEDURE</span> `demo`()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 定义变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n TINYTEXT;</span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"> # 求分割符号<span class="string">&#x27;,&#x27;</span>的位置</span><br><span class="line"><span class="keyword">DECLARE</span> _index <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息</span><br><span class="line"><span class="keyword">DECLARE</span> str TINYTEXT;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息长度</span><br><span class="line"><span class="keyword">DECLARE</span> strLength <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"># 物品名称</span><br><span class="line"><span class="keyword">DECLARE</span> goodName <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"># 物品数量</span><br><span class="line"><span class="keyword">DECLARE</span> goodCount <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"># 物品id</span><br><span class="line"><span class="keyword">DECLARE</span> goodId <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义游标，并将sql结果集赋值给游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> apply_id1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id, apply_content <span class="keyword">FROM</span> tw_apply <span class="keyword">WHERE</span> apply_content <span class="keyword">LIKE</span> &quot;本部%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明当游标遍历完后将标志变量置成1</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> s<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> apply_id1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将游标中的值赋值给变量，注意：变量名不要和返回列名同名，变量顺序要和sql结果顺序一致</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当s != 1,一直循环</span></span><br><span class="line">while s<span class="operator">&lt;&gt;</span><span class="number">1</span> do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过;分割单个物品的申请信息：北院—帐篷物品1个;北院—椅子物品1个;北院—桌子物品1个;</span></span><br><span class="line">while _index <span class="operator">&gt;</span> <span class="number">0</span>  do</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到单个物品申请信息：本部——桌子物品1个</span></span><br><span class="line"><span class="keyword">SET</span> str <span class="operator">=</span> <span class="keyword">LEFT</span>(n, _index<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> strLength <span class="operator">=</span> LENGTH(str) <span class="operator">/</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品名称</span></span><br><span class="line"><span class="keyword">SET</span> goodName <span class="operator">=</span> <span class="keyword">LEFT</span>(str, strLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品个数(类型转换为整数)</span></span><br><span class="line"><span class="keyword">SET</span> goodCount <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="keyword">LEFT</span>(<span class="keyword">RIGHT</span>(str, <span class="number">2</span>), <span class="number">1</span>) <span class="keyword">AS</span> signed) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> goodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按物品名称查到物品id并存储到goodId中</span></span><br><span class="line"><span class="comment">-- 这里如果查询不存在或为空会跳出游标循环，值得注意</span></span><br><span class="line"><span class="keyword">SELECT</span> goods_id <span class="keyword">into</span> goodId <span class="keyword">FROM</span> tw_goods <span class="keyword">WHERE</span> goods_show <span class="keyword">LIKE</span> goodName <span class="keyword">ORDER</span> <span class="keyword">BY</span> goods_count <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> tw_applydetail(apply_id, good_id, count) <span class="keyword">VALUES</span> (m, goodId, goodCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移动到下个分界点</span></span><br><span class="line"><span class="keyword">SET</span> n <span class="operator">=</span> SUBSTR(n <span class="keyword">FROM</span> _index<span class="operator">+</span><span class="number">1</span>);</span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行业务逻辑</span></span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取下一条数据，读取完成置变量s=1</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">close</span> apply_id1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>当时经过一天的对存储过程的学习，我总结出了以下经验：存储过程非常不方便调试，而且报错信息只定位不报错误类型（sql是这样的）。如果能重来，对数据库的批量操作，首选Python或Shell</p><h5 id="4-优化结果"><a href="#4-优化结果" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>截至目前物资申请表已有4817条数据，考虑到后面数据会长期积累，这样的优化是有必要的</li><li>去掉后端耗时耗内存的字符串解析工作</li><li>节省数据库存储空间，优化前申请表内存占0.79MB，优化后占0.56MB</li></ul><p>另外附加一个容量查询小工具，可查询数据库各表容量大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">table_schema as &#39;数据库&#39;,</span><br><span class="line">table_name as &#39;表名&#39;,</span><br><span class="line">table_rows as &#39;记录数&#39;,</span><br><span class="line">truncate(data_length&#x2F;1024&#x2F;1024, 2) as &#39;数据容量(MB)&#39;,</span><br><span class="line">truncate(index_length&#x2F;1024&#x2F;1024, 2) as &#39;索引容量(MB)&#39;</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema&#x3D;&#39;bgs&#39;</span><br><span class="line">order by data_length desc, index_length desc;</span><br></pre></td></tr></table></figure><h4 id="二-索引优化查询"><a href="#二-索引优化查询" class="headerlink" title="二.索引优化查询"></a>二.索引优化查询</h4><h5 id="1-相关表结构"><a href="#1-相关表结构" class="headerlink" title="1.相关表结构"></a>1.相关表结构</h5><p>日志记录表：共33687条数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031910440.png" alt="image-20220303191047146"></p><h5 id="2-优化思路：添加索引"><a href="#2-优化思路：添加索引" class="headerlink" title="2.优化思路：添加索引"></a>2.优化思路：添加索引</h5><p>关于索引的知识点这里不细说，推荐阅读：<a href="https://javaguide.cn/database/mysql/mysql-index/">MySQL 索引详解</a></p><p>由于日志表数据庞大，有3万条数据，为了达到快速通过用户名模糊查找到日志操作内容和操作时间，就需要用到索引，另外在模糊查询中，<strong>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用</strong></p><p>所以我将查询的模糊匹配由“%xxxx%”改为“xxxx%”，只模糊匹配前面部分</p><h5 id="3-优化操作"><a href="#3-优化操作" class="headerlink" title="3.优化操作"></a>3.优化操作</h5><p>这里直接使用Navicat可视化添加索引，因为后台查询日志是需要用用户名模糊查找到日志操作内容和操作时间，所以需要添加的索引为log_realnam</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203031939750.png" alt="image-20220303193939350"></p><p>更改mybatis的sql映射，解决sql注入和索引失效问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE &quot;%$&#123;log_name&#125;%&quot;;  </span><br></pre></td></tr></table></figure><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE concat(‘%’,#&#123;log_name&#125;, ‘%’) </span><br></pre></td></tr></table></figure><h5 id="4-优化结果-1"><a href="#4-优化结果-1" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>添加索引前使用用户名模糊查询日志，耗时大约0.045s，添加索引后耗时大约0.032s，减少了磁盘IO，提高了查询速度</li><li>修改mybatis中模糊查询的sql语句，解决索引失效的问题，并解决了模糊查询中拼接字符串的sql注入问题</li></ul><h3 id="Elasticsearch搜索"><a href="#Elasticsearch搜索" class="headerlink" title="Elasticsearch搜索"></a>Elasticsearch搜索</h3><h4 id="一-ES配置"><a href="#一-ES配置" class="headerlink" title="一.ES配置"></a>一.ES配置</h4><h5 id="1-ES可视化"><a href="#1-ES可视化" class="headerlink" title="1.ES可视化"></a>1.ES可视化</h5><p>kibana是es的可视化工具，开启后可以通过访问 <a href="http://127.0.0.1:5601/">http://127.0.0.1:5601/</a>  查看kibana页面</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203111029709.png" alt="image-20220311102937485"></p><h5 id="2-配置ES"><a href="#2-配置ES" class="headerlink" title="2.配置ES"></a>2.配置ES</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span> = <span class="string">127.0.0.1:9300</span></span><br></pre></td></tr></table></figure><h4 id="二-ES开发流程"><a href="#二-ES开发流程" class="headerlink" title="二.ES开发流程"></a>二.ES开发流程</h4><h5 id="1-ES注解实体类"><a href="#1-ES注解实体类" class="headerlink" title="1.ES注解实体类"></a>1.ES注解实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Document注解Category实体类，一个Category对象即为一个Document（相当于数据库的一行）</span></span><br><span class="line"><span class="comment">// 连接到es的tmall_springboot索引（相当于数据库），produt类（相当于表）上</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;tmall_springboot&quot;,type = &quot;product&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="2-esDAO的创建"><a href="#2-esDAO的创建" class="headerlink" title="2.esDAO的创建"></a>2.esDAO的创建</h5><p>由于整合了ES的JPA和操作数据库使用的JPA有冲突，所以不能放在同一个包下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.pojo.Product;</span><br><span class="line"><span class="comment">// 用于链接es的DAO</span></span><br><span class="line"><span class="comment">// esDAO和其他DAO不能放在一个包下否则会启动异常</span></span><br><span class="line"><span class="comment">// 主要使用es实现对产品的模糊查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductESDAO</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-Application引入ES"><a href="#3-Application引入ES" class="headerlink" title="3.Application引入ES"></a>3.Application引入ES</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// esJPA引入</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(basePackages = &quot;com.how2java.tmall.es&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JPA引入</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &#123;&quot;com.how2java.tmall.dao&quot;, &quot;com.how2java.tmall.pojo&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h5 id="4-服务层同步ES"><a href="#4-服务层同步ES" class="headerlink" title="4.服务层同步ES"></a>4.服务层同步ES</h5><p><strong>增删改操作</strong></p><p>增删改操作的数据需要同步ES和数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ProductDAO对数据库有影响的</span></span><br><span class="line"><span class="comment">// 都要通过productESDAO同步到es</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">productDAO.delete(id);</span><br><span class="line">productESDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ES初始化</strong></p><p>ES内数据为空，就将数据库中的数据同步到es</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据到es</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatabase2ES</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">Page&lt;Product&gt; page =productESDAO.findAll(pageable);</span><br><span class="line"><span class="comment">// 查询es中是否有数据</span></span><br><span class="line"><span class="keyword">if</span>(page.getContent().isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果数据为空，将数据从数据库同步到es中</span></span><br><span class="line">List&lt;Product&gt; products= productDAO.findAll();</span><br><span class="line"><span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">productESDAO.save(product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-服务层查询ES"><a href="#5-服务层查询ES" class="headerlink" title="5.服务层查询ES"></a>5.服务层查询ES</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过es进行查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">search</span><span class="params">(String keyword, <span class="keyword">int</span> start, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化es</span></span><br><span class="line">initDatabase2ES();</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryBuilders提供了大量静态方法，用于生成各种不同类型的查询对象</span></span><br><span class="line"><span class="comment">// 构建查询条件（多条件查询）</span></span><br><span class="line">FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()</span><br><span class="line"><span class="comment">// 为提供的字段名和文本创建一个通用查询</span></span><br><span class="line">.add(QueryBuilders.matchPhraseQuery(<span class="string">&quot;name&quot;</span>, keyword),</span><br><span class="line">ScoreFunctionBuilders.weightFactorFunction(<span class="number">100</span>))</span><br><span class="line"><span class="comment">// 设置权重分为求和模式</span></span><br><span class="line">.scoreMode(<span class="string">&quot;sum&quot;</span>)</span><br><span class="line"><span class="comment">// 设置权重分最低分</span></span><br><span class="line">.setMinScore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分页参数</span></span><br><span class="line">Sort sort  = <span class="keyword">new</span> Sort(Sort.Direction.DESC,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size,sort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分页参数和查询条件</span></span><br><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">.withPageable(pageable)</span><br><span class="line">.withQuery(functionScoreQueryBuilder).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询获取结果</span></span><br><span class="line">Page&lt;Product&gt; page = productESDAO.search(searchQuery);</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> page.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h3><h4 id="一-Redis可视化工具"><a href="#一-Redis可视化工具" class="headerlink" title="一.Redis可视化工具"></a>一.Redis可视化工具</h4><p>推荐使用RedisClient，数据一般都在db0中</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102017619.png" alt="image-20220310201748019"></p><h4 id="二-Redis配置"><a href="#二-Redis配置" class="headerlink" title="二.Redis配置"></a>二.Redis配置</h4><h5 id="1-Redis配置类"><a href="#1-Redis配置类" class="headerlink" title="1.Redis配置类"></a>1.Redis配置类</h5><p>该缓存配置类主要是使redis内的key和value转换为可读性的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//Redis 缓存配置类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate&lt;?,?&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        RedisSerializer stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.PUBLIC_ONLY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        redisTemplate.setKeySerializer(stringSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringSerializer);  </span><br><span class="line">         </span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);         </span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        CacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-Redis配置文件"><a href="#2-Redis配置文件" class="headerlink" title="2.Redis配置文件"></a>2.Redis配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h4 id="三-缓存启用与检测"><a href="#三-缓存启用与检测" class="headerlink" title="三.缓存启用与检测"></a>三.缓存启用与检测</h4><h5 id="1-缓存的启用"><a href="#1-缓存的启用" class="headerlink" title="1.缓存的启用"></a>1.缓存的启用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统启动入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 启动缓存</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(basePackages = &quot;com.how2java.tmall.es&quot;)</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &#123;&quot;com.how2java.tmall.dao&quot;, &quot;com.how2java.tmall.pojo&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 检测端口上的服务是否启动</span></span><br><span class="line">        PortUtil.checkPort(<span class="number">6379</span>,<span class="string">&quot;Redis 服务端&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        PortUtil.checkPort(<span class="number">9300</span>,<span class="string">&quot;ElasticSearch 服务端&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        PortUtil.checkPort(<span class="number">5601</span>,<span class="string">&quot;Kibana 工具&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-服务开启检测"><a href="#2-服务开启检测" class="headerlink" title="2.服务开启检测"></a>2.服务开启检测</h5><p>这里的PortUtil是一个检测端口上服务是否运行的简单工具类，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.how2java.tmall.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具类，检查某个端口对应的服务是否启动</span></span><br><span class="line"><span class="comment">// 可以用于检查redis服务和es服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PortUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">ss.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPort</span><span class="params">(<span class="keyword">int</span> port, String server, <span class="keyword">boolean</span> shutdown)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!testPort(port)) &#123;</span><br><span class="line"><span class="keyword">if</span>(shutdown) &#123;</span><br><span class="line">String message =String.format(<span class="string">&quot;在端口 %d 未检查得到 %s 启动%n&quot;</span>,port,server);</span><br><span class="line">JOptionPane.showMessageDialog(<span class="keyword">null</span>, message);</span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String message =String.format(<span class="string">&quot;在端口 %d 未检查得到 %s 启动%n,是否继续?&quot;</span>,port,server);</span><br><span class="line">    <span class="keyword">if</span>(JOptionPane.OK_OPTION != JOptionPane.showConfirmDialog(<span class="keyword">null</span>, message)) </span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-缓存的使用"><a href="#四-缓存的使用" class="headerlink" title="四.缓存的使用"></a>四.缓存的使用</h4><p>缓存的使用一般在服务层使用</p><h5 id="1-有序集合管理"><a href="#1-有序集合管理" class="headerlink" title="1.有序集合管理"></a>1.有序集合管理</h5><p>通过在服务层中注解@CacheConfig，创建一个有序集合类型的缓存，管理该服务下所有的keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类服务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// redis缓存一般都在服务层进行操作</span></span><br><span class="line"><span class="comment">// 分类服务下的所有keys都由categories来管理（数据存储与categories是平行关系）</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames=&quot;categories&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102026158.png" alt="image-20220310202613389"></p><h5 id="2查询插入缓存"><a href="#2查询插入缓存" class="headerlink" title="2查询插入缓存"></a>2查询插入缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得单条分类服务</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-one- + 参数id为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Category对象</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-one-&#x27;+ #p0&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Category c= categoryDAO.findOne(id);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出单页分类表（提供分页组索引）</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-page- + 参数start + 参数size 为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Page4Navigator&lt;Category&gt;数组</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-page-&#x27;+#p0+ &#x27;-&#x27; + #p1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page4Navigator&lt;Category&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> size, <span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">   Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size, sort);</span><br><span class="line">Page pageFromJPA =categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Page4Navigator&lt;&gt;(pageFromJPA,navigatePages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的java对象或集合都会变成JSON字符串</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102031241.png" alt="image-20220310203123882"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203102032065.png" alt="image-20220310203207786"></p><h5 id="3-更新删除缓存"><a href="#3-更新删除缓存" class="headerlink" title="3.更新删除缓存"></a>3.更新删除缓存</h5><p>准确来说是插入，删除，更新删除缓存以保持数据一致性</p><p>使用@CacheEvict(allEntries=true)删除category~keys的所有keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加删除更新时</span></span><br><span class="line"><span class="comment">// 增加分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">categoryDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shiro登录验证"><a href="#Shiro登录验证" class="headerlink" title="Shiro登录验证"></a>Shiro登录验证</h3><p>由于本项目仅仅有用户一个权限，所以只需要判断用户是否登录，并不需要比较细粒度的权限分配</p><h4 id="一-JPARealm验证授权器"><a href="#一-JPARealm验证授权器" class="headerlink" title="一.JPARealm验证授权器"></a>一.JPARealm验证授权器</h4><p>Shiro与用户之间的中介，为Shiro提供验证和授权用户的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.realm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过JPA进行验证授权</span></span><br><span class="line"><span class="comment">// （相当于一个中介，拿着用户信息去数据库找用户拥有的角色和权限）</span></span><br><span class="line"><span class="comment">// 将Realm提供给Shiro，由其负责调用，不需要直接调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JPARealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 认证：查询用户身份与密码，解决你是谁的问题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="comment">// 从token中取出用户名称</span></span><br><span class="line">String userName = token.getPrincipal().toString();</span><br><span class="line"><span class="comment">// 查询用户表得到用户加密密码</span></span><br><span class="line">User user = userService.getByName(userName);</span><br><span class="line">String passwordInDB = user.getPassword();</span><br><span class="line"><span class="comment">// 获得用户表中的盐</span></span><br><span class="line">String salt = user.getSalt();</span><br><span class="line"><span class="comment">// 以用户名，加密密码，盐，真实信息，真正姓名作为认证信息</span></span><br><span class="line">SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(userName, passwordInDB, ByteSource.Util.bytes(salt),</span><br><span class="line">getName());</span><br><span class="line"><span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 授权：赋予用户权限，解决你能做什么的问题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SimpleAuthorizationInfo s = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二-Shiro配置"><a href="#二-Shiro配置" class="headerlink" title="二.Shiro配置"></a>二.Shiro配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.realm.JPARealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.LifecycleBeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shiro配置文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor <span class="title">getLifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器，实现对请求的拦截和跳转</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shirFilter</span><span class="params">(SecurityManager securityManager)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ShiroFilterFactoryBean 对象</span></span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean  = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           这里可以设置URL并为它们配置权限，本项目没有用到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// shiro核心组件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建DefaultWebSecurityManager对象</span></span><br><span class="line">        DefaultWebSecurityManager securityManager =  <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">// 设置其使用的Realm</span></span><br><span class="line">        securityManager.setRealm(getJPARealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载身份认证与授权模块</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JPARealm <span class="title">getJPARealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JPARealm myShiroRealm = <span class="keyword">new</span> JPARealm();</span><br><span class="line">        myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher());</span><br><span class="line">        <span class="keyword">return</span> myShiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定使用md5加密算法，并进行两次加密</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashedCredentialsMatcher <span class="title">hashedCredentialsMatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashedCredentialsMatcher hashedCredentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        hashedCredentialsMatcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        hashedCredentialsMatcher.setHashIterations(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> hashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  开启shiro aop注解支持.</span></span><br><span class="line"><span class="comment">     *  使用代理方式;所以需要开启代码支持;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span></span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三-注册接口"><a href="#三-注册接口" class="headerlink" title="三.注册接口"></a>三.注册接口</h4><p>Realm的验证需要对应注册里的加密方法即md5 * 2 + 盐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册接口</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/foreregister&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    String name =  user.getName();</span><br><span class="line">    String password = user.getPassword();</span><br><span class="line">    <span class="comment">// 对姓名中的特殊符号进行转义</span></span><br><span class="line">    name = HtmlUtils.htmlEscape(name);</span><br><span class="line">    user.setName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户名是否存在</span></span><br><span class="line">    <span class="keyword">boolean</span> exist = userService.isExist(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">        String message =<span class="string">&quot;用户名已经被使用,不能使用&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成盐</span></span><br><span class="line">    String salt = <span class="keyword">new</span> SecureRandomNumberGenerator().nextBytes().toString();</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 采用md5加密</span></span><br><span class="line">    String algorithmName = <span class="string">&quot;md5&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// md5 + 盐对用户密码进行加密得到加密密码</span></span><br><span class="line">    <span class="comment">// times = 2，表明进行两次的md5加密</span></span><br><span class="line">    String encodedPassword = <span class="keyword">new</span> SimpleHash(algorithmName, password, salt, times).toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将盐和加密密码存入数据库中</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    user.setPassword(encodedPassword);</span><br><span class="line"></span><br><span class="line">    userService.add(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-登录接口"><a href="#四-登录接口" class="headerlink" title="四.登录接口"></a>四.登录接口</h4><p>配置好Shiro后，登录验证时可以快速使用啦！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录接口</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/forelogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User userParam, HttpSession session)</span> </span>&#123;</span><br><span class="line">        String name =  userParam.getName();</span><br><span class="line">        name = HtmlUtils.htmlEscape(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shiro认证登录（你是谁？）</span></span><br><span class="line">        <span class="comment">// subject指的是:&quot;当前正在执行的用户的特定的安全视图&quot;</span></span><br><span class="line">        <span class="comment">// 可以把Subject看成是shiro的&quot;User&quot;概念</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(name, userParam.getPassword());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            User user = userService.getByName(name);</span><br><span class="line">            <span class="comment">// 将user存储进seesion中，后续可以随时取出用于验证登录</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">            <span class="keyword">return</span> Result.success();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            String message =<span class="string">&quot;账号密码错误&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截前端某些没有权限的访问，如没有登录权限的用户访问个人信息表，跳转到登录页</p><h4 id="一-拦截器"><a href="#一-拦截器" class="headerlink" title="一.拦截器"></a>一.拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录拦截器，用于拦截未登录情况下的访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpSession session = httpServletRequest.getSession();</span><br><span class="line">        String contextPath=session.getServletContext().getContextPath();</span><br><span class="line"><span class="comment">// 需要验证登录的页面</span></span><br><span class="line">        String[] requireAuthPages = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">&quot;buy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;alipay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;payed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bought&quot;</span>,</span><br><span class="line">        <span class="string">&quot;confirmPay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderConfirmed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forebuyone&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forebuy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foreaddCart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forecart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forechangeOrderItem&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foredeleteOrderItem&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forecreateOrder&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forepayed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forebought&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foreconfirmPay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foreorderConfirmed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foredeleteOrder&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forereview&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foredoreview&quot;</span></span><br><span class="line">        </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取uri</span></span><br><span class="line">        String uri = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除前缀/tmall_springboot</span></span><br><span class="line">        uri = StringUtils.remove(uri, contextPath+<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String page = uri;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链接名，是否以验证登录数组里的开头</span></span><br><span class="line"><span class="keyword">if</span>(begingWith(page, requireAuthPages))&#123;</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">// 如果是则跳转到login页面</span></span><br><span class="line"><span class="keyword">if</span>(!subject.isAuthenticated()) &#123;</span><br><span class="line">httpServletResponse.sendRedirect(<span class="string">&quot;login&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">begingWith</span><span class="params">(String page, String[] requiredAuthPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (String requiredAuthPage : requiredAuthPages) &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.startsWith(page, requiredAuthPage)) &#123;</span><br><span class="line">result = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过实现SpringMCV的HandlerInterceptor来实现拦截器，其中包含3个方法：</p><p><strong>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)</strong></p><p>该方法将在请求处理之前进行调用。SpringMVC中的Interceptor是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。</p><p>每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。</p><p>该方法的返回值是布尔值Boolean类型的，当它返回为false 时，表示请求结束，后续的Interceptor和Controller都不会再执行；</p><p>当返回值为true时就会继续调用下一个Interceptor的preHandle方法，如果已经是最后一个Interceptor的时候就会是调用当前请求的Controller方法</p><p><strong>postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)</strong><br>由preHandle方法的解释我们知道这个方法包括后面要说到的afterCompletion方法都只能是在当前所属的Interceptor的preHandle方法的返回值为true时才能被调用</p><p>postHandle方法，顾名思义就是在当前请求进行处理之后，也就是Controller方法调用之后执行，<br>但是它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。</p><p>postHandle方法被调用的方向跟preHandle是相反的，也就是说先声明的Interceptor 的postHandle方法反而会后执行，这和Struts2里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的</p><p><strong>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</strong><br>该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。</p><p>顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。<br>这个方法的主要作用是用于进行资源清理工作的。</p><h4 id="二-拦截器配置"><a href="#二-拦截器配置" class="headerlink" title="二.拦截器配置"></a>二.拦截器配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问拦截器配置</span></span><br><span class="line"><span class="keyword">package</span> com.how2java.tmall.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.interceptor.OtherInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 拦截器的配置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">getLoginIntercepter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h2><h3 id="循环依赖解决方案"><a href="#循环依赖解决方案" class="headerlink" title="循环依赖解决方案"></a>循环依赖解决方案</h3><h4 id="一-Springboot注解补充"><a href="#一-Springboot注解补充" class="headerlink" title="一.Springboot注解补充"></a>一.Springboot注解补充</h4><p>实体类中，@Transient注解的字段，是不与数据库映射的，可以额外添加到接口的字段即该字段不参与自动关联中的sql查询</p><p>这些字段可以用来存储：通过查询数据库得到的列表（不用另外建集合对象存储），需要经过计算的数据（也可以放在数据库），数据状态（也可以放在数据库）</p><p>订单表@Transient注解字段，在服务层进行赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单项列表</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line"><span class="comment">// 订单总金额</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> total;</span><br><span class="line"><span class="comment">// 订单物品总数量</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalNumber;</span><br><span class="line"><span class="comment">// 订单状态</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String statusDesc;</span><br></pre></td></tr></table></figure><p>使用</p><p>@ManyToOne<br>@JoinColumn(name=”pid”)</p><p>可以标注关系，就可以使用JPA的findBy等方法如：<code>findByProductOrderByIdDesc</code>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个产品有多个属性值</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个属性有多个属性值（属性 + 产品决定一条属性值）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;ptid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Property property;</span><br></pre></td></tr></table></figure><h4 id="二-数据库设计：多对多关系"><a href="#二-数据库设计：多对多关系" class="headerlink" title="二.数据库设计：多对多关系"></a>二.数据库设计：多对多关系</h4><p>在实际应用中，多对多关系会分解为两个一对多的关系</p><p>属性值由产品和属性共同决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个产品，有多个属性值（不同属性，同一产品）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个属性有多个属性值（不同产品，同一属性）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;ptid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Property property;</span><br></pre></td></tr></table></figure><p>订单项由订单，用户，产品共同决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个产品可以有多个订单项（不同用户/不同订单，同一产品）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个订单可以有多个订单项（不同产品/不同用户，同一订单）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;oid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用户可以有多个订单项（不同产品/不同订单，同一用户）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;uid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br></pre></td></tr></table></figure><p>在review类中的内对象如：prouct，user由于一对多的关联，在数据库中映射为pid，uid字段）</p><p>所以说JPA是一个ORM框架，对象和数据库无缝衔接</p><h4 id="三-循环依赖的解决"><a href="#三-循环依赖的解决" class="headerlink" title="三.循环依赖的解决"></a>三.循环依赖的解决</h4><p>在SpringBoot + JPA的架构中，容易出现循环依赖问题，一般会出现在一对多的场景下，总结来说是一对多实体中都要引用对方来维持OnetoMany的关系，所以极容易出现循环依赖:(</p><h5 id="1-经典场景"><a href="#1-经典场景" class="headerlink" title="1.经典场景"></a>1.经典场景</h5><p>订单项中引用订单，以构成多对一关系</p><p>可以使用订单项查找其属于的订单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个订单可以有多个订单项（不同产品/不同用户，同一订单）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;oid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Order order;</span><br></pre></td></tr></table></figure><p>订单中引用订单项存储在集合中，用来存储从数据库查询来的结构（往往是因为要利用这些字段进行计算）</p><p>可以使用订单id查找订单项列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单项列表</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line"><span class="comment">// 订单总金额</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> total;</span><br><span class="line"><span class="comment">// 订单物品总数量</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalNumber;</span><br></pre></td></tr></table></figure><p>这样的结构就是循环依赖，导致数据重复加载，因为orderItems要调用方法填充，所以会为空（一般情况下会栈溢出）最终造成的数据是：Order含有orderItems，orderItems含有Order，Order的orderItem列表为空，所以这里的Order重复了一次</p><h5 id="2-方案一：-JsonBackReference注解"><a href="#2-方案一：-JsonBackReference注解" class="headerlink" title="2.方案一：@JsonBackReference注解"></a>2.方案一：@JsonBackReference注解</h5><p>JsonBackReference注解用在一（一对多的一）的一方，可以阻止其被序列化，前提是对应的接口不需要调用到它，而只是需要用它来查询</p><p>如：一个产品有多张图片，我们不需要在图片列表接口使用到产品信息，而只是需要用产品id查询其图片</p><p><strong>产品类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="comment">// 产品首图</span></span><br><span class="line"><span class="keyword">private</span> ProductImage firstProductImage;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productSingleImages;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productDetailImages;</span><br></pre></td></tr></table></figure><p><strong>产品图片类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="meta">@JsonBackReference</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ul><li>关系是双向的，使用了JsonBackReference，就无法使用根据图片找到其属于的产品的方法，只能单方向查询即根据产品查找到其图片列表</li><li>JsonBackReference标记的字段与Redis的整合会有冲突</li></ul><h5 id="3-方案二：及时清除法"><a href="#3-方案二：及时清除法" class="headerlink" title="3.方案二：及时清除法"></a>3.方案二：及时清除法</h5><p>在服务层定义清除方法，在控制层调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Orderitem中有Order字段，标注多对一关系</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，用于存储订单项列表</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，而Orderitem中又有Order字段，产生无穷的递归</span></span><br><span class="line"><span class="comment">// 所以这里需要设置Orderitem的Order设为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(List &lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">removeOrderFromOrderItem(order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">List&lt;OrderItem&gt; orderItems= order.getOrderItems();</span><br><span class="line"><span class="keyword">for</span> (OrderItem orderItem : orderItems) &#123;</span><br><span class="line">orderItem.setOrder(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充Order的orderItem列表</span></span><br><span class="line">orderItemService.fill(page.getContent());</span><br><span class="line"><span class="comment">// 清除orderItem中的Order字段</span></span><br><span class="line">orderService.removeOrderFromOrderItem(page.getContent());</span><br></pre></td></tr></table></figure><h5 id="4-方案三：延迟加载"><a href="#4-方案三：延迟加载" class="headerlink" title="4.方案三：延迟加载"></a>4.方案三：延迟加载</h5><p>关于延迟加载：<a href="https://www.baeldung.com/hibernate-lazy-eager-loading">延迟加载介绍</a></p><p>使用<code>FetchType.LAZY</code>的方法，在不适用关系属性时，就不会自动获取，而一旦触发使用就会自动获取其属性 问题是<code>Jackson</code>对<code>Hibernate</code>的<code>LazyFetch</code>并不默认支持，需要一些额外支持</p><p>使用jackson-datatype-hibernate5插件使Jackson支持hibernate的lazyFetch</p><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-hibernate5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateModuleConfig</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title">mappingJackson2HttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              MappingJackson2HttpMessageConverter jsonConverter = <span class="keyword">new</span> MappingJackson2HttpMessageConverter();</span><br><span class="line">              ObjectMapper objectMapper = jsonConverter.getObjectMapper();</span><br><span class="line">              objectMapper.registerModule(<span class="keyword">new</span> Hibernate5Module());</span><br><span class="line">              <span class="keyword">return</span> jsonConverter;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实体上增加主键Id识别信息，防止出现循环引用 所有关系都为Lazy，直观上不会出现循环引用，但是当你通过一对多查询而多对一存在引用时仍会出现循环引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIdentityInfo(</span></span><br><span class="line"><span class="meta">      generator = ObjectIdGenerators.PropertyGenerator.class,</span></span><br><span class="line"><span class="meta">      property = &quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardModifyLog</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="5-其他方案"><a href="#5-其他方案" class="headerlink" title="5.其他方案"></a>5.其他方案</h5><ul><li>创建DTO，类似的思路还有创建接口投影或者实体视图，见<a href="https://www.baeldung.com/spring-data-jpa-named-entity-graphs">Spring Data JPA和命名实体图</a>、<a href="https://docs.spring.io/spring-data/jpa/docs/2.2.2.RELEASE/reference/html/#projections">Spring data jpa 投影</a>。 问题在于需要根据情况创建多个视图或者多个投影（DTO），由于各个实体间关系的复杂程度，不建议用此方式</li><li>使用<code>@Transient</code>注解使所有的关系不被存储即不与数据库的字段对应，同时存在于实体中，每次使用时，自己手动查询set 也许是一种好办法，但是失去了关系的约束，可能得不偿失</li></ul><h3 id="缓存AOP拦截失效问题"><a href="#缓存AOP拦截失效问题" class="headerlink" title="缓存AOP拦截失效问题"></a>缓存AOP拦截失效问题</h3><h4 id="一-问题出现原因"><a href="#一-问题出现原因" class="headerlink" title="一.问题出现原因"></a>一.问题出现原因</h4><p>Spring只有在代理对象之间进行调用时，可以触发切面逻辑才可以使用事务，在同一个class中，方法B调用方法A，调用的是原对象的方法，而不通过代理对象就无法使用事务,如果方法B有事务只会使用方法B的事务，不会去管方法A的事务所以一个类中方法调用当前类的其他拥有事务的方法时这个被调用方法事务会失效</p><p>一个类中方法调用当前类的其他拥有事务的方法时这个被调用方法事务会失效。在默认的代理模式下，只有目标方法由外部调用，才能被 Spring 的事务拦截器拦截</p><p>同理使用spring cache模块的@Cacheable等注解 在同一个class中互相调用是无法走缓存的 因为这样无法访问到spring容器中的那个代理对象</p><p>因为Springboot的缓存机制是通过切面编程aop来实现，从fill方法中调用listByCategory即内部调用，aop是拦截不到的，自然不会走缓存</p><h4 id="二-问题解决方案"><a href="#二-问题解决方案" class="headerlink" title="二.问题解决方案"></a>二.问题解决方案</h4><p>可以使用 AspectJ 取代 Spring AOP 代理来解决，也可以使用工具类诱发aop</p><p>fill方法调用诱发工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充分类中的产品集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过SpringContextUtil调用listByCategory上的缓存方法</span></span><br><span class="line">    <span class="comment">// 即 @Cacheable(key=&quot;&#x27;products-cid-&#x27;+ #p0.id&quot;)</span></span><br><span class="line">    <span class="comment">// 这样在方法内部的查询也能够使用缓存</span></span><br><span class="line">    ProductService productService = SpringContextUtil.getBean(ProductService.class);</span><br><span class="line">    List&lt;Product&gt; products = productService.listByCategory(category);</span><br><span class="line">    productImageService.setFirstProdutImages(products);</span><br><span class="line">    category.setProducts(products);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringContextUtil工具类诱发aop</p><p>我们需要在代码中需要动态获取其它bean，我们可以通过实现ApplicationContextAware接口来实现</p><p>ApplicationContextAware可以对当前bean传入对应的Spring上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取spring容器，以访问容器中定义的其他bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring应用上下文环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ApplicationContextAware接口的回调方法，设置上下文环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象 这里重写了bean方法，起主要作用</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(beanId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页动态数组开发"><a href="#分页动态数组开发" class="headerlink" title="分页动态数组开发"></a>分页动态数组开发</h3><h4 id="一-简单分页方法"><a href="#一-简单分页方法" class="headerlink" title="一.简单分页方法"></a>一.简单分页方法</h4><h5 id="1-Service层实现简单分页方法"><a href="#1-Service层实现简单分页方法" class="headerlink" title="1.Service层实现简单分页方法"></a>1.Service层实现简单分页方法</h5><p>这里使用JPA提供的Pageable类型对列表进行分页</p><p>Pageable是从0开始计算页数的，所以这里需要<code>pageNum - 1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Category&gt; <span class="title">getpage</span><span class="params">(<span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageLimit)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Pageable pageable = <span class="keyword">new</span> PageRequest(pageNum - <span class="number">1</span> , pageLimit);</span><br><span class="line">    <span class="keyword">return</span> categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Controller层调用分页方法"><a href="#2-Controller层调用分页方法" class="headerlink" title="2.Controller层调用分页方法"></a>2.Controller层调用分页方法</h5><p>通过@RequestParam设置从前台get方法发来的page和size信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/catepage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Category&gt; <span class="title">pageList</span><span class="params">(<span class="meta">@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;)</span> <span class="keyword">int</span> page ,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> categoryService.getpage(page, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p>访问请求链接：<a href="http://localhost:8080/shopping_system/catepage?page=2&amp;size=5">http://localhost:8080/shopping_system/catepage?page=2&amp;size=5</a></p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203060908527.png" alt="image-20211215173655433" style="zoom:80%;"><h4 id="二-分页动态数组组类"><a href="#二-分页动态数组组类" class="headerlink" title="二.分页动态数组组类"></a>二.分页动态数组组类</h4><h5 id="1-分页功能进阶封装"><a href="#1-分页功能进阶封装" class="headerlink" title="1.分页功能进阶封装"></a>1.分页功能进阶封装</h5><p>JPA提供的分页类可以返回分割后的列表内容和分类信息如<strong>总共数据数（totalElements），总共分割的页面（totalPages）与当前访问的页面（number）</strong>，但是这些数据不能方便提供一个方便的接口让前端实现<strong>部分分页节点展示</strong>和<strong>分页节点遍历</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203060908268.png" alt="image-20220228201059144"></p><p>当前是第8页，前面要显示3个，后面要显示3个，总共7条分页点，Pageable默认就不提供了，即Pageable无法实现根据当前选择页调整接口返回的数据，而只能硬性分页</p><p>所以我们需要做了一个 PageNavigator， 首先对 Page 类进行了封装，然后在构造方法里提供了一个 navigatePages 参数作为区间分页节点数</p><p>在构造方法里，还调用了 calcNavigatepageNums， 就是用来计算这个数值，并返回到一个int 数组变量 navigatepageNums ，方便前端遍历展示，而这个数组的大小为navigatePages</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageNavigator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用Page类</span></span><br><span class="line">    Page&lt;T&gt; pageFromJPA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalPages;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">long</span> totalElements;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单页数据数</span></span><br><span class="line">    <span class="keyword">int</span> numberOfElements;</span><br><span class="line">    <span class="comment">// 分页数据</span></span><br><span class="line">    List&lt;T&gt; contents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为首尾判断</span></span><br><span class="line">    <span class="keyword">boolean</span> first;</span><br><span class="line">    <span class="keyword">boolean</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有数据</span></span><br><span class="line">    <span class="keyword">boolean</span> isHasContent;</span><br><span class="line">    <span class="comment">// 是否有前驱</span></span><br><span class="line">    <span class="keyword">boolean</span> isHasPrevious;</span><br><span class="line">    <span class="comment">// 是否有后续</span></span><br><span class="line">    <span class="keyword">boolean</span> isHasNext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定区间分页节点数</span></span><br><span class="line">    <span class="keyword">int</span> navigatePages;</span><br><span class="line">    <span class="comment">// 规定区间分页节点列表</span></span><br><span class="line">    <span class="keyword">int</span>[] navigatepageNums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageNavigator</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造规定分页区间大小的分页函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageNavigator</span><span class="params">(Page&lt;T&gt; pageFromJPA, <span class="keyword">int</span> navigatePages)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 引用Page里面的成员变量</span></span><br><span class="line">        <span class="keyword">this</span>.pageFromJPA = pageFromJPA;</span><br><span class="line">        <span class="keyword">this</span>.navigatePages = navigatePages;</span><br><span class="line"></span><br><span class="line">        totalPages = pageFromJPA.getTotalPages();</span><br><span class="line">        number = pageFromJPA.getNumber();</span><br><span class="line">        totalElements = pageFromJPA.getTotalElements();</span><br><span class="line">        size = pageFromJPA.getNumberOfElements();</span><br><span class="line">        contents = pageFromJPA.getContent();</span><br><span class="line">        isHasContent = pageFromJPA.hasContent();</span><br><span class="line">        first = pageFromJPA.isFirst();</span><br><span class="line">        last = pageFromJPA.isLast();</span><br><span class="line">        isHasNext = pageFromJPA.hasNext();</span><br><span class="line">        isHasPrevious = pageFromJPA.hasPrevious();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出分页节点列表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcNavigatepageNums</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] navigatepageNums;</span><br><span class="line">        <span class="comment">// 总页数</span></span><br><span class="line">        <span class="keyword">int</span> totalPages = getTotalPages();</span><br><span class="line">        <span class="comment">// 当前页</span></span><br><span class="line">        <span class="keyword">int</span> num = getNumber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总页数小于区间分页节点数</span></span><br><span class="line">        <span class="keyword">if</span>(totalPages &lt;= navigatePages)&#123;</span><br><span class="line">            navigatepageNums = <span class="keyword">new</span> <span class="keyword">int</span>[totalPages];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalPages; i++)&#123;</span><br><span class="line">                navigatepageNums[i] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            navigatepageNums = <span class="keyword">new</span> <span class="keyword">int</span>[ navigatePages];</span><br><span class="line">            <span class="comment">// 计算区间列表首尾索引</span></span><br><span class="line">            <span class="keyword">int</span> startNum = num - navigatePages / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> endNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(navigatePages % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                endNum = num + navigatePages / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                endNum = num + navigatePages / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首navigatePages页</span></span><br><span class="line">            <span class="keyword">if</span>(startNum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                startNum = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; navigatePages; i++)&#123;</span><br><span class="line">                    navigatepageNums[i] = startNum++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾navigatePages页</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(startNum &gt; navigatePages)&#123;</span><br><span class="line">                endNum = totalPages;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = navigatePages - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                    navigatepageNums[i] = endNum--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 中间navigatePages页</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; navigatePages; i++)&#123;</span><br><span class="line">                    navigatepageNums[i] = startNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.navigatepageNums = navigatepageNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量对应的Getter与Setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalPages</span><span class="params">(<span class="keyword">int</span> totalPages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalPages = totalPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalElements</span><span class="params">(<span class="keyword">long</span> totalElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalElements = totalElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberOfElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumberOfElements</span><span class="params">(<span class="keyword">int</span> numberOfElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numberOfElements = numberOfElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContents</span><span class="params">(List&lt;T&gt; contents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contents = contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(<span class="keyword">boolean</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(<span class="keyword">boolean</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasContent</span><span class="params">(<span class="keyword">boolean</span> hasContent)</span> </span>&#123;</span><br><span class="line">        isHasContent = hasContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasPrevious;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasPrevious</span><span class="params">(<span class="keyword">boolean</span> hasPrevious)</span> </span>&#123;</span><br><span class="line">        isHasPrevious = hasPrevious;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasNext</span><span class="params">(<span class="keyword">boolean</span> hasNext)</span> </span>&#123;</span><br><span class="line">        isHasNext = hasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNavigatePages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> navigatePages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNavigatePages</span><span class="params">(<span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.navigatePages = navigatePages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNavigatepageNums() &#123;</span><br><span class="line">        <span class="keyword">return</span> navigatepageNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNavigatepageNums</span><span class="params">(<span class="keyword">int</span>[] navigatepageNums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.navigatepageNums = navigatepageNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上面的写法外，如果不需要修改方法名，完全可以在继承Page类的基础上进行拓展</p><h5 id="2-Service层实现进阶分页方法"><a href="#2-Service层实现进阶分页方法" class="headerlink" title="2.Service层实现进阶分页方法"></a>2.Service层实现进阶分页方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageNavigator&lt;Category&gt; <span class="title">getpage</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size, <span class="keyword">int</span> navigatePages)</span></span>&#123;</span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">    Pageable pageable = <span class="keyword">new</span> PageRequest(page, size, sort);</span><br><span class="line">    Page pageFrom = categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageNavigator&lt;&gt;(pageFrom, navigatePages);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-Controller层调用进阶分页方法"><a href="#3-Controller层调用进阶分页方法" class="headerlink" title="3.Controller层调用进阶分页方法"></a>3.Controller层调用进阶分页方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/catepage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageNavigator&lt;Category&gt; <span class="title">pageList</span><span class="params">(<span class="meta">@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;)</span> <span class="keyword">int</span> page,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口初始页调整为从1开始</span></span><br><span class="line">        page = page &lt; <span class="number">1</span> ? <span class="number">1</span> : page;</span><br><span class="line">        PageNavigator&lt;Category&gt; list = categoryService.getpage(page - <span class="number">1</span>, size, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p>访问地址：<a href="http://localhost:8080/tmall_springboot/categories?start=3&amp;size=2">http://localhost:8080/tmall_springboot/categories?start=3&amp;size=2</a></p><p>可以看到最终实现了提供一个存储5个页面索引的数组</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202282106562.png" alt="image-20220228210601487"></p><h4 id="三-分页方法比较"><a href="#三-分页方法比较" class="headerlink" title="三.分页方法比较"></a>三.分页方法比较</h4><p>JPA提供的分页类——Page可以满足各种分页需求，大部分时候用它就足够了，但是Pageable无法实现根据当前选择页调整接口返回的数据，而只能硬性分页即 <code>页数（totalPage） =  数据数（totalElements） / 页大小（size）</code> </p><p>表现在前端所有的分页都在一组分页栏中，如果想部分显示分页栏就需要前端去定制分页分组方法</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202203060908527.png" alt="image-20211215173655433" style="zoom:80%;"><p>但是如果前端有需求让后端根据当前选择页，以当前页为中点返回n个页面为一组的索引供前端调用</p><p>这时候我们就要对Page类进行封装，构造一个分页组类，在构造方法中提供一个navigatePages参数（分页组大小），并提供calNavigateNums方法根据当前页计算出分到同一组的页面索引并存储到数组navigatepageNums中供前端遍历展示</p><p>表现在前端可以通过接口获得当前页同一组分页的索引方便遍历</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202202282106562.png" alt="image-20220228210601487"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/ifme/p/12005026.html">Spring Data Elasticsearch基本使用</a></p><p><a href="https://onblogs.net/2019/05/29/史上最全面的Elasticsearch使用指南/">史上最全面的Elasticsearch使用指南</a></p><p><a href="https://juejin.cn/post/6844904002400813070">Spring data jpa中实体关系解决方案</a></p><p><a href="https://www.jianshu.com/p/a2f98f6d6fbd">Spring Data JPA 使用详解</a></p><p><a href="https://mp.weixin.qq.com/s/aUqH_lFxohMWPW4xOpPTcA">Redis实用指南</a></p><p><a href="https://www.baeldung.com/hibernate-lazy-eager-loading">延迟加载介绍</a><br>-lazy-eager-loading)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202205041947181.png&quot; alt=&quot;image-20220504104541342&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|HTTP与HTTPS</title>
    <link href="https://autovy.github.io/2021/10/17/DevPrinciple/HTTP%E4%B8%8EHTTPS/"/>
    <id>https://autovy.github.io/2021/10/17/DevPrinciple/HTTP%E4%B8%8EHTTPS/</id>
    <published>2021-10-17T15:45:00.000Z</published>
    <updated>2022-10-27T07:56:48.897Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110172010735.webp" alt="Oh the fun of HTTP-based applications"></p><p>基于HTTP应用程序的乐趣，but…</p> <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202208300729665.jpeg" style="zoom:20%;"><span id="more"></span><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1.HTTP基本概念"></a>1.HTTP基本概念</h4><h5 id="（1）超文本传输协议"><a href="#（1）超文本传输协议" class="headerlink" title="（1）超文本传输协议"></a>（1）超文本传输协议</h5><p>HTTP是超文本传输协议（<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol），准确的定义为<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110140812679.png" alt="img"></p><ul><li>协议：HTTP确认了一种计算机之间交流<strong>通信规范</strong>，以及各种相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）</li><li>传输：HTTP是一个<strong>双向协议</strong>，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程（<strong>请求方-应答方</strong>）</li><li>超文本：超文本顾名思义就是超越了普通文本的文本，最常用的超文本是<strong>HTML</strong>，是文章、图片、视频以及可以跳转到其他超文本等的<strong>混合体</strong></li></ul><h5 id="（2）HTTP状态码"><a href="#（2）HTTP状态码" class="headerlink" title="（2）HTTP状态码"></a>（2）HTTP状态码</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110140831637.webp" alt="Quick guide to HTTP Status codes"></p><p>好像没毛病，更加具体的说明如下：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110140836668.png" alt="img"></p><ul><li>1xx：<strong>提示信息</strong>，是协议处理中的<strong>中间状态</strong>，实际用到比较少</li><li>2xx：服务器<strong>成功</strong>处理客户端的请求<ol><li>200 （<strong>OK</strong>）：最常见的<strong>成功</strong>状态码，表示一切正常，非HEAD请求，服务器返回的响应头都会<strong>有body</strong>数据</li><li>204（<strong>No Content</strong>）：与200基本相同，但是响应头<strong>没有body</strong>数据</li><li>206（<strong>Partial Content</strong>）：应用于HTTP<strong>分块下载</strong>或<strong>断电续传</strong>，表示响应返回的body数据并不是资源的全部</li></ol></li><li>3xx：客户端请求的资源发生了变动，需要进行<strong>重定向</strong>（在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL）<ol><li>301（<strong>Moved Permanently</strong>）：表示永久重定向，说明请求的资源已经<strong>不存在</strong>，需要改用新的URL再次访问</li><li>302（<strong>Moved Permanently</strong>）：表示临时重定向，说明请求的资源<strong>还在</strong>，但暂时需要用另一个URL来访问</li><li>304（<strong>Not Modified</strong>）：缓冲重定向，用于缓存控制，表示资源未修改，重定向到已存在的缓冲文件</li></ol></li><li>4xx：客户端发送的报文有误，服务器无法处理<ol><li>400（<strong>Bad Request</strong>）：表示客户端请求的报文有误，但是是个<strong>笼统</strong>的错误</li><li>403（<strong>Forbidden</strong>）：表示服务器<strong>禁止访问</strong>资源，并不是客户端请求出错</li><li>404（<strong>Not Found</strong>）：表示请求的资源在服务器上<strong>不存在</strong>或<strong>未找到</strong>，所以无法提供给客户端</li></ol></li><li>5xx：服务器处理时内部发生了错误<ol><li>500（<strong>Internal Server Error</strong>）：一个<strong>笼统</strong>通用的错误：是的，服务器发生错误了，我们也不到什么错误</li><li>501（<strong>Not Implemented</strong>）：客户端请求的功能暂不支持（敬请期待）</li><li>502（Bad Gateway）：服务器自身工作正常，访问后端服务器时发生了错误（通常时用作网关或代理时的错误码）</li><li>503（<strong>Service Unavailable</strong>）：服务器当前正忙，暂时无法响应</li></ol></li></ul><h5 id="（3）HTTP常见字段"><a href="#（3）HTTP常见字段" class="headerlink" title="（3）HTTP常见字段"></a>（3）HTTP常见字段</h5><p><strong>通用标头：</strong>通用标头可以出现在请求标头和响应标头</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110141947390.png" alt="image-20211014194734284"></p><ul><li><p>Date：表示创建报文时间（格林威治标准时间）</p><p><code>Date: Wed, 21 Oct 2015 07:28:00 GMT</code> </p></li></ul><ul><li><p>Cache-Control：可以表示<strong>可缓存性</strong>、阈值性、 重新验证并重新加载和其他特性</p><p><code>Cache-control: no-cache</code></p></li></ul><ul><li><p>Connection：决定当前事务（一次三次握手和四次挥手）完成后，是否关闭网络连接（即是否复用TCP连接）</p><p><code>Connection: keep-alive</code>：<strong>持久性</strong>连接，一次事务完成后<strong>不关闭</strong>网络连接</p><p><code>Connection: close</code>：<strong>非持久化</strong>连接，一次事务完成后<strong>关闭</strong>网络连接</p></li></ul><p><strong>实体标头：</strong>实体标头是描述消息正文内容的 HTTP 标头</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110141955891.png" alt="image-20211014195508646"></p><ul><li>Content-Length：指示实体主体的大小，以字节为单位，发送到接收方</li></ul><p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110142001859.jpeg" alt="img"></p><ul><li>Content-Type：用于描述数据类型（格式），与Accept配套</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110142006988.jpeg" alt="img"></p><ul><li><p>Content-Encoding：用来说明描述的压缩方法和编码类型，与Accept-Encoding配套</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110142003250.jpeg" alt="img"></p></li></ul><ul><li>Content-Language：描述了客户端或者服务端能够接受的语言，与Accept-Language配套</li></ul><p><strong>请求标头：</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110142011873.png" alt="image-20211014201122463"></p><ul><li><p>Host：指明服务器域名与TCP端口号（也有写作authority）</p><p><code>Host: autovy.github.io</code></p></li></ul><ul><li><p>Referer：告诉服务器该网页是从哪个页面链接跳转过来的</p><p><code>Referer: https://autovy.github.io/</code></p></li></ul><ul><li><p>If-None-Match：使请求标头成为<strong>条件请求</strong>，当与给定资源<strong>ETag</strong>不匹配时才会处理请求</p><p><code>if-none-match: W/&quot;61665f52-7ba7&quot;</code></p></li></ul><ul><li><p>If-Modified-Since：If-Modified-Since 通常会与 If-None-Match 搭配使用，用于确认代理或客户端拥有的本地资源的<strong>有效性</strong>（在 <code>Last-Modified</code> 之后更新了服务器资源，那么服务器会响应 200，如果在 <code>Last-Modified</code> 之后没有更新过资源，则返回 304）</p><p><code>If-Modified-Since: Sat, 09 Oct 2021 01:58:35 GMT</code></p></li></ul><ul><li><p>Accept：告知服务器客户端能够理解的<strong>MIME类型</strong>，与Content-Type配套</p><p><code>accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</code></p></li></ul><ul><li>Accept-Charset：规定服务器处理表单数据所接受的<strong>字符集</strong></li></ul><ul><li><p>Accept-Language ：用来告知服务器客户端能够处理的<strong>自然语言集</strong></p><p><code>accept-language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</code></p></li></ul><p><strong>响应标头：</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110141925192.png" alt="img"></p><ul><li>Access-Control-Allow-Origin： 指定一个来源，它告诉浏览器允许该来源进行资源访问</li></ul><ul><li><p>Keep-Alive：表示的是 Connection 非持续连接的存活时间，可以进行指定，与Connection配套</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUlhrVicZt4iaLPPibcD8KQV4z9vqwAaAjdtkjUo5fGlKOsTaicbtEDO4u1Q/640?wx_fmt=jpeg" alt="img"></p></li></ul><ul><li>Server：服务器标头包含有关<strong>原始服务器</strong>用来处理请求的软件的信息</li></ul><ul><li>Set-Cookie：用于服务器向客户端发送 <strong>sessionID</strong></li></ul><ul><li>Transfer-Encoding：规定了传输报文主体时采用的<strong>编码方式</strong></li></ul><ul><li>X-Frame-Options：用于控制网站内容在其他 Web 网站的 <strong>Frame 标签</strong>内的显示问题，其主要目的是为了防止点击<strong>劫持攻击</strong></li></ul><h5 id="（4）HTTP无状态分析"><a href="#（4）HTTP无状态分析" class="headerlink" title="（4）HTTP无状态分析"></a>（4）HTTP无状态分析</h5><p><strong>无状态协议</strong>指浏览器对于事务的处理没有<strong>记忆能力</strong>，HTTP连接之间彼此独立，不会对请求和响应之间的通信进行保存</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110161444685.png" alt="img"></p><p>而<strong>Cookie</strong>技术可以通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110161446059.png" alt="img"></p><ul><li>客户端第一次向服务端发起请求</li><li>服务端开辟一块<strong>Session空间</strong>，同时生成一个<strong>sessionId</strong>，通过响应头的<strong>Set-Cookie</strong>命令要求客户端设置<strong>Cookie</strong></li><li>客户端收到响应后，在本地设置<strong>JSESSIONID</strong>的<strong>Cookie</strong>信息，默认过期时间为浏览器会话结束；接下来客户端向同一个完整发送请求时都会携带该<strong>Cookie</strong>信息</li><li>服务端通过读取请求头的<strong>Cookie</strong>信息，获取<strong>JSESSIONID</strong>的值，与存储的<strong>Session</strong>内的<strong>seesionId</strong>匹配</li></ul><p>此外还有一种让浏览器有记忆能力的机制——<strong>JWT机制</strong>（JSON WEB TOKEN），与Cookie不同，JWT是保存在客户端的信息，广泛用于<strong>单点登录</strong>，这里先挖个坑以后会详细出一篇讲单点登录的文章</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110161506705.webp" alt="img"></p><p>JWT是基于token的鉴权机制，不需要服务端去保留用户的认证信息或者会话信息</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token（令牌）</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据（token一般存在数据库中，也可以放在内存中）</li></ul><h4 id="2-GET与POST"><a href="#2-GET与POST" class="headerlink" title="2.GET与POST"></a>2.GET与POST</h4><h5 id="（1）GET与POST区别"><a href="#（1）GET与POST区别" class="headerlink" title="（1）GET与POST区别"></a>（1）GET与POST区别</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110161530468.jpeg" alt="img"></p><p>GET请求报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.java67.blogspot.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>POST请求报文:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">content-type:application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line">host: https://importexport.amazonaws.com</span><br><span class="line">content-length:207</span><br><span class="line"></span><br><span class="line">Action=GetStatus&amp;SignatureMethod=HmacSHA256&amp;JobId=JOBID&amp;SignatureVersion=2</span><br><span class="line">&amp;Version=2010-06-03&amp;Signature=%2FVfkltRBOoSUi1sWxRzN8rw%3D</span><br><span class="line">&amp;Timestamp=2011-06-20T22%3A30%3A59.556Z</span><br></pre></td></tr></table></figure><ul><li><strong>GET</strong>方法的含义是从服务器获取<strong>资源</strong>，发送的内容添加在url后</li><li><strong>POST</strong>方法先<strong>URI</strong>指定资源提交数据，这些数据放在报文body中</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110161540496.png" alt="img"></p><h5 id="（2）安全与幂等"><a href="#（2）安全与幂等" class="headerlink" title="（2）安全与幂等"></a>（2）安全与幂等</h5><ul><li><p>安全：在HTTP协议中，<strong>安全</strong>即请求方法不全不会<strong>破坏</strong>服务器的资源</p></li><li><p>幂等：多次执行相同操作，结果<strong>相同</strong>即一次请求和重复的多次请求对系统资源的影响是一致的，幂等思想在开发中有多处应用，可参考文章<a href="https://os.51cto.com/art/202012/633886.htm">幂等本质</a>了解更多</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110161549945.png" alt="img"></p></li></ul><ul><li><p>GET： GET方法是<strong>安全且幂等</strong>的，它是<strong>只读</strong>操作，服务器上数据安全且每次结果<strong>相同</strong></p></li><li><p>POST：POST方法是<strong>不安全且不幂等</strong>，它是<strong>新增或提交数据</strong>操作会修改服务器上的资源，所以<strong>不安全</strong>；多次提交数据就会创建多个资源，所以不是<strong>幂等</strong>的</p></li></ul><h4 id="3-HTTP特性"><a href="#3-HTTP特性" class="headerlink" title="3.HTTP特性"></a>3.HTTP特性</h4><h5 id="（1）HTTP的优点"><a href="#（1）HTTP的优点" class="headerlink" title="（1）HTTP的优点"></a>（1）HTTP的优点</h5><ul><li>简单：HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong></li><li>灵活和易于扩展：HTTP协议中的各类请求方法、URI/URL、状态码、头字段等每个组成要求都允许开发人员<strong>自定义和扩充</strong>，并且HTTP工作在应用层，其下层可以随意变化</li><li>应用广泛和跨平台：HTTP的应用范围广泛，而且可以跨平台使用</li></ul><h5 id="（2）HTTP的缺点"><a href="#（2）HTTP的缺点" class="headerlink" title="（2）HTTP的缺点"></a>（2）HTTP的缺点</h5><ul><li><p>无状态双刃剑</p><ol><li>无状态的好处：服务器不需要记忆HTTP状态，不需要额外资源记录状态信息，减轻服务器负担</li><li>无状态的坏处：服务器在需要进行关联操作时会非常麻烦</li><li>无状态的问题可以配合Cookie或Token进行解决</li></ol></li></ul><ul><li><p>明文传输双刃剑</p><ol><li>明文传输好处：方便阅读，为<strong>调试</strong>提供极大的便利性</li><li>明文传输坏处：你能看到的信息别人也能看到，敏感信息直接就<strong>裸奔</strong>了</li></ol></li></ul><ul><li>不安全<ol><li>通信用明文，内容容易被窃听</li><li>不验证通信方的身份，可能遭遇伪装</li><li>无法验证报文的完整性，可以会被篡改</li></ol></li></ul><h5 id="（3）HTTP性能"><a href="#（3）HTTP性能" class="headerlink" title="（3）HTTP性能"></a>（3）HTTP性能</h5><p>主要针对目前应用广泛的HTTP/1.1进行评测</p><ul><li><p>长连接：提供持久连接，减少TCP连接的重复建立和断开所造成的额外开销</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162038444.jpeg" alt="img"></p></li></ul><ul><li><p>管道网络传输：客户端发起多个请求，发起了一个请求后不必等待响应，而是继续发送下一个请求，从而减少整体的响应时间</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162042091.jpeg" alt="img"></p></li></ul><ul><li><p>队头阻塞：当顺序发送时，请求序列中的一个请求被阻塞了，在后面排队的所有请求被阻塞了</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162044395.jpeg" alt="img"></p></li></ul><h4 id="4-HTTP版本比较"><a href="#4-HTTP版本比较" class="headerlink" title="4.HTTP版本比较"></a>4.HTTP版本比较</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162046556.jpeg" alt="img"></p><h5 id="（1）HTTP-1-1"><a href="#（1）HTTP-1-1" class="headerlink" title="（1）HTTP/1.1"></a>（1）HTTP/1.1</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162105544.png" alt="image-20211016210504151"></p><p>HTTP/1.1的性能改进：</p><ul><li>使用<strong>长连接</strong>改善短链接造成的性能开销</li><li>支持<strong>管道网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li></ul><p>HTTP/1.1 性能瓶颈：</p><ul><li>请求/响应<strong>头部未经压缩</strong>就发送，只压缩了Body部分，首部信息越多延迟越大</li><li>发送<strong>冗长的首部</strong>，每次互相发送相同的首部造成浪费较多</li><li>队头阻塞</li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="（2）HTTP-2"><a href="#（2）HTTP-2" class="headerlink" title="（2）HTTP/2"></a>（2）HTTP/2</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162104685.png" alt="image-20211016210448418"></p><p>HTTP/2的性能改进：</p><ul><li><p>头部压缩</p><p>利用<strong>HPACK算法</strong>压缩头部，如果同时发出多个请求，可以消除重复的部分（在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号）</p></li></ul><ul><li><p>二进制格式</p><p>报文采用<strong>二进制格式</strong>而不是纯文本的形式，头信息和数据体都是二进制统称为帧，增加数据传输的效率</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162058061.png" alt="img"></p></li></ul><ul><li><p>数据流</p><p>数据包不是按顺序发送，同一个连接里面连续的数据包，可能属于不同的回应</p><p>因此要对数据包做标记，每个请求或回应的所有数据包，称为一个<strong>数据流</strong>（<code>Stream</code>）</p><p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p><p>客户端还可以<strong>指定数据流的优先级</strong>，优先级高的请求，服务器就先响应该请求</p></li></ul><ul><li><p>多路复用</p><p>在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162107565.jpeg" alt="img"></p></li></ul><ul><li><p>服务器推送</p><p>服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息</p><p>在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是<strong>服务器推送</strong></p></li></ul><p>HTTP/2 性能瓶颈：</p><ul><li>多个HTTP请求复用一个TCP连接，下层的 TCP 协议是不知道有多少个 HTTP 请求</li><li>一旦发生丢包现象，就会触发<strong>重传机制</strong>，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong></li><li>这些都是基于TCP传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong></li></ul><h5 id="（3）HTTP-3"><a href="#（3）HTTP-3" class="headerlink" title="（3）HTTP/3"></a>（3）HTTP/3</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110162114689.png" alt="image-20211016211442384"></p><p>HTTP/3的性能改进：</p><ul><li><p><strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong>，UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p></li></ul><ul><li><p>UDP是不可靠的传输，所以HTTP/3使用的是基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</p><ol><li><p>QUIC协议当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响</p></li><li><p>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code></p></li><li><p>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong></p></li><li><p>QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议</p></li></ol></li></ul><pre><code>![img](https://raw.githubusercontent.com/Autovy/Image/master/img/202110162120028.jpeg)</code></pre><p>HTTP/3 性能瓶颈：</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，普及的进度非常的缓慢</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="1-HTTPS基本概念"><a href="#1-HTTPS基本概念" class="headerlink" title="1.HTTPS基本概念"></a>1.HTTPS基本概念</h4><h5 id="（1）HTTPS定义"><a href="#（1）HTTPS定义" class="headerlink" title="（1）HTTPS定义"></a>（1）HTTPS定义</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110170930547.png" alt="img"></p><p>HTTPS（HyperText Transfer Protocol Secure）超文本传输安全协议，数据通信仍然是HTTP，但利用<strong>SSL/TLS加密数据包</strong></p><h5 id="（2）HTTP的安全问题"><a href="#（2）HTTP的安全问题" class="headerlink" title="（2）HTTP的安全问题"></a>（2）HTTP的安全问题</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171058237.svg" alt="202110170933070 (1)"></p><p>HTTP的<strong>明文传输</strong>是一个致命缺陷，没有经过任何加密，而这些明文数据会经过<strong>WiFi、路由器、运营商、机房</strong>等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，，这一攻击手法叫做MITM（Man In The Middle）<strong>中间人</strong>攻击</p><h4 id="2-HTTPS实现原理"><a href="#2-HTTPS实现原理" class="headerlink" title="2.HTTPS实现原理"></a>2.HTTPS实现原理</h4><h5 id="（1）对称加密"><a href="#（1）对称加密" class="headerlink" title="（1）对称加密"></a>（1）对称加密</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110170959993.png" alt="img"></p><p>对称加密算法使用<strong>同一个密钥</strong>进行加密和解密</p><ul><li>优点：速度快，适合数据量比较大的数据进行加密</li><li>缺点：在HTTPS的传输场景下，服务端事先并不知道客户端是谁，必然需要一个<strong>密钥传输</strong>过程，这意味着该密钥必定会<strong>泄露</strong>，后续的加密就不起作用了</li></ul><h5 id="（2）非对称加密：一组公私钥"><a href="#（2）非对称加密：一组公私钥" class="headerlink" title="（2）非对称加密：一组公私钥"></a>（2）非对称加密：一组公私钥</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110170959312.png" alt="img"></p><p>非对称加密需要两个密钥，一个<strong>公开密钥（Public Key）</strong>,一个<strong>私有密钥（Private Key）</strong>。公钥和私钥是一对，如果使用公钥进行加密的数据，只有对应的私钥才能解密。相对的，如果是使用私钥加密的数据，只有对应的公钥才能解密</p><ul><li>优点：当客户端发起连接请求，服务端将公钥传输过去，客户端利用<strong>公钥加密</strong>好信息，再将密文发送给服务端，服务端里用<strong>私钥解密</strong>，从而基本保证了客户端发送信息是安全的（只有服务器的私钥可解）</li><li>缺点：服务器无法返回加密安全的数据，服务器有<strong>公钥和私钥</strong>，客户端只有<strong>公钥</strong>。如果服务器用公钥加密，客户端也没有私钥可以解密；如果服务器用私钥加密，但是公钥相当于公开的，这样数据就不安全了</li></ul><p>严格来说，私钥并不能用来加密，而一般用作<strong>签名</strong>使用，签名的功能也会应用在HTTPS中，后面再细嗦</p><h5 id="（3）非对称加密：两组公私钥"><a href="#（3）非对称加密：两组公私钥" class="headerlink" title="（3）非对称加密：两组公私钥"></a>（3）非对称加密：两组公私钥</h5><p>一组公钥私钥只能保证客户端到服务端的<strong>单程加解密</strong>，理论上使用两组公钥私钥是可以保证<strong>往返加解密</strong></p><ul><li>服务端有非对称加密的公钥A1，私钥A2</li><li>客户端有非对称加密的公钥B1，私钥B2</li><li>客户端向服务端发起请求，服务端将<strong>公钥A1</strong>返回给客户端</li><li>浏览器收到公钥A1，将自己保存的<strong>公钥B1</strong>发送给服务端</li><li>之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密</li><li>客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密</li></ul><p>虽然非对称加密两组公私钥可以让两条传输方向都经过非对称加密，都能保证安全性，但是<strong>非对称加密耗时远大于对称加密</strong>，对性能有很大的损耗</p><h5 id="（4）混合加密"><a href="#（4）混合加密" class="headerlink" title="（4）混合加密"></a>（4）混合加密</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171015628.jpeg" alt="img"></p><p>混合加密是对称加密和非对称加密的结合体，即<strong>传输密钥</strong>时（一般传输共享的<strong>对称密钥</strong>）使用<strong>非对称加密</strong>的公钥加密，<strong>传输数据</strong>时使用<strong>共享对称密钥</strong>加密</p><ul><li><strong>非对称加密</strong>交换<strong>对称加密</strong>的<strong>会话密钥</strong></li><li><strong>对称加密</strong>使用<strong>会话密钥</strong>加密并交换数据</li></ul><p>具体步骤如下：</p><ul><li>服务端有非对称加密的公钥A1，私钥A2</li><li>客户端发起请求，服务端将公钥A1返回给客户端</li><li>客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端</li><li>服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了<strong>安全的对称密钥交换</strong>，解决了对称加密时密钥传输被人窃取的问题</li><li>之后双方通信都使用<strong>密钥K进行对称加解密</strong></li></ul><h5 id="（5）CA与数字证书"><a href="#（5）CA与数字证书" class="headerlink" title="（5）CA与数字证书"></a>（5）CA与数字证书</h5><p>混合加密兼顾了安全性，但是仍然无法保证安全，<strong>非对称加密的算法</strong>是<strong>公开</strong>的，所有人都可以生成一对公钥私钥，我们仍需要考虑<strong>中间人攻击</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171034059.png" alt="img"></p><ul><li>服务端返回公钥A1的过程中，中间人<strong>替换</strong>成自己准备好的的公钥B1传送给客户端</li><li>客户端对篡改行为一无所知，傻傻地使用公钥B1加密了对称加密使用的<strong>会话密钥K</strong></li><li>中间人截获公钥B1加密的<strong>会话密钥K</strong>，利用自己的私钥B2简简单单解个密，<strong>会话密钥K</strong>就暴露了，再使用服务端的公钥A1加密K传送给服务端，成功欺骗服务端，完成了通信链路。此后的的通信数据和明文传输无异</li></ul><p>这一问题的核心是：客户端<strong>无法确认</strong>收到的公钥是不是真的来源于服务端，无法保证公钥不被<strong>篡改</strong>和其<strong>信任度</strong>，这时就需要第三方权威机构<strong>CA</strong>（数字证书认证机构）将<strong>服务器公钥放在数字证书</strong>中，只要证书可信，公钥就可信</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171059315.jpeg" alt="img"></p><p><strong>摘要算法（哈希处理）</strong>保证证书不被篡改的原理：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171635097.jpeg" alt="img"></p><ul><li><p>服务器的公钥要事先提交到<strong>CA</strong>进行注册，申请一份<strong>数字证书</strong>（数字证书包含证书持有者，证书有效期，服务器公钥，哈希算法等）</p></li><li><p><strong>CA</strong>在颁发<strong>数字证书</strong>前对证书明文信息进行哈希处理（信息摘要计算），并对哈希值用CA的<strong>私钥</strong>处理得到<strong>数字签名</strong>对数字证书进行<strong>加签</strong></p></li><li><p>CA的公钥会<strong>内置</strong>在浏览器或操作系统中，不需要额外的网络传输</p></li><li><p>客户端发送请求时，服务端通过发送<strong>数字证书</strong>传输服务器的公钥</p></li><li><p>客户端得到证书，分解为<strong>明文部分Text</strong>和<strong>数字签名Sig1</strong>，使用CA机构的公钥进行<strong>解签</strong>得到Sig2，用证书声明的哈希算法对明文部分Text进行<strong>哈希处理</strong>，再与Sig2对比，如果匹配成功表示证书可信即表示公钥可信</p></li></ul><h4 id="3-HTTPS工作流程"><a href="#3-HTTPS工作流程" class="headerlink" title="3.HTTPS工作流程"></a>3.HTTPS工作流程</h4><p>参考资料：（写的比我好😇）</p><p><a href="https://segmentfault.com/a/1190000021494676">HTTPS 详解一：附带最精美详尽的 HTTPS 原理图</a></p><p><a href="https://segmentfault.com/a/1190000021559557">HTTPS详解二：SSL / TLS 工作原理和详细握手过程</a></p><p><a href="https://razeencheng.com/post/ssl-handshake-detail.html">HTTPS篇之SSL握手过程详解</a></p><h5 id="（1）HTTPS加解密流程"><a href="#（1）HTTPS加解密流程" class="headerlink" title="（1）HTTPS加解密流程"></a>（1）HTTPS加解密流程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171621895.png" alt="preview"></p><ul><li>客户端发起HTTPS请求，默认使用服务器端的<strong>443端口</strong>进行连接</li><li>服务器收到请求，返回配好的包含<strong>公钥Pub</strong>的证书给客户端（对应的<strong>私钥Private</strong>保存在服务器不公开）</li><li>客户端收到证书，校验<strong>证书的合法性</strong>（包括证书的有效期，证书域名，请求域名，数字签名等），保证证书没有被篡改</li><li>客户端生成一个用于对称加密的<strong>随机key</strong>，并用证书内的<strong>公钥Pub</strong>进行解密，发送给服务端</li><li>服务端收到<strong>随机key</strong>的密文，使用<strong>公钥Pub</strong>对应的<strong>私钥Private</strong>解密得到客户端发送的<strong>随机key</strong></li><li>服务端使用客户端发送的<strong>随机key</strong>对需要传输的HTTP数据进行对称加密，将密文返回客户端</li><li>客户端使用<strong>随机key</strong>对称解密密文，得到HTTP数据明文</li><li>后续的HTTPS<strong>传输数据</strong>都使用交换好的<strong>随机key</strong>进行对称加解密保证了数据的安全</li></ul><h5 id="（2）HTTPS通信流程图"><a href="#（2）HTTPS通信流程图" class="headerlink" title="（2）HTTPS通信流程图"></a>（2）HTTPS通信流程图</h5><p>HTTPS握手过程即TCP三次握手 + TLS握手</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171537560.png" alt="img"></p><p>详细的TLS握手流程如下，其与<strong>HTTPS加解密的流程</strong>大致<strong>对应</strong>，但更侧重于TLS握手的概念</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171621720.png" alt="preview"></p><ul><li><p>客户端发送<strong>clienthello</strong>消息：客户端发送<strong>clienthello</strong>消息发起握手请求，该消息包含了客户端支持的<strong>TLS版本号</strong>和<strong>密码组合</strong>以及一个<strong>client random</strong>随机字符串，需要约定的密码组合如下</p><ol><li>握手期间所使用的的密钥交换和认证算法 (最常用的是 RSA 算法)</li><li>加密算法 (用于握手完成后的对称加密，常用的有 AES、3DES等)</li><li>信息摘要算法 (常用的有 SHA-256、SHA-1 和 MD5 等)</li></ol></li><li><p>服务端发送<strong>serverhello</strong>消息：服务器发送<strong>serverhello</strong>消息对客户端进行回应，该消息包含<strong>数字证书</strong>，服务器选择的<strong>密码组合</strong>和<strong>server random</strong>随机字符串</p></li><li><p>客户端验证<strong>数字证书</strong>：客户端对服务器发来的证书进行验证，确保对方的合法身份</p><ol><li><p>检查数字签名（前面有详细的讲解，<strong>数字签名</strong>即服务器对证书内容进行<strong>信息摘要计算</strong>后再用<strong>私钥</strong>加密的结果）</p></li><li><p>验证证书链（<strong>证书链</strong>也称为证书路径，用于认证实体合法身份的证书列表，可以验证服务器的合法身份，也可以保证根证书的安全）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171645010.png" alt="image-20211017164519690"></p></li><li><p>检查证书的有效期</p></li><li><p>检查证书的撤回状态 (撤回代表证书已失效)</p></li></ol></li><li><p>客户端发送<strong>premaster secret字符串</strong>密文：客户端生成随机字符串<strong>premaster secret</strong>（预主密钥），并用<strong>公钥</strong>进行加密发送给服务器，只有服务器的私钥可以解开</p></li><li><p>服务器解密<strong>premaster secret</strong>：服务器使用私钥解密<strong>premaster secret字符串</strong></p></li><li><p>客户端服务端生成<strong>共享密钥</strong>：客户端和服务器均使用 <strong>client random</strong>，<strong>server random</strong> 和 <strong>premaster secret</strong>，并通过相同的算法生成相同的共享密钥 <strong>KEY</strong></p></li><li><p>客户端就绪：客户端发送经过<strong>共享密钥KEY</strong>加密过的<strong>finished</strong>信号</p></li><li><p>服务端就绪：服务端发送经过<strong>共享密钥KEY</strong>加密过的<strong>finished</strong>信号</p></li><li><p>达成安全通信：握手完成，双方使用<strong>共享密钥KEY</strong>对称加密进行安全通信</p></li></ul><h3 id="HTTP-与-HTTPS对比"><a href="#HTTP-与-HTTPS对比" class="headerlink" title="HTTP 与 HTTPS对比"></a>HTTP 与 HTTPS对比</h3><h4 id="1-HTTPS与HTTP基本区别"><a href="#1-HTTPS与HTTP基本区别" class="headerlink" title="1.HTTPS与HTTP基本区别"></a>1.HTTPS与HTTP基本区别</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171931223.png!large" alt="img"></p><ul><li>HTTP 是<strong>超文本传输协议</strong>，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 <strong>SSL/TLS 安全协议</strong>，使得报文能够加密传输</li><li>HTTP 连接建立相对简单， <strong>TCP 三次握手</strong>之后便可进行 HTTP 的报文传输。而 HTTPS 在 <strong>TCP 三次握手</strong>之后，还需进行 <strong>SSL/TLS 的握手过程</strong>，才可进入加密报文传输</li><li>HTTP 的端口号是 <strong>80</strong>，HTTPS 的端口号是 <strong>443</strong></li><li>HTTPS 协议需要向 CA（证书权威机构）<strong>申请数字证书</strong>，来保证服务器的身份是可信的</li></ul><h4 id="2-HTTP与HTTPS网络模型"><a href="#2-HTTP与HTTPS网络模型" class="headerlink" title="2.HTTP与HTTPS网络模型"></a>2.HTTP与HTTPS网络模型</h4><h5 id="（1）OSI-七层网络模型"><a href="#（1）OSI-七层网络模型" class="headerlink" title="（1）OSI 七层网络模型"></a>（1）OSI 七层网络模型</h5><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="img" style="zoom: 80%;"><h5 id="（2）TCP-IP五层网络模型"><a href="#（2）TCP-IP五层网络模型" class="headerlink" title="（2）TCP/IP五层网络模型"></a>（2）TCP/IP五层网络模型</h5><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" alt="img" style="zoom:80%;"><p>TCP/IP网络模型着眼于<strong>传输过程</strong>，于是将应用层，表示层，会话层视为<strong>应用层</strong></p><p>也有分为四层的TCP/IP网络模型，将<strong>数据链路层和物理层都表示为网络接口层</strong></p><h5 id="（3）OSI七层模型与TCP-IP五层模型对比"><a href="#（3）OSI七层模型与TCP-IP五层模型对比" class="headerlink" title="（3）OSI七层模型与TCP/IP五层模型对比"></a>（3）OSI七层模型与TCP/IP五层模型对比</h5><p>各层设备：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171945314.png" alt="img"></p><p>各层协议：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171945281.png" alt="img"></p><h5 id="（4）HTTP与HTTPS网络模型"><a href="#（4）HTTP与HTTPS网络模型" class="headerlink" title="（4）HTTP与HTTPS网络模型"></a>（4）HTTP与HTTPS网络模型</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110171950558.png" alt="image-20211017195034373"></p><h4 id="3-HTTPS相比HTTP的升级"><a href="#3-HTTPS相比HTTP的升级" class="headerlink" title="3.HTTPS相比HTTP的升级"></a>3.HTTPS相比HTTP的升级</h4><img src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210613103539-https-essence.png" alt="image.png" style="zoom: 50%;"><h5 id="（1）HTTP的安全风险"><a href="#（1）HTTP的安全风险" class="headerlink" title="（1）HTTP的安全风险"></a>（1）HTTP的安全风险</h5><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容</li><li><strong>篡改风险</strong>，比如强制入垃圾广告，视觉污染</li><li><strong>冒充风险</strong>，比如一些仿真的钓鱼网站</li></ul><h5 id="（2）HTTPS解决方案"><a href="#（2）HTTPS解决方案" class="headerlink" title="（2）HTTPS解决方案"></a>（2）HTTPS解决方案</h5><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的<strong>「指纹」</strong>，指纹用于校验数据的完整性，解决了篡改的风险</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险<br>��字证书**中，解决了冒充的风险</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202110172010735.webp&quot; alt=&quot;Oh the fun of HTTP-based applications&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于HTTP应用程序的乐趣，but…&lt;/p&gt;
 &lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202208300729665.jpeg&quot; style=&quot;zoom:20%;&quot;&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|一个数据包的网络之旅</title>
    <link href="https://autovy.github.io/2021/10/13/DevPrinciple/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%97%85/"/>
    <id>https://autovy.github.io/2021/10/13/DevPrinciple/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%97%85/</id>
    <published>2021-10-13T15:45:00.000Z</published>
    <updated>2022-10-25T08:48:30.250Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131214746.webp" alt="When the internet stops working! "></p><p>本文紧接上文，聚焦于<strong>网络线程</strong>连接并请求主机直至获得<strong>响应报文</strong>这个过程，主要研究一个<strong>数据包</strong>的网络之旅</p><span id="more"></span><p>整个过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130822302.png" alt="image-20211013082245766"></p><p>参考资料：户根勤《网络是怎么连接的》</p><h3 id="浏览器生成消息"><a href="#浏览器生成消息" class="headerlink" title="浏览器生成消息"></a>浏览器生成消息</h3><h4 id="1-生成HTTP请求消息"><a href="#1-生成HTTP请求消息" class="headerlink" title="1.生成HTTP请求消息"></a>1.生成HTTP请求消息</h4><p>浏览器的第一步工作就是要对URL进行解析，并生成发送WEB服务器的请求信息</p><h5 id="（1）URL解析"><a href="#（1）URL解析" class="headerlink" title="（1）URL解析"></a>（1）URL解析</h5><ul><li>URL各个部分的含义：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082014448.png" alt="image-20211008201443231"></p><ul><li>对URL进行解析从而定位到Web服务器下对应的目录：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082017786.png" alt="image-20211008201702549"></p><p>我们常见的url中很多都是没有文件名的，例如<a href="https://www.baidu.com，这种情况往往是对文件名进行了省略，web服务器有默认指向的文件如index.html等，例如https://www.baidu.com/index.html">https://www.baidu.com，这种情况往往是对文件名进行了省略，web服务器有默认指向的文件如index.html等，例如https://www.baidu.com/index.html</a></p><h5 id="（2）HTTP请求消息生成"><a href="#（2）HTTP请求消息生成" class="headerlink" title="（2）HTTP请求消息生成"></a>（2）HTTP请求消息生成</h5><p>对URL进行解析后，浏览器确定了Web服务器和文件名，然后根据这些信息生成HTTP请求消息</p><ul><li>HTTP请求基本结构：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082026183.png" alt="image-20211008202601682"></p><ul><li>请求方法：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082038757.png" alt="img"></p><ul><li>请求报文：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082034679.png" alt="image-20211008203440385"></p><ul><li><p>HTTP状态码：</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110172023742.png" alt="image-20211008203622266" style="zoom:80%;"></li></ul><ul><li>响应报文：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082035607.png" alt="image-20211008203518461"></p><h4 id="2-DNS域名解析"><a href="#2-DNS域名解析" class="headerlink" title="2.DNS域名解析"></a>2.DNS域名解析</h4><p>通过浏览器解析URL并生成HTTP消息后，还需要查询服务器<strong>域名</strong>对应的<strong>IP</strong>地址，才能找到消息发送对象的地址位置</p><p><strong>DNS服务器</strong>就是专门用来保存WEB服务器域名与IP对应关系的服务器</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082113224.png" alt="image-20211008211346869"></p><h5 id="（1）IP地址知识"><a href="#（1）IP地址知识" class="headerlink" title="（1）IP地址知识"></a>（1）IP地址知识</h5><ul><li>IP地址结构</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082053217.png" alt="image-20211008205323963"></p><p>子网掩码表示IP地址中网络号与主机号的分界，子网掩码为1的部分为<strong>网络号</strong>，子网掩码为0的部分为<strong>主机号</strong></p><p>当主机号部分的比特全为0时表示整个子网（而不是某台设备）全为1表示向子网所以设备发送</p><ul><li>IP地址表示方法</li></ul><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110172023054.png" alt="image-20211008205140338" style="zoom: 80%;"><h5 id="（2）域名层级关系"><a href="#（2）域名层级关系" class="headerlink" title="（2）域名层级关系"></a>（2）域名层级关系</h5><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082116997.png" alt="img"></p><p>例如<a href="http://www.google.cn（上香）：">www.google.cn（上香）：</a></p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（cn）</li><li>权威 DNS 服务器（google.cn）</li><li>而<code>www</code> 是主机名 随意填写 域名解析的时候填写<strong>主机记录</strong>和<strong>记录值</strong> </li></ul><h5 id="（3）域名解析工作流程"><a href="#（3）域名解析工作流程" class="headerlink" title="（3）域名解析工作流程"></a>（3）域名解析工作流程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082129029.png" alt="image-20211008212953361"></p><ul><li>本地DNS服务器（离客户端最近的DNS服务器）运行的是<strong>递归查询</strong>：对客户端负责到底，不断去询问查找可以解析域名的服务器</li><li>其他DNS服务器运行的是<strong>迭代查询</strong>：奉行踢皮球原则，不主动询问其他服务器，而是把知道域名对应关系的服务器信息告诉给本地域名服务器</li></ul><h5 id="（4）域名解析内部原理"><a href="#（4）域名解析内部原理" class="headerlink" title="（4）域名解析内部原理"></a>（4）域名解析内部原理</h5><p>域名解析请求DNS服务器，与浏览器请求远程web服务器有类似的地方，后面含义再详细讲Socker库和协议栈</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110082104351.png" alt="image-20211008210454836"></p><h3 id="用电信号传输TCP-IP数据"><a href="#用电信号传输TCP-IP数据" class="headerlink" title="用电信号传输TCP/IP数据"></a>用电信号传输TCP/IP数据</h3><p>协议分层模型：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090830845.jpeg" alt="OSI协议模型、TCP/IP协议模型"></p><p>TCP/IP数据包封装：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090853102.png" alt="TCP/IP数据包的封装"></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）</p><p>通信操作中使用的控制信息分为两类：</p><ul><li>头部中记录的信息（即加载数据包前的控制信息）</li><li>套接字（协议栈中的内存空间）中记录的信息</li></ul><h4 id="1-委托协议栈发送消息"><a href="#1-委托协议栈发送消息" class="headerlink" title="1.委托协议栈发送消息"></a>1.委托协议栈发送消息</h4><p>通过DNS获取IP后，就可以把HTTP的传输工作交给<strong>操作系统</strong>中的<strong>协议栈</strong></p><p>委托的结果是：<strong>协议栈</strong>之间连接了一条数据通道，数据包能沿着这条通道流动（<strong>套接字</strong>则可以视为管道的出入口，<strong>套接字</strong>的实体就是通信控制信息）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090819495.png" alt="image-20211009081901393"></p><h5 id="（1）套接字结构"><a href="#（1）套接字结构" class="headerlink" title="（1）套接字结构"></a>（1）套接字结构</h5><p>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于<strong>控制通信操作的控制信息</strong>，我们可以认为这些控制信息就是套接字的实体</p><p>套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用（协议栈是根据套接字中记录的控制信息来工作的）</p><p>套接字内容查看：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090911172.png" alt="image-20211009091135737"></p><h5 id="（2）TCP-IP-软件分层结构"><a href="#（2）TCP-IP-软件分层结构" class="headerlink" title="（2）TCP/IP 软件分层结构"></a>（2）TCP/IP 软件分层结构</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090805877.png" alt="image-20211009080517915" style="zoom:80%;"><h5 id="（3）Socket库"><a href="#（3）Socket库" class="headerlink" title="（3）Socket库"></a>（3）Socket库</h5><p>浏览器通过调用<strong>Socket</strong>库，委托协议栈来工作</p><p>向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket 库中的程序组件：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090811908.png" alt="image-20211009081135594"></p><ul><li>创建套接字（创建套接字阶段）</li><li>将管道连接到服务器端的套接字上（连接阶段）</li><li>收发数据（通信阶段）</li><li>断开管道并删除套接字（断开阶段）</li></ul><h5 id="（4）TCP与UDP协议"><a href="#（4）TCP与UDP协议" class="headerlink" title="（4）TCP与UDP协议"></a>（4）TCP与UDP协议</h5><p>TCP和UDP协议，接收应用层的委托指向收发数据的操作</p><ul><li>TCP和UDP协议的运用：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090832758.jpeg" alt="TCP/UDP常见应用"></p><ul><li>TCP/UDP比较：</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p><p>咳咳，正经详细的比较如下：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131209573.png" alt="image-20211013120922107"></p><ul><li>TCP/UDP编程模型</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090836254.jpeg" alt="TCP/UDP编程模型"></p><h5 id="（5）IP协议"><a href="#（5）IP协议" class="headerlink" title="（5）IP协议"></a>（5）IP协议</h5><p>在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议：</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作</p><h4 id="2-TCP可靠传输"><a href="#2-TCP可靠传输" class="headerlink" title="2.TCP可靠传输"></a>2.TCP可靠传输</h4><p>参考资料：<a href="https://www.eet-china.com/mp/a44399.html">TCP三次握手</a></p><h5 id="（1）TCP包头格式"><a href="#（1）TCP包头格式" class="headerlink" title="（1）TCP包头格式"></a>（1）TCP包头格式</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091935607.png" alt="img"></p><ul><li><p>源端口号：发送网络包的程序的端口号</p></li><li><p>目标端口号： 网络包的接收方程序的端口号</p></li><li><p>序号：<strong>发送方告知接收方</strong>，该网络包发送的数据相当于所有发送数据的第几个字节</p></li><li><p>ACK 号（确认号）：<strong>接收方告知发送方</strong>，接收方已经收到了所有数据的第几个字节</p></li><li><p>数据偏移量（首部长度）： 表示数据部分的起始位置，也可以认为表示头部的长度</p></li><li><p>保留：该字段为保留，现在未使用</p></li><li><p>控制位（状态位）：该字段中的每个比特分别表示以下通信控制含义</p><ul><li>URG：表示紧急指针字段有效</li><li>ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></li><li>PSH：表示通过flush 操作发送的数据</li><li>RST：<strong>强制断开</strong>连接，用于异常中断的情况</li><li>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作</li><li>FIN：表示<strong>断开</strong>连接</li></ul></li><li><p>窗口大小：接收方告知发送方窗口大小（窗口大小即缓存大小，标识当前处理能力，用于<strong>流量控制</strong>，<strong>拥塞控制</strong>）</p></li><li><p>校验和：用来检查是否出现错误</p></li><li><p>紧急指针：表示应紧急处理的数据位置</p></li><li><p>可选字段：除了上面的固定头部字段之外，还可以添加可选字段，但除了连接操作之外，很少使用可选字段</p></li></ul><h5 id="（2）TCP三次握手"><a href="#（2）TCP三次握手" class="headerlink" title="（2）TCP三次握手"></a>（2）TCP三次握手</h5><p>TCP三次握手其实就是<strong>建立一个TCP连接</strong>，客户端和服务器之间需要<strong>3个数据包</strong>，握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091957945.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></p><ul><li>初始状态下，客户端和服务端都处在<strong>CLOSED</strong>状态，先是服务端主动监听某个端口，处于<strong>LISTEN</strong>状态</li><li>第一次握手：客户端发送<strong>SYN</strong>报文，并进入<strong>SYN-SENT</strong>状态，等待服务器确认</li><li>第二次握手：服务器收到<strong>SYN</strong>报文后，需要向客户端发送<strong>ACK</strong>确认<strong>收到</strong>的报文；同时服务端也向客户端发送一个<strong>SYN报文</strong>（也就是说服务端向客户端发送了<strong>SYN+ACK</strong>报文），然后服务端进入<strong>SYN_RCVD</strong>状态</li><li>第三次握手：客户端收到<strong>SYN+ACK</strong>报文后，向服务端发送<strong>ACK</strong>确认<strong>收到</strong>的报文，客户端进入<strong>ESTABLISHED</strong>状态； 服务端收到客户端的<strong>ACK</strong>包后也会进入<strong>ESTABLISHED</strong>状态，完成三次握手</li></ul><p>三次握手的本质是——客户端和服务器通过<strong>两对SYN-ACK报文</strong>互相确认能力正不正常</p><p>每次SYN发送一个随机数<strong>n</strong>（seq=n），则ACK需要返回<strong>n+1</strong>（ack=n+1）</p><h5 id="（3）TCP连接状态查看"><a href="#（3）TCP连接状态查看" class="headerlink" title="（3）TCP连接状态查看"></a>（3）TCP连接状态查看</h5><p>在Linux系统可以通过<code>netstat -napt</code>命令查看TCP连接状态</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092029731.png" alt="img"></p><h5 id="（4）TCP分割数据"><a href="#（4）TCP分割数据" class="headerlink" title="（4）TCP分割数据"></a>（4）TCP分割数据</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092031256.png" alt="image-20211009203103835"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092036185.png" alt="image-20211009203651137"></p><p>HTTP请求消息比较长，超过MSS长度，TCP就会把HTTP消息的数据拆解成一块块的数据发送，数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中</p><h5 id="（5）TCP报文生成"><a href="#（5）TCP报文生成" class="headerlink" title="（5）TCP报文生成"></a>（5）TCP报文生成</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092037127.jpeg" alt="img"></p><p>TCP 协议里面的两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>）</p><p>TCP报文即为TCP头部+HTTP头部+数据，组装好后交给下面的网络层（IP）处理</p><h5 id="（6）TCP四次挥手"><a href="#（6）TCP四次挥手" class="headerlink" title="（6）TCP四次挥手"></a>（6）TCP四次挥手</h5><p>当我们的应用不再需要数据通信，就会发起断开TCP连接，建立一个连接需要<strong>三次握手</strong>，而终止一个连接需要经过<strong>四次挥手</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111551532.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong>；    FIN：表示<strong>断开</strong>连接</p><ul><li>第一次挥手：客户端发起<strong>FIN</strong>包，客户端进入<strong>FIN_WAIT_1</strong>状态（虽然FIN包不携带数据，也需要消耗一个序号u）</li><li>第二次挥手：服务端收到<strong>FIN</strong>包，发出确认包<strong>ACK</strong>（ack=u+1），并带上自己的序号seq=v，服务端进入<strong>CLOSE_WAIT</strong>状态（这个时候客户端仍需要接收服务器发送的数据）；客户端接收到服务端发送的<strong>ACK</strong>后，进入<strong>FIN_WAIT_2</strong>状态</li><li>第三次挥手：服务端数据发送完毕后，向客户端发送<strong>FIN</strong>包（seq=w，ack=u+1），<strong>半连接状态</strong>下服务器可能又发送一些数据，服务端此时进入<strong>LAST_ACK</strong>状态</li><li>第四次挥手：客户端收到服务端的<strong>FIN</strong>包后，发出确认包ACK（ACK=1， ack=w+1），此时客户端进入<strong>TIME_WAIT</strong>状态；服务端收到客户端确认包后进入<strong>CLOSED</strong>状态，而客户端需要等待2MSL后才进入<strong>CLOSED</strong>状态</li></ul><p>四次挥手的本质是——客户端和服务器通过<strong>两对FIN-ACK报文</strong>通知对方自己要关闭了</p><p>三次握手中，在第二次握手时，接收端将一个<strong>ACK</strong>包和一个<strong>SYN</strong>包合并一起发送，所以减少了一次包的发送</p><p>四次挥手中，在主动关闭方（客户端）发送FIN包后，接收方（服务端）可能还要发送数据，不能立即关闭数据通道，所以服务端要先确认ACK，然后等到自己把数据发无可发后再发送<strong>FIN</strong>包</p><h4 id="3-IP远程定位"><a href="#3-IP远程定位" class="headerlink" title="3.IP远程定位"></a>3.IP远程定位</h4><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象</p><h5 id="（1）IP包头格式"><a href="#（1）IP包头格式" class="headerlink" title="（1）IP包头格式"></a>（1）IP包头格式</h5><p>参考资料：<a href="https://www.malaoshi.top/show_1EF2boBn83hd.html">IP报头格式</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111650792.png" alt="img"></p><ul><li>版本号（Version）：标明了<strong>IP 协议的版本号</strong>，目前的协议版本号为4，下一代IP 协议的版本号为6</li><li>首部长度：指 <strong>IP 包头部长度</strong>，占4 位</li><li>区分类型（服务类型）：包括一个3 位的优先权字段（<strong>COS</strong>，Class of Service），4 位<strong>TOS</strong> 字段和1 位未用位。4 位TOS 分别代表最小时延、最大吞吐量、最高可靠性和最小费用</li><li>总长度：是整个<strong>IP 数据报长度</strong>，包括数据部分</li><li>标识：唯一的标识主机发送的每一份数据报，通常每发送一份报文它的值就会加1</li><li>Flag：3bite 它是用来<strong>标志数据包是否分段</strong>，其中包含<strong>DF（do not fragment）</strong>和<strong>MF(more fragment)</strong>，当DF的值为1时，则MF的值必为0，DF为1，则说明数据包有分段。同样可以知道当MF为1时，则DF为0，这表示的是数据包没有分段。当然也有可能MF和DF都为0的</li><li>Frag offset：<strong>段偏移</strong> 15bite 用于<strong>描述此分段在数据包中的位置</strong></li><li>生存时间：Time To Live（TTL），设置了数据包可以经过的 <strong>路由器数目</strong>。一旦经过一个路由器，TTL 值就会减1，当该字段值为0 时，数据包将被丢弃</li><li>协议：指示应当把这个数据包发往更高层的协议，<strong>TCP</strong> 协议的协议号为 <strong>6</strong>，<strong>UDP</strong> 协议的协议号为<strong>17</strong></li><li>报头校验和：计算IP 头部的校验和，<strong>检查报文头部的完整性</strong></li><li>源IP 地址：标识数据包的<strong>源端设备</strong>（即客户端输出的IP地址）</li><li>目的IP 地址：标识数据包的<strong>目的端设备</strong>（即通过DNS域名解析得到的WEB服务器IP）</li><li>IP选项：一般格式为1个字节的代码，1个字节的长度，1个字节的指针，指针的值从1开始计数，指向IP选项的内容，一般其值为4(跳过了前面的代码&amp;长度&amp;指针的三个字节)，长度包括前面3个字节在内的整个IP选项，最大值为40</li></ul><h5 id="（2）IP地址选择"><a href="#（2）IP地址选择" class="headerlink" title="（2）IP地址选择"></a>（2）IP地址选择</h5><p>客户端有多个网卡时，在填写源地址IP时就要根据<strong>路由表</strong>规则来判定应该使用哪一块网卡来发送包</p><p>在lInux系统，我们使用<code>route -n</code>，在windows系统则用 <code>route print</code>查看路由表</p><p>利用子网掩码与路由表判断源地址：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111928914.jpeg" alt="img"></p><p>假设目的IP 地址（web服务器）是<strong>192.168.10.200</strong>，与各条目的<strong>子网掩码</strong>做<strong>与运算</strong>，计算出IP和条目的<strong>网络目标IP</strong>（destination）匹配，则选择该条目的网卡作为IP包头的源地址</p><p>第三条目的目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器（Gateway即路由器的IP）</p><h5 id="（3）IP报文生成"><a href="#（3）IP报文生成" class="headerlink" title="（3）IP报文生成"></a>（3）IP报文生成</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111945739.jpeg" alt="img"></p><p>IP报文即为IP头部+TCP头部+HTTP头部+数据，组装好后IP模块还要进一步处理</p><h4 id="4-MAC传输"><a href="#4-MAC传输" class="headerlink" title="4.MAC传输"></a>4.MAC传输</h4><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong></p><h5 id="（1）MAC包头格式"><a href="#（1）MAC包头格式" class="headerlink" title="（1）MAC包头格式"></a>（1）MAC包头格式</h5><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的MAC 地址等信息</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111958982.png" alt="img"></p><ul><li>接收方MAC 地址：网络包接收方的MAC 地址，在<strong>局域网</strong>中使用这一地址来传输网络包</li><li>发送方MAC 地址：网络包发送方的MAC 地址，接收方通过它来判断是谁发送了这个包</li><li>以太类型：使用的<strong>协议类型</strong>，下面是一些常见的类型，一般在TCP/IP 通信中只使用0800 和0806这两种<ol><li>0000-05DC：IEEE 802.3</li><li>0800　　 ：IP 协议</li><li>0806　 ：ARP 协议</li><li>86DD　　　 IPv6</li></ol></li></ul><h5 id="（2）MAC地址确认"><a href="#（2）MAC地址确认" class="headerlink" title="（2）MAC地址确认"></a>（2）MAC地址确认</h5><p><strong>发送方</strong>：</p><p>发送方的MAC地址获取比较简单，MAC地址在网卡生产时写入<strong>ROM</strong>中的，只需将其读取出来放到MAC头部即可</p><p><strong>接收方</strong>：</p><p>发送IP网络包需要告诉以太网对方的MAC地址，IP 模块根<strong>据路由表Gateway</strong> 栏的内容判断应该把包发送给谁，然后在利用<code>ARP</code> 协议通过<strong>广播</strong>的方法帮我们找到路由器（目标设备与发送方在同一子网中）的 MAC 地址</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110112024487.png" alt="image-20211011202440537"></p><p>后续操作系统会将ARP的查询结果缓存在<strong>ARP缓存</strong>的内存空间内，可以通过<code>arp -a</code>命令进行查看</p><h5 id="（3）MAC报文生成"><a href="#（3）MAC报文生成" class="headerlink" title="（3）MAC报文生成"></a>（3）MAC报文生成</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110112029433.jpeg" alt="img"></p><p>MAC报文即为MAC头部+IP头部+TCP头部+HTTP头部+数据，至此网络包终于完整了，可以从本设备的大门（网卡）走出去开始真正的网络之旅</p><h4 id="5-网卡出口"><a href="#5-网卡出口" class="headerlink" title="5.网卡出口"></a>5.网卡出口</h4><h5 id="（1）网卡处理IP网络包"><a href="#（1）网卡处理IP网络包" class="headerlink" title="（1）网卡处理IP网络包"></a>（1）网卡处理IP网络包</h5><p>IP生成的<strong>网络包</strong>只是放在内存中的一串二进制数字信息，所以在其开始网络旅程之前还要经过<strong>网卡</strong>将<strong>数字信息转换为电信号</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110112051633.png" alt="img"></p><p>网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110112054908.png" alt="image-20211011205426437"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡将网络包转换为电信号，通过网线发送出去</p><h5 id="（2）以太网"><a href="#（2）以太网" class="headerlink" title="（2）以太网"></a>（2）以太网</h5><p>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，它可以让信号通过网线流过整个网络，最终到达所有的设备</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110121936474.png" alt="image-20211012193540441"></p><p>以太网的三个性质：</p><ul><li>包发送到MAC 头部的接收方MAC 地址代表的目的地</li><li>用发送方MAC地址识别发送方</li><li>用以太类型识别包的内容</li></ul><h5 id="（3）网络包传输"><a href="#（3）网络包传输" class="headerlink" title="（3）网络包传输"></a>（3）网络包传输</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111956850.png" alt="image-20211011195613299"></p><p>经过网卡处理后的网络包会发往<strong>最近的网络转换设备</strong>，当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里</p><p>这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向</p><p>网络中有<strong>路由器</strong>和<strong>集线器</strong>两种不同的转发设备，它们在传输网络包时有着各自的分工</p><p>（1）路由器根据目标地址判断下一个路由器的位置（基于IP规则）</p><p>（2）集线器在子网中将网络包传输到下一个路由（以太网规则）</p><h3 id="从网线到网络设备"><a href="#从网线到网络设备" class="headerlink" title="从网线到网络设备"></a>从网线到网络设备</h3><p>参考资料：<a href="https://www.bilibili.com/video/BV1yt411d7Rd/">集线器，交换机，路由器的区别</a></p><p>网络数据包的网络之旅：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110121910213.png" alt="image-20211012191019888"></p><p>各设备处理数据包的方式：</p><ul><li><p>集线器：构建局域网的设备，它会将信号复制并发向连接同一个集线器（即同一局域网）的全部端口（广播）</p></li><li><p>交换机：构建局域网的设备，运行在MAC层，它会将信号发向指定MAC的端口</p></li><li><p>路由器：将局域网连接上互联网的设备，运行在IP层，路由器可以分析网络包的目标地址IP，如果该IP在自己负责的网络内则接收，如果不在的话就发向其他网络（本质上是一个网络网关）</p></li></ul><h4 id="1-集线器传输"><a href="#1-集线器传输" class="headerlink" title="1.集线器传输"></a>1.集线器传输</h4><p>集线器（Hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备</p><h5 id="（1）网卡与集线器的双绞线连接"><a href="#（1）网卡与集线器的双绞线连接" class="headerlink" title="（1）网卡与集线器的双绞线连接"></a>（1）网卡与集线器的双绞线连接</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110121922490.png" alt="img"></p><p>网线周围的电磁波会产生<strong>噪声</strong>混淆<strong>信号</strong>导致信号的波形发生<strong>失真</strong>，所以用<strong>双绞线</strong>移植噪声</p><h5 id="（2）集线器将信号发往所有线路"><a href="#（2）集线器将信号发往所有线路" class="headerlink" title="（2）集线器将信号发往所有线路"></a>（2）集线器将信号发往所有线路</h5><p>当电信号（网络包经过网卡转换后的形态）到达集线器后，<strong>集线器将信号发送给所有连接在它上面的线路</strong>，会被广播到整个网络中</p><p><strong>集线器</strong>将包发到所有的设备，然后由设备根据接收方MAC 地址来判断应该接收哪些包</p><h4 id="2-交换机包转发"><a href="#2-交换机包转发" class="headerlink" title="2.交换机包转发"></a>2.交换机包转发</h4><p>交换机意为“开关”，是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路</p><p>交换机工作在<strong>MAC层</strong>，也称为<strong>二层网络设备</strong></p><h5 id="（1）交换机包接收操作"><a href="#（1）交换机包接收操作" class="headerlink" title="（1）交换机包接收操作"></a>（1）交换机包接收操作</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110122048818.png" alt="image-20211012204847117"></p><ul><li>电信号进入交换器模块后，<strong>电信号</strong>转换为<strong>数字信号</strong></li><li>通过包末尾的<strong>FCS</strong>校验错误，无误后信号放入缓冲区</li><li>交换机的端口<strong>不具有MAC地址</strong>，所以会将接收到所有的包存放再缓冲区中</li></ul><h5 id="（2）交换机MAC地址查找"><a href="#（2）交换机MAC地址查找" class="headerlink" title="（2）交换机MAC地址查找"></a>（2）交换机MAC地址查找</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110122049533.png" alt="image-20211012204902267"></p><ul><li>包存入的缓冲区后，就需要查询<strong>MAC地址表</strong>找到包的接收发<strong>MAC地址</strong>对应的<strong>端口</strong>，从而准确发送到连接该端口的设备</li><li>如果地址表找不到指定的MAC地址（可能是该地址没有向交换机发送过包，或者这个设备一段时间没有工作导致地址从地址表删除了），就将包复制并发向其他所有的端口（和集线器同样的转发方法），然后<strong>只有相应的接收者才接收包，其他设备会忽略这个包</strong></li><li>如果接受方MAC地址是一个<strong>广播地址</strong>，交换机也会将包复制并发向其他所有的端口</li></ul><h4 id="3-路由器包转发"><a href="#3-路由器包转发" class="headerlink" title="3.路由器包转发"></a>3.路由器包转发</h4><p>经过交换机后，网络包终于走出了子网，再经过路由器这个关口正式进入互联网</p><p>路由器，是连接因特网中各局域网、广域网的设备</p><h5 id="（1）交换机与路由器"><a href="#（1）交换机与路由器" class="headerlink" title="（1）交换机与路由器"></a>（1）交换机与路由器</h5><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址</li></ul><h5 id="（2）路由器基本原理"><a href="#（2）路由器基本原理" class="headerlink" title="（2）路由器基本原理"></a>（2）路由器基本原理</h5><p>路由器的端口具有MAC地址，因此它可以成为以太网的发送方和接收方；同时还具有IP地址，从这个意义上说，它和计算机的网卡是一样的</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的<strong>端口</strong>作为发送方将以太网包发送出去</p><h5 id="（3）路由器包接收操作"><a href="#（3）路由器包接收操作" class="headerlink" title="（3）路由器包接收操作"></a>（3）路由器包接收操作</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110122126261.png" alt="image-20211012212606988"></p><ul><li>电信号到达网线接口部分，路由器模块会将<strong>电信号转成数字信号</strong></li><li>通过包末尾的<strong>FCS</strong>进行错误校验</li><li>检查MAC头部<strong>接收方MAC地址</strong>，如果是发给自己的就放到<strong>接收缓冲区</strong>中，否则就丢弃这个包</li><li>路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃</li></ul><h5 id="（4）路由表查询确认输出端口"><a href="#（4）路由表查询确认输出端口" class="headerlink" title="（4）路由表查询确认输出端口"></a>（4）路由表查询确认输出端口</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110122136962.jpeg" alt="img"></p><p>完成包接收操作后，路由器就会<strong>去掉</strong>MAC头部（MAC头部的作用就是将包送达路由器，接收方 MAC 地址就是路由器端口的 MAC 地址）</p><p> 然后查询<strong>路由表</strong>判断转发目标，如图<code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这里的<strong>路由匹配</strong>与之前讲的<strong>IP地址的选择</strong>一样，即用目标IP与各条目的<strong>子网掩码</strong>做<strong>与运算</strong>，直到找到计算出IP和条目的<strong>网络目标IP</strong>（destination）匹配，则该条目的记录作为转发目标</p><p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」</p><h5 id="（5）路由器包发送操作"><a href="#（5）路由器包发送操作" class="headerlink" title="（5）路由器包发送操作"></a>（5）路由器包发送操作</h5><ul><li><p>路由器包发送操作需要根据<strong>路由表</strong>的<strong>网关列</strong>来判断：</p><ol><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ol></li><li><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址</p></li><li><p>发送方 MAC 地址字段，填写输出端口的 MAC 地址</p></li><li><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去（与计算机的网卡的操作是一致的）</p></li><li><p>经过多个路由器的大接力，层层转发最终到达目的地</p></li></ul><p>在网络包传输的过程中，源 IP 和目标 IP 始终不变，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输</p><h3 id="通过接入网进入互联网内部"><a href="#通过接入网进入互联网内部" class="headerlink" title="通过接入网进入互联网内部*"></a>通过接入网进入互联网内部*</h3><p>（对于这部分我只做简单介绍，详细资料可参考<a href="https://www.tuhd.top/2017/07/12/2017-07-12-4network/">接入网进入互联网内部——探索接入网和网络运营商 </a>）</p><p>网络包出了局域网后通过接入网进入互联网。和局域网一样，互联网也是通过路由器来转发包的，因此我们可以将互联网视为局域网络的放大版</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130828926.png" alt="image-20211013082847731"></p><h4 id="1-ADSL接入网"><a href="#1-ADSL接入网" class="headerlink" title="1.ADSL接入网"></a>1.ADSL接入网</h4><p>连接用户与互联网的接入网，所谓接入网，就是指连接互联网与家庭、公司网络的通信线路</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130833348.png" alt="image-20211013083304491"></p><h4 id="2-光纤接入网"><a href="#2-光纤接入网" class="headerlink" title="2.光纤接入网"></a>2.光纤接入网</h4><p>另外一种接入网技术光纤接入网（FTTH），通过光纤分路来降低传输成本</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130840845.png" alt="image-20211013084030599"></p><p>用户发送的网络包会通过ADSL 和FTTH 等接入网到达运营商的BAS，通过ADSL 接入网和BAS 之后，网络包就到达了互联网内部</p><h4 id="3-接入网中使用的PPP和隧道"><a href="#3-接入网中使用的PPP和隧道" class="headerlink" title="3.接入网中使用的PPP和隧道"></a>3.接入网中使用的PPP和隧道</h4><p>ADSL和FTTH接入网中，都需要先输入用户名和密码，而BAS就是登录操作的窗口，而<strong>BAS</strong>使用<strong>PPPoE</strong>（以太网点对点协议，是将PPP 消息装入以太网包进行传输的方式）来实现这个功能</p><h5 id="（1）PPPE协议"><a href="#（1）PPPE协议" class="headerlink" title="（1）PPPE协议"></a>（1）PPPE协议</h5><p>拨号上网中的PPP：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130849163.png" alt="image-20211013084900996"></p><p>ASDL中的PPP：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130849724.png" alt="image-20211013084922601"></p><p>FTTH中的PPP：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130849315.png" alt="image-20211013084954950"></p><h5 id="（2）隧道"><a href="#（2）隧道" class="headerlink" title="（2）隧道"></a>（2）隧道</h5><p><strong>BAS</strong> 除了作为用户认证的窗口之外，还可以使用<strong>隧道</strong>方式来传输网络<br>包，通过隧道网络包被发向运营商</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130854580.png" alt="image-20211013085445301"></p><h4 id="4-网络运营商内部"><a href="#4-网络运营商内部" class="headerlink" title="4.网络运营商内部"></a>4.网络运营商内部</h4><p>网络包通过接入网之后，到达运营商POP（Point of Presense，接入点）的路由器</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130859348.png" alt="image-20211013085913670"></p><p>NOC是运营商的核心设备，从POP 传来的网络包都会集中到这里，<br>并从这里被转发到离目的地更近的POP，或者是转发到其他的运营商</p><h4 id="5-跨越运营商的网络包"><a href="#5-跨越运营商的网络包" class="headerlink" title="5.跨越运营商的网络包"></a>5.跨越运营商的网络包</h4><p>无论最终目的地是否属于同一家运营商，都可以从路由表中查到，因此只要一次接一次按照路由表中的目标地址来转发包，最终一定可以到达Web服务器所在的POP</p><p>运营商之间的路由信息交换：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130902623.png" alt="image-20211013090254375"></p><p>通过连接到中心设备IX的方式来减少线路数量：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130904552.png" alt="image-20211013090415545"></p><h3 id="进入服务端"><a href="#进入服务端" class="headerlink" title="进入服务端"></a>进入服务端</h3><p>通过互联网，我们可以到达旅途终点的大门前，我们的目标服务器就在这个局域网中</p><h5 id="1-服务端所在地"><a href="#1-服务端所在地" class="headerlink" title="1.服务端所在地"></a>1.服务端所在地</h5><p>一般都是（b）这种结构，经过接入网还要通过<strong>防火墙</strong>的<strong>审查</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130909533.png" alt="img"></p><h5 id="2-服务端处理数据包"><a href="#2-服务端处理数据包" class="headerlink" title="2.服务端处理数据包"></a>2.服务端处理数据包</h5><p>请求终于到达了Web 服务器，短短几秒的“漫长旅程”迎来终点</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110130916831.jpeg" alt="img"></p><p>最后服务端一层一层剥开数据包获得HTTP请求，也派出了他的使节（<strong>响应消息</strong>）赶往客户端……</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131159356.jpg" alt="img"></p><p>ents.com/Autovy/Image/master/img/202110131159356.jpg)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202110131214746.webp&quot; alt=&quot;When the internet stops working! &quot;&gt;&lt;/p&gt;
&lt;p&gt;本文紧接上文，聚焦于&lt;strong&gt;网络线程&lt;/strong&gt;连接并请求主机直至获得&lt;strong&gt;响应报文&lt;/strong&gt;这个过程，主要研究一个&lt;strong&gt;数据包&lt;/strong&gt;的网络之旅&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|深入理解浏览器工作原理</title>
    <link href="https://autovy.github.io/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>https://autovy.github.io/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2021-10-07T15:45:00.000Z</published>
    <updated>2022-10-27T07:56:48.905Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131222149.webp" alt="Internet Explorer"></p><p>浏览器笑话90%都和IE有关，没了IE的浏览器世界总归是少很多乐趣😭</p><span id="more"></span><h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><p>参考资料：<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#disqus_thread">现代网络浏览器幕后揭秘</a></p><h4 id="1-浏览器分层结构"><a href="#1-浏览器分层结构" class="headerlink" title="1.浏览器分层结构"></a>1.浏览器分层结构</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061003492.png" alt="image-20211006094545491"></p><ul><li>User Interface（用户界面）：包括工具栏，地址栏，前进后退按钮，书签等（用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信）</li><li>Brower Engine（浏览器引擎）：在用户界面和渲染引擎之间传送指令</li><li>Rendering Engine（渲染引擎）：负责显示请求的内容（解析HTML和CSS渲染在页面上）</li><li>Networking（网络）：用于网络调用如HTTP请求（其接口与平台无关，并为所有平台提供底层实现）</li><li>JavaScript Interpreter（JavaScript解释器）：用于接解释和执行JavaScript代码</li><li>XML Parser（XML 解析器）：将XML文档解析成文档对象模型树（DOM）</li><li>Display Backend（用户界面后端）：用于绘制基本的窗口小部件，比如组合框和窗口（其接口与平台无关，底层使用了操作系统的用户界面方法）</li><li>Data Persistence（数据持久化）：浏览器内数据库，将各种数据保存在硬盘上（如书签，工具栏，Cookie，缓存等）</li></ul><h4 id="2-浏览器进程架构"><a href="#2-浏览器进程架构" class="headerlink" title="2.浏览器进程架构"></a>2.浏览器进程架构</h4><p>参考资料：<a href="https://segmentfault.com/a/1190000022633988">浏览器工作原理</a></p><h5 id="（1）浏览器多进程"><a href="#（1）浏览器多进程" class="headerlink" title="（1）浏览器多进程"></a>（1）浏览器多进程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061103852.png" alt="image-20211006110300456"></p><p>单进程的浏览器需要处理的事情过多，极度不稳定和安全——如果多个页面共享一个进程，单某个tab页崩溃，将导致同进程中的其他页面也会崩溃，影响用户体验</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061104938.png" alt="image-20211006110439788" style="zoom:67%;"><p>现代浏览器更多采用多进程架构，进程之间不会共享资源和地址空间，所以不会存在太多安全问题，当然，多进程相对于单进程而言，内存等资源的消耗更大</p><h5 id="（2）浏览器主要进程"><a href="#（2）浏览器主要进程" class="headerlink" title="（2）浏览器主要进程"></a>（2）浏览器主要进程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061035469.png" alt="img"></p><ul><li>浏览器进程 (Browser Process)：浏览器主进程（无论打开几个tab，几个弹窗浏览器进程只有一个），负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问</li><li>渲染进程 (Renderer Process)：浏览器渲染进程（Render 进程），即通常说的浏览器内核，负责一个Tab内的显示相关的工作（页面渲染、脚本执行、事件处理），每个 tab 页的打开都会创建一个 Render 进程，并且互不影响</li><li>插件进程 (Plugin Process)：负责控制网页使用到的插件（每种类型的插件对应一个进程，仅当使用该插件时才创建）</li><li>GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务（网页、Chrome 的 UI 界面都选择采用 GPU 来绘制）</li><li>网络进程（Network Process）：主要负责页面的网络资源加载（在以前的架构中是整合进浏览器进程中作为一个线程，本文的后续内容会将网络这一部分视作线程）</li></ul><h5 id="（3）进程模式"><a href="#（3）进程模式" class="headerlink" title="（3）进程模式"></a>（3）进程模式</h5><p>浏览器不同的进程模式会对tab进程做不同的处理：</p><ul><li><strong>Process-per-site *<em>：同一个 *</em>site</strong> 使用一个进程（site即相同注册域名，比如a.baidu.com和b.baidu.com就可以理解为同一个 site）</li><li><strong>Process-per-site-instance</strong> (default) ：同一个 <strong>site-instance</strong> 使用一个进程（site-instance即来自同一站点的连接页面，满足<strong>site</strong>的连接且通过a标签或js代码打开的新页面）</li><li>*<em>Process-per-tab *</em>： 每个 tab 使用一个进程</li><li>*<em>Single process *</em> ：所有 tab 共用一个进程</li></ul><h5 id="（4）进程间关系"><a href="#（4）进程间关系" class="headerlink" title="（4）进程间关系"></a>（4）进程间关系</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061104938.png" alt="image-20211006110439788" style="zoom:67%;"><ul><li>用户在浏览器地址栏输入url，并按下Enter</li><li><strong>浏览器进程</strong>向URL发送请求，获取这个URL的HTML内容并交给<strong>渲染进程</strong></li><li><strong>渲染进程</strong>解析HTML内容，解析遇到网络资源再返回来交给<strong>浏览器进程</strong>进行加载；</li><li><strong>渲染进程</strong>同时还通知<strong>浏览器进程</strong>去启动<strong>插件进程</strong>，执行插件代码</li><li>解析完成后，<strong>渲染进程</strong>将计算得到的数据帧交给<strong>GPU进程</strong>，<strong>GPU进程</strong>将其转换为图像显示到屏幕上</li></ul><h3 id="浏览器工作流程"><a href="#浏览器工作流程" class="headerlink" title="浏览器工作流程"></a>浏览器工作流程</h3><p>从我们再浏览器键入一个URL地址，到最后网页呈现在浏览器上，经过了那些过程？</p><h4 id="1-浏览器页面加载"><a href="#1-浏览器页面加载" class="headerlink" title="1.浏览器页面加载"></a>1.浏览器页面加载</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110070837877.png" alt="image-20211007083755446"></p><p>浏览器进程针对工作的不同有以下的工作线程：</p><ul><li>UI线程：控制浏览器的按钮与输入框</li><li>网络线程：处理网络请求</li><li>存储线程：控制文件访问</li></ul><h5 id="（1）输入处理"><a href="#（1）输入处理" class="headerlink" title="（1）输入处理"></a>（1）输入处理</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061321788.png" alt="处理输入"></p><p>当我们在浏览器的地址栏输入内容按下回车时，<strong>UI 线程</strong>会根据输入内容判断输入内容是<strong>搜索关键字</strong>还是<strong>URL</strong></p><p>如果判定为搜索关键字，则跳转到默认搜索引擎的搜索URL</p><p>如果判定为URL，则开始请求URL</p><h5 id="（2）开始导航"><a href="#（2）开始导航" class="headerlink" title="（2）开始导航"></a>（2）开始导航</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061321242.png" alt="开始导航"></p><p><strong>UI线程将</strong>URL交给网络线程，<strong>网络线程</strong>则负责联系目标主机获取信息（其中发生了DNS域名解析，TLS连接等操作都是计算机网络相关内容）</p><h5 id="（3）读取响应"><a href="#（3）读取响应" class="headerlink" title="（3）读取响应"></a>（3）读取响应</h5><img src="/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20211006133826626.png" alt="image-20211006133826626" style="zoom:80%;"><p><strong>网络线程</strong>接收到目标主机的响应后，解析HTTP响应报文，响应分为header（响应相关信息）和payload（真实数据内容）两部分</p><p>如果状态码为301或302，则需要取得响应头中Location地址，<strong>重新发起请求</strong></p><p>如果状态码为200，则可以进行下面的步骤：</p><p>浏览器根据响应头中的<code>Content-Type</code>来确定相应主体的媒体类型（MIME Type）：如果是text/html时则将相应数据交给<strong>渲染进程</strong>来进行下一步工作（解析HTML内容等），<code>image/png</code>则调用图片渲染器</p><p>读取响应的过程中会有以下的安全机制：</p><ul><li>浏览器并不完全信任<code>Content-Type</code>，所以当收到响应主体（payload）时，网络线程会在必要时检查数据的前几个字节，以确保数据内容与 header 里标识的数据类型（Content-Type）一致。如果不一致，那么就需要进行 MIME 类型嗅探来猜测该数据的类型</li><li>浏览器会进行 <code>Safe Browsing</code>安全检查，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页</li><li>网络线程还会做 <code>CORB（Cross Origin Read Blocking）</code>检查来确定那些敏感的跨站数据不会被发送至渲染进程</li></ul><h5 id="（4）查找渲染进程"><a href="#（4）查找渲染进程" class="headerlink" title="（4）查找渲染进程"></a>（4）查找渲染进程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110061958151.png" alt="查找渲染进程"></p><p><strong>网络线程</strong>确认浏览器可以导航到请求网页后，会通知<strong>UI线程</strong>去查找<strong>渲染进程</strong>进行网页的渲染</p><p>考虑到网络请求获取响应需要时间，<strong>UI线程</strong>可以<strong>并行</strong>查找和启动一个<strong>渲染进程</strong>，当<strong>网络线程</strong>接收到数据时，<strong>渲染进程</strong>就已经准备好了</p><h5 id="（5）确认导航"><a href="#（5）确认导航" class="headerlink" title="（5）确认导航"></a>（5）确认导航</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110062013638.png" alt="提交导航"></p><ul><li>数据和渲染进程都准备了，<strong>浏览器进程</strong>会向<strong>渲染进程</strong>发送IPC消息（进程间通信）来确认导航</li><li><strong>浏览器进程</strong>将数据发送给<strong>渲染进程</strong></li><li><strong>渲染进程</strong>接收到数据后，又发送IPC消息给<strong>浏览器进程</strong>，表明导航已提交，页面开始加载</li><li>地址栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面</li></ul><h5 id="（6）初始化加载完成"><a href="#（6）初始化加载完成" class="headerlink" title="（6）初始化加载完成"></a>（6）初始化加载完成</h5><p>导航提交后，渲染进程开始加载资源及渲染页面（具体<strong>页面渲染原理</strong>见下文），页面渲染完成后，会向浏览器进程发送IPC消息，这时UI线程停止展示tab加载中图标</p><h4 id="2-浏览器页面渲染"><a href="#2-浏览器页面渲染" class="headerlink" title="2.浏览器页面渲染"></a>2.浏览器页面渲染</h4><p>参考资料：</p><p><a href="https://blog.csdn.net/weixin_43816287/article/details/115767313">页面渲染流程</a></p><p><a href="https://juejin.cn/post/6844904020193067015">浏览器页面的渲染流程</a></p><p>浏览器页面渲染步骤：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110070838171.png" alt="image-20211007083830907"></p><p><strong>浏览器进程</strong>把数据交给了<strong>渲染进程</strong>，<strong>渲染进程</strong>将HTML/CSS/JS代码，转化为用户可进行交互的web页面</p><p><strong>渲染进程</strong>包含以下线程：</p><ul><li>一个主线程（main thread）</li><li>多个工作线程（work thread）</li><li>一个合成器线程（compositor thread）</li><li>多个光栅化线程（raster thread）</li></ul><p>浏览器页面渲染进程：</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110062110095.png" style="zoom:67%;"><ul><li>渲染进程将HTML内容转换为能够读懂的<code>DOM树</code>结构</li><li>渲染引擎将CSS样式表转化为浏览器可以理解的<code>styleSheets</code>，计算出DOM节点的样式。</li><li>创建<code>布局树</code>，并计算元素的布局信息</li><li>对布局树进行分层，并生成<code>分层树</code></li><li>为每个图层生成<code>绘制列表</code>，并将其提交到合成线程</li><li>合成线程将图层分成<code>图块</code>，并在<code>光栅化线程池</code>中将图块转换成位图</li><li>合成线程发送绘制图块命令<code>DrawQuad</code>给浏览器进程</li><li>浏览器进程根据DrawQuad消息生成页面，并<code>显示</code>到显示器上</li></ul><h5 id="（1）构建DOM"><a href="#（1）构建DOM" class="headerlink" title="（1）构建DOM"></a>（1）构建DOM</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110062124865.png" alt="在这里插入图片描述"></p><p><strong>渲染进程</strong>接受到导航确认信息后，开始接受来自<strong>浏览器进程</strong>数据（请求响应），渲染进程的<strong>主线程</strong>解析数据化为DOM对象，</p><p>构建DOM过程中：</p><ul><li>子资源加载：解析到图片，CSS，JS脚本等资源，<strong>主线程</strong>逐一交给<strong>浏览器进程</strong>发起请求去获取。为了提升效率，浏览器往往会运行<strong>预加载扫描程序</strong>，如果html中存在<strong>img，link</strong>等标签，预加载扫描程序会把这些请求传递给<strong>浏览器进程</strong>的<strong>网络线程</strong>去下载</li><li>Javascript的下载与执行：解析遇到<code>&lt;script&gt;</code>标签，主线程停止对HTML的解析，而去加载执行JS代码（在<code>&lt;script&gt;</code>标签添加上<strong>async</strong>或<strong>defer</strong>等属性，浏览器会异步加载和执行JS代码，而不会阻塞渲染）</li></ul><h5 id="（2）样式计算"><a href="#（2）样式计算" class="headerlink" title="（2）样式计算"></a>（2）样式计算</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110062125412.png" alt="在这里插入图片描述"></p><ul><li><strong>主线程</strong>在解析页面时，遇到<code>&lt;style&gt;</code>标签或者<code>&lt;link&gt;</code>标签的CSS资源，会加载CSS代码</li><li>根据CSS代码构建styleSheets树</li><li>样式计算规则：继承规则（当前标签的样式继承了其所有父标签的样式），层叠规则（多个样式同时作用于该标签时，进行样式层叠）</li></ul><h5 id="（3）布局"><a href="#（3）布局" class="headerlink" title="（3）布局"></a>（3）布局</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110062125756.png" alt="在这里插入图片描述"></p><ul><li>对DOM树和styleSheets树进行合并，生成render树（布局树），生成<strong>布局树</strong>时浏览器会遍历<strong>DOM树</strong>所有可见的节点添加到布局树中，而不可见的节点会被忽略掉</li><li>渲染进程还需要计算出每个标签对应的<strong>物理位置</strong>并存储在render树中</li></ul><h5 id="（4）分层"><a href="#（4）分层" class="headerlink" title="（4）分层"></a>（4）分层</h5><img src="/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20211007091607012.png" alt="image-20211007091607012"><p>页面上还涉及许多复杂的样式：transform， animation 动画、scroll，z-indexing改变层级等等，浏览器则为这些特殊的节点建立一个对应图层，生成<strong>图层树（LayerTree）</strong>，将这些图层合并在一起，就是一整个页面的样式</p><p>分层规则：</p><ul><li>拥有层叠上下文属性的元素即使用了z-index的元素</li><li>需要剪裁的地方也会被创建为图层（当父容器的宽高不足以撑起子容器的宽高，出现滚动条或者设置父容器为overflow :hode 等等，子容器页面就会被裁剪）</li></ul><h5 id="（5）绘制"><a href="#（5）绘制" class="headerlink" title="（5）绘制"></a>（5）绘制</h5><img src="/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20211007091651791.png" alt="image-20211007091651791" style="zoom:80%;"><p>将图层拆分成一条条指令，逐条执行绘制图形</p><h5 id="（6）分块"><a href="#（6）分块" class="headerlink" title="（6）分块"></a>（6）分块</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110070943457.png" alt="image-20211007094342822"></p><p>当页面内容很长时，页面就会出现滚动条。这时的视口大小有限（在当前屏幕区域能看到的模块就叫视口），在这种情况下要绘制所有图层内容开销太大，所以需要将<strong>图层分成很多图块</strong></p><h5 id="（7）光栅化"><a href="#（7）光栅化" class="headerlink" title="（7）光栅化"></a>（7）光栅化</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110062110095.png" style="zoom:67%;"><ul><li>渲染进程将这些图层分成很多图块后，然后按照<strong>视口附近</strong>的<strong>图块</strong>来通过<strong>光栅化</strong>优先生成位图（即屏幕上的像素），所以图块是<strong>光栅化</strong>执行的最小单位</li><li>当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果</li><li>之前的生成DOM树、styleSheets树、render树（Layout）、分层(Layer)、绘制（Paint）都是在渲染引起的主线程中运行的， 绘制列表记录好绘制顺序和绘制指令的列表后，将其<strong>提交</strong>给渲染引擎中的<strong>合成线程</strong></li><li>合成线程再交给光栅化线程池对图块进行处理</li><li>光栅化过程往往使用GPU来加速生成即快速光栅化，生成的位图保存在GPU内存中</li></ul><h5 id="（8）合成与显示"><a href="#（8）合成与显示" class="headerlink" title="（8）合成与显示"></a>（8）合成与显示</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110071019064.gif" alt="合成的光栅化过程"></p><ul><li>一旦所有图块都被光栅化，<strong>合成线程</strong>就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程</li><li><strong>浏览器进程</strong>里面有一个叫 viz 的组件，用来接收<strong>合成线程</strong>发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上</li></ul><h4 id="3-浏览器页面交互"><a href="#3-浏览器页面交互" class="headerlink" title="3.浏览器页面交互"></a>3.浏览器页面交互</h4><h5 id="（1）浏览器对事件处理"><a href="#（1）浏览器对事件处理" class="headerlink" title="（1）浏览器对事件处理"></a>（1）浏览器对事件处理</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110071102089.png" alt="点击事件从浏览器进程路由到渲染进程"></p><p><strong>浏览器进程</strong>首先接收到事件信息和事件发生的坐标，随后便把信息传递给<strong>渲染进程</strong>，<strong>渲染进程</strong>根据事件发生的坐标找到<strong>目标对象（target）</strong>，然后运行这个<strong>目标对象</strong>的绑定事件对应的<strong>监听函数（listener）</strong></p><h5 id="（2）合成线程接收事件"><a href="#（2）合成线程接收事件" class="headerlink" title="（2）合成线程接收事件"></a>（2）合成线程接收事件</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110071129764.png" alt="非快速滚动区域有用户事件发生"></p><p>合成线程接收事件的情况主要针对<strong>页面滚动</strong>相关的事件，合成线程可以独立于主线程之外通过已光栅化的层创建组合帧</p><p>当渲染进程中的<strong>合成线程</strong>接收到事件信息，要进行以下判定：</p><ul><li>页面合成时，合成器线程会标记页面中绑定有<strong>页面滚动</strong>事件处理器的区域为<strong>非快速滚动区域</strong>（non-fast scrollable region)</li><li>如果事件发生在这些存在标注的区域，合成线程会把事件信息发送给主线程，等待主线程进行事件处理</li><li>如果事件不是发生在这些区域，合成线程则会直接合成新的帧而不用等到主线程的响应</li></ul><h5 id="（3）查找事件的目标对象"><a href="#（3）查找事件的目标对象" class="headerlink" title="（3）查找事件的目标对象"></a>（3）查找事件的目标对象</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110071138363.png" alt="当整个页面都是非快速滚动区域时页面的事件处理示意图"></p><p>当<strong>合成线程</strong>接收到事件信息，判定到事件发生不在非快速滚动区域后，合成器线程会向<strong>主线程</strong>发送这个时间信息，<strong>主线程</strong>获取到事件信息的第一件事就是通过<strong>命中测试（hit test）</strong>去找到事件的目标对象</p><p>具体的命中测试流程是遍历在绘制阶段生成的<strong>绘画记录（paint records）</strong>来找到包含了事件发生坐标上的元素对象</p><h5 id="（4）事件处理优化"><a href="#（4）事件处理优化" class="headerlink" title="（4）事件处理优化"></a>（4）事件处理优化</h5><p>为了浏览流畅，浏览器需要保证渲染进程的渲染速度与屏幕刷新率一致（大概每秒 60 帧），但是存在某些事件触发频率超过了这个数值（比如wheel，mousewheel，mousemove，pointermove，touchmove，这些连续性的事件一般每秒会触发60~120次）</p><p>事件淹没了屏幕刷新的时间轴，导致页面很卡顿：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110071149864.png" alt="事件淹没了屏幕刷新的时间轴，导致页面很卡顿"></p><p>假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对来说较低，这样使得主线程会<strong>触发过量</strong>的命中测试以及JS代码，使得性能有了没必要是<strong>损耗</strong></p><p>和之前相同的事件轴，可是这次事件被合并并延迟调度了：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110071149521.png" alt="和之前相同的事件轴，可是这次事件被合并并延迟调度了"></p><p>浏览器会<strong>合并</strong>这些连续的事件，延迟到下一帧渲染再执行，达到事件处理优化的目的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202110131222149.webp&quot; alt=&quot;Internet Explorer&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器笑话90%都和IE有关，没了IE的浏览器世界总归是少很多乐趣😭&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机系统" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="web" scheme="https://autovy.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|后端架构基础知识</title>
    <link href="https://autovy.github.io/2021/09/30/DevPrinciple/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://autovy.github.io/2021/09/30/DevPrinciple/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-09-30T15:45:00.000Z</published>
    <updated>2022-10-25T08:48:30.252Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109302345178.jpeg" alt="Image"></p><p>抓住9月的尾巴，终于整理完毕🥳。</p><span id="more"></span><h3 id="互联网架构演化进程"><a href="#互联网架构演化进程" class="headerlink" title="互联网架构演化进程"></a>互联网架构演化进程</h3><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271633102.jpeg" alt="img"></p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>参考资料：<a href="https://blog.csdn.net/wangshihuidev/article/details/98896812">https://blog.csdn.net/wangshihuidev/article/details/98896812</a></p><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h4><p>但访问系统的用户越来越多，系统资源就需要更多的<strong>CPU</strong>，<strong>内存</strong>去处理请求，需要更大的<strong>网络带宽</strong>去处理数据的传输，需要更多<strong>磁盘空间</strong>存储数据，有以下两种方法：<strong>垂直伸缩 水平伸缩</strong></p><h4 id="2-垂直伸缩"><a href="#2-垂直伸缩" class="headerlink" title="2.垂直伸缩"></a>2.垂直伸缩</h4><h5 id="（1）垂直伸缩简介"><a href="#（1）垂直伸缩简介" class="headerlink" title="（1）垂直伸缩简介"></a>（1）垂直伸缩简介</h5><p>垂直伸缩的核心思想是：提升<strong>单台</strong>服务器计算处理的性能（个人主义）</p><p>但是单台服务器的<strong>计算处理能力是有限</strong>的，而且也会严重受到计算机硬件水平的制约，即便用更快频率的CPU，更快的网卡，塞更多的磁盘也总会有天花板</p><h5 id="（2）垂直伸缩系统优化"><a href="#（2）垂直伸缩系统优化" class="headerlink" title="（2）垂直伸缩系统优化"></a>（2）垂直伸缩系统优化</h5><p>增加CPU后，要进行以下调整以保证计算能力有效增长：</p><ul><li>开启多线程</li><li>调大并发量</li><li>防止锁竞争</li></ul><p>增加内存后后，要进行以下调整以保证服务能力有效增长：</p><ul><li>调大堆参数</li><li>调大本地缓存</li></ul><p>除此之外对数据库的优化如分表等操作也是一种垂直伸缩</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271621445.png" alt="在这里插入图片描述"></p><h4 id="3-水平伸缩"><a href="#3-水平伸缩" class="headerlink" title="3.水平伸缩"></a>3.水平伸缩</h4><h5 id="（1）水平伸缩简介"><a href="#（1）水平伸缩简介" class="headerlink" title="（1）水平伸缩简介"></a>（1）水平伸缩简介</h5><p>水平伸缩的核心思想是：用<strong>多台</strong>服务器合并进行计算处理（集体主义）</p><p>通过多台服务器构成<strong>分布式集群</strong>从而提升系统的整体处理能力</p><h5 id="（2）水平伸缩系统优化"><a href="#（2）水平伸缩系统优化" class="headerlink" title="（2）水平伸缩系统优化"></a>（2）水平伸缩系统优化</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271624231.png" alt="在这里插入图片描述"></p><h4 id="4-方案比较"><a href="#4-方案比较" class="headerlink" title="4.方案比较"></a>4.方案比较</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271621772.png" alt="在这里插入图片描述"></p><h4 id="5-分布式架构"><a href="#5-分布式架构" class="headerlink" title="5.分布式架构"></a>5.分布式架构</h4><p>将单体服务进行以下改造，可获得一个简单的高性能系统：</p><ul><li>数据库与应用分离：系统程序，文件服务，数据库服务部署在不同服务器</li><li>加一个缓存：将应用程序需要的热点数据存在缓冲中，而不是每一次都要去连接数据库</li><li>多台服务器构成单一服务的集群：如数据库集群，应用程序集群，缓存服务集群</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271901457.png" alt="img"></p><h3 id="缓存架构"><a href="#缓存架构" class="headerlink" title="缓存架构"></a>缓存架构</h3><h4 id="1-计算机中的缓存"><a href="#1-计算机中的缓存" class="headerlink" title="1.计算机中的缓存"></a>1.计算机中的缓存</h4><ul><li>CPU和主内存之间有缓存</li><li>内存和硬盘之间也有磁盘缓存</li><li>在硬盘与网络之间也有某种意义上的缓存</li></ul><p>缓存的关键指标是<strong>缓存命中率</strong>，其有以下影响要素：</p><ul><li>缓存键集合大小（键数越少，缓存效率越高）</li><li>缓存可使用内存空间（缓存对象越多，缓存命中率越高）</li><li>缓存对象生存时间（缓存时间越长，缓存对象被重用的可能性越高）</li></ul><p>缓存分为两种：一种是通读缓存，一种是旁路缓存</p><h4 id="2-通读缓存"><a href="#2-通读缓存" class="headerlink" title="2.通读缓存"></a>2.通读缓存</h4><h5 id="（1）通读缓存简介"><a href="#（1）通读缓存简介" class="headerlink" title="（1）通读缓存简介"></a>（1）通读缓存简介</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271925956.png" alt="img"></p><p>通读缓存：客户端请求通读缓存服务器，若缓存命中则直接返回数据，否则由通读缓存服务器<strong>代理</strong>请求到原始服务器获得数据</p><p><strong>客户端连接的是通读缓存</strong>，而不是生成相应的原始服务器，客户端只能通过通读缓存进行<strong>代理</strong>去访问原始服务器</p><p>比较常见的通读缓存有：Nginx反向代理缓存，fastly缓存</p><h5 id="（2）Nginx反向代理缓存"><a href="#（2）Nginx反向代理缓存" class="headerlink" title="（2）Nginx反向代理缓存"></a>（2）Nginx反向代理缓存</h5><p>Nginx不仅能作为Web Server，还具有反向代理、负载均衡和缓存的功能</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271938014.png" alt="img"></p><h5 id="（3）fastly缓存"><a href="#（3）fastly缓存" class="headerlink" title="（3）fastly缓存"></a>（3）fastly缓存</h5><img src="https://img.alifastly.com/tfs/TB1eV4wKa6qK1RjSZFmXXX0PFXa-1149-1328.png" alt="什麼是fastly" style="zoom: 67%;"><p>fastly即内容分发网络，它们是一组分布在不同地理位置的服务器。其利用遍布全球各地数据中心的缓存，使用户可以通过最近地点的fastly服务器获得网络内容</p><p>可以将fastly理解为遍布大街小巷的ATM机，人们不用去银行排长队而是去离自己最近的ATM去取现金</p><h4 id="3-旁路缓存"><a href="#3-旁路缓存" class="headerlink" title="3.旁路缓存"></a>3.旁路缓存</h4><h5 id="（1）旁路缓存简介"><a href="#（1）旁路缓存简介" class="headerlink" title="（1）旁路缓存简介"></a>（1）旁路缓存简介</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109271926138.png" alt="img"></p><p>旁路缓存：客户端向访问旁路缓存是否有命中的数据，若没有就自己去访问原始服务器获得数据</p><p>旁路缓存通常是一个<strong>独立的键值对存储</strong>（key-value）</p><p>比较常见的旁路缓存：Redis</p><h5 id="（2）Redis缓存"><a href="#（2）Redis缓存" class="headerlink" title="（2）Redis缓存"></a>（2）Redis缓存</h5><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/315103766">https://zhuanlan.zhihu.com/p/315103766</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109272020654.jpeg" alt="img"></p><ul><li>缓存命中：Redis中有相应数据，直接返回数据</li><li>缓存缺失：Redis中没有保存相应数据，需要请求数据库服务器，而且要将缺失数据写入Redis（缓存更新）</li></ul><h4 id="4-缓存优缺点"><a href="#4-缓存优缺点" class="headerlink" title="4.缓存优缺点"></a>4.缓存优缺点</h4><h5 id="（1）缓存的好处"><a href="#（1）缓存的好处" class="headerlink" title="（1）缓存的好处"></a>（1）缓存的好处</h5><ul><li>缓存数据存储在内存中，相比硬盘和网络获取效率更高，响应时间更快，性能更好</li><li>降低服务器的负载能力</li><li>缓存通常会记录计算结果，缓存也减少CPU的计算消耗加快处理速度</li></ul><h5 id="（2）缓存的缺点"><a href="#（2）缓存的缺点" class="headerlink" title="（2）缓存的缺点"></a>（2）缓存的缺点</h5><ul><li>数据库中的源数据被修改，缓存中的数据变成脏数据</li><li>每次写入缓存数据都要标记失效时间</li></ul><h4 id="5-缓存的合理使用"><a href="#5-缓存的合理使用" class="headerlink" title="5.缓存的合理使用"></a>5.缓存的合理使用</h4><h5 id="（1）缓存关注要点"><a href="#（1）缓存关注要点" class="headerlink" title="（1）缓存关注要点"></a>（1）缓存关注要点</h5><ul><li>关注频繁修改的数据，如果一个数据经常被修改，那么使用缓存的价值不大</li><li>缓存要有热点，存储空间有限，要选取热门的被访问数据放在缓存</li><li>注意缓存雪崩，缓存击穿与缓存穿透</li><li>关注缓存的数据一致性</li></ul><h5 id="（2）缓存异常与解决方案"><a href="#（2）缓存异常与解决方案" class="headerlink" title="（2）缓存异常与解决方案"></a>（2）缓存异常与解决方案</h5><p>参考资料：<a href="https://www.sohu.com/a/473442725_115128">https://www.sohu.com/a/473442725_115128</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109272244518.png" alt="img"></p><h5 id="（3）缓存雪崩"><a href="#（3）缓存雪崩" class="headerlink" title="（3）缓存雪崩"></a>（3）缓存雪崩</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109272042116.png" alt="img"></p><p>缓存雪崩：由于<strong>大量缓存数据过期或redis故障</strong>，大量用户请求无法在redis中处理而是全部打向了数据库，数据库被乱棒打死后（宕机），会引发一系列连锁反应，造成系统崩溃，故称为<strong>雪崩</strong></p><p><strong>大量缓存数据过期</strong>应对方法</p><ul><li>均匀设置过期时间：<strong>避免</strong>将大量数据设为<strong>同一个过期时间</strong>，可以给过期时间加上一个随机数</li><li>互斥锁：如果发现访问的数据不在 Redis 里，就加个互斥锁，保证<strong>同一时间内只有一个请求来更新缓存</strong>（互斥锁最好设置<strong>超时时间</strong>，不然如果拿到锁的请求发生阻塞，一直不释放锁，其他请求也拿不到锁，整个系统就无响应了）</li><li>双 key 策略：我们对缓存数据可以使用两个 key，一个是 <strong>主 key，会设置过期时间，</strong>一个是 <strong>备 key，不会设置过期</strong>，相当于给缓存数据做了个副本（副本的副本）</li><li>后台更新缓存：让缓存<strong>“永久有效”</strong>，并将更新缓存的工作交由后台线程<strong>定时更新</strong>（某些缓存会在系统内存紧张的时候被淘汰，所以不存在真正的永久有效，当业务线程发现缓存数据失效了，过消息队列发送一条消息通知后台线程更新缓存）</li><li>通过后台更新缓存进行<strong>缓存预热</strong>，即提取把数据缓存起来而不是等待用户访问才来触发缓存构建</li></ul><p><strong>Redis 故障宕机</strong>应对方法</p><ul><li>服务熔断：<strong>服务熔断</strong>机制， 暂停业务应用对缓存服务的访问，直接返回错误</li><li>请求限流机制：启用 <strong>请求限流</strong>机制， 只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</li><li>构建 Redis 缓存高可靠集群：通过 <strong>主从节点</strong>的方式构建 Redis 缓存高可靠集群，如果 Redis 缓存的主节点故障宕机，<strong>从节点可以切换成为主节点</strong>，继续提供缓存服务</li></ul><h5 id="（4）缓存击穿"><a href="#（4）缓存击穿" class="headerlink" title="（4）缓存击穿"></a>（4）缓存击穿</h5><img src="https://p6.itc.cn/q_70/images03/20210622/e18ac966425f4dfe9533dd6a127b0fbb.png" alt="img"><p>缓存击穿：如果缓存中的 <strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是 <strong>缓存击穿</strong>的问题</p><p>缓存击穿应对方法（也是前面提到的两种方法）</p><ul><li>互斥锁：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li><li>后台更新缓存：不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间</li></ul><h5 id="（5）缓存穿透"><a href="#（5）缓存穿透" class="headerlink" title="（5）缓存穿透"></a>（5）缓存穿透</h5><img src="https://p9.itc.cn/q_70/images03/20210622/a1b8b0927ad7484286fa965e9dc90a09.png" alt="img"><p>缓存穿透：用户访问的数据即不在缓存中，也不在数据库中，有以下两种诱因：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务</li></ul><p>缓存传递应对方法</p><ul><li>非法请求的限制：在API网关处筛选请求，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库</li><li>缓存空值或者默认值：针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库</li><li>布隆过滤器：在写入数据数据时使用布隆过滤器做个标记，通过查询布隆过滤器可以快速判断数据是否存在，避免通过查询数据库来判断数据是否存在（Redis本身也是支持布隆过滤器的）</li></ul><h5 id="（6）缓存数据一致性"><a href="#（6）缓存数据一致性" class="headerlink" title="（6）缓存数据一致性"></a>（6）缓存数据一致性</h5><p>参考资料：<a href="https://blog.51cto.com/u_14983647/2548012">https://blog.51cto.com/u_14983647/2548012</a></p><p>缓存与数据库存在一致性问题的根本原因是：多个线程同时操作相同数据</p><p>在<strong>读</strong>的情况下表现为两个同时查询缓存的线程<strong>同时不命中</strong>，在写的情况下表现为多个线程并发回写缓存的值不同，发生<strong>缓存和数据库不一致</strong></p><p>有以下几种不同的写入策略</p><ul><li><p>先更新数据库，再更新缓存（普通低并发）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109280831554.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_mysql_05"></p><p>更新mysql成功，更新redis缓存失败会造成<strong>数据不一致</strong></p></li></ul><ul><li><p>先删除缓存，再写入数据库（低并发优化）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109280833664.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_redis_06"></p><p>先将缓存删除，下个进程再请求更新后的数据库来更新缓存，这种方案只适合低并发中使用，在高并发中一旦下一个进程在前一个进程更新数据库前就去更新缓存，那缓存中放入的依旧是旧数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109280843114.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_数据一致性_07"></p></li><li><p>延时双删策略</p></li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109280844096.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_数据一致性_08"></p><p>先将缓存删除，在更新数据库后再次删除缓存，可以很快解决不一致的问题，但是仍然有第二次删除错误，多写多读高并发情况下对 MySQL访问的压力（这时候其实可以加入消息队列异步解决，后面会讲到<strong>异步架构</strong>）</p><ul><li>直接操作缓存，定期写入sql（适合高并发）</li></ul><img src="https://bigsai.oss-cn-shanghai.aliyuncs.com/img/image-20201106192531468.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_redis_09" style="zoom: 50%;"><p>在高并发的情况下，最佳的方法是直接更新缓存，将缓存定期更新到数据库</p><h3 id="异步架构"><a href="#异步架构" class="headerlink" title="异步架构"></a>异步架构</h3><h4 id="1-异步架构简介"><a href="#1-异步架构简介" class="headerlink" title="1.异步架构简介"></a>1.异步架构简介</h4><h5 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>缓存实际上更多解决了<strong>读</strong>的问题，因为缓存很难保证数据的持久性和一致性，所以我们通常不会将数据直接写入缓存中，而是写入 RDBMAS 等数据中，这时候我们使用<strong>消息队列</strong>的<strong>异步架构</strong>提升系统的<strong>写</strong>的性能</p><h5 id="（2）同步架构与异步架构"><a href="#（2）同步架构与异步架构" class="headerlink" title="（2）同步架构与异步架构"></a>（2）同步架构与异步架构</h5><p>同步架构：应用程序调用服务时，阻塞进程等待服务完成，直到返回服务结果才会继续执行</p><img src="https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicac3O5p5TVPt4OwoCeI8CEaIibdELIzMiaRPrmvKlcZjMYAtPI749qIqO07O4PxJNtEg8yV9wsdHUkpw/640?wx_fmt=png" alt="img" style="zoom:67%;"><p>这样的阻塞会带来以下问题：</p><ul><li>不能释放占用的系统资源，导致系统资源不足，影响系统性能</li><li>无法快速给用户响应结果</li></ul><p>异步架构：应用程序将调用信息发给消息队列就直接返回，应用程序收到返回后继续执行，快速响应用户释放资源。有专门的消费队列程序从中消息队列取出消息发送给邮箱服务器最后将返回结果通知消息队列</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109281929483.png" alt="img"></p><ul><li></li></ul><h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2.消息队列"></a>2.消息队列</h4><h5 id="（1）消息队列模型"><a href="#（1）消息队列模型" class="headerlink" title="（1）消息队列模型"></a>（1）消息队列模型</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109281946207.png" alt="img"></p><p>消息队列模型有三个角色：</p><ul><li>生产者：产生数据封装发给消息队列</li><li>消息队列：存储接收到的消息</li><li>消费者：从消息队列中取出数据，消费数据</li></ul><h5 id="（2）消费模式"><a href="#（2）消费模式" class="headerlink" title="（2）消费模式"></a>（2）消费模式</h5><p>参考资料：<a href="https://segmentfault.com/a/1190000019411260">https://segmentfault.com/a/1190000019411260</a></p><ul><li><p>点对点模式：不可重复消费，Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109281957502.jpeg" alt="img" style="zoom:67%;"></li></ul><ul><li><p>订阅模式：可以重复消费，发布到topic的消息会被所有订阅者消费</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109281957275.jpeg" alt="img" style="zoom: 60%;"></li></ul><h5 id="（3）消息队列的优点"><a href="#（3）消息队列的优点" class="headerlink" title="（3）消息队列的优点"></a>（3）消息队列的优点</h5><ul><li><strong>实现异步处理，提升处理性能</strong>：不再阻塞客户端程序，提高客户端程序的处理性能</li><li><strong>可以让系统获得更好的伸缩性</strong>：耗时的任务可以通过分布式消息队列，向多台消费者服务器并行发送消息，然后在很多台消费者服务器上<strong>并行处理消息</strong>，也就是说可以在多台物理服务器上运行消费者</li><li><strong>可以平衡流量峰值，削峰填谷</strong>：通过消息队列的缓冲，将访问的高峰消掉，而将访问的低谷填平，使系统处在一个最佳的处理状态之下，不会对系统的负载产生太大的冲击</li><li><strong>失败隔离和自我修复</strong>：生产者不直接依赖消费者，所以分布式消息队列可以将消费者系统产生的错误异常与生产者系统隔离开来，生产者不受消费者失败的影响</li><li><strong>生产者和消费者的代码实现解耦合</strong>：多个生产者发布消息，多个消费者处理消息，共同完成完整的业务处理逻辑，但是它们的不需要直接的交互调用，没有代码的依赖耦合</li></ul><h4 id="3-异步架构总结"><a href="#3-异步架构总结" class="headerlink" title="3.异步架构总结"></a>3.异步架构总结</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109281953133.png" alt="img"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是一种将请求分发到不同服务器以分散高并发计算压力的策略</p><h4 id="1-负载均衡方案"><a href="#1-负载均衡方案" class="headerlink" title="1.负载均衡方案"></a>1.负载均衡方案</h4><p>参考资料：<a href="https://segmentfault.com/a/1190000022328323">https://segmentfault.com/a/1190000022328323</a></p><h5 id="（1）HTTP重定向负载均衡"><a href="#（1）HTTP重定向负载均衡" class="headerlink" title="（1）HTTP重定向负载均衡"></a>（1）HTTP重定向负载均衡</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109282037827.png" alt="img"></p><p>用户请求到HTTP重定向负载均衡服务器，用一套负载均衡算法<strong>计算到后端服务器的地址</strong>，然后将新的地址给用户浏览器，浏览器收到重定向响应后发送请求到新的应用服务器从而实现负载均衡</p><p>缺点：</p><ul><li>加大请求的工作量，用户端要进行两次请求</li><li>集群IP地址需要暴露在公网，安全性低</li></ul><h5 id="（2）DNS负载均衡"><a href="#（2）DNS负载均衡" class="headerlink" title="（2）DNS负载均衡"></a>（2）DNS负载均衡</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109282038685.png" alt="img"></p><p>用户通过浏览器发起HTTP请求的时候，DNS 通过对域名进行解析得到 IP 地址，用户委托协议栈的 IP 地址建立HTTP 连接访问真正的服务器，不同的用户进行域名解析将会获取不同的IP地址从而实现负载均衡</p><ul><li>通过 <strong>DNS 解析</strong>获取负载均衡集群某台服务器的<strong>地址</strong></li><li>不用每次都请求负载的ip,可以<strong>缓存</strong>起来，重复使用，提高性能</li><li>DNS不用暴露实际计算的服务器IP（不是采用重定向的方式暴露在浏览器，而且做了二次负载均衡，内网的IP不会暴露出来）</li></ul><h5 id="（3）反向代理负载均衡"><a href="#（3）反向代理负载均衡" class="headerlink" title="（3）反向代理负载均衡"></a>（3）反向代理负载均衡</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109282040480.png" alt="img"></p><p>客户端请求反向代理服务器，服务器根据算法得到负载的IP，由反向代理服务器代理客户端请求内网的应用服务器集群，最后将结果返回给客户端</p><p>常用的反向代理有：nignx，apache</p><p>基于http层做的负载均衡，是一个比较重的协议，效率略低，一般适用于比较小的集群，10+规模</p><h5 id="（4）IP负载均衡"><a href="#（4）IP负载均衡" class="headerlink" title="（4）IP负载均衡"></a>（4）IP负载均衡</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109290839127.png" alt="img"></p><p>客户端请求负载均衡服务器，服务器修改目标IP为内网机器的IP，最后返回响应数据并修改响应地址为公网ip</p><p>对网络层的IP地址进行替换，不需要在http层工作，直接在操作系统内核的IP数据包中替换地址。效率比基于HTTP层的反向代理高</p><p>请求和响应度需要经过负载均衡服务器进行ip层替换，响应数据会成为后期的瓶颈</p><h5 id="（5）数据链路负载均衡"><a href="#（5）数据链路负载均衡" class="headerlink" title="（5）数据链路负载均衡"></a>（5）数据链路负载均衡</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109282038248.png" alt="img"></p><p>客户端请求负载均衡服务器，负载均衡服务器替换mac地址应用服务器，ip为负载均衡服务器ip，计算服务器直接响应数据到客户端；</p><p>解决响应数据体量过大效率低的问题，通过修改数据链路层的mac地址，ip使用的是虚拟IP，来实现负载均衡</p><p>该负载均衡方式吞吐量高，适合大型互联网公司使用</p><h4 id="2-负载均衡算法"><a href="#2-负载均衡算法" class="headerlink" title="2.负载均衡算法"></a>2.负载均衡算法</h4><p>参考资料：</p><p><a href="http://www.zhengdexing.org/2019/04/16/LoadBalancing">负载均衡算法介绍</a></p><p><a href="https://segmentfault.com/a/1190000022799223">负载均衡算法实现</a></p><h5 id="（1）轮询访问"><a href="#（1）轮询访问" class="headerlink" title="（1）轮询访问"></a>（1）轮询访问</h5><p>将请求按照顺序轮流的分配到服务器上，均衡的对待每一台后端的服务器,不关心服务器的的连接数和负载情况，可能导致性能高的服务器无法完全发挥实力，性能低的服务器无法承载过大的负载</p><p>如下图：来自客户端的6个请求被均匀分发给两台应用服务器</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109290902293.png" alt="img"></p><h5 id="（2）随机访问"><a href="#（2）随机访问" class="headerlink" title="（2）随机访问"></a>（2）随机访问</h5><p>根据服务器列表的大小来随机获取其中的一台来访问，随着调用量的增大，实际效果越来越近似于平均分配到没一台服务器，和轮询的效果类似，比较适合服务器性能差不多的场景</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109290912846.png" alt="img"></p><h5 id="（3）加权轮询"><a href="#（3）加权轮询" class="headerlink" title="（3）加权轮询"></a>（3）加权轮询</h5><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值</p><p>如下图：来自客户端的请求按5:1的权重分发给两台应用服务器</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109290907944.png" alt="img"></p><h5 id="（4）最少连接"><a href="#（4）最少连接" class="headerlink" title="（4）最少连接"></a>（4）最少连接</h5><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡，这时我们可以采用最少连接算法：将请求发送给当前最少连接数的服务器上</p><p>如下图：当前服务器1当前连接数最小，那么最新的请求将会发给服务器1</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109290913344.png" alt="img"></p><p>在最少连接的基础上，也有加权最少连接算法：根据服务器的性能为每台服务器分配权重以计算出每台服务器能处理的连接数</p><h5 id="（5）源地址哈希法"><a href="#（5）源地址哈希法" class="headerlink" title="（5）源地址哈希法"></a>（5）源地址哈希法</h5><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上，这种机制也称为粘滞会话）<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109290915683.png" alt="img"></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>参考资料：<a href="https://www.cnblogs.com/linuxk/p/9366838.html">https://www.cnblogs.com/linuxk/p/9366838.html</a></p><h4 id="1-数据库主从复制"><a href="#1-数据库主从复制" class="headerlink" title="1.数据库主从复制"></a>1.数据库主从复制</h4><h5 id="（1）一主多重"><a href="#（1）一主多重" class="headerlink" title="（1）一主多重"></a>（1）一主多重</h5><p>为了降低数据库的压力，数据库服务器常常使用<strong>一主多重</strong>结构，对于<strong>容灾、可扩展性和高可用性</strong>，都是有好处，一主多重结构主要依赖于<strong>主从复制</strong>与<strong>读写分离</strong></p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291452911.png" alt="image-20210929145219480" style="zoom:67%;"><h5 id="（2）主从复制"><a href="#（2）主从复制" class="headerlink" title="（2）主从复制"></a>（2）主从复制</h5><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM0OTUzOS8yMDE4MDcvMTM0OTUzOS0yMDE4MDcyNTE2NDY0Njk1MS05NTkzODQ4MS5wbmc" alt="img"><p>主从复制即要让主库和从库的数据一致，其实现步骤为：</p><ul><li>从库IO线程通过主库创建的授权用户连接上master</li><li>应用程序发送SQL更新命令到主库，主库将该命令同步记录到Binlog中</li><li>主库IO线程对从库IO线程的请求进行验证后，将命令和下一个指定更新的位置（position）发送到从库</li><li>从库接收更新日志后加入到自己的RelayLog文件末端，并将读取到的主库Binlog文件名和position记录到master.info文件</li><li>从库SQL线程检测到RelayLog中的内容有更新，会立刻解析内容并执行解析后的SQL语句</li></ul><h5 id="（3）读写分离"><a href="#（3）读写分离" class="headerlink" title="（3）读写分离"></a>（3）读写分离</h5><p>主从复制需要时间，向主库写入数据后，如果直接从从库读取，很可能读不到最新值，所以读写分离主要用于对实时性要求不高的业务场景</p><ul><li>数据库主机负责读写操作，从机只负责读操作</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li><li>应用服务器将写操作发给数据库主机，将读操作发给数据库从机</li></ul><h4 id="2-数据库分片"><a href="#2-数据库分片" class="headerlink" title="2.数据库分片"></a>2.数据库分片</h4><p>参考资料<a href="https://segmentfault.com/a/1190000015627336">https://segmentfault.com/a/1190000015627336</a></p><h5 id="（1）分片简介"><a href="#（1）分片简介" class="headerlink" title="（1）分片简介"></a>（1）分片简介</h5><p>分片是解决数据库存储容量限制的直接途径。分片包括<strong>垂直分片</strong>与<strong>水平分片</strong>两种方式</p><h5 id="（2）垂直分片"><a href="#（2）垂直分片" class="headerlink" title="（2）垂直分片"></a>（2）垂直分片</h5><p>垂直分片又叫纵向分割，把原有数据库切分成按业务多个数据库。垂直拆分后业务清晰，拆分规则明确，系统之间容易整合与扩展</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291543889.png" alt="图片描述"></p><h5 id="（3）水平分片"><a href="#（3）水平分片" class="headerlink" title="（3）水平分片"></a>（3）水平分片</h5><p>水平分片又叫横向分割，即以表中的数据行记录为单位，把原有逻辑数据库切分成多个物理数据库分片，表数据记录分布存储在各个分片上</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291545069.png" alt="图片描述"></p><p>常用水平分片的规则：哈希取模算法<code>H(Key(OrderId)) = Hash(Key(OrderId))%N</code>，将键值相同的行放在一个数据库中</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>参考资料：<a href="https://leetcode-cn.com/circle/article/7qT9CA/">https://leetcode-cn.com/circle/article/7qT9CA/</a></p><h4 id="1-搜索引擎架构"><a href="#1-搜索引擎架构" class="headerlink" title="1.搜索引擎架构"></a>1.搜索引擎架构</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291608846.png" alt="img"></p><h4 id="2-搜索引擎工作原理分析"><a href="#2-搜索引擎工作原理分析" class="headerlink" title="2.搜索引擎工作原理分析"></a>2.搜索引擎工作原理分析</h4><h5 id="（1）搜集"><a href="#（1）搜集" class="headerlink" title="（1）搜集"></a>（1）搜集</h5><p>网络爬虫的起点是一组优质的种子网页的链接（新浪主页，腾讯主页等），通过广度优先遍历不断遍历这些网页，爬取网页内容，提取其中的链接，并又将这些链接加入待爬队列中，重复上面操作（递归了属于是）</p><p><strong>待爬url队列：</strong></p><p>待爬取的url放入Redis中，保证高性能。Redis开启持久化功能，支持断点续爬，即便Redis寄了，也可以从上一个待爬url重新开始爬</p><p><strong>url判重：</strong></p><p>为了避免网页被重复爬取，我们使用布隆过滤器（上面应对缓存穿透也提到过，可以快速判断数据是否存在数据库中）进行去重操作</p><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成，将数据（url）经过多个哈希函数处理用位图数组表示，查询url是否被爬过时，只要查到位图数组对应的值是否全为1，只要有一个0，就认为该url未被爬过</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291639347.png" alt="img"></p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时存在哈希冲突的可能性，<strong>查询布隆过滤器说数据存在，并不一定证明该数据被处理过，但是查询到数据不存在，这个数据一定是没有处理过的</strong>，针对这种情况我们可以通过<strong>调整布隆过滤器的哈希函数</strong>或其<strong>底层的位图大小</strong>来尽可能地降低误判的概率，至于发生误判的少量url，let it go！（就是这么粗暴）</p><p><strong>网页存储文件：</strong></p><p>网页信息存储文件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291654266.png" alt="img"></p><p>网页id-url对应文件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291654439.png" alt="img"></p><h5 id="（2）预处理"><a href="#（2）预处理" class="headerlink" title="（2）预处理"></a>（2）预处理</h5><p>参考资料：<a href="https://mah93.github.io/2019/08/08/string-matching/">字符串匹配算法</a></p><p>爬取完一个网页的html代码后，需要将<code>&lt;script&gt;,&lt;style&gt;,&lt;option&gt;</code>这些无用的标签及标签包含的内容给去掉，然后把其他标签也去掉但是保留里面的内容，最后得到<strong>纯文本</strong>（内容包含用户要搜索的关键词），所以我们需要使用<strong>字符串匹配算法</strong>对html内容进行<strong>预处理</strong>，对于字符串匹配算法这里列个清单自己去查罢 :(</p><p>单模式串匹配算法：</p><ul><li>BF算法</li><li>RK算法</li><li>BM算法</li><li>KMP算法</li></ul><p>上面的查询算法查询单个字符串效率确实不错，但是我们要一次性查出<code>&lt;script&gt;,&lt;style&gt;,&lt;option&gt;</code>这些字段串，多模式串匹配算法更加高效</p><p>多模式串匹配算法：</p><ul><li>AC自动机</li></ul><h5 id="（3）分词并创建倒排索引"><a href="#（3）分词并创建倒排索引" class="headerlink" title="（3）分词并创建倒排索引"></a>（3）分词并创建倒排索引</h5><p><strong>分词：</strong></p><p>预处理获得纯文本后，要对文本内容进行分词即把一段文本切分为一个个词。英语的分词比较简单，每一个单词基本都是用空格隔开的，中文的分词比较难分割，一般是根据现成的词库进行匹配，有兴趣可以研究一下github上有名的<a href="https://github.com/fxsjy/jieba">jieba</a>分词开源库</p><p><strong>组织：</strong></p><p>分词后，将单词与网页信息存储文件（文档）对应起来组成以下矩阵</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291737670.png" alt="img"></p><p><strong>倒排索引：</strong></p><p>再按照单词-文档组织起来就叫做<strong>倒排索引</strong></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109291955544.png" alt="img"></p><p>这样我们只要搜索<strong>单词</strong>，就能找到单词对应的<strong>文档id</strong>，从而定位url（上面分词+倒排索引的处理流程，就是 ElasticSearch 搜索引擎干的事，也是 ES 能达到毫秒级响应的关键）</p><p><strong>排序：</strong></p><p>根据词语我们获得了一组网页的id，那哪些网页应该排在前面呢？</p><p>Google使用了一种叫做”<strong>PageRank</strong>“的算法，通过计算每个网页的权重，并按照权重排序。它以网页之间的超链接个数和质量作为主要因素粗略地分析网页重要性以便对其进行打分。</p><p>在PageRank中，如果网页A包含网页B说明A认可了B，即为页面B投了一票</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109292017540.png" alt="img"></p><p>如上图：ABCD 初始值都为1，然后根据关系计算权重。比如此时B包含了AD两个网页，那么权重1被分为两个1/2分别给A和D，此时A包含BCD，那么此时A页面新的权重为1/2 + 1/3 + 1 = 11/6</p><p>此外还有通过<strong>词频TF</strong>进行排序</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109292024700.png" alt="img"></p><h5 id="（4）查询过程"><a href="#（4）查询过程" class="headerlink" title="（4）查询过程"></a>（4）查询过程</h5><ul><li>用户输入搜索内容，首先经过分词器处理</li><li>按获得的词语去倒排索引里查询相应文档</li><li>得到网页id后，去网页存储文件中提取出网页的链接和内容，再按权重从大到小排序即可</li></ul><h5 id="（5）寻找热门搜索字符串"><a href="#（5）寻找热门搜索字符串" class="headerlink" title="（5）寻找热门搜索字符串"></a>（5）寻找热门搜索字符串</h5><p>现在的搜索引擎还有一项功能：搜索提示词，其主要利用Trie树来实现（字典树，前缀树，单词查询树），如下图</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109292042845.png" alt="img"></p><p>这颗多叉树表示了关键字集合 <code>[&quot;to&quot;，&quot;tea&quot;，&quot;ted&quot;，&quot;ten&quot;，&quot;a&quot;，&quot;i&quot;，&quot;in&quot;, &quot;inn&quot;]</code>，</p><p>一般搜索引擎会维护一个词库，假设这个词库由所有搜索次数大于某个阈值（如 1000）的字符串组成，我们就可以用这个词库构建一颗 Trie 树，这样当用户输入字母的时候，就可以以这个字母作为前缀去 Trie 树中查找</p><p>哪如何获得热门的搜索提示词放在最前面呢？</p><p>通常在实现Trie树的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词，该标记也可以设置为<strong>搜索次数</strong></p><p>依次遍历 Trie 树的节点，将节点（字符串+次数）传给一个<strong>小顶堆</strong>，根据搜索次数不断调整小顶堆，这样遍历完 Trie 树的节点后，小顶堆里的 10 个节点即是最热门的搜索字符</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="1-软件架构"><a href="#1-软件架构" class="headerlink" title="1.软件架构"></a>1.软件架构</h4><p>参考资料：<a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构</a></p><h5 id="（1）单体架构"><a href="#（1）单体架构" class="headerlink" title="（1）单体架构"></a>（1）单体架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121533917.png" alt="image-20210912153357714"></p><p>典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层</p><p>单体架构出现的问题：</p><ul><li>代码分支管理困难</li><li>新增功能麻烦</li><li>容易耗尽数据库连接</li></ul><h5 id="（2）分布式架构"><a href="#（2）分布式架构" class="headerlink" title="（2）分布式架构"></a>（2）分布式架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121532105.png" alt="img"></p><p>将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上</p><h5 id="（3）微服务架构"><a href="#（3）微服务架构" class="headerlink" title="（3）微服务架构"></a>（3）微服务架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121533619.png" alt="img"></p><p>将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用</p><p>微服务的特点：</p><ul><li>大应用拆分为小模块</li><li>小模块不属于集群中</li><li>通过远程调用的方式依赖各个独立的模块完成业务的处理</li></ul><p>这些小模块就是一个微服务了</p><h4 id="2-微服务技术选型"><a href="#2-微服务技术选型" class="headerlink" title="2.微服务技术选型"></a>2.微服务技术选型</h4><p>参考资料：<a href="https://xie.infoq.cn/article/23d55563fdda52771571807e9">2020微服务架构技术选型</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109292309972.png" alt="img"></p><p>微服务的内容有点庞大😰，各种技术选型方案也很多，可以查看我的前一篇博文（SpringCloud + Netflix OSS）做一个了解：<a href="https://autovy.github.io/2021/09/20/Java/Java-SpringCloud/">Java|SpringCloud + Netflix OSS Demo</a></p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="1-高可用简介"><a href="#1-高可用简介" class="headerlink" title="1.高可用简介"></a>1.高可用简介</h4><p>系统高可用意味着在一台服务器挂掉的情况下，系统仍然无中断地执行其功能的能力</p><h4 id="2-高可用策略"><a href="#2-高可用策略" class="headerlink" title="2.高可用策略"></a>2.高可用策略</h4><h5 id="（1）冗余备份"><a href="#（1）冗余备份" class="headerlink" title="（1）冗余备份"></a>（1）冗余备份</h5><p>冗余备份是指复制关键部件或者系统的主要功能，当意外发生时，可以快速安全地恢复原有的系统，在一定的范围内保障业务的正常运行</p><h5 id="（2）负载均衡"><a href="#（2）负载均衡" class="headerlink" title="（2）负载均衡"></a>（2）负载均衡</h5><p>负载均衡也可以保证高可用，使用多台服务器分担一台服务器的压力，负载均衡服务器一旦发现集群中某台服务器出现问题，立刻停止对其的请求分发</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109300822419.png" alt="img"></p><h5 id="（3）限流降级"><a href="#（3）限流降级" class="headerlink" title="（3）限流降级"></a>（3）限流降级</h5><p>限流是对部分请求进行丢弃处理，保证大部分的用户可以正常的请求完成任务</p><p>降级即可以屏蔽部分当前看来不是很有用的任务</p><h5 id="（5）异地多活"><a href="#（5）异地多活" class="headerlink" title="（5）异地多活"></a>（5）异地多活</h5><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/32009822">饿了么异地多活技术实现</a></p><p>大型的系统多会在各个地方部署数据中心，采用异地多活的多机房策略</p><p>异地多活下，各个地域独立隔离，业务流量可以不均等的分配到各个地域和可用区里面</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109300837226.jpeg" alt="img"></p><ul><li>gzs是一个全局的（所有机房都可以访问的）服务，保存和推送sharding信息。</li><li>API router复制路由外网流量</li><li>SOAProxy实现跨机房调用</li><li>强一致数据库 / 数据库层的拦截 由DAL实现（图上没展示）</li><li>DRC实现Mqsql的双向复制</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h4 id="1-数据加密"><a href="#1-数据加密" class="headerlink" title="1.数据加密"></a>1.数据加密</h4><p>参考资料：<a href="https://www.jianshu.com/p/94dc5186746d">对称加密、单向加密和非对称加密</a></p><h5 id="（1）单向散列加密"><a href="#（1）单向散列加密" class="headerlink" title="（1）单向散列加密"></a>（1）单向散列加密</h5><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109300857948.png" alt="img"><p>单向加密有以下特征：</p><ul><li>输入一样，输出必然相同</li><li>雪崩效应，输入的微小改变，将会引起结果的巨大变化</li><li>定长输出，无论原始数据多大，结果大小都是相同的</li><li>不可逆，无法根据特征码还原原来的数据</li></ul><p>常用的单向加密算法有：MD5，SHA，CRC</p><p>单向加密通常应用在用户密码加密中，经过加密后的密码存储在数据库中，即便被脱库了也无法解密出密码（鉴于有些用户会用一些弱密码，容易被彩虹表暴杀，索引单向加密常常也要加一点盐）</p><h5 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109300857192.png" alt="img"></p><p>采用单钥密码的加密方法，同一个密钥可以同时用来加密和解密</p><p>对称加密有以下特点：</p><ul><li>加密方和解密方使用同一个密钥</li><li>加密解密的速度比较快，适合数据比较长时的使用</li><li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦</li></ul><p>常用的对称加密算法有：DES，3DES，AES，Blowfish</p><h5 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109300857820.png" alt></p><p>非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的</p><p>可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密；也可以用私钥加密，用公钥解密，常用于数字签名</p><p>非对称加密的<strong>主要功能就是加密和数字签名</strong></p><p>常用的非对称加密：RSA，DSA，ECC</p><h4 id="2-HTTP攻击与防护"><a href="#2-HTTP攻击与防护" class="headerlink" title="2.HTTP攻击与防护"></a>2.HTTP攻击与防护</h4><h5 id="（1）SQL注入"><a href="#（1）SQL注入" class="headerlink" title="（1）SQL注入"></a>（1）SQL注入</h5><p>SQL注入是攻击者在提交请求参数的时候，包含了恶意的SQL脚本</p><p>一阶sql注入：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109301727816.png" alt="image-20210930172727417"></p><p>二阶sql注入：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109301728597.png" alt="image-20210930172812394"></p><p>SQL注入防御方法（来源于wiki）：</p><ul><li>在设计应用程序时，完全使用<a href="https://zh.wikipedia.org/wiki/參數化查詢">参数化查询</a>（Parameterized Query）来设计资料访问功能（最有效的方式）</li><li>在组合SQL字符串时，先针对所传入的参数加入其他字符（将单引号字符前加上转义字符）。</li><li>如果使用<a href="https://zh.wikipedia.org/wiki/PHP">PHP</a>开发网页程序的话，需加入转义字符之功能（自动将所有的网页传入参数，将单引号字符前加上转义字符）。</li><li>使用php开发，可写入html特殊函数，可正确阻挡<a href="https://zh.wikipedia.org/wiki/XSS">XSS</a>攻击。</li><li>其他，使用其他更安全的方式连接SQL数据库。例如已修正过SQL注入问题的数据库连接组件，例如<a href="https://zh.wikipedia.org/wiki/ASP.NET">ASP.NET</a>的SqlDataSource对象或是 <a href="https://zh.wikipedia.org/wiki/语言集成查询">LINQ</a> to SQL。</li><li>增强<a href="https://zh.wikipedia.org/w/index.php?title=Web_application_firewall&action=edit&redlink=1">WAF</a>的防御力</li></ul><h5 id="（2）XSS攻击"><a href="#（2）XSS攻击" class="headerlink" title="（2）XSS攻击"></a>（2）XSS攻击</h5><p>跨站点脚本攻击，攻击者通过构造恶意的浏览器脚本文件注入到网页上，使其在其他用户的浏览器运行进而进行攻击</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109301732875.png" alt="xss.gif"></p><p>XSS攻击防御方法：</p><ul><li>过滤特殊字符</li><li>使用HTTP头指定类型即，可强行指定输出内容为文本或JavaScript脚本（顺便指定了内容编码），而非可以引发攻击的HTML</li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>参考资料：<a href="https://www.hadoopdoc.com/hdfs/hdfs-tutorial">https://www.hadoopdoc.com/hdfs/hdfs-tutorial</a></p><p>（本文只做简单介绍，大数据的内容也挺多的，有兴趣的可以点入上面链接深入学习）</p><h4 id="1-文件存储HDFS架构"><a href="#1-文件存储HDFS架构" class="headerlink" title="1.文件存储HDFS架构"></a>1.文件存储HDFS架构</h4><h5 id="（1）HDFS简介"><a href="#（1）HDFS简介" class="headerlink" title="（1）HDFS简介"></a>（1）HDFS简介</h5><p>HDFS是一种分布式文件系统，设计用于在商用硬件上商用，管理数以千计的服务器，数以万计的磁盘，将大规模的服务器资源当做一个单一的出承诺函系统进行管理，操作大批量数据就像使用普通文件系统一样</p><h5 id="（2）HDFS节点"><a href="#（2）HDFS节点" class="headerlink" title="（2）HDFS节点"></a>（2）HDFS节点</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109302252992.png" alt="HDFS架构图"></p><ul><li>Namenode会规范客户端对文件的访问，它维护和管理Slave节点，并把读写任务分配给Slave节点（部署在高可靠的硬件上面）</li><li>Datanode负责数据存储，它是真正干活的节点，比如响应客户端的数据读写请求，根据Namenode的指令创建和删除block（可以部署在价格低廉的商用机器上）</li></ul><h5 id="（3）HDFS进程"><a href="#（3）HDFS进程" class="headerlink" title="（3）HDFS进程"></a>（3）HDFS进程</h5><p>HDFS有2个守护进程：</p><ul><li><strong>Namenode</strong>：该进程运行在master节点上，Namenode节点存储元数据，比如文件名，块数量，块副本数量，块的存储位置，以及块ID等</li><li><strong>Datanode</strong>：该进程运行在Slave节点，这些节点是真正对数据进行处理和存储的节点</li></ul><h5 id="（4）HDFS数据存储"><a href="#（4）HDFS数据存储" class="headerlink" title="（4）HDFS数据存储"></a>（4）HDFS数据存储</h5><p><img src="/2021/09/30/DevPrinciple/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C:%5CUsers%5Clinghao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210930225658950.png" alt="image-20210930225658950"></p><p>把文件写入到HDFS的时候，HDFS会把文件分割成很多分片，也就是块（block），文件分割成块之后，HDFS会把他们以分布式方式存储在集群的不多节点上</p><h5 id="（5）HDFS机架感知"><a href="#（5）HDFS机架感知" class="headerlink" title="（5）HDFS机架感知"></a>（5）HDFS机架感知</h5><p>为了数据容错，NameNode把块的副本放在多个机架上，NameNode尽量会在每个机架都存储至少一个块副本，这样如果其中一个机架发生故障，系统还是可用的</p><p>机架感知策略的目的是提升数据可用性、可靠性和网络带宽利用率</p><h5 id="（6）HDFS架构"><a href="#（6）HDFS架构" class="headerlink" title="（6）HDFS架构"></a>（6）HDFS架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109301755744.jpeg" alt="HDFS 1.0 架构图"></p><ul><li><p>Namenode负责存储元数据而Datanode负责存储实际的数据。执行任何任务，客户端都得和Namenode进行交互，因为Namenode是整个集群的中心</p></li><li><p>Datanode是把数据存储在本地磁盘的，它会定期给Namenode发送心跳信息，以此来表明自己处在工作状态，Datanode还会根据副本因子负责把block拷贝到其他Datanode</p></li></ul><h4 id="2-大数据处理框架"><a href="#2-大数据处理框架" class="headerlink" title="2.大数据处理框架"></a>2.大数据处理框架</h4><h5 id="（1）Mapreduce"><a href="#（1）Mapreduce" class="headerlink" title="（1）Mapreduce"></a>（1）Mapreduce</h5><p>MapReduce 是 Hadoop 生态下面的计算层，它把任务分割成小任务并分发到集群的机器上并行执行，其分为Map和Reduce两个阶段</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109302309030.png" alt="img"></p><p>map和reduce进程在分布式集群中启动过程如下：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109302313905.png" alt="img"></p><h5 id="（2）Hive"><a href="#（2）Hive" class="headerlink" title="（2）Hive"></a>（2）Hive</h5><p>Hive 是一个架构在 Hadoop 之上的数据仓库基础工具，它可以处理结构化和半结构化数据，它使得查询和分析存储在 Hadoop 上的数据变得非常方便</p><p>有了 Hive，你只要开发简单的 SQL 查询就可以达到 MapReduce 作业同样的查询功能</p><p><img src="https://www.hadoopdoc.com/media/editor/file_1570081501000_20191003134501543078.png" alt="Hive架构组件"></p><h5 id="（3）Spark"><a href="#（3）Spark" class="headerlink" title="（3）Spark"></a>（3）Spark</h5><p>Spark 是一种高效且多用途的集群计算平台，它提供了一整套开发 API，包括流计算、机器学习或者SQL并支持支持批处理和流处理</p><p>Spark已经逐步替代MapReduce、Hive、Storm 等传统的大数据计算框架</p><p><img src="https://www.hadoopdoc.com/media/editor/file_1571152729000_20191015231852727918.png" alt="spark运行架构及流程"></p><p>Spark应用程序涉及了driver，master，worker三个节点：</p><ul><li>Driver：运行Application的main函数并创建SparkContext（运行环境），Driver同时负责将SparkContext关闭</li><li>Worker：集群中任何一个可以运行spark应用代码的节点</li><li>Executor：一个应用程序运行的监控和执行容器</li></ul><h5 id="（4）Flink"><a href="#（4）Flink" class="headerlink" title="（4）Flink"></a>（4）Flink</h5><p>参考资料：<a href="https://flink.apache.org/zh/">Apache Flink</a></p><p>Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算</p><p>作为流式数据流执行引擎，针对数据流的分布式计算提供数据分布，数据通信以及容错机制等功能。同时Flink也提供了机器学习库，图计算库等</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109302330786.png" alt="image-20210930233007590"></p><p>ontents.com/Autovy/Image/master/img/202109302330786.png)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202109302345178.jpeg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p&gt;抓住9月的尾巴，终于整理完毕🥳。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java|SpringCloud + Netflix OSS Demo</title>
    <link href="https://autovy.github.io/2021/09/20/Java/Java-SpringCloud/"/>
    <id>https://autovy.github.io/2021/09/20/Java/Java-SpringCloud/</id>
    <published>2021-09-20T06:30:00.000Z</published>
    <updated>2022-10-25T08:48:30.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109201109518.png" alt="image-20210920110949198"></p><p>Netflix OSS已在新版的SpringCloud中移除了，SpringCloud Netflix已经落后版本了🤯，但是不妨通过其掌握微服务的思想，理解SpringCloud的核心思想，核心组件</p><span id="more"></span><h4 id="分布式与集群"><a href="#分布式与集群" class="headerlink" title="分布式与集群"></a>分布式与集群</h4><h5 id="（1）微服务概念"><a href="#（1）微服务概念" class="headerlink" title="（1）微服务概念"></a>（1）微服务概念</h5><p>微服务简单来说，一个springboot就是一个微服务，不同的是这个springboot只做一项单纯的任务</p><h5 id="（2）服务注册"><a href="#（2）服务注册" class="headerlink" title="（2）服务注册"></a>（2）服务注册</h5><p>springcloud有个微服务注册中eureka server，通过它把微服务注册起来以供来调用</p><h5 id="（3）服务访问"><a href="#（3）服务访问" class="headerlink" title="（3）服务访问"></a>（3）服务访问</h5><p>微服务直接可以通过注册中心的定位相互访问</p><h5 id="（4）分布式概念"><a href="#（4）分布式概念" class="headerlink" title="（4）分布式概念"></a>（4）分布式概念</h5><p> 简单说，原来是在一个 springboot里就完成的事情，现在分布在多个 springboot里做，这就是初步具备分布式雏形了</p><ul><li>如果我要更新数据微服务，视图微服务是不受影响的</li><li>可以让不同的团队开发不同的微服务，他们之间只要约定好接口，彼此之间是低耦合的。</li><li>如果视图微服务挂了，数据微服务依然可以继续使用<br>等等</li></ul><h5 id="（5）集群"><a href="#（5）集群" class="headerlink" title="（5）集群"></a>（5）集群</h5><p>提供相同功能，只是端口不一样的微服务称为集群</p><ul><li>比起一个 springboot, 两个springboot 可以分别部署在两个不同的机器上，那么理论上来说，能够承受的负载就是 x 2. 这样系统就具备通过横向扩展而提高性能的机制</li><li>如果 8001 挂了，还有 8002 继续提供微服务，这就叫做高可用 </li></ul><h4 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h4><p>参考资料：<a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构</a></p><h5 id="（1）单体架构"><a href="#（1）单体架构" class="headerlink" title="（1）单体架构"></a>（1）单体架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121533917.png" alt="image-20210912153357714"></p><p>典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层</p><h5 id="（2）分布式架构"><a href="#（2）分布式架构" class="headerlink" title="（2）分布式架构"></a>（2）分布式架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121532105.png" alt="img"></p><p>将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上</p><h5 id="（3）微服务架构"><a href="#（3）微服务架构" class="headerlink" title="（3）微服务架构"></a>（3）微服务架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121533619.png" alt="img"></p><p>将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用</p><h5 id="（4）SpringCloud组成"><a href="#（4）SpringCloud组成" class="headerlink" title="（4）SpringCloud组成"></a>（4）SpringCloud组成</h5><p>SpringCloud 就是一套工具，帮助我们很容易地搭建出这么一个 集群和分布式的架子出来，Spring Cloud 专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121619055.png" alt="img"></p><ul><li>Spring Cloud Netflix：cloud各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的主要有组成有Eureka, Hystrix, Zuul</li><li>Eureka注册中心服务：SpringCloud服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移</li><li>Microservice：微服务，在springcloud可以简单理解为专职做一项任务的springboot，微服务之间可以通过Ribbon和Feign两种方式进行微服务之间的访问（Feign是主流方式）</li><li>Zipkin链路跟踪：从属于Spring Cloud Sleuth（日志收集工具包），为SpringCloud应用实现了一种分布式追踪解决方案，可以查看微服务之间的复杂的调用关系</li><li>Config Server 配置服务器：俗称配置中心，配置管理工具包，让你可以把配置放到远程服务器（比如集中放在git），集中化管理集群配置</li><li>Bus 消息总线：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Config Server 联合，再使用RabbitMQ实现热部署（所谓热部署即不需要重启微服务，对配置信息自动更新）</li><li>断路器Hystrix：容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力，简单来说就是提供异常或错误的处理微服务，比如说某个微服务寄了，断路器就可以调用其他微服务顶上（一般是错误处理的微服务）</li><li>Hystrix dashboard 断路器监控：通过turbine将集群中多个实例汇聚在一起，对微服务进行断路器监控</li><li>网关Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架，通过网关简化了对各个服务的访问：不再需要记录各个微服务的地址和端口，而是通过网关去访问他们</li></ul><h4 id="Springcloud-启动测试"><a href="#Springcloud-启动测试" class="headerlink" title="Springcloud 启动测试"></a>Springcloud 启动测试</h4><h5 id="（1）项目启动"><a href="#（1）项目启动" class="headerlink" title="（1）项目启动"></a>（1）项目启动</h5><ul><li><p>启动RabbitMQ（访问<a href="http://127.0.0.1:15672/#">http://127.0.0.1:15672/#</a> 即已开启）</p></li><li><p>启动链路追踪服务器（这里开启的端口要与微服务中的配置一致）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin-server-2.10.1-exec.jar  --server.port=8050 --zipkin.collector.rabbitmq.addresses=localhost</span><br></pre></td></tr></table></figure></li><li><p>访问配置仓库<a href="https://github.com/Autovy/SpringCloudConfig/">https://github.com/Autovy/SpringCloudConfig/</a> （也可以在config-server模块的配置文件修改成自己的仓库）</p></li><li><p>运行EurekaServerApplication，启动注册中心服务（端口为8761）</p></li><li><p>运行ConfigServerApplication，启动配置服务器（端口为8030）</p></li><li><p>运行ProductDataServiceApplication，启动数据微服务（端口填写8001，8002形成集群）</p></li><li><p>运行ProductViewServiceFeignApplication，启动视图微服务（端口可填写8012，8013）</p></li><li><p>运行ProductServiceHystrixDashboardApplication，开启断路器监控，监控单个微服务（端口为8020）</p></li><li><p>运行ProductServiceTurbineApplication，开启聚合断路器监控以监控集群（端口为8021）</p></li><li><p>运行视图微服务里的 AccessViewService 来周期性地访问 <code>http://127.0.0.1:8012/products</code> 和 <code>http://127.0.0.1:8013/products</code>，以提供监控数据</p></li><li><p>运行ProductServiceZuulApplication，开启网关服务（端口为8060）</p></li></ul><h5 id="（2）测试服务注册中心"><a href="#（2）测试服务注册中心" class="headerlink" title="（2）测试服务注册中心"></a>（2）测试服务注册中心</h5><p>打开链接<a href="http://127.0.0.1:8761/">http://127.0.0.1:8761/</a>   ，即可查看到注册服务中心Eureka</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191356386.png" alt="image-20210919135602819"></p><h5 id="（3）测试数据微服务"><a href="#（3）测试数据微服务" class="headerlink" title="（3）测试数据微服务"></a>（3）测试数据微服务</h5><p>打开链接<a href="http://127.0.0.1:8001/products">http://127.0.0.1:8001/products</a> 和 <a href="http://127.0.0.1:8002/products">http://127.0.0.1:8002/products</a> 都可以访问到返回的数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><h5 id="（4）测试视图微服务"><a href="#（4）测试视图微服务" class="headerlink" title="（4）测试视图微服务"></a>（4）测试视图微服务</h5><p>打开链接<a href="http://127.0.0.1:8012/products">http://127.0.0.1:8012/products</a> 和 <a href="http://127.0.0.1:8013/products">http://127.0.0.1:8013/products</a> 可以访问到视图页面，并且可以发现视图微服务会随机选择端口访问数据微服务实现负载均衡</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191401332.png" alt="image-20210919140106927"></p><h5 id="（5）测试服务链路追踪"><a href="#（5）测试服务链路追踪" class="headerlink" title="（5）测试服务链路追踪"></a>（5）测试服务链路追踪</h5><p>打开链接<a href="http://127.0.0.1:8050/zipkin/dependency/">http://127.0.0.1:8050/zipkin/dependency/</a>  即可访问到</p><p>Zipkin链路跟踪服务页面，即可看到微服务间的访问关系</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191404204.png" alt="image-20210919140414948"></p><h5 id="（6）测试Bus消息总线"><a href="#（6）测试Bus消息总线" class="headerlink" title="（6）测试Bus消息总线"></a>（6）测试Bus消息总线</h5><p>可访问<a href="http://127.0.0.1:8030/version/dev">http://127.0.0.1:8030/version/dev</a> 查看到配置服务器的信息</p><p>访问视图查看当前版本号</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191407817.png" alt="image-20210919140727703"></p><p>修改配置服务器git上的版本号，这里我的仓库地址为<a href="https://github.com/Autovy/SpringCloudConfig/">https://github.com/Autovy/SpringCloudConfig/</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191411510.png" alt="image-20210919141137143"></p><p>启动视图微服务中的FreshConfigUtil使用 post 的方式访问 <a href="http://localhost:8012/actuator/bus-refresh">http://localhost:8012/actuator/bus-refresh</a>  地址，更新配置信息</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191414604.png" alt="image-20210919141416336"></p><p>最后再查看视图上的更新</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191415873.png" alt="image-20210919141503558"></p><p>可以访问RabbitMQ页面：<a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a> ，查看队列，连接，还有交换机</p><h5 id="（7）测试Hystrix断路器及其监控"><a href="#（7）测试Hystrix断路器及其监控" class="headerlink" title="（7）测试Hystrix断路器及其监控"></a>（7）测试Hystrix断路器及其监控</h5><p>打开链接<a href="http://localhost:8020/hystrix">http://localhost:8020/hystrix</a> 即可进入Hystrix断路器的监控入口</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191417418.png" alt="image-20210919141754328"></p><p>框内输入<a href="http://localhost:8012/actuator/hystrix.stream">http://localhost:8012/actuator/hystrix.stream</a> 即可对8012端口的视图微服务进行监控</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191419460.png" alt="image-20210919141940229"></p><p>框内输入<a href="http://localhost:8021/turbine.stream">http://localhost:8021/turbine.stream</a> 即可实现对整个集群的视图微服务进行监控</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191421059.png" alt="image-20210919142137829"></p><p><strong>停止数据微服务</strong>ProductDataServiceApplication集群，触发断路器：</p><p>访问视图可得</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191429890.png" alt="image-20210919142903819"></p><p>访问单个微服务监控页面可得</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191432572.png" alt="image-20210919143250565"></p><p>访问聚合集群微服务监控页面可得</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191431299.png" alt="image-20210919143120242"></p><h5 id="（8）网关测试"><a href="#（8）网关测试" class="headerlink" title="（8）网关测试"></a>（8）网关测试</h5><p>可以在zuul的配置文件中修改微服务的访问路由，我绑定的路由如下：</p><p><a href="http://localhost:8060/api-data/products">http://localhost:8060/api-data/products</a>  ：访问数据微服务集群</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><p><a href="http://localhost:8060/api-view/products">http://localhost:8060/api-view/products</a>  ：访问视图微服务集群</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191426987.png" alt="image-20210919142625877"></p><p>可以发现其访问集群的端口也是负载均衡的</p><h4 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h4><h5 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>通过服务注册中心管理微服务，并且让微服务直接可以相互定位交流</p><h5 id="（2）相关依赖"><a href="#（2）相关依赖" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        添加eureka服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置"><a href="#（3）相关配置" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eureka服务配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sring微服务模块命名</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>hostname: localhost 表示主机名称</li><li>registerWithEureka：false 表示是否注册到服务器。 因为它本身就是服务器，所以就无需把自己注册到服务器</li><li>fetchRegistry: false 表示是否获取服务器的注册信息，和上面同理，这里也设置为 false</li><li>defaultZone： <code>http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</code> 自己作为服务器，公布出来的地址。 比如后续某个微服务要把自己注册到 eureka server, 那么就要使用这个地址： <a href="http://localhost:8761/eureka/">http://localhost:8761/eureka/</a></li></ul><h5 id="（4）服务启动"><a href="#（4）服务启动" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 注解标注为Eureka服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8761</span>;</span><br><span class="line">        <span class="comment">// 启动EurekaServer管理页面</span></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(EurekaServerApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><h5 id="（1）需求-1"><a href="#（1）需求-1" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>微服务要做集群，这就意味着，会有多个微服务实例。 在业务上有时候需要修改一些配置信息，比如说 版本信息，倘若没有配置服务， 那么就需要挨个修改微服务，挨个重新部署微服务，这样就比较麻烦。</p><p>我们可以把这些配置信息放在一个公共的地方，比如git，然后通过配置服务器把它获取下来，然后微服务再从配置服务器上取下来</p><h5 id="（2）git准备"><a href="#（2）git准备" class="headerlink" title="（2）git准备"></a>（2）git准备</h5><p>在github上新建仓库，并创建respo目录，在目录下添加 product-view-service-feign-dev.properties文件并写入版本信息</p><p>如我创建的仓库：<a href="https://github.com/Autovy/SpringCloudConfig">https://github.com/Autovy/SpringCloudConfig</a></p><h5 id="（3）相关依赖"><a href="#（3）相关依赖" class="headerlink" title="（3）相关依赖"></a>（3）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- eureka客户端注册依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot web支持 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置服务支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（4）相关配置"><a href="#（4）相关配置" class="headerlink" title="（4）相关配置"></a>（4）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务名与配置服务器的配置信息（这里用git作为配置服务器）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/Autovy/SpringCloudConfig/</span> <span class="comment">#github仓库地址</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">respo</span>  <span class="comment"># 仓库下的目录</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">main</span>  <span class="comment"># 分支名改为了main</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h5 id="（5）服务启动"><a href="#（5）服务启动" class="headerlink" title="（5）服务启动"></a>（5）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span>  <span class="comment">// 注解标注为Eureka客户端，实现注册</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span>  <span class="comment">// 使用该注解表明该springboot是个配置服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8030</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ConfigServerApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span>+port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="（1）-RabbitMQ的介绍"><a href="#（1）-RabbitMQ的介绍" class="headerlink" title="（1） RabbitMQ的介绍"></a>（1） RabbitMQ的介绍</h5><p>通过RabbitMQ与消息总线Bus实现配置服务器热部署即自动更新配置信息</p><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p><code>AMQP</code>(<code>Advanced Message Queuing Protocol</code>)，顾名思义，它是一个消息协议，能够使得遵循该协议的客户端和消息中间件(<code>Broker</code>)进行通讯</p><h5 id="（2）RabbitMQ安装"><a href="#（2）RabbitMQ安装" class="headerlink" title="（2）RabbitMQ安装"></a>（2）RabbitMQ安装</h5><p>首先要安装erlang，并配置环境，才继续安装RabbitMQ</p><p>配置插件后重启RabbitMQ</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109160921566.png" alt="image-20210916092150386"></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109160922543.png" alt="image-20210916092243391"></p><h5 id="（3）RabbitMQ页面无法访问问题"><a href="#（3）RabbitMQ页面无法访问问题" class="headerlink" title="（3）RabbitMQ页面无法访问问题"></a>（3）RabbitMQ页面无法访问问题</h5><p>一般来说开启了RabbitMQ服务后，可以通过链接<a href="http://127.0.0.1:15672/进行访问">http://127.0.0.1:15672/进行访问</a></p><p>如果页面无法访问到，可以自行下列语句重新生成相关配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop rabbitmq &amp;&amp; rabbitmq-server -detached &amp;&amp; net start rabbitmq</span><br></pre></td></tr></table></figure><p>这样即可访问到RabbitMQ的页面（用户与密码默认为guest/guest）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109160935154.png" alt="image-20210916093536018"></p><h5 id="（4）消息路由过程"><a href="#（4）消息路由过程" class="headerlink" title="（4）消息路由过程"></a>（4）消息路由过程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109160946397.png" alt="image-20210916094610081"></p><p>消息<code>(message)</code>发布给交换机<code>(Exchange)</code></p><p><code>Exchange</code>相当于邮局或者信箱，它接收到消息后会根据不同的规则(称为<code>Bindings</code>)来确定要发给哪个队列<code>(queue)</code></p><p>最后AMQP代理会将消息投递给订阅了此队列的消费者，或者是消费者依据需求自行获取</p><h5 id="（5）模式分类"><a href="#（5）模式分类" class="headerlink" title="（5）模式分类"></a>（5）模式分类</h5><p>RabbitMQ提供了四种Exchange模式：fanout,direct,topic,header 。header在实际使用中很少用到，故我们只介绍前面三种</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109160953038.png" alt="img"></p><ul><li>Direct 模式就是指定队列模式， 消息来了，只发给指定的 Queue, 其他Queue 都收不到</li><li>Topic 模式就是主题模式，Queue 按照某种主题分类接收消息</li><li>Fanout 模式就是广播模式，消息来了，会发给所有的队列</li></ul><p>在本项目中，我们让config-server去git获取最新配置信息，并将该信息广播给集群中的所有视图微服务</p><h4 id="断路器监控"><a href="#断路器监控" class="headerlink" title="断路器监控"></a>断路器监控</h4><h5 id="（1）需求-2"><a href="#（1）需求-2" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>前面我们了解了断路器， 当数据服务不可用的时候， 断路器就会发挥作用</p><p>而我们可以使用断路器监控来可视化断路器运行情况</p><h5 id="（2）相关依赖-1"><a href="#（2）相关依赖-1" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在eureka注册微服务依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加web支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息总线依赖，用于访问路径/actuator/bus-refresh --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 增加断路器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 增加断路器依赖监控面板依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-1"><a href="#（3）相关配置-1" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务并命名</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hystrix-dashboard</span></span><br></pre></td></tr></table></figure><h5 id="（4）服务启动-1"><a href="#（4）服务启动-1" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceHystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8020</span>;</span><br><span class="line">        <span class="keyword">if</span>(!NetUtil.isUsableLocalPort(port)) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;端口%d被占用了，无法启动%n&quot;</span>, port );</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造服务</span></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductServiceHystrixDashboardApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断路器聚合监控"><a href="#断路器聚合监控" class="headerlink" title="断路器聚合监控"></a>断路器聚合监控</h4><h5 id="（1）需求-3"><a href="#（1）需求-3" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>上面的内容只能针对一个微服务进行断路器监控，但是一个微服务通常由多个实例组成，监控起来十分不方便；springcloud提供了turbine可以把一个集群里的多个实例汇聚在一个turbine里，这样就能够在集群层面进行监控了</p><h5 id="（2）相关依赖-2"><a href="#（2）相关依赖-2" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在eureka注册微服务依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息总线依赖，用于访问路径/actuator/bus-refresh --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加断路器依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加断路器依赖监控面板依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加turbine --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-2"><a href="#（3）相关配置-2" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">turbine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置turbine</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line">  <span class="attr">aggregator:</span></span><br><span class="line">    <span class="attr">cluster-config:</span> <span class="string">default</span></span><br><span class="line">  <span class="comment"># 配置Eureka中的serviceId列表，表明监控哪些服务</span></span><br><span class="line">  <span class="comment">#（这样就会把微服务名称为product-view-service-feign的实例信息收集起来）</span></span><br><span class="line">  <span class="attr">app-config:</span> <span class="string">product-view-service-feign</span></span><br><span class="line">  <span class="attr">cluster-name-expression:</span> <span class="string">new</span> <span class="string">String(&quot;default&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应（注册）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h5 id="（4）服务启动-2"><a href="#（4）服务启动-2" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span> <span class="comment">// 开启Turbine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceTurbineApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8021</span>;</span><br><span class="line">        <span class="keyword">if</span>(!NetUtil.isUsableLocalPort(port))&#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;端口%d被占用，无法启动%n&quot;</span>, port);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductServiceTurbineApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span>+ port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网关Zuul"><a href="#网关Zuul" class="headerlink" title="网关Zuul"></a>网关Zuul</h4><h5 id="（1）需求-4"><a href="#（1）需求-4" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>微服务有可能放在不同的 ip 地址上，有可能是不同的端口</p><p>为了访问他们，就需要记录这些地址和端口。 而地址和端口都可能会变化，这就增加了访问者的负担</p><p>这时候我们就可以通过网关简化对微服务的访问，仅需要一个地址一个端口就可以实现对一个微服务集群的访问</p><h5 id="（2）相关依赖-3"><a href="#（2）相关依赖-3" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 微服务注册中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web服务支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 增加zuul网关 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-3"><a href="#（3）相关配置-3" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product-service-zuul</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应（注册）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对zuul进行路由映射</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">api-a:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/api-data/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">PRODUCT-DATA-SERVICE</span></span><br><span class="line">    <span class="attr">api-b:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/api-view/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">PRODUCT-VIEW-SERVICE-FEIGN</span></span><br></pre></td></tr></table></figure><h5 id="（4）服务启动-3"><a href="#（4）服务启动-3" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 网关服务</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 注册服务客户端</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8060</span>;</span><br><span class="line">        <span class="keyword">if</span>(!NetUtil.isUsableLocalPort(port))&#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;端口%d被占用了，无法启动%d&quot;</span>, port);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductServiceZuulApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据微服务"><a href="#数据微服务" class="headerlink" title="数据微服务"></a>数据微服务</h4><h5 id="（1）需求-5"><a href="#（1）需求-5" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>访问数据库为视图微服务提供数据（在本项目中为了配置方便，不设dao层直接在service层提供假数据），真正意义上完整的springboot</p><h5 id="（2）相关依赖-4"><a href="#（2）相关依赖-4" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web服务用于提供控制层 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--增加zipkin，使服务可以被追踪到--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-4"><a href="#（3）相关配置-4" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务名与配置服务链路追踪</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product-data-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:8050</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h5 id="（4）实体类"><a href="#（4）实体类" class="headerlink" title="（4）实体类"></a>（4）实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 默认构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用该构造方法，可以声明一个由默认值的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）服务层"><a href="#（5）服务层" class="headerlink" title="（5）服务层"></a>（5）服务层</h5><p>不接入dao层，直接在服务层提供假数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务层（这里不接入dao层，而是提供假数据）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得配置中的端口号</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    String port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; ps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 提供假数据，list方法没有对应dao层相应的数据库操作方法</span></span><br><span class="line">        ps.add(<span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;product a from port:&quot;</span>+port, <span class="number">50</span>));</span><br><span class="line">        ps.add(<span class="keyword">new</span> Product(<span class="number">2</span>,<span class="string">&quot;product b from port:&quot;</span>+port, <span class="number">150</span>));</span><br><span class="line">        ps.add(<span class="keyword">new</span> Product(<span class="number">3</span>,<span class="string">&quot;product c from port:&quot;</span>+port, <span class="number">250</span>));</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）控制层"><a href="#（6）控制层" class="headerlink" title="（6）控制层"></a>（6）控制层</h5><p>接入服务层并映射路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自动装配服务层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射url路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/products&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">products</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用服务层的方法</span></span><br><span class="line">        List&lt;Product&gt; ps = productService.list();</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（7）服务启动"><a href="#（7）服务启动" class="headerlink" title="（7）服务启动"></a>（7）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 服务注册中心客户端，微服务注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDataServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让用户输入端口号，开启多个服务形成集群</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入开启服务的端口号：&quot;</span>);</span><br><span class="line">        Scanner strpost = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        port = strpost.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动ProductDataService服务</span></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductDataServiceApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置zipkin:在启动类里配置 Sampler 抽样策略： ALWAYS_SAMPLE 表示持续抽样*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sampler <span class="title">defaultSampler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sampler.ALWAYS_SAMPLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视图微服务"><a href="#视图微服务" class="headerlink" title="视图微服务"></a>视图微服务</h4><h5 id="（1）需求-6"><a href="#（1）需求-6" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>访问数据微服务（这里主要用feign的方式），将数据发送到视图层展示</p><h5 id="（2）相关依赖-5"><a href="#（2）相关依赖-5" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务注册依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持 Feign 方式的微服务访问--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web支持依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图层依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--增加zipkin，使服务可以被追踪到--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加一个 spring-cloud-starter-config 用于访问配置服务器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息总线依赖，用于访问路径/actuator/bus-refresh --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于支持rabbitmq --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于支持断路器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-5"><a href="#（3）相关配置-5" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><p>这里的微服务由于要通过rabbitMQ访问到配置服务器，需要系统层面上的配置，故需要两个配置文件：<strong>bootstrap.yml 和 application.yml</strong></p><p>参考资料：<a href="https://www.jianshu.com/p/c955c44ae534">application.yml与bootstrap.yml的区别</a></p><ul><li>bootstrap.yml 和 application.yml 都可以用来配置参数</li><li>bootstrap.yml 用来程序引导时执行，应用于更加早期配置信息读取。可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。一旦bootStrap.yml 被加载，则内容不会被覆盖</li><li>application.yml 可以用来定义应用级别的， 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等</li></ul><p><strong>bootstrap.yml文件</strong></p><p>主要提供了 serviceId: config-server, 这个是配置服务器在 eureka server 里的服务名称，这样就可以定位 config-server了</p><p>在注册服务中心的注册也移到了bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 config-server（服务端）的信息</span></span><br><span class="line"><span class="attr">spring :</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line">    <span class="comment"># 增加总线配置</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">trace:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 新增rabbitMQ配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中心的地址要与Eureka的配置对应（注册）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>application.yml文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务名与配置服务链路追踪</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product-view-service-feign</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:8050</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 配置thymeleaf</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">servlet:</span></span><br><span class="line">      <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启断路器</span></span><br><span class="line"><span class="attr">feign.hystrix.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增路径访问允许，这样才能访问 /actuator/bus-refresh,用于访问配置服务器更新配置信息</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">      <span class="attr">cors:</span></span><br><span class="line">        <span class="attr">allowed-origins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="attr">allowed-methods:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（4）实体类-1"><a href="#（4）实体类-1" class="headerlink" title="（4）实体类"></a>（4）实体类</h5><p>与数据微服务的一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）客户端"><a href="#（5）客户端" class="headerlink" title="（5）客户端"></a>（5）客户端</h5><p>视图微服务作为客户端去访问数据微服务这个服务端，并利用断路器提供访问失败后的异常处理信息</p><p><strong>Feign客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Feign 客户端， 通过 注解方式访问PRODUCT-DATA-SERVICE服务的 products路径</span></span><br><span class="line"><span class="comment">// 如果访问的 PRODUCT-DATA-SERVICE 不可用的话，就调用 ProductClientFeignHystrix 来进行反馈信息</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;, fallback = ProductClientFeignHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClientFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;products&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hystrix断路器处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了 ProductClientFeign 接口，并提供了 list() 方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductClientFeignHystrix</span> <span class="keyword">implements</span>  <span class="title">ProductClientFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> Product(<span class="number">0</span>, <span class="string">&quot;产品数据微服务不可用&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）服务层"><a href="#（6）服务层" class="headerlink" title="（6）服务层"></a>（6）服务层</h5><p>接入客户端，自动装配客户端请求到的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductClientFeign productClientFeign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务类的数据从ProductClientRibbon（客户端）中获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productClientFeign.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（7）控制层"><a href="#（7）控制层" class="headerlink" title="（7）控制层"></a>（7）控制层</h5><p>接入服务层，映射访问路径，发送数据到视图层并输出视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在配置服务器获得版本号</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;version&#125;&quot;)</span></span><br><span class="line">    String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制器将数据放入product.html</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/products&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">products</span><span class="params">(Model m)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Product&gt; ps = productService.list();</span><br><span class="line">        <span class="comment">// 发送到视图</span></span><br><span class="line">        m.addAttribute(<span class="string">&quot;version&quot;</span>, version);</span><br><span class="line">        m.addAttribute(<span class="string">&quot;ps&quot;</span>, ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;products&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（8）视图层"><a href="#（8）视图层" class="headerlink" title="（8）视图层"></a>（8）视图层</h5><p>使用thymeleaf可接入java动态化数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>products<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">table</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-collapse</span>:collapse;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>:<span class="number">20px</span> auto;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">td</span>,<span class="selector-tag">th</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>:<span class="number">1px</span> solid gray;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;workingArea&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;p: $&#123;ps&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;p.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;p.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;p.price&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;version&#125;&quot;</span> &gt;</span>how2j springcloud version unknown<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（9）网络访问"><a href="#（9）网络访问" class="headerlink" title="（9）网络访问"></a>（9）网络访问</h5><p><strong>更新配置信息</strong></p><p>使用 post 的方式访问配置服务器的 <a href="http://localhost:8012/actuator/bus-refresh">http://localhost:8012/actuator/bus-refresh</a> 地址，用于更新配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 post 的方式访问 http://localhost:8012/actuator/bus-refresh 地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshConfigUntil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 增加请求头</span></span><br><span class="line">          HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          headers.put(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 因为要去git获取，还要刷新config-server, 会比较卡，所以一般会要好几秒才能完成</span></span><br><span class="line">          System.out.println(<span class="string">&quot;请耐心等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 发送post请求</span></span><br><span class="line">          String result = HttpUtil.createPost(<span class="string">&quot;http://localhost:8012/actuator/bus-refresh&quot;</span>)</span><br><span class="line">                  .addHeaders(headers).execute().body();</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">&quot;result&quot;</span> + result);</span><br><span class="line">          System.out.println(<span class="string">&quot;refresh 完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提供监控数据</strong></p><p>不断对视图层进行访问，以提供断路器监控的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个不断访问视图服务的类，以便在监控中观察到现象</span></span><br><span class="line"><span class="comment">// 访问集群的8012和8013端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessViewService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">            access(<span class="number">8012</span>);</span><br><span class="line">            access(<span class="number">8013</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String html = HttpUtil.get(String.format(<span class="string">&quot;http://127.0.0.1:%d/products&quot;</span>, port));</span><br><span class="line">            System.out.println(<span class="string">&quot;html length:&quot;</span> + html.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d地址的视图服务无法访问%n&quot;</span>, port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（10）服务启动"><a href="#（10）服务启动" class="headerlink" title="（10）服务启动"></a>（10）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 注册服务中信息注册客户端</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>   <span class="comment">//表明使用Feign方式</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span> <span class="comment">// 共享信息给断路监控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductViewServiceFeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加rabbitmq是否启动判断</span></span><br><span class="line">        <span class="keyword">int</span> rabbitMQPort = <span class="number">5672</span>;</span><br><span class="line">        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(rabbitMQPort))&#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;未在端口%d发现rabbitMQ服务，请检查&quot;</span>, rabbitMQPort);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让用户输入端口号，开启多个服务形成集群</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入开启服务的端口号：&quot;</span>);</span><br><span class="line">        Scanner strpost = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        port = strpost.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductViewServiceFeignApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置zipkon:在启动类里配置 Sampler 抽样策略： ALWAYS_SAMPLE 表示持续抽样*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sampler <span class="title">defaultSampler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sampler.ALWAYS_SAMPLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MPLE;<br>    }</p><p>}</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202109201109518.png&quot; alt=&quot;image-20210920110949198&quot;&gt;&lt;/p&gt;
&lt;p&gt;Netflix OSS已在新版的SpringCloud中移除了，SpringCloud Netflix已经落后版本了🤯，但是不妨通过其掌握微服务的思想，理解SpringCloud的核心思想，核心组件&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="开发实战" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="框架学习" scheme="https://autovy.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://autovy.github.io/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="https://autovy.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java|JavaWeb入门讲解</title>
    <link href="https://autovy.github.io/2021/09/14/Java/Java-JavaWeb%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>https://autovy.github.io/2021/09/14/Java/Java-JavaWeb%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-09-14T06:30:00.000Z</published>
    <updated>2022-10-27T07:56:48.914Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109140841902.png" alt="pngkey.com-java-logo-png-2232144"></p><span id="more"></span><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学会本地搭建环境，运行springboot项目</li><li>了解javaweb开发基本技术与工具使用</li><li>了解spring重要概念</li><li>清楚基本的开发架构</li><li>学会开发Springboot入门实例</li><li>学会开发SpringBoot JPA 持久层支持实例</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://autovy.github.io/JavaWebDemo.zip">Demo下载</a></p><p><a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis中文文档</a></p><p><a href="https://lfvepclr.gitbooks.io/spring-framework-5-doc-cn/content/">Spring Framework 5 中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-documentation.html">SpringBoot中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/spring-cloud/Greenwich.RELEASE/reference/">SpringCloud中文文档</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰Java教程博客</a></p><p><a href="https://autovy.github.io/2021/06/30/Java/Java-%E5%9F%BA%E4%BA%8ESSM%E8%AF%84%E8%AE%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/">autovy博客：基于SSM评论管理系统开发</a></p><h3 id="基本工具的使用"><a href="#基本工具的使用" class="headerlink" title="基本工具的使用"></a>基本工具的使用</h3><h4 id="IDE推荐"><a href="#IDE推荐" class="headerlink" title="IDE推荐"></a>IDE推荐</h4><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110902451.png" alt="image-20210911090207325"></p><p>推荐JetBrains公司的IDE全家桶，保持风格一致，减少对IDE的学习成本</p><p>使用<a href="https://www.jetbrains.com/toolbox-app/">toolbox</a>下载更方便</p><h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><p>使用构建工具管理java项目的依赖项并实现自动化构建</p><h5 id="（1）基本介绍"><a href="#（1）基本介绍" class="headerlink" title="（1）基本介绍"></a>（1）基本介绍</h5><p>Maven </p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110852517.png" alt="Apache_Maven_logo.svg"></p><p>Ant</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110848712.png" alt="1024px-Apache-Ant-logo.svg" style="zoom: 50%;"><p>Gradle</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110847529.png" alt="Gradle_logo"></p><h5 id="（2）比较"><a href="#（2）比较" class="headerlink" title="（2）比较"></a>（2）比较</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110854847.png" alt="image-20210911085448524"></p><ul><li>Ant：纯java编写，需要自定义构建过程</li><li>Maven：实现了自动化构建，并内置了依赖管理</li><li>Gradle：Gradle结合了前两者的优点，是Android Studio指定构建工具</li></ul><p>通过自动化构建工具，springboot大大减少了依赖项的添加工作</p><h5 id="（3）Maven结构"><a href="#（3）Maven结构" class="headerlink" title="（3）Maven结构"></a>（3）Maven结构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110937736.jpeg" alt="img"></p><h5 id="（4）Maven基本使用操作"><a href="#（4）Maven基本使用操作" class="headerlink" title="（4）Maven基本使用操作"></a>（4）Maven基本使用操作</h5><p>IDEA创建Maven项目：</p><ul><li>左边选择Maven</li><li>创建空Maven项目</li></ul><p>查看配置文件pom.xml：</p><p>配置jar包的仓库地址</p><p>maven的仓库默认在国外，这里可以更换为阿里云的仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> # 仓库地址       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加依赖项：</p><p>在mvnrepository查找依赖项：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p>查找并复制junit 4.12的依赖配置信息</p><p>增加依赖标签<code>&lt;dependencies&gt;</code>后</p><p>在idea中导入依赖项</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110954913.png" alt="image-20210911095458093"></p><p>查看外部库：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109110955224.png" alt="image-20210911095520948"></p><h4 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h4><p>Web服务器一般指网站服务器，是指驻留于[因特网]上某种类型计算机的程序，可以处理浏览器等Web客户端的请求并返回相应响应</p><h5 id="（1）Tomcat介绍"><a href="#（1）Tomcat介绍" class="headerlink" title="（1）Tomcat介绍"></a>（1）Tomcat介绍</h5><p>Java学习中常常使用<strong>Tomcat</strong>，这个个小型、轻量级的支持JSP和Servlet 技术的Web服务器，新版的springboot直接就内嵌了这个web服务器放在了启动项中</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111020941.png" alt="img" style="zoom: 25%;"><h5 id="（2）Tomcat下载"><a href="#（2）Tomcat下载" class="headerlink" title="（2）Tomcat下载"></a>（2）Tomcat下载</h5><p>新版的springboot已内嵌tomcat，不需要再下载，所以这块做简单的介绍，了解一下运行的原理就好</p><p>官网下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><h5 id="（3）Tomcat运行"><a href="#（3）Tomcat运行" class="headerlink" title="（3）Tomcat运行"></a>（3）Tomcat运行</h5><ul><li><p>新建文件html文件在webapps\www文件夹</p></li><li><p>启动bin/startup.bat</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111044774.png" alt="image-20210911104424694"></p></li><li><p>访问<code>http://127.0.0.1:8080/www/test.html</code></p></li></ul><p>tomcat的默认端口是8080端口，所以springboot启动的网页服务默认也是8080端口</p><h5 id="（4）Tomcat修改端口"><a href="#（4）Tomcat修改端口" class="headerlink" title="（4）Tomcat修改端口"></a>（4）Tomcat修改端口</h5><p>网页的默认端口使80端口</p><ul><li>查看文件<code>conf\server.xml</code></li><li>修改端口为80端口</li><li>重新启动bin/startup.bat</li><li>80端口占用问题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 参看端口号含80的条目</span><br><span class="line">netstat -ano|findstr &quot;80&quot;</span><br><span class="line"></span><br><span class="line">// 根据pid查询对应的应用程序</span><br><span class="line">tasklist|findstr &quot;1828&quot;</span><br><span class="line"></span><br><span class="line">// 杀死进程</span><br><span class="line">taskkill /f /pid 1828</span><br></pre></td></tr></table></figure><ul><li><p>如果是被系统占用，可以进入服务中心<code>services.msc</code>，停止或禁用SQL Server Reporting Services (MSSQLSERVER) （日志服务，一般用不上）</p></li><li><p>访问<code>http://127.0.0.1/www/test.html</code></p></li></ul><h4 id="本地数据库环境搭建"><a href="#本地数据库环境搭建" class="headerlink" title="本地数据库环境搭建"></a>本地数据库环境搭建</h4><h5 id="（1）PHPstudy介绍"><a href="#（1）PHPstudy介绍" class="headerlink" title="（1）PHPstudy介绍"></a>（1）PHPstudy介绍</h5><p>phpstudy集成了web服务（apache和nginx）,数据库服务（mysql），还有数据库缓存工具redis等。</p><p>能比较方便得搭建本地环境（如果没有docker进行容器化的话，确实是最佳选择）</p><p>下载地址：<a href="https://www.xp.cn/">https://www.xp.cn/</a></p><h5 id="（2）创建数据库"><a href="#（2）创建数据库" class="headerlink" title="（2）创建数据库"></a>（2）创建数据库</h5><p>这里使用mysql8.0.12版本</p><p>无代码创建好数据库</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111420500.png" alt="image-20210911142052336"></p><h5 id="（3）数据库连接"><a href="#（3）数据库连接" class="headerlink" title="（3）数据库连接"></a>（3）数据库连接</h5><p>在idea中连接数据库，测试连接后出现时区问题则填写<code>GMT</code>等时区,推荐使用<code>serverTimezone=Asia/Shanghai</code></p><p>创建数据表student，可在类型处填入长度例如<code>char(20)</code></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111444220.png" alt="image-20210911144428199"></p><h3 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h3><p>Java EE是一系列技术标准所组成的平台，它定义了动态Web页面功能（Servlet和Jsp）、商业组件（EJB）、异步消息传输机制（JMS）、名称和目录定位服务（JNDI）、数据库访问（JDBC）、与子系统的连接器（JCA）和安全服务等</p><p>这里主要介绍Servlet（服务端程序，可处理请求生成动态web内容），JDBC（数据库访问连接），java的web开发框架都是在此基础上的延拓</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109132024561.png" alt="image-20210913202431607"></p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><h5 id="（1）浏览器访问Servlet流程"><a href="#（1）浏览器访问Servlet流程" class="headerlink" title="（1）浏览器访问Servlet流程"></a>（1）浏览器访问Servlet流程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111454488.png" alt="image-20210911145431318"></p><h5 id="（2）Servlet-demo-开发"><a href="#（2）Servlet-demo-开发" class="headerlink" title="（2）Servlet demo 开发"></a>（2）Servlet demo 开发</h5><p>1.新建一个空maven的项目</p><p>2.maven导入Servlet依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.编写Servlet类</p><p>编写Servlet类接收请求，返回内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Servlet提供的http处理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写doGet方法，处理get请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉http请求异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 返回响应输出到页面</span></span><br><span class="line">            response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Hello Servlet&lt;h1&gt;&quot;</span>);</span><br><span class="line">            response.getWriter().println(<span class="keyword">new</span> Date().toString());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.编写web.xml配置文件</p><p>编写web.xml配置Servlet</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111532343.png" alt="image-20210911153159249"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    配置servlet信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    配置http处理类与url映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.将Servlet部署到tomcat上</p><p>打开模块设置(F4) &gt;  工件  &gt;  创建web工件</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111539001.png" alt="image-20210911153909470"></p><p>添加配置 &gt; tomcat本地服务器 &gt; 添加刚刚创建的工件 &gt; 注意修改应用程序上下文（影响访问的url）</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111541291.png" alt="image-20210911154152177"></p><p>开启服务进行测试</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111556434.png" alt="image-20210911155646449"></p><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p><strong>JDBC</strong> (<strong>J</strong>ava <strong>D</strong>ata<strong>B</strong>ase <strong>C</strong>onnection) 是通过JAVA访问数据库</p><h5 id="（1）Java连接数据库流程"><a href="#（1）Java连接数据库流程" class="headerlink" title="（1）Java连接数据库流程"></a>（1）Java连接数据库流程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111653998.png" alt="undefined"></p><h5 id="（2）JDBC查询数据库开发"><a href="#（2）JDBC查询数据库开发" class="headerlink" title="（2）JDBC查询数据库开发"></a>（2）JDBC查询数据库开发</h5><p>1.新建一个空maven的项目</p><p>2.添加mysql-connector-java依</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.注意开启phpstudy的mysql服务，并在idea中连接，记录jdbc链接</p><p>4.编写JDBC查询demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 导入数据库驱动包</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立与数据库的连接</span></span><br><span class="line">            <span class="comment">// 数据库名称， 账号，密码</span></span><br><span class="line">            Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Statement，用于执行sql语句</span></span><br><span class="line">            Statement s = c.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 编写sql语句</span></span><br><span class="line">            String sql  = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行sql语句，并返回结果</span></span><br><span class="line">            ResultSet res = s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理返回结果</span></span><br><span class="line">            <span class="keyword">while</span>(res.next())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> id = res.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = res.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d.%s\n&quot;</span>, id, name);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库加载异常</span></span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库连接异常</span></span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）JDBC-ORM-持久化存储"><a href="#（3）JDBC-ORM-持久化存储" class="headerlink" title="（3）JDBC ORM 持久化存储"></a>（3）JDBC ORM 持久化存储</h5><p>ORM=Object Relationship Database Mapping</p><p>对象和关系数据库的映射 简单说，<strong>一个对象</strong>，对应数据库里的<strong>一条记录</strong>，使用Java对象来将数据库内的数据持久化</p><p>JDBC 是面向 SQL 的，使用起来比较繁琐。所以就有了 ORM 框架，建立了 Java 对象与数据库表之间的映射关系，可以通过直接操作对象来实现持久化，简化了操作的繁杂度</p><p>java目前流行的数据库访问框架都是ORM框架</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109132026779.jpeg" alt="img"></p><p>1.创建Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般将一个数据表抽象为一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将表中的字段作为类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供外界操作属性的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在idea中实体类的创建有以下三种方法：</p><ul><li><p>选定类的字段生成setter和getter方法</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109200954096.png" alt="image-20210920095441605"></p></li></ul><ul><li><p>使用数据库工具创建实体类</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109041650556.png" alt="image-20210904165034192" style="zoom: 67%;"></li></ul><ul><li>使用Lombok工具自动生成getter和setter方法</li></ul><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109041657535.png" alt="image-20210904165746685"></p><p>2.修改demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 导入数据库驱动包</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立与数据库的连接</span></span><br><span class="line">            <span class="comment">// 数据库名称， 账号，密码</span></span><br><span class="line">            Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Statement，用于执行sql语句</span></span><br><span class="line">            Statement s = c.createStatement();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt; 修改sql语句</span></span><br><span class="line">            String sql  = <span class="string">&quot;select * from student where id = 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行sql语句，并返回结果</span></span><br><span class="line">            ResultSet res = s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  &gt;&gt;&gt;&gt;去掉while处理返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(res.next())&#123;</span><br><span class="line">                <span class="comment">//&gt;&gt;&gt;&gt;&gt;&gt; 实例化一个对象，用于存储一条数据</span></span><br><span class="line">                Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将数据库中的值存储在对象中</span></span><br><span class="line">                student.setId(res.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                student.setName(res.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                System.out.println(student);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库加载异常</span></span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库连接异常</span></span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.打断点参看student对象</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111751277.png" alt="image-20210911175137132"></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring重要概念"><a href="#Spring重要概念" class="headerlink" title="Spring重要概念"></a>Spring重要概念</h4><p>参考资料：<a href="https://blog.csdn.net/qq_40587575/article/details/79901550">https://blog.csdn.net/qq_40587575/article/details/79901550</a></p><h5 id="（1）IoC与DI概念"><a href="#（1）IoC与DI概念" class="headerlink" title="（1）IoC与DI概念"></a>（1）IoC与DI概念</h5><p>IoC：</p><ul><li>Ioc—Inversion of Control，即“控制反转”</li><li>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制</li><li>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由<strong>IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找</strong></li></ul><table><thead><tr><th>Ioc特点</th><th>传统java程序</th><th>Ioc设计</th></tr></thead><tbody><tr><td>控制</td><td>在对象内部通过new进行创建对象，是程序主动去创建依赖对象</td><td>IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建</td></tr><tr><td>反转</td><td>由我们自己在对象中主动控制去直接获取依赖对象，也就是正转</td><td>反转则是由容器来帮忙创建及注入依赖对象，对象只是被动的接受依赖对象</td></tr></tbody></table><p>DI：</p><ul><li>DI—Dependency Injection，即“依赖注入”</li><li>组件之间依赖关系由容器在运行期决定，由容器动态的将某个依赖关系注入到组件之中</li><li>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现</li><li>“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”</li></ul><h5 id="（2）IoC与DI概念图例"><a href="#（2）IoC与DI概念图例" class="headerlink" title="（2）IoC与DI概念图例"></a>（2）IoC与DI概念图例</h5><p>传统的java程序</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109120728738.png" alt="image-20210912072844684"></p><p>使用了loC/DI的程序</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109120729641.png" alt="image-20210912072938515"></p><h5 id="（3）Spring的应用"><a href="#（3）Spring的应用" class="headerlink" title="（3）Spring的应用"></a>（3）Spring的应用</h5><p>只需要理解一点：Spring帮我们完成了类的创建，多个类的合作的工作，即将IoC容器与其在其中注册的类看作黑盒，通过<strong>注解</strong>和<strong>配置文件</strong>，可以让类在平台上注册，而这些注册的类叫<strong>Bean</strong>，我们要做的工作实际上就是注册类和拿到IoC装配好的类</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109120939057.png" alt="image-20210912093936648"></p><h5 id="（4）Spring模块"><a href="#（4）Spring模块" class="headerlink" title="（4）Spring模块"></a>（4）Spring模块</h5><p>参考资料：</p><p><a href="https://blog.csdn.net/u010648555/article/details/76299467">Spring常用注解</a></p><p><a href="https://blog.csdn.net/qq_44543508/article/details/103718958">Spring的@bean注解</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121039116.png" alt="spring-overview"></p><p>Spring提供了一堆组件，通过拼接这些组件我们可以组装出web应用（比较经典的缝合怪有：SSI，SSH，SSM，他们的首字母就代表Spring）</p><p>Spring怎么知道应该把哪些Java类当成bean注册到容器中呢？<br>使用配置文件或者注解的方式进行标识需要处理的java类!</p><p>放在具体的实例中可以这样理解：将数据库的配置信息注册在容器中，在需要访问数据库的对象中用户通过注解（java程序中的特殊标记）让该对象依赖注入了数据库配置信息，从而可以访问到数据库；</p><h4 id="开发架构"><a href="#开发架构" class="headerlink" title="开发架构"></a>开发架构</h4><h5 id="（1）业务逻辑"><a href="#（1）业务逻辑" class="headerlink" title="（1）业务逻辑"></a>（1）业务逻辑</h5><p><strong>Controller–&gt;service接口–&gt;serviceImpl–&gt;dao接口–&gt;daoImpl–&gt;mapper–&gt;db</strong></p><h5 id="（2）执行流程"><a href="#（2）执行流程" class="headerlink" title="（2）执行流程"></a>（2）执行流程</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109041811913.png" alt="img"></p><p>而<code>pojo</code>则是实体类作为各层次处理传递的对象：</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109041811687.png" alt="image-20210629104056016"></p><h5 id="（3）各层职能"><a href="#（3）各层职能" class="headerlink" title="（3）各层职能"></a>（3）各层职能</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109120951753.png" alt="image-20210912095119480"></p><ul><li>dao/mapper层即数据持久层，dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务</li><li>service层调用dao层的接口进行业务逻辑应用的处理，封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性</li><li>controller层即控制层，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程</li><li>view层即视图层，用户可以看到并操作，可以理解为前端</li></ul><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>SpringBoot让Spring应用更加轻量化，并简化了了配置，实现自动化配置</p><p>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序</p><p>总而言之，Springboot是Spring的一套快速开发整合包</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109140739880.gif" alt="img"></p><h5 id="（1）SpringBoot启动原理"><a href="#（1）SpringBoot启动原理" class="headerlink" title="（1）SpringBoot启动原理"></a>（1）SpringBoot启动原理</h5><p>参考资料：</p><p><a href="https://www.cnblogs.com/theRhyme/p/11057233.html">https://www.cnblogs.com/theRhyme/p/11057233.html</a></p><p><a href="https://juejin.cn/post/6895341123816914958#heading-1">https://juejin.cn/post/6895341123816914958#heading-1</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111934807.png" alt="img"></p><ul><li><p>启动过程中，将注册类装配到Ioc容器，到时候我们可以直接获得装配好的类</p></li><li><p>反射：通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的</p></li><li><p>@ComponentScan ：<strong>扫描所在类的package</strong>；告诉Spring扫描哪个包下面类，加载符合条件的组件(比如@Component和@Repository以及@RestController，@Service等类)</p></li><li><p>@EnableAutoConfiguration：<strong>开启自动配置</strong>；经过层层调用，最终通过loadSpringFactories()方法加载META-INF/spring.factories中的配置类</p></li><li><p>@SpringBootConfiguration：<strong>标注当前类是配置类</strong>；将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名</p></li></ul><h5 id="（2）SpringBoot-Web-Demo"><a href="#（2）SpringBoot-Web-Demo" class="headerlink" title="（2）SpringBoot Web Demo"></a>（2）SpringBoot Web Demo</h5><p>1.新建Spring Initializr项目</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111939355.png" alt="image-20210911193904203"></p><p>2.勾选web模块</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109111940650.png" alt="image-20210911194039612"></p><p>3.查看pom.xml</p><p>查看pom.xml等待依赖下载完毕（springboot内置的依赖项过多，下载时间较长，start-web简化了Maven的依赖加载）</p><p>4.查看SpringbootApplication.java文件</p><p>项目创建好之后，就自带一个SpringbootApplication, 其被@SpringBootApplication 所标记，表示这个是一个Springboot 应用，其为Springboot 应用的入口</p><p>5.新建web文件存放控制器</p><p>新建HelloController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解为控制器</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解为映射url</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello SpringBoot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就相当于实现了Servlet的功能：处理http请求，返回响应内容</p><p>而这里的注解就相当于实现了Servlet的web.xml配置文件的功能</p><p>注解是java一个强大的特性，简单来说可以理解为代码中的特殊标记，开发人员可以在不改变原有代码情况下，在源代码中嵌入补充信息</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109112001559.png" alt="image-20210911200155436"></p><p>6.运行测试</p><p>访问链接：<code>http://localhost:8080/hello</code></p><p>感觉少了什么……我的tomcat呢？好像没有配web服务器😰</p><p>原来tomcat已经内嵌在SpringbootApplication中一起启动了</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109112009212.png" alt="image-20210911200952174"></p><p>也可以看到依赖项中也加载了tomcat，Tomcat的属性都在<code>org.springframework.boot.autoconfigure.web.ServerProperties</code>配置类中做了定义</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109112026994.png" alt="image-20210911202642854"></p><p>7.修改端口和上下文</p><p>在<code>resources/application.properties</code>文件修改配置（可以修改端口和上下文以及视图定位）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/test</span></span><br></pre></td></tr></table></figure><p>测试访问<code>http://localhost/test/hello</code>，如果出现了端口占用情况，可以参考tomcat的处理方法</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109112044412.png" alt="image-20210911204412242"></p><h5 id="（3）持久层支持"><a href="#（3）持久层支持" class="headerlink" title="（3）持久层支持"></a>（3）持久层支持</h5><p><strong>Hibernate</strong></p><p>Hibernate是jpa的具体实现，springboot默认使用的就是Hibernate，可以让我们不写一句sql，便于移植，同时也缺乏灵活性</p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109140808602.png" alt="image-20210912105841614" style="zoom:50%;"><p><strong>MyBatis</strong></p><p>MyBatis也是一个持久化框架，不完全是一个ORM框架（Mybatis是将java方法与sql语句关联起来，而没有将java对象与数据库关联起来）不是依照的JPA规范，可以进行更细致的SQL优化，比较灵活适合处理大量数据的业务，推荐学习</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121103990.png" alt="@mybatis"></p><h5 id="（4）SpringBoot-JPA-Demo"><a href="#（4）SpringBoot-JPA-Demo" class="headerlink" title="（4）SpringBoot  JPA Demo"></a>（4）SpringBoot  JPA Demo</h5><p>JPA(Java Persistence API)是Sun官方提出的Java持久化规范，用来方便大家操作数据库</p><p>1.准备数据库，参考本地服务器环境搭建章节</p><p>2.在前一个demo中进行修改（或新建一个spring项目）</p><p>3.增加对mysql和jpa的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jpa--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>4.修改springboot配置文件，连接数据库</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库配置信息（注意配置数据库的编码和时区）</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 数据库连接驱动</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>5.根据orm创建实体类Entity</p><p>实体层是各层次用于输入输出处理的数据对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记为实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;student&quot;)</span> <span class="comment">// 表明类对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类的私有属性</span></span><br><span class="line">  <span class="meta">@Id</span> <span class="comment">// 标记为主键</span></span><br><span class="line">  <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 表明为自增长方式</span></span><br><span class="line">  <span class="meta">@Column(name = &quot;id&quot;)</span> <span class="comment">// 表明对应的数据库字段名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供外界操作属性的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.编写DAO层</p><p>DAO与选择的数据库框架有关</p><p>DAO层提供与数据库交互的接口，继承JpaRepository父接口,提供了一系列操作数据库方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承JpaRepository父接口,提供了一系列操作数据库方法</span></span><br><span class="line"><span class="comment">// 并且提供了泛型&lt;类 , 主键类型&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Student</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.编写Service层</p><p>定义会用到的操作数据库接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义会用到的操作数据库接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找所有</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">listAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 查找指定id</span></span><br><span class="line">    <span class="function">Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现接口中具体的操作数据库的方法</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServicempl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDAO studentDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">listAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDAO.findAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDAO.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.编写控制器</p><p>负责调用服务层的方法，并映射路径提供给客户端使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">// 注解为控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自动装配service层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentServicempl studentServicempl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 存储数据库返回的列表</span></span><br><span class="line">        List&lt;Student&gt; list = studentServicempl.listAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出的字符串</span></span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历列表,获得对象属性的值</span></span><br><span class="line">        <span class="keyword">for</span> (Student item: list) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拼接为字符串输出</span></span><br><span class="line">            str += item.getId() + <span class="string">&quot;.&quot;</span> + item.getName() + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 映射get url</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student student = studentServicempl.get(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> student.getName() + student.getId();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试controller层</span></span><br><span class="line">    MockMvc mockMvc;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebApplicationContext context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(context);</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/list&quot;</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试Dao层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = dao.findAll();</span><br><span class="line">        <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试service层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentServicempl studentServicempl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = studentServicempl.listAll();</span><br><span class="line">        <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）SpringBoot-Mybatis-Demo"><a href="#（5）SpringBoot-Mybatis-Demo" class="headerlink" title="（5）SpringBoot  Mybatis  Demo"></a>（5）SpringBoot  Mybatis  Demo</h5><p>修改JPA Demo的dao层与实体类，为service提供操作数据库的方法，有注解法和xml两种方式</p><p>这里采用比较方便的注解法</p><ul><li><p>修改Dao，映射sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标注为mybatis的mapper接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用@Select注解表示调用方法会去执行对应的sql语句</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from student&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from student where id= #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Student <span class="title">getById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改pojo</p><p>Mybatis是将java方法与sql语句关联起来，而没有将java对象与数据库关联起来。所以不需要注解实体类与数据库的联系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">long</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="SpringCloud-Netflix"><a href="#SpringCloud-Netflix" class="headerlink" title="SpringCloud Netflix"></a>SpringCloud Netflix</h3><h4 id="分布式与集群"><a href="#分布式与集群" class="headerlink" title="分布式与集群"></a>分布式与集群</h4><h5 id="（1）微服务概念"><a href="#（1）微服务概念" class="headerlink" title="（1）微服务概念"></a>（1）微服务概念</h5><p>微服务简单来说，一个springboot就是一个微服务，不同的是这个springboot只做一项单纯的任务</p><h5 id="（2）服务注册"><a href="#（2）服务注册" class="headerlink" title="（2）服务注册"></a>（2）服务注册</h5><p>springcloud有个微服务注册中eureka server，通过它把微服务注册起来以供来调用</p><h5 id="（3）服务访问"><a href="#（3）服务访问" class="headerlink" title="（3）服务访问"></a>（3）服务访问</h5><p>微服务直接可以通过注册中心的定位相互访问</p><h5 id="（4）分布式概念"><a href="#（4）分布式概念" class="headerlink" title="（4）分布式概念"></a>（4）分布式概念</h5><p> 简单说，原来是在一个 springboot里就完成的事情，现在分布在多个 springboot里做，这就是初步具备分布式雏形了</p><ul><li>如果我要更新数据微服务，视图微服务是不受影响的</li><li>可以让不同的团队开发不同的微服务，他们之间只要约定好接口，彼此之间是低耦合的。</li><li>如果视图微服务挂了，数据微服务依然可以继续使用<br>等等</li></ul><h5 id="（5）集群"><a href="#（5）集群" class="headerlink" title="（5）集群"></a>（5）集群</h5><p>提供相同功能，只是端口不一样的微服务称为集群</p><ul><li>比起一个 springboot, 两个springboot 可以分别部署在两个不同的机器上，那么理论上来说，能够承受的负载就是 x 2. 这样系统就具备通过横向扩展而提高性能的机制</li><li>如果 8001 挂了，还有 8002 继续提供微服务，这就叫做高可用 </li></ul><h4 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h4><p>参考资料：<a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构</a></p><h5 id="（1）单体架构"><a href="#（1）单体架构" class="headerlink" title="（1）单体架构"></a>（1）单体架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121533917.png" alt="image-20210912153357714"></p><p>典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层</p><h5 id="（2）分布式架构"><a href="#（2）分布式架构" class="headerlink" title="（2）分布式架构"></a>（2）分布式架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121532105.png" alt="img"></p><p>将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上</p><h5 id="（3）微服务架构"><a href="#（3）微服务架构" class="headerlink" title="（3）微服务架构"></a>（3）微服务架构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121533619.png" alt="img"></p><p>将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用</p><h5 id="（4）SpringCloud基本组成"><a href="#（4）SpringCloud基本组成" class="headerlink" title="（4）SpringCloud基本组成"></a>（4）SpringCloud基本组成</h5><p>Spring将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p><p>SpringCloud 就是一套工具，帮助我们很容易地搭建出这么一个 集群和分布式的架子出来，Spring Cloud 专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109121619055.png" alt="img"></p><ul><li>Spring Cloud Netflix：cloud各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的主要有组成有Eureka, Hystrix, Zuul</li><li>Eureka注册中心服务：SpringCloud服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移</li><li>Microservice：微服务，在springcloud可以简单理解为专职做一项任务的springboot，微服务之间可以通过Ribbon和Feign两种方式进行微服务之间的访问（Feign是主流方式）</li><li>Zipkin链路跟踪：从属于Spring Cloud Sleuth（日志收集工具包），为SpringCloud应用实现了一种分布式追踪解决方案，可以查看微服务之间的复杂的调用关系</li><li>Config Server 配置服务器：俗称配置中心，配置管理工具包，让你可以把配置放到远程服务器（比如集中放在git），集中化管理集群配置</li><li>Bus 消息总线：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Config Server 联合，再使用RabbitMQ实现热部署（所谓热部署即不需要重启微服务，对配置信息自动更新）</li><li>断路器Hystrix：容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力，简单来说就是提供异常或错误的处理微服务，比如说某个微服务寄了，断路器就可以调用其他微服务顶上（一般是错误处理的微服务）</li><li>Hystrix dashboard 断路器监控：通过turbine将集群中多个实例汇聚在一起，对微服务进行断路器监控</li><li>网关Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架，通过网关简化了对各个服务的访问：不再需要记录各个微服务的地址和端口，而是通过网关去访问他们</li></ul><h4 id="Springcloud-启动测试"><a href="#Springcloud-启动测试" class="headerlink" title="Springcloud 启动测试"></a>Springcloud 启动测试</h4><h5 id="（1）项目启动"><a href="#（1）项目启动" class="headerlink" title="（1）项目启动"></a>（1）项目启动</h5><ul><li><p>启动RabbitMQ（访问<a href="http://127.0.0.1:15672/#即已开启）">http://127.0.0.1:15672/#即已开启）</a></p></li><li><p>启动链路追踪服务器（这里开启的端口要与微服务中的配置一致）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin-server-2.10.1-exec.jar  --server.port=8050 --zipkin.collector.rabbitmq.addresses=localhost</span><br></pre></td></tr></table></figure></li><li><p>访问配置仓库<a href="https://github.com/Autovy/SpringCloudConfig/（也可以在config-server模块的配置文件修改成自己的仓库）">https://github.com/Autovy/SpringCloudConfig/（也可以在config-server模块的配置文件修改成自己的仓库）</a></p></li><li><p>运行EurekaServerApplication，启动注册中心服务（端口为8761）</p></li><li><p>运行ConfigServerApplication，启动配置服务器（端口为8030）</p></li><li><p>运行ProductDataServiceApplication，启动数据微服务（端口填写8001，8002形成集群）</p></li><li><p>运行ProductViewServiceFeignApplication，启动视图微服务（端口可填写8012，8013）</p></li><li><p>运行ProductServiceHystrixDashboardApplication，开启断路器监控，监控单个微服务（端口为8020）</p></li><li><p>运行ProductServiceTurbineApplication，开启聚合断路器监控以监控集群（端口为8021）</p></li><li><p>运行视图微服务里的 AccessViewService 来周期性地访问 <code>http://127.0.0.1:8012/products</code> 和 <code>http://127.0.0.1:8013/products</code>，以提供监控数据</p></li><li><p>运行ProductServiceZuulApplication，开启网关服务（端口为8060）</p></li></ul><h5 id="（2）测试服务注册中心"><a href="#（2）测试服务注册中心" class="headerlink" title="（2）测试服务注册中心"></a>（2）测试服务注册中心</h5><p>打开链接<a href="http://127.0.0.1:8761/，即可查看到注册服务中心Eureka">http://127.0.0.1:8761/，即可查看到注册服务中心Eureka</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191356386.png" alt="image-20210919135602819"></p><h5 id="（3）测试数据微服务"><a href="#（3）测试数据微服务" class="headerlink" title="（3）测试数据微服务"></a>（3）测试数据微服务</h5><p>打开链接<a href="http://127.0.0.1:8001/products">http://127.0.0.1:8001/products</a> 和 <a href="http://127.0.0.1:8002/products">http://127.0.0.1:8002/products</a> 都可以访问到返回的数据</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><h5 id="（4）测试视图微服务"><a href="#（4）测试视图微服务" class="headerlink" title="（4）测试视图微服务"></a>（4）测试视图微服务</h5><p>打开链接<a href="http://127.0.0.1:8012/products">http://127.0.0.1:8012/products</a> 和 <a href="http://127.0.0.1:8013/products">http://127.0.0.1:8013/products</a> 可以访问到视图页面，并且可以发现视图微服务会随机选择端口访问数据微服务实现负载均衡</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191401332.png" alt="image-20210919140106927"></p><h5 id="（5）测试服务链路追踪"><a href="#（5）测试服务链路追踪" class="headerlink" title="（5）测试服务链路追踪"></a>（5）测试服务链路追踪</h5><p>打开链接<a href="http://127.0.0.1:8050/zipkin/dependency/">http://127.0.0.1:8050/zipkin/dependency/</a> 即可访问到</p><p>Zipkin链路跟踪服务页面，即可看到微服务间的访问关系</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191404204.png" alt="image-20210919140414948"></p><h5 id="（6）测试Bus消息总线"><a href="#（6）测试Bus消息总线" class="headerlink" title="（6）测试Bus消息总线"></a>（6）测试Bus消息总线</h5><p>可访问<a href="http://127.0.0.1:8030/version/dev查看到配置服务器的信息">http://127.0.0.1:8030/version/dev查看到配置服务器的信息</a></p><p>访问视图查看当前版本号</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191407817.png" alt="image-20210919140727703"></p><p>修改配置服务器git上的版本号，这里我的仓库地址为<a href="https://github.com/Autovy/SpringCloudConfig/">https://github.com/Autovy/SpringCloudConfig/</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191411510.png" alt="image-20210919141137143"></p><p>启动视图微服务中的FreshConfigUtil使用 post 的方式访问 <a href="http://localhost:8012/actuator/bus-refresh">http://localhost:8012/actuator/bus-refresh</a> 地址，更新配置信息</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191414604.png" alt="image-20210919141416336"></p><p>最后再查看视图上的更新</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191415873.png" alt="image-20210919141503558"></p><p>可以访问RabbitMQ页面：<a href="http://127.0.0.1:15672/，查看队列，连接，还有交换机">http://127.0.0.1:15672/，查看队列，连接，还有交换机</a></p><h5 id="（7）测试Hystrix断路器及其监控"><a href="#（7）测试Hystrix断路器及其监控" class="headerlink" title="（7）测试Hystrix断路器及其监控"></a>（7）测试Hystrix断路器及其监控</h5><p>打开链接<a href="http://localhost:8020/hystrix即可进入Hystrix断路器的监控入口">http://localhost:8020/hystrix即可进入Hystrix断路器的监控入口</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191417418.png" alt="image-20210919141754328"></p><p>框内输入<a href="http://localhost:8012/actuator/hystrix.stream即可对8012端口的视图微服务进行监控">http://localhost:8012/actuator/hystrix.stream即可对8012端口的视图微服务进行监控</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191419460.png" alt="image-20210919141940229"></p><p>框内输入<a href="http://localhost:8021/turbine.stream即可实现对整个集群的视图微服务进行监控">http://localhost:8021/turbine.stream即可实现对整个集群的视图微服务进行监控</a></p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191421059.png" alt="image-20210919142137829"></p><p><strong>停止数据微服务</strong>ProductDataServiceApplication集群，触发断路器：</p><p>访问视图可得</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191429890.png" alt="image-20210919142903819"></p><p>访问单个微服务监控页面可得</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191432572.png" alt="image-20210919143250565"></p><p>访问聚合集群微服务监控页面可得</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191431299.png" alt="image-20210919143120242"></p><h5 id="（8）网关测试"><a href="#（8）网关测试" class="headerlink" title="（8）网关测试"></a>（8）网关测试</h5><p>可以在zuul的配置文件中修改微服务的访问路由，我绑定的路由如下：</p><p><a href="http://localhost:8060/api-data/products">http://localhost:8060/api-data/products</a> ：访问数据微服务集群</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><p><a href="http://localhost:8060/api-view/products">http://localhost:8060/api-view/products</a> ：访问视图微服务集群</p><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202109191426987.png" alt="image-20210919142625877"></p><p>可以发现其访问集群的端口也是负载均衡的</p><p>可以发现其访问集群的端口也是负载均衡的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Autovy/Image/master/img/202109140841902.png&quot; alt=&quot;pngkey.com-java-logo-png-2232144&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="入门教程" scheme="https://autovy.github.io/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="框架学习" scheme="https://autovy.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
