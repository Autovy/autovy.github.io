<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Autovy&#39;s blog</title>
  
  <subtitle>Just For Interest</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://autovy.github.io/"/>
  <updated>2022-08-30T08:07:45.180Z</updated>
  <id>https://autovy.github.io/</id>
  
  <author>
    <name>Autovy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java|渐进式本地缓存开发总结</title>
    <link href="https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://autovy.github.io/2022/04/20/Java/Java-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-20T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.180Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205211137136.png" alt="img"></p><span id="more"></span><h3 id="一-固定大小缓存实现"><a href="#一-固定大小缓存实现" class="headerlink" title="一.固定大小缓存实现"></a>一.固定大小缓存实现</h3><h4 id="缓存接口定义"><a href="#缓存接口定义" class="headerlink" title="缓存接口定义"></a>缓存接口定义</h4><p>为了兼容 Map，我们定义缓存接口继承自 Map 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><p>我们主要看一下 put 时的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 尝试驱除</span></span><br><span class="line">    CacheEvictContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheEvictContext&lt;&gt;();</span><br><span class="line">    context.key(key).size(sizeLimit).cache(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// context包含新的键和旧的缓存，放入驱除类中按规则淘汰</span></span><br><span class="line">    cacheEvict.evict(context);</span><br><span class="line">    <span class="comment">//2. 判断驱除后的信息</span></span><br><span class="line">    <span class="keyword">if</span>(isSizeLimit()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 执行添加</span></span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以让用户动态指定大小，但是指定大小肯就要有对应的淘汰策略。</p><p>否则，固定大小的 map 肯定无法放入元素。</p><h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>淘汰策略可以有多种，比如 LRU/LFU/FIFO 等等，我们此处实现一个最基本的 FIFO。</p><p>所有实现以接口的方式实现，便于后期灵活替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictFIFO</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * queue 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;K&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，执行移除</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            K evictKey = queue.remove();</span><br><span class="line">            <span class="comment">// 移除最开始的元素</span></span><br><span class="line">            cache.remove(evictKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新加的元素放入队尾</span></span><br><span class="line">        <span class="keyword">final</span> K key = context.key();</span><br><span class="line">        queue.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FIFO 比较简单，我们使用一个队列，存储每一次放入的元素，当队列超过最大限制时，删除最早的元素。</p><h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>为了便于用户使用，我们实现类似于 guava 的引导类。</p><p>所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存引导类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBs</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CacheBs</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建对象实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">CacheBs&lt;K,V&gt; <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheBs&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K,V&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驱除策略默认设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">map</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">        ArgUtil.notNull(map, <span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 size 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">size</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArgUtil.notNegative(size, <span class="string">&quot;size&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置驱除策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict 驱除策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 0.0.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheBs&lt;K, V&gt; <span class="title">evict</span><span class="params">(ICacheEvict&lt;K, V&gt; evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.evict = evict;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICache&lt;K,V&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheContext&lt;&gt;();</span><br><span class="line">        context.cacheEvict(evict);</span><br><span class="line">        context.map(map);</span><br><span class="line">        context.size(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cache&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">2</span>)</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p>默认为先进先出的策略，此时输出 keys，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="二-LRU缓存淘汰策略"><a href="#二-LRU缓存淘汰策略" class="headerlink" title="二.LRU缓存淘汰策略"></a>二.LRU缓存淘汰策略</h3><p>上面默认使用FIFO淘汰策略即先进先淘汰，下我们来开发LRU缓存淘汰策略即淘汰最近最少使用</p><h4 id="LRU基本原理"><a href="#LRU基本原理" class="headerlink" title="LRU基本原理"></a>LRU基本原理</h4><h5 id="1-LRU-是什么"><a href="#1-LRU-是什么" class="headerlink" title="1.LRU 是什么"></a>1.LRU 是什么</h5><p>LRU 是由 Least Recently Used 的首字母组成，表示最近最少使用的含义，一般使用在对象淘汰算法上。</p><p>也是比较常见的一种淘汰算法。</p><p>其核心思想是<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>。</p><h5 id="2-连续性"><a href="#2-连续性" class="headerlink" title="2.连续性"></a>2.连续性</h5><p>在计算机科学中，有一个指导准则：连续性准则。</p><p>时间连续性：对于信息的访问，最近被访问过，被再次访问的可能性会很高。缓存就是基于这个理念进行数据淘汰的。</p><p>空间连续性：对于磁盘信息的访问，将很有可能访问连续的空间信息。所以会有 page 预取来提升性能。</p><h5 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h5><ol><li>新数据插入到链表头部；</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ol><p>其实比较简单，比起 FIFO 的队列，我们引入一个链表实现即可。</p><h5 id="5-LRU实现步骤疑点"><a href="#5-LRU实现步骤疑点" class="headerlink" title="5.LRU实现步骤疑点"></a>5.LRU实现步骤疑点</h5><p>我们针对上面的 3 句话，逐句考虑一下，看看有没有值得优化点或者一些坑。</p><p><strong>如何判断是新数据？</strong></p><p><strong>新数据插入到链表头部；</strong></p><p>我们使用的是链表。</p><p>判断新数据最简单的方法就是遍历是否存在，对于链表，这是一个 O(n) 的时间复杂度。</p><p>其实性能还是比较差的。</p><p>当然也可以考虑空间换时间，比如引入一个 set 之类的，不过这样对空间的压力会加倍。</p><p><strong>什么是缓存命中</strong></p><p><strong>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</strong></p><p>put(key,value) 的情况，就是新元素。如果已有这个元素，可以先删除，再加入，参考上面的处理。</p><p>get(key) 的情况，对于元素访问，删除已有的元素，将新元素放在头部。</p><p>remove(key) 移除一个元素，直接删除已有元素。</p><p>keySet() valueSet() entrySet() 这些属于无差别访问，我们不对队列做调整。</p><p><strong>移除</strong></p><p><strong>当链表满的时候，将链表尾部的数据丢弃。</strong></p><p>链表满只有一种场景，那就是添加元素的时候，也就是执行 put(key, value) 的时候。</p><p>直接删除对应的 key 即可。</p><h4 id="Java-代码实现"><a href="#Java-代码实现" class="headerlink" title="Java 代码实现"></a>Java 代码实现</h4><h5 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1.接口定义"></a>1.接口定义</h5><p>和 FIFO 的接口保持一致，调用地方也不变</p><p>为了后续 LRU/LFU 实现，新增 remove/update 两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 驱除策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否执行驱除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> ICacheEvictContext&lt;K, V&gt; context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-LRU-实现"><a href="#2-LRU-实现" class="headerlink" title="2.LRU 实现"></a>2.LRU 实现</h5><p>直接基于 LinkedList 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 丢弃策略-LRU 最近最少使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLRU</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLRU.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;K&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            K evictKey = list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 移除对应的元素</span></span><br><span class="line">            cache.remove(evictKey);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(key);</span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="number">0</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现比较简单，相对 FIFO 多了三个方法：</p><p>update()：我们做一点简化，认为只要是访问，就是删除，然后插入到队首。</p><p>remove()：删除就是直接删除。</p><p>这三个方法是用来更新最近使用情况的。</p><p>那什么时候调用呢？</p><h5 id="3-注解属性"><a href="#3-注解属性" class="headerlink" title="3.注解属性"></a>3.注解属性</h5><p>为了保证核心流程，我们基于注解实现。</p><p>添加属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否执行驱除更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 主要用于 LRU/LFU 等驱除策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">evict</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br></pre></td></tr></table></figure><h5 id="4-注解使用"><a href="#4-注解使用" class="headerlink" title="4.注解使用"></a>4.注解使用</h5><p>有哪些方法需要使用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(refresh = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(evict = true)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 刷新所有过期信息</span></span><br><span class="line">    K genericKey = (K) key;</span><br><span class="line">    <span class="keyword">this</span>.expire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true, evict = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-注解驱除拦截器实现"><a href="#5-注解驱除拦截器实现" class="headerlink" title="5.注解驱除拦截器实现"></a>5.注解驱除拦截器实现</h5><p>执行顺序：放在方法之后更新，不然每次当前操作的 key 都会被放在最前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 驱除策略拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptorEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheInterceptorEvict.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">        ICacheEvict&lt;K,V&gt; evict = context.cache().evict();</span><br><span class="line"></span><br><span class="line">        Method method = context.method();</span><br><span class="line">        <span class="keyword">final</span> K key = (K) context.params()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;remove&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            evict.remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            evict.update(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只对 remove 方法做下特判，其他方法都使用 update 更新信息。</p><p>参数直接取第一个参数。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line"></span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><ul><li>日志信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><p>通过 removeListener 日志也可以看到 B 被移除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">21</span>:<span class="number">33</span>:<span class="number">44.578</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key:</span><br></pre></td></tr></table></figure><h3 id="三-LRU缓存策略的优化"><a href="#三-LRU缓存策略的优化" class="headerlink" title="三.LRU缓存策略的优化"></a>三.LRU缓存策略的优化</h3><h4 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h4><h5 id="1-基于数组"><a href="#1-基于数组" class="headerlink" title="1.基于数组"></a>1.基于数组</h5><p>方案：为每一个数据附加一个额外的属性——时间戳，当每一次访问数据时，更新该数据的时间戳至当前时间。</p><p>当数据空间已满后，则扫描整个数组，淘汰时间戳最小的数据。</p><p>不足：维护时间戳需要耗费额外的空间，淘汰数据时需要扫描整个数组。</p><p>这个时间复杂度太差，空间复杂度也不好。</p><h5 id="2-基于长度有限的双向链表"><a href="#2-基于长度有限的双向链表" class="headerlink" title="2.基于长度有限的双向链表"></a>2.基于长度有限的双向链表</h5><p>方案：访问一个数据时，当数据不在链表中，则将数据插入至链表头部，如果在链表中，则将该数据移至链表头部。当数据空间已满后，则淘汰链表最末尾的数据。</p><p>不足：插入数据或取数据时，需要扫描整个链表。</p><p>这个就是我们上一节实现的方式，缺点还是很明显，每次确认元素是否存在，都要消耗 O(n) 的时间复杂度去查询。</p><h5 id="3-基于双向链表和哈希表"><a href="#3-基于双向链表和哈希表" class="headerlink" title="3.基于双向链表和哈希表"></a>3.基于双向链表和哈希表</h5><p>方案：为了改进上面需要扫描链表的缺陷，配合哈希表，将数据和链表中的节点形成映射，将插入操作和读取操作的时间复杂度从O(N)降至O(1)</p><p>缺点：这个使我们上一节提到的优化思路，不过还是有缺点的，那就是空间复杂度翻倍。</p><h5 id="4-数据结构的选择总结"><a href="#4-数据结构的选择总结" class="headerlink" title="4.数据结构的选择总结"></a>4.数据结构的选择总结</h5><p>（1）基于数组的实现</p><p>这里不建议选择 array 或者 ArrayList，因为读取的时间复杂度为 O(1)，但是更新相对是比较慢的，虽然 jdk 使用的是 System.arrayCopy。</p><p>（2）基于双向链表的实现</p><p>如果我们选择链表，HashMap 中还是不能简单的存储 key, 和对应的下标。</p><p>因为链表的遍历，实际上还是 O(n) 的，双向链表理论上可以优化一半，但是这并不是我们想要的 O(1) 效果。</p><p>（3）基于双向链表 + Map实现</p><p>双向链表我们保持不变。</p><p>Map 中 key 对应的值我们放双向链表的节点信息。</p><p>那实现方式就变成了实现一个双向链表。</p><h4 id="基于自定义双向链表实现"><a href="#基于自定义双向链表实现" class="headerlink" title="基于自定义双向链表实现"></a>基于自定义双向链表实现</h4><h5 id="1-节点定义"><a href="#1-节点定义" class="headerlink" title="1.节点定义"></a>1.节点定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fluent get &amp; set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-核心代码实现"><a href="#2-核心代码实现" class="headerlink" title="2.核心代码实现"></a>2.核心代码实现</h5><p>我们保持和原来的接口不变，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLruDoubleListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLruDoubleListMap.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLruDoubleListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">            <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">            DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">            <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            K evictKey = tailPre.key();</span><br><span class="line">            V evictValue = cache.remove(evictKey);</span><br><span class="line">            result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行删除</span></span><br><span class="line">        <span class="keyword">this</span>.remove(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 新元素插入到头部</span></span><br><span class="line">        <span class="comment">//head&lt;-&gt;next</span></span><br><span class="line">        <span class="comment">//变成：head&lt;-&gt;new&lt;-&gt;next</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; newNode = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        newNode.key(key);</span><br><span class="line"></span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = <span class="keyword">this</span>.head.next();</span><br><span class="line">        <span class="keyword">this</span>.head.next(newNode);</span><br><span class="line">        newNode.pre(<span class="keyword">this</span>.head);</span><br><span class="line">        next.pre(newNode);</span><br><span class="line">        newNode.next(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 插入到 map 中</span></span><br><span class="line">        indexMap.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment">     * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment">     * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment">     * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        DoubleListNode&lt;K,V&gt; node = indexMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 list node</span></span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line"></span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.indexMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现起来不难，就是一个简易版本的双向列表。</p><p>只是获取节点的时候，借助了一下 map，让时间复杂度降低为 O(1)。</p><h5 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p>我们验证一下自己的实现：</p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lruDoubleListMap())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>日志</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> 09:<span class="number">37</span>:<span class="number">41.007</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><p>因为我们访问过一次 A，所以 B 已经变成最少被访问的元素。</p><h4 id="基于-LinkedHashMap-实现"><a href="#基于-LinkedHashMap-实现" class="headerlink" title="基于 LinkedHashMap 实现"></a>基于 LinkedHashMap 实现</h4><p>实际上，LinkedHashMap 本身就是对于 list 和 hashMap 的一种结合的数据结构，我们可以直接使用 jdk 中 LinkedHashMap 去实现。</p><h5 id="1-直接实现"><a href="#1-直接实现" class="headerlink" title="1.直接实现"></a>1.直接实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里将LinkedHashMap的accessOrder设为true</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt;= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认LinkedHashMap并不会淘汰数据，所以我们重写了它的removeEldestEntry()方法，当数据数量达到预设上限后，淘汰数据，accessOrder设为true意为按照访问的顺序排序。</p><p>整个实现的代码量并不大，主要都是应用LinkedHashMap的特性。</p><h5 id="2-简单改造"><a href="#2-简单改造" class="headerlink" title="2.简单改造"></a>2.简单改造</h5><p>我们对这个方法简单改造下，让其适应我们定义的接口。</p><h5 id="3-测试结果-1"><a href="#3-测试结果-1" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lruLinkedHashMap())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>日志</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">57.842</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><h4 id="LRU扩展算法"><a href="#LRU扩展算法" class="headerlink" title="LRU扩展算法"></a>LRU扩展算法</h4><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><h5 id="1-LRU-K"><a href="#1-LRU-K" class="headerlink" title="1. LRU-K"></a>1. LRU-K</h5><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。</p><p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。</p><p>当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p><p>数据第一次被访问时，加入到历史访问列表，如果数据在访问历史列表中没有达到K次访问，则按照一定的规则（FIFO,LRU）淘汰；</p><p>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列中删除，将数据移到缓存队列中，并缓存数据，缓存队列重新按照时间排序；</p><p>缓存数据队列中被再次访问后，重新排序，需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即“淘汰倒数K次访问离现在最久的数据”。</p><p>LRU-K具有LRU的优点，同时还能避免LRU的缺点，实际应用中LRU-2是综合最优的选择。</p><p>由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多。</p><h5 id="2-two-queue"><a href="#2-two-queue" class="headerlink" title="2. two queue"></a>2. two queue</h5><p>Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p><p>当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。</p><p>新访问的数据插入到FIFO队列中，如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p><p>如果数据在FIFO队列中再次被访问到，则将数据移到LRU队列头部，如果数据在LRU队列中再次被访问，则将数据移动LRU队列头部，LRU队列淘汰末尾的数据。</p><h5 id="3-Multi-Queue-MQ"><a href="#3-Multi-Queue-MQ" class="headerlink" title="3. Multi Queue(MQ)"></a>3. Multi Queue(MQ)</h5><p>MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：<strong>优先缓存访问次数多的数据</strong>。</p><p>详细的算法结构图如下，Q0，Q1….Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列：</p><p>新插入的数据放入Q0，每个队列按照LRU进行管理，当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列中删除，加入到高一级队列的头部；为了防止高优先级数据永远不会被淘汰，当数据在指定的时间里没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；需要淘汰数据时，从最低一级队列开始按照LRU淘汰，每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部。</p><p>如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列头部。</p><p>Q-history按照LRU淘汰数据的索引。</p><p>MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。</p><h5 id="4-LRU算法对比"><a href="#4-LRU算法对比" class="headerlink" title="4.LRU算法对比"></a>4.LRU算法对比</h5><table><thead><tr><th align="left">对比点</th><th align="left">对比</th></tr></thead><tbody><tr><td align="left">命中率</td><td align="left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr><tr><td align="left">复杂度</td><td align="left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr><tr><td align="left">代价</td><td align="left">LRU-2  &gt; MQ(2) &gt; 2Q &gt; LRU</td></tr></tbody></table><p>实际上上面的几个算法，思想上大同小异。</p><p>核心目的：解决批量操作导致热点数据失效，缓存被污染的问题。</p><p>实现方式：增加一个队列，用来保存只访问一次的数据，然后根据次数不同，放入到 LRU 中。</p><p>只访问一次的队列，可以是 FIFO 队列，可以是 LRU，我们来实现一下 2Q 和 LRU-2 两种实现。</p><h4 id="2Q算法实现"><a href="#2Q算法实现" class="headerlink" title="2Q算法实现"></a>2Q算法实现</h4><h5 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h5><p>实际上就是我们以前的 FIFO + LRU 二者的结合。</p><h5 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2.基本属性"></a>2.基本属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLru2Q</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLru2Q.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小限制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 降低 O(n) 的消耗，避免耗时过长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT_QUEUE_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次访问的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;K&gt; firstQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; lruIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLru2Q</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.lruIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-数据淘汰"><a href="#3-数据淘汰" class="headerlink" title="3.数据淘汰"></a>3.数据淘汰</h5><p>数据淘汰的逻辑：</p><p>当缓存大小，已经达到最大限制时执行：</p><p>（1）优先淘汰 firstQueue 中的数据</p><p>（2）如果 firstQueue 中数据为空，则淘汰 lruMap 中的数据信息。</p><p>这里有一个假设：我们认为被多次访问的数据，重要性高于被只访问了一次的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">    ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">    <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">        K evictKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. firstQueue 不为空，优先移除队列中元素</span></span><br><span class="line">        <span class="keyword">if</span>(!firstQueue.isEmpty()) &#123;</span><br><span class="line">            evictKey = firstQueue.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">            DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">            <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            evictKey = tailPre.key();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行移除操作</span></span><br><span class="line">        V evictValue = cache.remove(evictKey);</span><br><span class="line">        result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-数据删除"><a href="#4-数据删除" class="headerlink" title="4.数据删除"></a>4.数据删除</h5><p>当数据被删除时调用：</p><p>这个逻辑和以前类似，只是多了一个 FIFO 队列的移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment"> * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment"> * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment"> * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    DoubleListNode&lt;K,V&gt; node = lruIndexMap.get(key);</span><br><span class="line">    <span class="comment">//1. LRU 删除逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isNotNull(node)) &#123;</span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.lruIndexMap.remove(node.key());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. FIFO 删除逻辑（O(n) 时间复杂度）</span></span><br><span class="line">        firstQueue.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数据的更新"><a href="#5-数据的更新" class="headerlink" title="5.数据的更新"></a>5.数据的更新</h5><p>当数据被访问时，提升数据的优先级。</p><p>（1）如果在 lruMap 中，则首先移除，然后放入到头部</p><p>（2）如果不在 lruMap 中，但是在 FIFO 队列，则从 FIFO 队列中移除，添加到 LRU map 中。</p><p>（3）如果都不在，直接加入到 FIFO 队列中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放入元素</span></span><br><span class="line"><span class="comment"> * 1. 如果 lruIndexMap 已经存在，则处理 lru 队列，先删除，再插入。</span></span><br><span class="line"><span class="comment"> * 2. 如果 firstQueue 中已经存在，则处理 first 队列，先删除 firstQueue，然后插入 Lru。</span></span><br><span class="line"><span class="comment"> * 1 和 2 是不同的场景，但是代码实际上是一样的，删除逻辑中做了二种场景的兼容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 如果不在1、2中，说明是新元素，直接插入到 firstQueue 的开始即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 是否在 LRU MAP 中</span></span><br><span class="line">    <span class="comment">//1.2 是否在 firstQueue 中</span></span><br><span class="line">    DoubleListNode&lt;K,V&gt; node = lruIndexMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isNotNull(node)</span><br><span class="line">        || firstQueue.contains(key)) &#123;</span><br><span class="line">        <span class="comment">//1.3 删除信息</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line">        <span class="comment">//1.4 加入到 LRU 中</span></span><br><span class="line">        <span class="keyword">this</span>.addToLruMapHead(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 直接加入到 firstQueue 队尾</span></span><br><span class="line">    <span class="comment">//        if(firstQueue.size() &gt;= LIMIT_QUEUE_SIZE) &#123;</span></span><br><span class="line"><span class="comment">//            // 避免第一次访问的列表一直增长，移除队头的元素</span></span><br><span class="line"><span class="comment">//            firstQueue.remove();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    firstQueue.add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我想到了一个优化点，限制 firstQueue 的一直增长，因为遍历的时间复杂度为 O(n)，所以限制最大的大小为 1024。</p><p>如果超过了，则把 FIFO 中的元素先移除掉。</p><p>不过只移除 FIFO，不移除 cache，会导致二者的活跃程度不一致；</p><p>如果同时移除，但是 cache 的大小还没有满足，可能会导致超出用户的预期，这个可以作为一个优化点，暂时注释掉。</p><h5 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h5><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru2Q())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">13</span>:<span class="number">15</span>:<span class="number">50.670</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><h4 id="LRU-2算法实现"><a href="#LRU-2算法实现" class="headerlink" title="LRU-2算法实现"></a>LRU-2算法实现</h4><h5 id="1-实现LRU简介"><a href="#1-实现LRU简介" class="headerlink" title="1.实现LRU简介"></a>1.实现LRU简介</h5><p>FIFO 中的缺点还是比较明显的，需要 O(n) 的时间复杂度做遍历。</p><p>而且命中率和 LRU-2 比起来还是会差一点。</p><p>这里 LRU map 出现了多次，我们为了方便，将 LRU map 简单的封装为一个数据结构。</p><p>我们使用双向链表+HashMap 实现一个简单版本的。</p><h5 id="2-节点"><a href="#2-节点" class="headerlink" title="2.节点"></a>2.节点</h5><p>node 节点和以前一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fluent getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h5><p>我们根据自己的需要，暂时定义 3 个最重要的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU map 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILruMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除最老的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的明细</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICacheEntry&lt;K, V&gt; <span class="title">removeEldest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 key 的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除对应的 key 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">final</span> K key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h5><p>我们基于 DoubleLinkedList + HashMap 实现。</p><p>就是把上一节中的实现整理一下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于双向列表的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMapDoubleList</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ILruMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(LruMapDoubleList.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾巴节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DoubleListNode&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key: 元素信息</span></span><br><span class="line"><span class="comment">     * value: 元素在 list 中对应的节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, DoubleListNode&lt;K,V&gt;&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruMapDoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head.next(<span class="keyword">this</span>.tail);</span><br><span class="line">        <span class="keyword">this</span>.tail.pre(<span class="keyword">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICacheEntry&lt;K, V&gt; <span class="title">removeEldest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取尾巴节点的前一个元素</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; tailPre = <span class="keyword">this</span>.tail.pre();</span><br><span class="line">        <span class="keyword">if</span>(tailPre == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;当前列表为空，无法进行删除&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;不可删除头结点!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        K evictKey = tailPre.key();</span><br><span class="line">        V evictValue = tailPre.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CacheEntry.of(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （1）删除已经存在的</span></span><br><span class="line"><span class="comment">     * （2）新元素放到元素头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 执行删除</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 新元素插入到头部</span></span><br><span class="line">        <span class="comment">//head&lt;-&gt;next</span></span><br><span class="line">        <span class="comment">//变成：head&lt;-&gt;new&lt;-&gt;next</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; newNode = <span class="keyword">new</span> DoubleListNode&lt;&gt;();</span><br><span class="line">        newNode.key(key);</span><br><span class="line"></span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = <span class="keyword">this</span>.head.next();</span><br><span class="line">        <span class="keyword">this</span>.head.next(newNode);</span><br><span class="line">        newNode.pre(<span class="keyword">this</span>.head);</span><br><span class="line">        next.pre(newNode);</span><br><span class="line">        newNode.next(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 插入到 map 中</span></span><br><span class="line">        indexMap.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 获取 map 中的元素</span></span><br><span class="line"><span class="comment">     * 2. 不存在直接返回，存在执行以下步骤：</span></span><br><span class="line"><span class="comment">     * 2.1 删除双向链表中的元素</span></span><br><span class="line"><span class="comment">     * 2.2 删除 map 中的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">        DoubleListNode&lt;K,V&gt; node = indexMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 list node</span></span><br><span class="line">        <span class="comment">// A&lt;-&gt;B&lt;-&gt;C</span></span><br><span class="line">        <span class="comment">// 删除 B，需要变成：A&lt;-&gt;C</span></span><br><span class="line">        DoubleListNode&lt;K,V&gt; pre = node.pre();</span><br><span class="line">        DoubleListNode&lt;K,V&gt; next = node.next();</span><br><span class="line"></span><br><span class="line">        pre.next(next);</span><br><span class="line">        next.pre(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 map 中对应信息</span></span><br><span class="line">        <span class="keyword">this</span>.indexMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexMap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-基本属性"><a href="#5-基本属性" class="headerlink" title="5.基本属性"></a>5.基本属性</h5><p>LRU 的实现保持不变。我们直接将 FIFO 替换为 LRU map 即可。</p><p>为了便于理解，我们将 FIFO 对应为 firstLruMap，用来存放用户只访问了一次的元素。</p><p>将原来的 LRU 中存入访问了 2 次及其以上的元素。</p><p>其他逻辑和 2Q 保持一致。</p><p>定义两个 LRU，用来分别存储访问的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEvictLru2</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCacheEvict</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheEvictLru2.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次访问的 lru</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILruMap&lt;K,V&gt; firstLruMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2次及其以上的 lru</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILruMap&lt;K,V&gt; moreLruMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheEvictLru2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstLruMap = <span class="keyword">new</span> LruMapDoubleList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.moreLruMap = <span class="keyword">new</span> LruMapDoubleList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-淘汰实现"><a href="#6-淘汰实现" class="headerlink" title="6.淘汰实现"></a>6.淘汰实现</h5><p>和 lru 2Q 模式类似，这里我们优先淘汰 firstLruMap 中的数据信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ICacheEntry&lt;K, V&gt; <span class="title">doEvict</span><span class="params">(ICacheEvictContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">    ICacheEntry&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">    <span class="comment">// 超过限制，移除队尾的元素</span></span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class="line">        ICacheEntry&lt;K,V&gt;  evictEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. firstLruMap 不为空，优先移除队列中元素</span></span><br><span class="line">        <span class="keyword">if</span>(!firstLruMap.isEmpty()) &#123;</span><br><span class="line">            evictEntry = firstLruMap.removeEldest();</span><br><span class="line">            log.debug(<span class="string">&quot;从 firstLruMap 中淘汰数据：&#123;&#125;&quot;</span>, evictEntry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 否则从 moreLruMap 中淘汰数据</span></span><br><span class="line">            evictEntry = moreLruMap.removeEldest();</span><br><span class="line">            log.debug(<span class="string">&quot;从 moreLruMap 中淘汰数据：&#123;&#125;&quot;</span>, evictEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行缓存移除操作</span></span><br><span class="line">        <span class="keyword">final</span> K evictKey = evictEntry.key();</span><br><span class="line">        V evictValue = cache.remove(evictKey);</span><br><span class="line">        result = <span class="keyword">new</span> CacheEntry&lt;&gt;(evictKey, evictValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-删除"><a href="#7-删除" class="headerlink" title="7.删除"></a>7.删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 多次 lru 中存在，删除</span></span><br><span class="line"><span class="comment"> * 2. 初次 lru 中存在，删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 多次LRU 删除逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(moreLruMap.contains(key)) &#123;</span><br><span class="line">        moreLruMap.removeKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 从 moreLruMap 中移除&quot;</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLruMap.removeKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 从 firstLruMap 中移除&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-更新"><a href="#8-更新" class="headerlink" title="8.更新"></a>8.更新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新信息</span></span><br><span class="line"><span class="comment"> * 1. 如果 moreLruMap 已经存在，则处理 more 队列，先删除，再插入。</span></span><br><span class="line"><span class="comment"> * 2. 如果 firstLruMap 中已经存在，则处理 first 队列，先删除 firstLruMap，然后插入 Lru。</span></span><br><span class="line"><span class="comment"> * 1 和 2 是不同的场景，但是代码实际上是一样的，删除逻辑中做了二种场景的兼容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 如果不在1、2中，说明是新元素，直接插入到 firstLruMap 的开始即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 元素已经在多次访问，或者第一次访问的 lru 中</span></span><br><span class="line">    <span class="keyword">if</span>(moreLruMap.contains(key)</span><br><span class="line">        || firstLruMap.contains(key)) &#123;</span><br><span class="line">        <span class="comment">//1.1 删除信息</span></span><br><span class="line">        <span class="keyword">this</span>.removeKey(key);</span><br><span class="line">        <span class="comment">//1.2 加入到多次 LRU 中</span></span><br><span class="line">        moreLruMap.updateKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 多次访问，加入到 moreLruMap 中&quot;</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 加入到第一次访问 LRU 中</span></span><br><span class="line">        firstLruMap.updateKey(key);</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125; 为第一次访问，加入到 firstLruMap 中&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上使用 LRU-2 的代码逻辑反而变得清晰了一些，主要是因为我们把 lruMap 作为独立的数据结构抽离了出去</p><h5 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h5><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .evict(CacheEvicts.&lt;String, String&gt;lru2Q())</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line"><span class="comment">// 访问一次A</span></span><br><span class="line">cache.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p><strong>日志</strong></p><p>为了便于定位分析，源代码实现的时候，加了一点日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.966</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: A 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.967</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: B 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.968</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: C 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.970</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.removeKey] - key: A 从 firstLruMap 中移除</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.970</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: A 多次访问，加入到 moreLruMap 中</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.972</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.doEvict] - 从 firstLruMap 中淘汰数据：EvictEntry&#123;key=B, value=<span class="keyword">null</span>&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.974</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: B, value: world, type: evict</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">04.974</span>] [main] [c.g.h.c.c.s.e.CacheEvictLru2.updateKey] - key: D 为第一次访问，加入到 firstLruMap 中</span><br><span class="line">[D, A, C]</span><br></pre></td></tr></table></figure><h5 id="10-小结"><a href="#10-小结" class="headerlink" title="10.小结"></a>10.小结</h5><p>对于 LRU 算法的改进我们主要做了两点：</p><p>（1）性能的改进，从 O(N) 优化到 O(1)</p><p>（2）批量操作的改进，避免缓存污染</p><h3 id="四-过期功能的实现"><a href="#四-过期功能的实现" class="headerlink" title="四.过期功能的实现"></a>四.过期功能的实现</h3><h4 id="缓存接口定义-1"><a href="#缓存接口定义-1" class="headerlink" title="缓存接口定义"></a>缓存接口定义</h4><p>我们首先来定义一下接口。</p><p>主要有两个：一个是多久之后过期，一个是在什么时候过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> timeInMills)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的时间过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeInMills 时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> timeInMills)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存接口实现"><a href="#缓存接口实现" class="headerlink" title="缓存接口实现"></a>缓存接口实现</h4><p>为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。</p><p>核心的代码，主要还是看 cacheExpire 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireTime = System.currentTimeMillis() + timeInMills;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.expireAt(key, expireTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheExpire.expire(key, timeInMills);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存过期接口"><a href="#缓存过期接口" class="headerlink" title="缓存过期接口"></a>缓存过期接口</h4><p>这里为了便于后期拓展，对于过期的处理定义为接口，便于后期灵活替换</p><p>其中 <code>expire(final K key, final long expireAt);</code> 就是我们方法中调用的地方。</p><p>refershExpire 属于惰性删除，需要进行刷新时才考虑，我们后面讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheExpire</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定过期信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireAt 什么时候过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expire</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">long</span> expireAt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 惰性删除中需要处理的 keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyList keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(<span class="keyword">final</span> Collection&lt;K&gt; keyList)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="expire-实现原理"><a href="#expire-实现原理" class="headerlink" title="expire 实现原理"></a>expire 实现原理</h4><p>其实过期的实思路也比较简单：我们可以开启一个定时任务，比如 1 秒钟做一次轮训，将过期的信息清空。</p><h5 id="1-过期信息的存储"><a href="#1-过期信息的存储" class="headerlink" title="1.过期信息的存储"></a>1.过期信息的存储</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过期 map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 空间换时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Long&gt; expireMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> expireAt)</span> </span>&#123;</span><br><span class="line">    expireMap.put(key, expireAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个 map，key 是对应的要过期的信息，value 存储的是过期时间。</p><h5 id="2-轮询清理"><a href="#2-轮询清理" class="headerlink" title="2.轮询清理"></a>2.轮询清理</h5><p>我们固定 100ms 清理一次，每次最多清理 100 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单次清空的数量限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheExpire</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> ExpireThread(), <span class="number">100</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个单线程，用于执行清空任务。</p><h5 id="3-清空任务"><a href="#3-清空任务" class="headerlink" title="3.清空任务"></a>3.清空任务</h5><p>这个非常简单，遍历过期数据，判断对应的时间，如果已经到期了，则执行清空操作。</p><p>为了避免单次执行时间过长，最多只处理 100 条</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(MapUtil.isEmpty(expireMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取 key 进行处理</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= LIMIT) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expireKey(entry);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行过期操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entry 明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expireKey</span><span class="params">(Map.Entry&lt;K, Long&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key = entry.getKey();</span><br><span class="line">    <span class="keyword">final</span> Long expireAt = entry.getValue();</span><br><span class="line">    <span class="comment">// 删除的逻辑处理</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class="line">        expireMap.remove(key);</span><br><span class="line">        <span class="comment">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><h5 id="1-出现的原因"><a href="#1-出现的原因" class="headerlink" title="1.出现的原因"></a>1.出现的原因</h5><p>类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。</p><p>那当我们查询时，可能获取到到是脏数据。</p><p>于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。</p><p>算是一种折中方案。</p><h5 id="2-需要惰性删除的方法"><a href="#2-需要惰性删除的方法" class="headerlink" title="2.需要惰性删除的方法"></a>2.需要惰性删除的方法</h5><p>一般就是各种查询方法，比如我们获取 key 对应的值时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 刷新所有过期信息</span></span><br><span class="line">    K genericKey = (K) key;</span><br><span class="line">    <span class="keyword">this</span>.cacheExpire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在获取之前，先做一次数据的刷新。</p><h5 id="3-刷新的实现"><a href="#3-刷新的实现" class="headerlink" title="3.刷新的实现"></a>3.刷新的实现</h5><p>实现原理也非常简单，就是一个循环，然后作删除即可。</p><p>这里加了一个小的优化：选择数量少的作为外循环。</p><p>循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(Collection&lt;K&gt; keyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断大小，小的作为外循环。一般都是过期的 keys 比较小。</span></span><br><span class="line">    <span class="keyword">if</span>(keyList.size() &lt;= expireMap.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : keyList) &#123;</span><br><span class="line">            expireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.expireKey(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>上面的代码写完之后，我们就可以验证一下了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">3</span>)</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.expire(<span class="string">&quot;1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line"></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, cache.size());</span><br><span class="line"></span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p>结果也符合我们的预期</p><h3 id="五-过期功能的优化"><a href="#五-过期功能的优化" class="headerlink" title="五.过期功能的优化"></a>五.过期功能的优化</h3><p>上面的过期功能的实现中存在两个问题：</p><p>（1）keys 的选择不够随机，可能会导致每次循环 100 个结束时，真正需要过期的没有被遍历到</p><p>（2）keys 的遍历可能大部分都是无效的</p><p>所以下面以过期时间为维度对过期功能进行优化</p><h4 id="基于时间的遍历"><a href="#基于时间的遍历" class="headerlink" title="基于时间的遍历"></a>基于时间的遍历</h4><h5 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h5><p>我们换一种思路，让过期的时间做 key，相同时间的需要过期的信息放在一个列表中，作为 value</p><p>然后对过期时间排序，轮询的时候就可以快速判断出是否有过期的信息了。</p><p>我们每次 put 放入过期元素时，根据过期时间对元素进行排序，相同的过期时间的 Keys 放在一起。</p><p>优点：定时遍历的时候，如果时间不到当前时间，就可以直接返回了，大大降低无效遍历。</p><p>缺点：考虑到惰性删除问题，还是需要存储以删除信息作为 key 的 map 关系，这样内存基本翻倍。</p><h5 id="2-基本属性定义"><a href="#2-基本属性定义" class="headerlink" title="2.基本属性定义"></a>2.基本属性定义</h5><p>我们这里使用 <code>TreeMap</code> 帮助我们进行过期时间的排序，这个集合后续有时间可以详细讲解了，我大概看了下 jdk1.8 的源码，主要是通过红黑树实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheExpireSort</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheExpire</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单次清空的数量限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序缓存存储</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用按照时间排序的缓存处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, List&lt;K&gt;&gt; sortMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (o1 - o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期 map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间换时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Long&gt; expireMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-放入元素时"><a href="#3-放入元素时" class="headerlink" title="3.放入元素时"></a>3.放入元素时</h5><p>每次存入新元素时，同时放入 sortMap 和 expireMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> expireAt)</span> </span>&#123;</span><br><span class="line">    List&lt;K&gt; keys = sortMap.get(expireAt);</span><br><span class="line">    <span class="keyword">if</span>(keys == <span class="keyword">null</span>) &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    keys.add(key);</span><br><span class="line">    <span class="comment">// 设置对应的信息</span></span><br><span class="line">    sortMap.put(expireAt, keys);</span><br><span class="line">    expireMap.put(key, expireAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时任务的执行"><a href="#定时任务的执行" class="headerlink" title="定时任务的执行"></a>定时任务的执行</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><p>我们定义一个定时任务，100ms 执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheExpireSort</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> ExpireThread(), <span class="number">100</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-执行任务"><a href="#2-执行任务" class="headerlink" title="2.执行任务"></a>2.执行任务</h5><p>实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(MapUtil.isEmpty(sortMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取 key 进行处理</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Long, List&lt;K&gt;&gt; entry : sortMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Long expireAt = entry.getKey();</span><br><span class="line">            List&lt;K&gt; expireKeys = entry.getValue();</span><br><span class="line">            <span class="comment">// 判断队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(CollectionUtil.isEmpty(expireKeys)) &#123;</span><br><span class="line">                sortMap.remove(expireAt);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= LIMIT) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除的逻辑处理</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class="line">                Iterator&lt;K&gt; iterator = expireKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    K key = iterator.next();</span><br><span class="line">                    <span class="comment">// 先移除本身</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    expireMap.remove(key);</span><br><span class="line">                    <span class="comment">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class="line">                    cache.remove(key);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接跳过，没有过期的信息</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接遍历 sortMap，对应的 key 就是过期时间，然后和当前时间对比即可。</p><p>删除的时候，需要删除 expireMap/sortMap/cache。</p><h4 id="惰性删除刷新"><a href="#惰性删除刷新" class="headerlink" title="惰性删除刷新"></a>惰性删除刷新</h4><p>惰性删除刷新时，就会用到 expireMap。</p><p>因为有时候刷新的 key 就一个，如果没有 expireMap 映射关系，可能要把 sortMap 全部遍历一遍才能找到对应的过期时间。</p><p>就是一个时间复杂度与空间复杂度衡量的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshExpire</span><span class="params">(Collection&lt;K&gt; keyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历判断过期信息</span></span><br><span class="line">    <span class="comment">// 这样维护两套的代价太大，后续优化，暂时不用。</span></span><br><span class="line">    <span class="comment">// 判断大小，小的作为外循环</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expireSize = expireMap.size();</span><br><span class="line">    <span class="keyword">if</span>(expireSize &lt;= keyList.size()) &#123;</span><br><span class="line">        <span class="comment">// 一般过期的数量都是较少的</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            <span class="comment">// 这里直接执行过期处理，不再判断是否存在于集合中。</span></span><br><span class="line">            <span class="comment">// 因为基于集合的判断，时间复杂度为 O(n)</span></span><br><span class="line">            <span class="keyword">this</span>.removeExpireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : keyList) &#123;</span><br><span class="line">            <span class="keyword">this</span>.removeExpireKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除过期信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeExpireKey</span><span class="params">(<span class="keyword">final</span> K key)</span> </span>&#123;</span><br><span class="line">    Long expireTime = expireMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(expireTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(currentTime &gt;= expireTime) &#123;</span><br><span class="line">            expireMap.remove(key);</span><br><span class="line">            List&lt;K&gt; expireKeys = sortMap.get(expireTime);</span><br><span class="line">            expireKeys.remove(key);</span><br><span class="line">            sortMap.put(expireTime, expireKeys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六-RBD持久化功能的实现"><a href="#六-RBD持久化功能的实现" class="headerlink" title="六.RBD持久化功能的实现"></a>六.RBD持久化功能的实现</h3><p>缓存的持久化功能分为以下两个部分：</p><ul><li>Cache 的内容持久化到文件或者数据库</li><li>初始化的时候加载持久化数据</li></ul><h4 id="持久化操作"><a href="#持久化操作" class="headerlink" title="持久化操作"></a>持久化操作</h4><h5 id="1-持久化操作接口"><a href="#1-持久化操作接口" class="headerlink" title="1.持久化操作接口"></a>1.持久化操作接口</h5><p>为了便于灵活替换，我们定义一个持久化的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-持久化操作接口实现"><a href="#2-持久化操作接口实现" class="headerlink" title="2.持久化操作接口实现"></a>2.持久化操作接口实现</h5><p>我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePersistDbJson</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachePersistDbJson</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化</span></span><br><span class="line"><span class="comment">     * key长度 key+value</span></span><br><span class="line"><span class="comment">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = cache.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        FileUtil.createFile(dbPath);</span><br><span class="line">        <span class="comment">// 清空文件</span></span><br><span class="line">        FileUtil.truncate(dbPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry : entrySet) &#123;</span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            Long expireTime = cache.expire().expireTime(key);</span><br><span class="line">            <span class="comment">// 填充持久化数据</span></span><br><span class="line">            PersistEntry&lt;K,V&gt; persistEntry = <span class="keyword">new</span> PersistEntry&lt;&gt;();</span><br><span class="line">            persistEntry.setKey(key);</span><br><span class="line">            persistEntry.setValue(entry.getValue());</span><br><span class="line">            persistEntry.setExpire(expireTime);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 持久化数据转换为JSON数据</span></span><br><span class="line">            String line = JSON.toJSONString(persistEntry);</span><br><span class="line">            <span class="comment">// JSON数据追加到文件中</span></span><br><span class="line">            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-持久化操作的触发"><a href="#3-持久化操作的触发" class="headerlink" title="3.持久化操作的触发"></a>3.持久化操作的触发</h5><p>上面定义好了一种持久化的策略，但是没有提供对应的触发方式。</p><p>我们就采用对用户透明的设计方式：定时执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerCachePersist</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(InnerCachePersist.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICache&lt;K,V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存持久化策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICachePersist&lt;K,V&gt; persist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程执行类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerCachePersist</span><span class="params">(ICache&lt;K, V&gt; cache, ICachePersist&lt;K, V&gt; persist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">        <span class="keyword">this</span>.persist = persist;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;开始持久化缓存信息&quot;</span>);</span><br><span class="line">                    persist.persist(cache);</span><br><span class="line">                    log.info(<span class="string">&quot;完成持久化缓存信息&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;文件持久化异常&quot;</span>, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时执行的时间间隔为 10min。</p><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h5><p>我们只需要在创建 Cache 时，指定我们的持久化策略即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .load(<span class="keyword">new</span> MyCacheLoad())</span><br><span class="line">        .persist(CachePersists.&lt;String, String&gt;dbJson(<span class="string">&quot;1.rdb&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, cache.size());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>为了确保文件持久化完成，我们沉睡了一会儿。</p><p>测试结果如下</p><p>生成1.rdb文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;key&quot;</span>:<span class="string">&quot;2&quot;</span>,<span class="attr">&quot;value&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;key&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;value&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存数据的加载"><a href="#缓存数据的加载" class="headerlink" title="缓存数据的加载"></a>缓存数据的加载</h4><h5 id="1-缓存初始化接口"><a href="#1-缓存初始化接口" class="headerlink" title="1.缓存初始化接口"></a>1.缓存初始化接口</h5><p>缓存初始化即从持久化中提取数据到缓存内存中</p><p>为了便于后期拓展，定义 ICacheLoad 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheLoad</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> ICache&lt;K,V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-缓存初始化接口实现"><a href="#2-缓存初始化接口实现" class="headerlink" title="2.缓存初始化接口实现"></a>2.缓存初始化接口实现</h5><p>我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载策略-文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLoadDbJson</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheLoad</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheLoadDbJson.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheLoadDbJson</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class="line">        log.info(<span class="string">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String line : lines) &#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="comment">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class="line">            PersistEntry&lt;K,V&gt; entry = JSON.parseObject(line, PersistEntry.class);</span><br><span class="line"></span><br><span class="line">            K key = entry.getKey();</span><br><span class="line">            V value = entry.getValue();</span><br><span class="line">            Long expire = entry.getExpire();</span><br><span class="line"></span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            <span class="keyword">if</span>(ObjectUtil.isNotNull(expire)) &#123;</span><br><span class="line">                cache.expireAt(key, expire);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在初始化时使用即可。</p><h3 id="七-AOF持久化功能的实现"><a href="#七-AOF持久化功能的实现" class="headerlink" title="七.AOF持久化功能的实现"></a>七.AOF持久化功能的实现</h3><h4 id="Redis-AOF-解析"><a href="#Redis-AOF-解析" class="headerlink" title="Redis AOF 解析"></a>Redis AOF 解析</h4><h5 id="1-为什么选择-AOF？"><a href="#1-为什么选择-AOF？" class="headerlink" title="1.为什么选择 AOF？"></a>1.为什么选择 AOF？</h5><p>AOF 模式的<strong>性能特别好</strong>：</p><p>用过 kafka 的同学肯定知道，kafka 也用到了顺序写这个特性。</p><p>顺序写添加文件内容，避免了文件 IO 的随机写问题，性能基本可以和内存媲美。</p><p>AOF 的<strong>实时性更好</strong>，这个是相对于 RDB 模式而言的：</p><p>我们原来使用 RDB 模式，将缓存内容全部持久化，这个是比较耗时的动作，一般是几分钟持久化一次。</p><p>AOF 模式主要是针对修改内容的指令，然后将所有的指令顺序添加到文件中。这样的话，实时性会好很多，可以提升到秒级别，甚至秒级别。可以将AOF模式理解为一个操作流水表</p><h5 id="2-AOF-的吞吐量"><a href="#2-AOF-的吞吐量" class="headerlink" title="2.AOF 的吞吐量"></a>2.AOF 的吞吐量</h5><p>AOF 模式可以每次操作都进行持久化，但是这样会导致吞吐量大大下降。</p><p>提升吞吐量最常用的方式就是<strong>批量</strong>，这个 kafka 中也是类似的，比如我们可以 1s 持久化一次，将 1s 内的操作全部放入 buffer 中。</p><p>这里其实就是一个 trade-off 问题，实时性与吞吐量的平衡艺术。</p><p>实际业务中，1s 的误差一般都是可以接受的，所以这个也是业界比较认可的方式。</p><h5 id="3-AOF-的异步-多线程"><a href="#3-AOF-的异步-多线程" class="headerlink" title="3.AOF 的异步+多线程"></a>3.AOF 的异步+多线程</h5><p>kafka 中所有的操作实际上都是异步+回调的方式实现的。</p><p>异步+多线程，确实可以提升操作的性能。</p><p>当然 redis 6 以前，其实一直是单线程的。那为什么性能依然这么好呢？</p><p>其实多线程也有代价，那就是线程上下文的切换是需要耗时的，保持并发的安全问题，也需要加锁，从而降低性能。</p><p>所以这里要考虑异步的收益，与付出的耗时是否成正比的问题。</p><h5 id="4-AOF-的落盘"><a href="#4-AOF-的落盘" class="headerlink" title="4.AOF 的落盘"></a>4.AOF 的落盘</h5><p>我们 AOF 与 RDB 模式，归根结底都是基于操作系统的文件系统做持久化的。</p><p>对于开发者而言，可能就是调用一个 api 就实现了，但是实际持久化落盘的动作并不见得就是一步完成的。</p><p>文件系统为了提升吞吐量，也会采用类似 buffer 的方式。这忽然有一点俄罗斯套娃的味道。</p><p>但是优秀的设计总是相似的，比如说缓存从 cpu 的设计中就有 L1/L2 等等，思路是一致的。</p><p>阿里的很多开源技术，都会针对操作系统的落盘做进一步的优化，这个我们后续做深入学习</p><h5 id="5-AOF-的缺陷"><a href="#5-AOF-的缺陷" class="headerlink" title="5.AOF 的缺陷"></a>5.AOF 的缺陷</h5><p>大道缺一，没有银弹。</p><p>AOF 千好万好，和 RDB 对比也存在一个缺陷，那就是指令</p><h4 id="AOF注解实现"><a href="#AOF注解实现" class="headerlink" title="AOF注解实现"></a>AOF注解实现</h4><h5 id="1-接口"><a href="#1-接口" class="headerlink" title="1.接口"></a>1.接口</h5><p>接口和 rdb 的保持一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化缓存接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-注解定义"><a href="#2-注解定义" class="headerlink" title="2.注解定义"></a>2.注解定义</h5><p>为了和耗时统计，刷新等特性保持一致，对于操作类的动作才添加到文件中（append to file）我们也基于注解属性来指定，而不是固定写死在代码中，便于后期拓展调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作是否需要 append to file，默认为 false</span></span><br><span class="line"><span class="comment">     * 主要针对 cache 内容有变更的操作，不包括查询操作。</span></span><br><span class="line"><span class="comment">     * 包括删除，添加，过期等操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">aof</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在原来的 <code>@CacheInterceptor</code> 注解中添加 aof 属性，用于指定是否对操作开启 aof 模式</p><h5 id="3-过期操作中启用AOF"><a href="#3-过期操作中启用AOF" class="headerlink" title="3.过期操作中启用AOF"></a>3.过期操作中启用AOF</h5><p>类似于 spring 的事务拦截器，我们使用代理类调用 expireAt。</p><p>expire 方法就不需要添加 aof 拦截了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key         key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expire</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expireTime = System.currentTimeMillis() + timeInMills;</span><br><span class="line">    <span class="comment">// 使用代理调用</span></span><br><span class="line">    Cache&lt;K,V&gt; cachePoxy = (Cache&lt;K, V&gt;) CacheProxy.getProxy(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cachePoxy.expireAt(key, expireTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定过期信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeInMills 时间戳</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICache&lt;K, V&gt; <span class="title">expireAt</span><span class="params">(K key, <span class="keyword">long</span> timeInMills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expire.expire(key, timeInMills);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-变更操作中启用AOF"><a href="#4-变更操作中启用AOF" class="headerlink" title="4.变更操作中启用AOF"></a>4.变更操作中启用AOF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.1 尝试驱除</span></span><br><span class="line">    CacheEvictContext&lt;K,V&gt; context = <span class="keyword">new</span> CacheEvictContext&lt;&gt;();</span><br><span class="line">    context.key(key).size(sizeLimit).cache(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> evictResult = evict.evict(context);</span><br><span class="line">    <span class="keyword">if</span>(evictResult) &#123;</span><br><span class="line">        <span class="comment">// 执行淘汰监听器</span></span><br><span class="line">        ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(value).type(CacheRemoveType.EVICT.code());</span><br><span class="line">        <span class="keyword">for</span>(ICacheRemoveListener&lt;K,V&gt; listener : <span class="keyword">this</span>.removeListeners) &#123;</span><br><span class="line">            listener.listen(removeListenerContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断驱除后的信息</span></span><br><span class="line">    <span class="keyword">if</span>(isSizeLimit()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheRuntimeException(<span class="string">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 执行添加</span></span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    map.putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheInterceptor(refresh = true, aof = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AOF-持久化拦截实现"><a href="#AOF-持久化拦截实现" class="headerlink" title="AOF 持久化拦截实现"></a>AOF 持久化拦截实现</h4><h5 id="1-持久化对象定义"><a href="#1-持久化对象定义" class="headerlink" title="1.持久化对象定义"></a>1.持久化对象定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AOF 持久化明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistAofEntry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;（</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter &amp; setter &amp;toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只需要方法名，和参数对象。</p><p>暂时实现的简单一些即可</p><h5 id="2-持久化拦截器"><a href="#2-持久化拦截器" class="headerlink" title="2.持久化拦截器"></a>2.持久化拦截器</h5><p>我们定义拦截器，当 cache 中定义的持久化类为 <code>CachePersistAof</code> 时，将操作的信息放入到 CachePersistAof 的 buffer 列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptorAof</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheInterceptorAof.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(ICacheInterceptorContext&lt;K,V&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 持久化类</span></span><br><span class="line">        ICache&lt;K,V&gt; cache = context.cache();</span><br><span class="line">        ICachePersist&lt;K,V&gt; persist = cache.persist();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(persist <span class="keyword">instanceof</span> CachePersistAof) &#123;</span><br><span class="line">            CachePersistAof&lt;K,V&gt; cachePersistAof = (CachePersistAof&lt;K,V&gt;) persist;</span><br><span class="line"></span><br><span class="line">            String methodName = context.method().getName();</span><br><span class="line">            PersistAofEntry aofEntry = PersistAofEntry.newInstance();</span><br><span class="line">            aofEntry.setMethodName(methodName);</span><br><span class="line">            aofEntry.setParams(context.params());</span><br><span class="line"></span><br><span class="line">            String json = JSON.toJSONString(aofEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接持久化</span></span><br><span class="line">            log.debug(<span class="string">&quot;AOF 开始追加文件内容：&#123;&#125;&quot;</span>, json);</span><br><span class="line">            cachePersistAof.append(json);</span><br><span class="line">            log.debug(<span class="string">&quot;AOF 完成追加文件内容：&#123;&#125;&quot;</span>, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-拦截器调用"><a href="#3-拦截器调用" class="headerlink" title="3.拦截器调用"></a>3.拦截器调用</h5><p>当 AOF 的注解属性为 true 时，调用上述拦截器即可。</p><p>这里为了避免浪费，只有当持久化类为 AOF 模式时，才进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. AOF 追加</span></span><br><span class="line"><span class="keyword">final</span> ICachePersist cachePersist = cache.persist();</span><br><span class="line"><span class="keyword">if</span>(cacheInterceptor.aof() &amp;&amp; (cachePersist <span class="keyword">instanceof</span> CachePersistAof)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(before) &#123;</span><br><span class="line">        persistInterceptors.before(interceptorContext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        persistInterceptors.after(interceptorContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h4><p>这里的 AOF 模式和以前的 RDB 持久化类只是不同的模式，实际上二者是相同的接口。</p><h5 id="1-接口-1"><a href="#1-接口-1" class="headerlink" title="1.接口"></a>1.接口</h5><p>这里我们统一定义了不同的持久化类的时间，便于 RDB 与 AOF 不同任务的不同时间间隔触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICachePersist</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化缓存信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> ICache&lt;K, V&gt; cache)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间间隔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">period</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">timeUnit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-持久化类实现"><a href="#2-持久化类实现" class="headerlink" title="2.持久化类实现"></a>2.持久化类实现</h5><p>实现一个 Buffer 列表，用于每次拦截器直接顺序添加</p><p>持久化的实现也比较简单，追加到文件之后，直接清空 buffer 列表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存持久化-AOF 持久化模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachePersistAof</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">CachePersistAdaptor</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CachePersistAof.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; bufferList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据持久化路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dbPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachePersistAof</span><span class="params">(String dbPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbPath = dbPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持久化</span></span><br><span class="line"><span class="comment">     * key长度 key+value</span></span><br><span class="line"><span class="comment">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cache 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始 AOF 持久化到文件&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建文件</span></span><br><span class="line">        <span class="keyword">if</span>(!FileUtil.exists(dbPath)) &#123;</span><br><span class="line">            FileUtil.createFile(dbPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 持久化追加到文件中</span></span><br><span class="line">        FileUtil.append(dbPath, bufferList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 清空 buffer 列表</span></span><br><span class="line">        bufferList.clear();</span><br><span class="line">        log.info(<span class="string">&quot;完成 AOF 持久化到文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">period</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimeUnit <span class="title">timeUnit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TimeUnit.SECONDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文件内容到 buffer 列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json json 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> String json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotEmpty(json)) &#123;</span><br><span class="line">            bufferList.add(json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久化测试"><a href="#持久化测试" class="headerlink" title="持久化测试"></a>持久化测试</h4><h5 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1.测试代码"></a>1.测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .persist(CachePersists.&lt;String, String&gt;aof(<span class="string">&quot;1.aof&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.expire(<span class="string">&quot;1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">cache.remove(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="2-测试日志"><a href="#2-测试日志" class="headerlink" title="2.测试日志"></a>2.测试日志</h5><p>expire 实际上调用的是 expireAt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.979</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.980</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.982</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.982</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.984</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 开始追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">41.984</span>] [main] [c.g.h.c.c.s.i.a.CacheInterceptorAof.after] - AOF 完成追加文件内容：&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.088</span>] [pool-<span class="number">1</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: <span class="number">1</span>, value: <span class="number">1</span>, type: expire</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.789</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.InnerCachePersist.run] - 开始持久化缓存信息</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.789</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.CachePersistAof.persist] - 开始 AOF 持久化到文件</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.798</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.CachePersistAof.persist] - 完成 AOF 持久化到文件</span><br><span class="line">[INFO] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">42.799</span>] [pool-<span class="number">2</span>-thread-<span class="number">1</span>] [c.g.h.c.c.s.p.InnerCachePersist.run] - 完成持久化缓存信息</span><br></pre></td></tr></table></figure><h5 id="3-文件内容"><a href="#3-文件内容" class="headerlink" title="3.文件内容"></a>3.文件内容</h5><p><code>1.aof</code> 的文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;expireAt&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="number">1601612441990</span>]&#125;</span><br><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;remove&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;2&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>将每一次的操作，简单的存储到文件中</p><h4 id="AOF-加载实现"><a href="#AOF-加载实现" class="headerlink" title="AOF 加载实现"></a>AOF 加载实现</h4><h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h5><p>类似于 RDB 的加载模式，aof 的加载模式也是类似的。</p><p>我们需要根据文件的内容，还原以前的缓存的内容。</p><p>实现思路：遍历文件内容，反射调用原来的方法。</p><h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><p><strong>解析文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ICache&lt;K, V&gt; cache)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class="line">    log.info(<span class="string">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        <span class="comment">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class="line">        PersistAofEntry entry = JSON.parseObject(line, PersistAofEntry.class);</span><br><span class="line">        <span class="keyword">final</span> String methodName = entry.getMethodName();</span><br><span class="line">        <span class="keyword">final</span> Object[] objects = entry.getParams();</span><br><span class="line">        <span class="keyword">final</span> Method method = METHOD_MAP.get(methodName);</span><br><span class="line">        <span class="comment">// 反射调用</span></span><br><span class="line">        ReflectMethodUtil.invoke(cache, method, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法映射的预加载</strong></p><p>Method 反射是固定的，为了提升性能，我们做一下预处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法缓存</span></span><br><span class="line"><span class="comment"> * 暂时比较简单，直接通过方法判断即可，不必引入参数类型增加复杂度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Method&gt; METHOD_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Method[] methods = Cache.class.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        CacheInterceptor cacheInterceptor = method.getAnnotation(CacheInterceptor.class);</span><br><span class="line">        <span class="keyword">if</span>(cacheInterceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 暂时</span></span><br><span class="line">            <span class="keyword">if</span>(cacheInterceptor.aof()) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                METHOD_MAP.put(methodName, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久化加载测试"><a href="#持久化加载测试" class="headerlink" title="持久化加载测试"></a>持久化加载测试</h4><h5 id="1-文件内容"><a href="#1-文件内容" class="headerlink" title="1.文件内容"></a>1.文件内容</h5><ul><li>default.aof</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;methodName&quot;</span>:<span class="string">&quot;put&quot;</span>,<span class="string">&quot;params&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><h5 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .load(CacheLoads.&lt;String, String&gt;aof(<span class="string">&quot;default.aof&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, cache.size());</span><br><span class="line">System.out.println(cache.keySet());</span><br></pre></td></tr></table></figure><p>直接将 default.aof 文件加载到 cache 缓存中</p><h3 id="八-监听器的开发"><a href="#八-监听器的开发" class="headerlink" title="八.监听器的开发"></a>八.监听器的开发</h3><p>下面我们将一起学习一下如何实现类似 guava-cache 中的 removeListener 删除监听器，和类似 redis 中的慢日志监控的 slowListener</p><p><strong>删除监听器</strong>：将数据驱除或过期时删除的数据记录打印到删除日志中</p><p><strong>慢操作监听器</strong>：当操作变慢时，将警告信息或报警信息打印到慢日志中</p><h4 id="删除监听器的开发"><a href="#删除监听器的开发" class="headerlink" title="删除监听器的开发"></a>删除监听器的开发</h4><h5 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h5><p>我们在两种场景下删除数据是对用户透明的：</p><p>（1）size 满了之后，进行数据淘汰。</p><p>（2）expire 过期时，清除数据。</p><p>这两个特性对用户本来应该是无感的，不过用户如果关心的话，也可以通过添加删除监听器来获取到相关的变更信息</p><h5 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h5><p>为了实现删除的监听，我们需要找到删除的位置，然后调用监听器即可</p><ul><li>evict 驱除的场景</li></ul><p>​    每次 put 数据时，都会校验 size 是否达到最大的限制，如果达到，则进行 evict 淘汰</p><ul><li>expire 过期的场景</li></ul><p>​    用户指定 expire 时间之后，回后台异步执行刷新</p><p>​    也存在惰性删除的场景</p><h5 id="3-接口定义"><a href="#3-接口定义" class="headerlink" title="3.接口定义"></a>3.接口定义</h5><p>为了统一，我们将所有的删除都定义统一的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除监听器接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> ICacheRemoveListenerContext&lt;K,V&gt; context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-内置实现"><a href="#4-内置实现" class="headerlink" title="4.内置实现"></a>4.内置实现</h5><p>系统内置的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(CacheRemoveListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheRemoveListenerContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Remove key: &#123;&#125;, value: &#123;&#125;, type: &#123;&#125;&quot;</span>,</span><br><span class="line">                context.key(), context.value(), context.type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个监听器是默认开启的，暂时无法关闭</p><h5 id="5-自定义"><a href="#5-自定义" class="headerlink" title="5.自定义"></a>5.自定义</h5><p>用户可以自己的需要，进行自定义实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ICacheRemoveListener</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheRemoveListenerContext&lt;K, V&gt; context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【删除提示】可恶，我竟然被删除了！&quot;</span> + context.key());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-使用测试"><a href="#6-使用测试" class="headerlink" title="6.使用测试"></a>6.使用测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .size(<span class="number">1</span>)</span><br><span class="line">        .addRemoveListener(<span class="keyword">new</span> MyRemoveListener&lt;String, String&gt;())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们指定 cache 的大小为1，设置我们自定义的删除监听器</p><p>这里的删除监听器可以添加多个</p><h5 id="7-测试结果"><a href="#7-测试结果" class="headerlink" title="7.测试结果"></a>7.测试结果</h5><p>测试日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">19</span>:<span class="number">32</span>:<span class="number">54.617</span>] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: <span class="number">2</span>, value: <span class="number">2</span>, type: evict</span><br><span class="line">【删除提示】可恶，我竟然被删除了！<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="慢操作监听器开发"><a href="#慢操作监听器开发" class="headerlink" title="慢操作监听器开发"></a>慢操作监听器开发</h4><h5 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h5><p>redis 中会存储慢操作的相关日志信息，主要是由两个参数构成：</p><p>（1）slowlog-log-slower-than 预设阈值,它的单位是毫秒(1秒=1000000微秒)默认值是10000</p><p>（2）slowlog-max-len 最多存储多少条的慢日志记录</p><p>不过 redis 是直接存储到内存中，而且有长度限制。</p><p>根据实际工作体验，如果我们可以添加慢日志的监听，然后有对应的存储或者报警，这样更加方便问题的分析和快速反馈。</p><p>所以我们引入类似于删除的监听器。</p><h5 id="2-实现思路-1"><a href="#2-实现思路-1" class="headerlink" title="2.实现思路"></a>2.实现思路</h5><p>我们处理所有的 cache 操作，并且记录对应的操作耗时。</p><p>如果耗时操作用户设置的时间阈值，则调用慢操作监听器。</p><h5 id="3-接口定义-1"><a href="#3-接口定义-1" class="headerlink" title="3.接口定义"></a>3.接口定义</h5><p>为了保证接口的灵活性，每一个实现都可以定义自己的慢操作阈值，这样便于分级处理。</p><p>比如超过 100ms，用户可以选择输出 warn 日志；超过 1s，可能影响到业务了，可以直接接入报警系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICacheSlowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> ICacheSlowListenerContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 慢日志的阈值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 慢日志的阙值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">slowerThanMills</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-自定义监听器"><a href="#4-自定义监听器" class="headerlink" title="4.自定义监听器"></a>4.自定义监听器</h5><p>实现接口 <code>ICacheSlowListener</code></p><p>这里每一个监听器都可以指定自己的慢日志阈值，便于分级处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySlowListener</span> <span class="keyword">implements</span> <span class="title">ICacheSlowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ICacheSlowListenerContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【慢日志】name: &quot;</span> + context.methodName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">slowerThanMills</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-使用测试"><a href="#5-使用测试" class="headerlink" title="5.使用测试"></a>5.使用测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class="line">        .addSlowListener(<span class="keyword">new</span> MySlowListener())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="6-测试结果"><a href="#6-测试结果" class="headerlink" title="6.测试结果"></a>6.测试结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.547</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: put</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.551</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: put, cost: 10ms</span><br><span class="line">【慢日志】name: put</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.554</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: get</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-09-<span class="number">30</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">11.554</span>] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: get, cost: 1ms</span><br><span class="line">【慢日志】name: get</span><br></pre></td></tr></table></figure><p>实际工作中，我们可以针对慢日志数据存储，便于后期分析。</p><p>也可以直接接入报警系统，及时反馈问题</p><h3 id="九-Redis-渐进式-Rehash详解"><a href="#九-Redis-渐进式-Rehash详解" class="headerlink" title="九.Redis 渐进式 Rehash详解"></a>九.Redis 渐进式 Rehash详解</h3><h4 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h4><h5 id="1-HashMap-的-rehash"><a href="#1-HashMap-的-rehash" class="headerlink" title="1.HashMap 的 rehash"></a>1.HashMap 的 rehash</h5><p>读过 HashMap 源码的同学，应该都知道 map 在扩容的时候，有一个 rehash 的过程</p><h5 id="2-HashMap-的扩容简介"><a href="#2-HashMap-的扩容简介" class="headerlink" title="2.HashMap 的扩容简介"></a>2.HashMap 的扩容简介</h5><p>这里简单介绍下：</p><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素</p><p>当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶</p><h4 id="Redis-中的扩容设计"><a href="#Redis-中的扩容设计" class="headerlink" title="Redis 中的扩容设计"></a>Redis 中的扩容设计</h4><p>HashMap 的扩容需要对集合中大部分的元素进行重新计算，但是对于 redis 这种企业级应用，特别是单线程的应用，如果像传统的 rehash 一样把所有元素来一遍的话，估计要十几秒的时间。</p><p>十几秒对于常见的金融、电商等相对高并发的业务场景，是无法忍受的。</p><p>那么 redis 的 rehash 是如何实现的呢？</p><p>实际上 redis 的 rehash 动作并不是一次性、集中式地完成的， 而是<strong>分多次、渐进式地完成的</strong>。</p><p>这里补充一点，不单单是扩容，缩容也是一样的道理，二者都需要进行 rehash。</p><p>只增不降就是对内存的浪费，浪费就是犯罪，特别是内存还这么贵。</p><p>ps: 这种思想和 key 淘汰有异曲同工之妙，一口吃不了一个大胖子，一次搞不定，那就 1024 次，慢慢来总能解决问题</p><h4 id="Redis-的渐进式-rehash"><a href="#Redis-的渐进式-rehash" class="headerlink" title="Redis 的渐进式 rehash"></a>Redis 的渐进式 rehash</h4><p>这部分直接选自经典入门书籍《Redis 设计与实现》</p><h5 id="1-为什么要渐进式处理？"><a href="#1-为什么要渐进式处理？" class="headerlink" title="1.为什么要渐进式处理？"></a>1.为什么要渐进式处理？</h5><p>实际上 redis 内部有两个 hashtable，我们称之为 ht[0] 和 ht[1]。传统的 HashMap 中只有一个。</p><p>为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p><h5 id="2-详细步骤"><a href="#2-详细步骤" class="headerlink" title="2.详细步骤"></a>2.详细步骤</h5><p>哈希表渐进式 rehash 的详细步骤：</p><p>（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</p><p>（2）在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</p><p>（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增1。</p><p>（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</p><p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p><h5 id="3-rehash-间的操作怎么兼容呢？"><a href="#3-rehash-间的操作怎么兼容呢？" class="headerlink" title="3.rehash 间的操作怎么兼容呢？"></a>3.rehash 间的操作怎么兼容呢？</h5><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 那这期间的操作如何保证正常进行呢？</p><p>（1）查询一个信息</p><p>这个类似于我们的数据库信息等迁移，先查询一个库，没有的话，再去查询另一个库。</p><p>ht[0] 中没找到，我们去 ht[1] 中查询即可。</p><p>（2）新数据怎么办？</p><p>这个和数据迁移一样的道理。</p><p>当我们有新旧的两个系统时，新来的用户等信息直接落在新系统即可，</p><p>这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h5 id="1-什么时候判断？"><a href="#1-什么时候判断？" class="headerlink" title="1.什么时候判断？"></a>1.什么时候判断？</h5><p>redis 在每次执行 put 操作的时候，就可以检查是否需要扩容。</p><p>其实也很好理解，put 插入元素的时候，判断是否需要扩容，然后开始扩容，是直接的一种思路。</p><p>留一个思考题：我们可以在其他的时候判断吗？</p><h5 id="2-redis-判断是否需要扩容的源码"><a href="#2-redis-判断是否需要扩容的源码" class="headerlink" title="2.redis 判断是否需要扩容的源码"></a>2.redis 判断是否需要扩容的源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictExpandIfNeeded</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">// 如果正在进行渐进式扩容，则返回OK</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="comment">// 如果哈希表ht[0]的大小为0，则初始化字典</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果哈希表ht[0]中保存的key个数与哈希表大小的比例已经达到1:1，即保存的节点数已经大于哈希表大小</span></span><br><span class="line"><span class="comment">     * 且redis服务当前允许执行rehash，或者保存的节点数与哈希表大小的比例超过了安全阈值（默认值为5）</span></span><br><span class="line"><span class="comment">     * 则将哈希表大小扩容为原来的两倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的条件总结下来就是两句话：</p><p>（1）服务器目前没有在执行 BGSAVE/BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1；</p><p>（2）服务器目前正在执行 BGSAVE/BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5；</p><p>这里其实体现了作者的一种设计思想：如果负载因子超过5，说明信息已经很多了，管你在不在保存，都要执行扩容，优先保证服务可用性。如果没那么高，那就等持久化完成再做 rehash。</p><p>我们自己在实现的时候可以简化一下，比如只考虑情况2。</p><h5 id="3-扩容到原来的多少？"><a href="#3-扩容到原来的多少？" class="headerlink" title="3.扩容到原来的多少？"></a>3.扩容到原来的多少？</h5><p>知道了什么时候应该开始扩容，但是要扩容到多大也是值得思考的一个问题。</p><p>扩容的太小，会导致频繁扩容，浪费性能。</p><p>扩容的太大，会导致资源的浪费。</p><p>其实这个最好的方案是结合我们实际的业务，不过这部分对用户是透明的。</p><p>一般是扩容为原来的两倍。</p><h5 id="4-为什么需要扩容？"><a href="#4-为什么需要扩容？" class="headerlink" title="4.为什么需要扩容？"></a>4.为什么需要扩容？</h5><p>我们在实现 ArrayList 的时候需要扩容，因为数据放不下了。</p><p>我们知道 HashMap 的底层是数组 + 链表（红黑树）的数据结构。</p><p>那么会存在放不下的情况吗？</p><p>个人理解实际上不会。因为链表可以一直加下去。</p><p>那为什么需要扩容呢？</p><p>实际上更多的是处于性能的考虑。我们使用 HashMap 就是为了提升性能，如果一直不扩容，可以理解为元素都 hash 到相同的 bucket 上，这时就退化成了一个链表。</p><p>这会导致查询等操作性能大大降低。</p><h4 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h4><h5 id="1-什么时候判断？-1"><a href="#1-什么时候判断？-1" class="headerlink" title="1.什么时候判断？"></a>1.什么时候判断？</h5><p>看了前面的扩容，我们比较直观地方式是在用户 remove 元素的时候执行是否需要缩容。</p><p>不过 redis 并不完全等同于传统的 HashMap，还有数据的淘汰和过期，这些是对用户透明的。</p><p>redis 采用的方式实际上是一个定时任务。</p><p>个人理解内存缩容很重要，但是没有那么紧急，我们可以 1min 扫描一次，这样可以节省机器资源。</p><p>实际工作中，一般 redis 的内存都是逐步上升的，或者稳定在一个范围内，很少去大批量删除数据。（除非数据搞错了，我就遇到过一次，数据同步错地方了）。</p><p>所以数据删除，一般几分钟内给用户一个反馈就行。</p><p>知其然，知其所以然。</p><p>我们懂得了这个道理也就懂得了为什么有时候删除 redis 的几百万 keys，内存也不是直接降下来的原因。</p><h5 id="2-缩容的条件"><a href="#2-缩容的条件" class="headerlink" title="2.缩容的条件"></a>2.缩容的条件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL</span></span><br><span class="line"><span class="comment"> * we resize the hash table to save memory */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tryResizeHashTables</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].dict))</span><br><span class="line">        dictResize(server.db[dbid].dict);</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].expires))</span><br><span class="line">        dictResize(server.db[dbid].expires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table parameters */</span></span><br><span class="line">#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和扩容类似，不过这里的缩容比例不是 5 倍，而是当哈希表保存的key数量与哈希表的大小的比例小于 10% 时需要缩容。</p><h5 id="3-缩容到多少？"><a href="#3-缩容到多少？" class="headerlink" title="3.缩容到多少？"></a>3.缩容到多少？</h5><p>最简单的方式是直接变为原来的一半，不过这么做有时候也不是那么好用。</p><p>redis 是<strong>缩容后的大小为第一个大于等于当前key数量的2的n次方。</strong></p><p>这个可能不太好理解，举几个数字就懂了：</p><table><thead><tr><th align="left">keys数量</th><th align="left">缩容大小</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">4</td></tr><tr><td align="left">4</td><td align="left">4</td></tr><tr><td align="left">5</td><td align="left">8</td></tr><tr><td align="left">9</td><td align="left">16</td></tr></tbody></table><p>主要保障以下3点：</p><p>（1）缩容之后，要大于等于 key 的数量</p><p>（2）尽可能的小，节约内存</p><p>（3）2 的倍数。</p><p>第三个看过 HashMap 源码讲解的小伙伴应该深有体会。</p><p>当然也不能太小，redis 限制的最小为 4。</p><p>实际上如果 redis 中只放 4 个 key，实在是杀鸡用牛刀，一般不会这么小。</p><p>我们在实现的时候，直接参考 jdk 好了，给个最小值限制 8。</p><h5 id="4-为什么需要缩容？"><a href="#4-为什么需要缩容？" class="headerlink" title="4.为什么需要缩容？"></a>4.为什么需要缩容？</h5><p>最核心的目的就是为了节约内存，其实还有一个原因，叫 small means fast（小即是快——老马）。</p><h4 id="渐进式-ReHash-实现的思考"><a href="#渐进式-ReHash-实现的思考" class="headerlink" title="渐进式 ReHash 实现的思考"></a>渐进式 ReHash 实现的思考</h4><p>好了，扩容和缩容就聊到这里，那么这个渐进式 rehash 到底怎么一个渐进法？</p><h5 id="1-扩容前"><a href="#1-扩容前" class="headerlink" title="1.扩容前"></a>1.扩容前</h5><p>不需要扩容时应该有至少需要初始化两个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = <span class="keyword">new</span> HashTable(size);</span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>hashtable 中存储着当前的元素信息，hashIndex=-1 标识当前没有在进行扩容。</p><h5 id="2-扩容准备"><a href="#2-扩容准备" class="headerlink" title="2.扩容准备"></a>2.扩容准备</h5><p>当需要扩容的时候，我们再去创建一个 hashtable[1]，并且 size 是原来的 2倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = <span class="keyword">new</span> HashTable(size);</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">new</span> HashTable(<span class="number">2</span> * size);</span><br><span class="line"></span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>主要是为了节约内存，使用惰性初始化的方式创建 hashtable。</p><h5 id="3-扩容时"><a href="#3-扩容时" class="headerlink" title="3.扩容时"></a>3.扩容时</h5><p>调整 hashIndex=0…size，逐步去 rehash 到新的 hashtable[1]</p><p>新的插入全部放入到 hashtable[1]</p><h5 id="4-扩容后"><a href="#4-扩容后" class="headerlink" title="4.扩容后"></a>4.扩容后</h5><p>扩容后我们应该把 hashtable[0] 的值更新为 hashtable[1]，并且释放掉 hashtable[1] 的资源。</p><p>并且设置 hashIndex=-1，标识已经 rehash 完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">0</span>] = hashtable[<span class="number">1</span>];</span><br><span class="line">hashIndex=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hashtable[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这样整体的实现思路就已经差不多了，光说不练假把式，我们下一节就来自己实现一个渐进式 rehash 的 HashMap</p><h3 id="十-实现渐进式ReHash-Map类定义"><a href="#十-实现渐进式ReHash-Map类定义" class="headerlink" title="十.实现渐进式ReHash Map类定义"></a>十.实现渐进式ReHash Map类定义</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己实现的渐进式 rehash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; key 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; value 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProgressiveReHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和简易版本类似。</p><h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(MyProgressiveReHashMap.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rehash 的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 rehashIndex != -1，说明正在进行 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rehashIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量</span></span><br><span class="line"><span class="comment"> * 默认为 8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处于 rehash 状态的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rehashCapacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计大小的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阈值</span></span><br><span class="line"><span class="comment"> * 阈值=容量*factor</span></span><br><span class="line"><span class="comment"> * 暂时不考虑最大值的问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当达到这个阈值的时候，直接进行两倍的容量扩充+rehash。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存放信息的 table 数组。</span></span><br><span class="line"><span class="comment"> * 数组：数组的下标是一个桶，桶对应的元素 hash 值相同。</span></span><br><span class="line"><span class="comment"> * 桶里放置的是一个链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以理解为 table 是一个 ArrayList</span></span><br><span class="line"><span class="comment"> * arrayList 中每一个元素，都是一个 DoubleLinkedList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Entry&lt;K, V&gt;&gt;&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渐进式 rehash 时，用来存储元素信息使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Entry&lt;K, V&gt;&gt;&gt; rehashTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否开启 debug 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> debugMode = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>rehashIndex/rehashCapacity/rehashTable 这三个值都是我们在进行渐进式实现的时候需要使用的值。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>主要是一些值的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> debugMode 是否开启 debug 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProgressiveReHashMap</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> debugMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 初始化最大为容量的个数，如果 hash 的非常完美的话。</span></span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">    <span class="comment">// 初始化为空列表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.table.add(i, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.debugMode = debugMode;</span><br><span class="line">    <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashCapacity = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashTable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h4><p>这个方法相对难度比较大：</p><p>put() 的过程可以见方法的注释。</p><p>需要考虑是否为 rehash 阶段，还需要考虑是否为更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put 一个值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果不处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.1 判断是否为 table 更新，如果是，则进行更新</span></span><br><span class="line"><span class="comment"> * 1.2 如果不是更新，则进行插入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 插入的时候可能触发 rehash</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （2）如果处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.0 执行一次渐进式 rehash 的动作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1 判断是否为更新，需要遍历 table 和 rehashTable</span></span><br><span class="line"><span class="comment"> * 如果是，执行更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.2 如果不是，则执行插入</span></span><br><span class="line"><span class="comment"> * 插入到 rehashTable 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInRehash = isInReHash();</span><br><span class="line">    <span class="keyword">if</span>(!isInRehash) &#123;</span><br><span class="line">        <span class="comment">//1. 是否为更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair = updateTableInfo(key, value, <span class="keyword">this</span>.table, <span class="keyword">this</span>.capacity);</span><br><span class="line">        <span class="keyword">if</span>(pair.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;不处于渐进式 rehash，此次为更新操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createNewEntry(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2.0 执行一个附加操作，进行渐进式 rehash 处理</span></span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 阶段，额外执行一次渐进式 rehash 的动作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rehashToNew();</span><br><span class="line">        <span class="comment">//2.1 是否为 table 更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair = updateTableInfo(key, value, <span class="keyword">this</span>.table, <span class="keyword">this</span>.capacity);</span><br><span class="line">        <span class="keyword">if</span>(pair.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;此次为更新 table 操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 是否为 rehashTable 更新</span></span><br><span class="line">        Pair&lt;Boolean, V&gt; pair2 = updateTableInfo(key, value, <span class="keyword">this</span>.rehashTable, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        <span class="keyword">if</span>(pair2.getValueOne()) &#123;</span><br><span class="line">            V oldVal = pair2.getValueTwo();</span><br><span class="line">            <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;此次为更新 rehashTable 操作。key: &#123;&#125;, value: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">                printTable(<span class="keyword">this</span>.table);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.3 插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createNewEntry(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-是否为-rehash-阶段"><a href="#1-是否为-rehash-阶段" class="headerlink" title="1.是否为 rehash 阶段"></a>1.是否为 rehash 阶段</h5><p>这个实现比较简单，就是判断 rehashIndex 是否为 -1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否处于 rehash 阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInReHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rehashIndex != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-更新列表信息"><a href="#2-更新列表信息" class="headerlink" title="2.更新列表信息"></a>2.更新列表信息</h5><p>这里为了复用，对方法进行了抽象。可以同时使用到 table 和 rehashTable 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为更新信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> table table 信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableCapacity table 的容量（使用 size 也可以，因为都默认初始化了。）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 更新结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Pair&lt;Boolean, V&gt; <span class="title">updateTableInfo</span><span class="params">(K key, V value, <span class="keyword">final</span> List&lt;List&lt;Entry&lt;K,V&gt;&gt;&gt; table,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> <span class="keyword">int</span> tableCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 index 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = HashUtil.hash(key);</span><br><span class="line">    <span class="keyword">int</span> index = HashUtil.indexFor(hash, tableCapacity);</span><br><span class="line">    <span class="comment">// 判断是否为替换</span></span><br><span class="line">    List&lt;Entry&lt;K,V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(index &lt; table.size()) &#123;</span><br><span class="line">        entryList = table.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; entry : entryList) &#123;</span><br><span class="line">        <span class="comment">// 二者的 key 都为 null，或者二者的 key equals()</span></span><br><span class="line">        <span class="keyword">final</span> K entryKey = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtil.isNull(key, entryKey)</span><br><span class="line">                || key.equals(entryKey)) &#123;</span><br><span class="line">            <span class="keyword">final</span> V oldValue = entry.getValue();</span><br><span class="line">            <span class="comment">// 更新新的 value</span></span><br><span class="line">            entry.setValue(value);</span><br><span class="line">            <span class="keyword">return</span> Pair.of(<span class="keyword">true</span>, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pair.of(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和以前基本是类似的。</p><p>返回结果时，为了同时保存是否为更新，以及更新的 value 值。所以使用了 Pair 工具类。</p><h5 id="3-插入新的元素"><a href="#3-插入新的元素" class="headerlink" title="3.插入新的元素"></a>3.插入新的元素</h5><p>插入方法也比较麻烦，需要区分是否处于渐进式 rehash 阶段。还要考虑是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的明细</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果处于渐进式 rehash 中，则设置到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （2）如果不是，则判断是否需要扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1 如果扩容，则直接放到 rehashTable 中。</span></span><br><span class="line"><span class="comment"> * 因为我们每次扩容内存翻倍，一次只处理一个 index 的信息，所以不会直接 rehash 结束，直接放到新的 rehashTable 中即可</span></span><br><span class="line"><span class="comment"> * 2.2 如果不扩容，则放入 table 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">createNewEntry</span><span class="params">(<span class="keyword">final</span> K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; entry = <span class="keyword">new</span> DefaultMapEntry&lt;&gt;(key, value);</span><br><span class="line">    <span class="comment">// 重新计算 tableIndex</span></span><br><span class="line">    <span class="keyword">int</span> hash = HashUtil.hash(key);</span><br><span class="line">    <span class="comment">//是否处于 rehash 中？</span></span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.rehashTable.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前处于 rehash 中，元素直接插入到 rehashTable 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.rehashTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否需要扩容 &amp;&amp; 不处于渐进式 rehash</span></span><br><span class="line">    <span class="comment">// rehash 一定是扩容 rehashTable</span></span><br><span class="line">    <span class="comment">// 如果发生了 rehash，元素是直接放到 rehashTable 中的</span></span><br><span class="line">    <span class="keyword">if</span>(isNeedExpand()) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">        <span class="comment">// 放入到 rehashTable 中</span></span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.rehashTable.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前处于 rehash 中，元素直接插入到 rehashTable 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.rehashTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, <span class="keyword">this</span>.capacity);</span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; list = <span class="keyword">this</span>.table.get(index);</span><br><span class="line">        list.add(entry);</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;目前不处于 rehash 中，元素直接插入到 table 中。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.table);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否需要扩容的方法也比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比例满足，且不处于渐进式 rehash 中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNeedExpand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证比例</span></span><br><span class="line">    <span class="keyword">double</span> rate = size*<span class="number">1.0</span> / capacity*<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> rate &gt;= factor &amp;&amp; !isInReHash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们这次添加了一个不要处于渐进式 rehash 过程中。</p><p>其中 rehash 的实现也发生了很大的变化，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接 rehash 的流程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）如果处于 rehash 中，直接返回</span></span><br><span class="line"><span class="comment"> * （2）初始化 rehashTable，并且更新 rehashIndex=0;</span></span><br><span class="line"><span class="comment"> * （3）获取 table[0]，rehash 到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （4）设置 table[0] = new ArrayList();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 阶段，不重复进行 rehash!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 rehashTable</span></span><br><span class="line">    <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rehashCapacity = <span class="number">2</span>*capacity;</span><br><span class="line">    <span class="keyword">this</span>.rehashTable = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.rehashCapacity);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rehashCapacity; i++) &#123;</span><br><span class="line">        rehashTable.add(i, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素第一个元素，其他的进行渐进式更新。</span></span><br><span class="line">    rehashToNew();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渐进式更新的方法，可以在 get/put/remove 等操作时，执行附加操作时使用。</p><p>所以单独抽成了一个方法，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将信息从旧的 table 迁移到新的 table 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （1）table[rehashIndex] 重新 rehash 到 rehashTable 中</span></span><br><span class="line"><span class="comment"> * （2）设置 table[rehashIndex] = new ArrayList();</span></span><br><span class="line"><span class="comment"> * （3）判断是否完成渐进式 rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehashToNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rehashIndex++;</span><br><span class="line"></span><br><span class="line">    List&lt;Entry&lt;K, V&gt;&gt; list = table.get(rehashIndex);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; entry : list) &#123;</span><br><span class="line">        <span class="keyword">int</span> hash = HashUtil.hash(entry);</span><br><span class="line">        <span class="keyword">int</span> index = HashUtil.indexFor(hash, rehashCapacity);</span><br><span class="line">        <span class="comment">//  添加元素</span></span><br><span class="line">        <span class="comment">// 获取列表，避免数组越界</span></span><br><span class="line">        List&lt;Entry&lt;K,V&gt;&gt; newList = rehashTable.get(index);</span><br><span class="line">        <span class="comment">// 添加元素到列表</span></span><br><span class="line">        <span class="comment">// 元素不存在重复，所以不需要考虑更新</span></span><br><span class="line">        newList.add(entry);</span><br><span class="line">        rehashTable.set(index, newList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 index 处的信息</span></span><br><span class="line">    table.set(rehashIndex, <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断大小是否完成 rehash</span></span><br><span class="line">    <span class="comment">// 验证是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span>(rehashIndex == (table.size()-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="keyword">this</span>.rehashCapacity;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">this</span>.rehashTable;</span><br><span class="line">        <span class="keyword">this</span>.rehashIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rehashCapacity = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rehashTable = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;渐进式 rehash 已经完成。&quot;</span>);</span><br><span class="line">            printTable(<span class="keyword">this</span>.table);</span><br><span class="line">        &#125;p</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;渐进式 rehash 处理中, 目前 index：&#123;&#125; 已完成&quot;</span>, rehashIndex);</span><br><span class="line">            printAllTable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-操作"><a href="#get-操作" class="headerlink" title="get() 操作"></a>get() 操作</h4><p>渐进式 rehash 将动作分散到每一个操作中，我们对 get 方法进行重写，当做一个例子。其他的方法如果实现也是类似的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询方法</span></span><br><span class="line"><span class="comment"> * （1）如果处于渐进式 rehash 状态，额外执行一次 rehashToNew()</span></span><br><span class="line"><span class="comment"> * （2）判断 table 中是否存在元素</span></span><br><span class="line"><span class="comment"> * （3）判断 rehashTable 中是否存在元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(debugMode) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前处于渐进式 rehash 状态，额外执行一次操作&quot;</span>);</span><br><span class="line">            rehashToNew();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断 table 中是否存在</span></span><br><span class="line">    V result = getValue(key, <span class="keyword">this</span>.table);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 是否处于渐进式 rehash</span></span><br><span class="line">    <span class="keyword">if</span>(isInReHash()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getValue(key, <span class="keyword">this</span>.rehashTable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>我们历经千辛万苦，终于实现了一个简单版本的渐进式 hash map。</p><p>下面来测试一下功能是否符合我们的预期。</p><h5 id="1-put-操作"><a href="#1-put-操作" class="headerlink" title="1.put 操作"></a>1.put 操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> MyProgressiveReHashMap&lt;&gt;(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">30</span>:<span class="number">15.072</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">30</span>:<span class="number">15.076</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.put] - 不处于渐进式 rehash，此次为更新操作。key: <span class="number">1</span>, value: <span class="number">2</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>&#125; </span><br></pre></td></tr></table></figure><p>第一次是插入，第二次是更新。</p><p>这里都没有触发扩容，下面我们看一下触发扩容的情况。</p><h5 id="2-扩容测试"><a href="#2-扩容测试" class="headerlink" title="2.扩容测试"></a>2.扩容测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> MyProgressiveReHashMap&lt;&gt;(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;1&quot;</span>, map.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;2&quot;</span>, map.get(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;3&quot;</span>, map.get(<span class="string">&quot;3&quot;</span>));</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.559</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.560</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前不处于 rehash 中，元素直接插入到 table 中。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.563</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.rehashToNew] - 渐进式 rehash 处理中, 目前 index：<span class="number">0</span> 已完成</span><br><span class="line">原始 table 信息: </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">新的 table 信息: </span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.563</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.createNewEntry] - 目前处于 rehash 中，元素直接插入到 rehashTable 中。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">3</span>&#125; </span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.564</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.get] - 当前处于渐进式 rehash 状态，额外执行一次操作</span><br><span class="line">[DEBUG] [<span class="number">2020</span>-<span class="number">10</span>-<span class="number">11</span> <span class="number">21</span>:<span class="number">31</span>:<span class="number">12.564</span>] [main] [c.g.h.d.s.c.u.m.MyProgressiveReHashMap.rehashToNew] - 渐进式 rehash 已经完成。</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">2</span>&#125; </span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>&#125; </span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">3</span>&#125; </span><br></pre></td></tr></table></figure><p>当放入元素【3】的时候，已经触发了 rehash。</p><p>（1）第一次渐进式 rehash 将 table[0] 的元素 rehash 到了新的节点。</p><p>（2）插入的元素直接插入到 rehashTable 中</p><p>（3）get 操作时，额外触发一次 rehash，然后所有的 rehash 已经完成。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/4ffc613d6eaf">Fluent Interface 流式接口</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202205211137136.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
      <category term="Redis" scheme="https://autovy.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|MySQL最佳实践</title>
    <link href="https://autovy.github.io/2022/02/25/DevPrinciple/MySQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://autovy.github.io/2022/02/25/DevPrinciple/MySQL%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-02-25T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.156Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.staticdn.net/Autovy/Image/master/img/202203041310207.png" alt="image-20220304131032975" style="zoom: 33%;"><p>MySQL  ❎</p><p>OurSQL ✅</p><span id="more"></span><h3 id="Debain安装MySQL"><a href="#Debain安装MySQL" class="headerlink" title="Debain安装MySQL"></a>Debain安装MySQL</h3><h4 id="添加-MySQL-存储库"><a href="#添加-MySQL-存储库" class="headerlink" title="添加 MySQL 存储库"></a>添加 MySQL 存储库</h4><p>MySQL 服务器包可通过其官方存储库获得。 因此，我们现在将下载并安装 MySQL 存储库安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.18-1_all.deb</span><br></pre></td></tr></table></figure><p>使用 <code>dpkg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config_0.8.18-1_all.deb</span><br></pre></td></tr></table></figure><p>进入mysql安装页面选择ok即可</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203021941621.png" alt="image-20220302194144873"></p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><p>等待存储库配置完成，然后使用 apt 命令更新存储库索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>安装mysql服务器</p><p>使用apt-get install mysql-server安装时，如果出现报错Package ‘mysql-server’ has no installation candidate，可以使用下面的命令进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>理论上这时候的mysql服务已经安装完成了，我们可以通过命令service –status-all 查看到服务列表中有mariadb</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203021949399.png" alt="image-20220302194955961"></p><p>但是使用mysql命令时，会出现以下报错，这是因为mariadb服务还未启动</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203021952567.png" alt="image-20220302195236210"></p><p>使用以下命令启动即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mariadb start</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203021955103.png" alt="image-20220302195514826"></p><h3 id="命令行准备数据库"><a href="#命令行准备数据库" class="headerlink" title="命令行准备数据库"></a>命令行准备数据库</h3><h4 id="root账号进入数据库"><a href="#root账号进入数据库" class="headerlink" title="root账号进入数据库"></a>root账号进入数据库</h4><p>mysql命令进入mysql服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br></pre></td></tr></table></figure><p>修改root账号密码</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022003140.png" alt="image-20220302200352926"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password for root@localhost &#x3D; password(&quot;123456&quot;)</span><br></pre></td></tr></table></figure><p>退出mysql服务，并使用root账号登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022006437.png" alt></p><h4 id="新用户与新数据库"><a href="#新用户与新数据库" class="headerlink" title="新用户与新数据库"></a>新用户与新数据库</h4><p>创建新数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database testdb;</span><br></pre></td></tr></table></figure><p>查看已有数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022010700.png" alt="image-20220302201054361"></p><p>创建新用户</p><p>@localhost设置只允许用户本地登录，并设置其密码为123456</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user aut@localhost identifide by &#39;123456&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022015408.png" alt="image-20220302201501975"></p><p>查看用户列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user for mysql.user</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022018844.png" alt="image-20220302201847575"></p><p>分配新数据库给新用户</p><p>注意这里是指将testdb库的所有表（testdb.*）的所有权限（all）给aut本地使用（localhost）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on testdb.* to aut@localhost;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022027073.png" alt="image-20220302202739833"></p><p>查看用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for aut@localhost;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022031370.png" alt="image-20220302203155016"></p><h4 id="测试数据准备"><a href="#测试数据准备" class="headerlink" title="测试数据准备"></a>测试数据准备</h4><p>使用新用户aut连接mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u aut -p</span><br></pre></td></tr></table></figure><p>切换数据库到新数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use testdb;</span><br></pre></td></tr></table></figure><p>创建一个只含一个字段的数据表</p><p>test表只含有一个整型不为空的字段money</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table test (money int not null)</span><br></pre></td></tr></table></figure><p>添加一条数据到表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test(money) values(5000) </span><br></pre></td></tr></table></figure><h3 id="MySQL事务隔离实验"><a href="#MySQL事务隔离实验" class="headerlink" title="MySQL事务隔离实验"></a>MySQL事务隔离实验</h3><p>新开一个终端使用连接上新数据库testdb（可以aut，也可以自己新建一个用户）</p><h4 id="读未提交级别"><a href="#读未提交级别" class="headerlink" title="读未提交级别"></a>读未提交级别</h4><p>出现脏读问题</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022050355.jpeg" alt="img"></p><h4 id="读已提交级别"><a href="#读已提交级别" class="headerlink" title="读已提交级别"></a>读已提交级别</h4><p>避免脏读，但是不可重复读</p><h5 id="1-避免脏读测试"><a href="#1-避免脏读测试" class="headerlink" title="1.避免脏读测试"></a>1.避免脏读测试</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022051306.jpeg" alt="img"></p><h5 id="2-不可重复读测试"><a href="#2-不可重复读测试" class="headerlink" title="2.不可重复读测试"></a>2.不可重复读测试</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022051474.jpeg" alt="img"></p><h4 id="可重复读级别"><a href="#可重复读级别" class="headerlink" title="可重复读级别"></a>可重复读级别</h4><p>可以重复读，并且可以防止幻读</p><h5 id="1-可重复读测试"><a href="#1-可重复读测试" class="headerlink" title="1.可重复读测试"></a>1.可重复读测试</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022052001.jpeg" alt="img"></p><h5 id="2-防止幻读测试"><a href="#2-防止幻读测试" class="headerlink" title="2.防止幻读测试"></a>2.防止幻读测试</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022052706.jpeg" alt="img"></p><h3 id="MySQL优化实验"><a href="#MySQL优化实验" class="headerlink" title="MySQL优化实验"></a>MySQL优化实验</h3><p>上面的实验全程在Linux环境中，在日常开发中我们可以使用数据库可视化工具如Navicat或IDEA自带的数据库工具，下面我主要使用Navicat进行操作</p><p>此章节的优化实例来自一次对学校校团委物资管理系统的维护，鉴于此项目糟心的数据库设计，给我留下了深刻的印象，难以想象的是这样的项目竟然从16年运行至今</p><h4 id="T-SQL脚本分表优化"><a href="#T-SQL脚本分表优化" class="headerlink" title="T-SQL脚本分表优化"></a>T-SQL脚本分表优化</h4><h5 id="1-相关表的结构"><a href="#1-相关表的结构" class="headerlink" title="1.相关表的结构"></a>1.相关表的结构</h5><p>此处展示的表结构为维护前</p><p>物资申请表：共4817条数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031543098.png" alt="image-20220303154338625"></p><p>物资信息表：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031545235.png" alt="image-20220303154513022"></p><p>goods_count：当前仓库物品数（物理的）</p><p>good_leftCount：当前物品可借数（网络的：存在部分未借出，但已被预订仍在审核中的物品）</p><h5 id="2-优化思路：物资申请表分表"><a href="#2-优化思路：物资申请表分表" class="headerlink" title="2.优化思路：物资申请表分表"></a>2.优化思路：物资申请表分表</h5><p>从上面的tw_apply表就可以知道：</p><ul><li><p>在用户提出申请后，物资申请信息被后端拼成了一个字符串存储在apply_content（同时利用了前端的数据执行了物品可借数的预扣除，所以这部分没有用到物资申请信息字符串的解析）</p></li><li><p>通过审核后，物品正式借出，这时候只留有物资申请信息的字符串存储在数据库，所以需要后端对该字符串解析提取出申请物资与其借用数量，再去操作数据库</p></li></ul><p>还好后端大哥没有把物资申请信息的字符串直接发给前端，我真的哭死，设计数据库的那个出来挨打（前端不需要解析，但是要拼接展示字符串）</p><p>数据库设计十分不合理，甚至不符合第一范式，<strong>浪费数据库大量存储空间</strong>不说，而且后端拼接字符串解析字符串这一过程<strong>十分耗时且占用内存</strong>，而且最新的需求是需要增加一个审核过程申请物资调整功能</p><p>所以我将物资申请表进行分表（水平分表），分出物资申请详情表并联系物资信息表，其结构如下</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031646110.png" alt="image-20220303164602406"></p><p>删除掉apply_content字段，节省数据库空间</p><p>分表后，通过tw_applydetail表，我们对物资申请信息的所以内容进行操作，省去了物资审核接口对字符串解析的耗时过程并且方便审核过程申请物资调整功能的开发（通过tw_appdetail找到物品信息和物品数量）</p><h5 id="3-优化操作：存储过程脚本"><a href="#3-优化操作：存储过程脚本" class="headerlink" title="3.优化操作：存储过程脚本"></a>3.优化操作：存储过程脚本</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象</p><p>这里值得注意的是在遍历游标的循环中，如果查询不存在或为空会跳出循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`Autovy`@`localhost` <span class="keyword">PROCEDURE</span> `demo`()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 定义变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n TINYTEXT;</span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"> # 求分割符号<span class="string">&#x27;,&#x27;</span>的位置</span><br><span class="line"><span class="keyword">DECLARE</span> _index <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息</span><br><span class="line"><span class="keyword">DECLARE</span> str TINYTEXT;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息长度</span><br><span class="line"><span class="keyword">DECLARE</span> strLength <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"># 物品名称</span><br><span class="line"><span class="keyword">DECLARE</span> goodName <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"># 物品数量</span><br><span class="line"><span class="keyword">DECLARE</span> goodCount <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"># 物品id</span><br><span class="line"><span class="keyword">DECLARE</span> goodId <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义游标，并将sql结果集赋值给游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> apply_id1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id, apply_content <span class="keyword">FROM</span> tw_apply <span class="keyword">WHERE</span> apply_content <span class="keyword">LIKE</span> &quot;本部%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明当游标遍历完后将标志变量置成1</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> s<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> apply_id1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将游标中的值赋值给变量，注意：变量名不要和返回列名同名，变量顺序要和sql结果顺序一致</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当s != 1,一直循环</span></span><br><span class="line">while s<span class="operator">&lt;&gt;</span><span class="number">1</span> do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过;分割单个物品的申请信息：北院—帐篷物品1个;北院—椅子物品1个;北院—桌子物品1个;</span></span><br><span class="line">while _index <span class="operator">&gt;</span> <span class="number">0</span>  do</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到单个物品申请信息：本部——桌子物品1个</span></span><br><span class="line"><span class="keyword">SET</span> str <span class="operator">=</span> <span class="keyword">LEFT</span>(n, _index<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> strLength <span class="operator">=</span> LENGTH(str) <span class="operator">/</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品名称</span></span><br><span class="line"><span class="keyword">SET</span> goodName <span class="operator">=</span> <span class="keyword">LEFT</span>(str, strLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品个数(类型转换为整数)</span></span><br><span class="line"><span class="keyword">SET</span> goodCount <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="keyword">LEFT</span>(<span class="keyword">RIGHT</span>(str, <span class="number">2</span>), <span class="number">1</span>) <span class="keyword">AS</span> signed) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> goodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按物品名称查到物品id并存储到goodId中</span></span><br><span class="line"><span class="comment">-- 这里如果查询不存在或为空会跳出游标循环，值得注意</span></span><br><span class="line"><span class="keyword">SELECT</span> goods_id <span class="keyword">into</span> goodId <span class="keyword">FROM</span> tw_goods <span class="keyword">WHERE</span> goods_show <span class="keyword">LIKE</span> goodName <span class="keyword">ORDER</span> <span class="keyword">BY</span> goods_count <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> tw_applydetail(apply_id, good_id, count) <span class="keyword">VALUES</span> (m, goodId, goodCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移动到下个分界点</span></span><br><span class="line"><span class="keyword">SET</span> n <span class="operator">=</span> SUBSTR(n <span class="keyword">FROM</span> _index<span class="operator">+</span><span class="number">1</span>);</span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行业务逻辑</span></span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取下一条数据，读取完成置变量s=1</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">close</span> apply_id1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>当时经过一天的对存储过程的学习，我总结出了以下经验：存储过程非常不方便调试，而且报错信息只定位不报错误类型（sql是这样的）。如果能重来，对数据库的批量操作，首选Python或Shell</p><h5 id="4-优化结果"><a href="#4-优化结果" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>截至目前物资申请表已有4817条数据，考虑到后面数据会长期积累，这样的优化是有必要的</li><li>去掉后端耗时耗内存的字符串解析工作</li><li>节省数据库存储空间，优化前申请表内存占0.79MB，优化后占0.56MB</li></ul><p>另外附加一个容量查询小工具，可查询数据库各表容量大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">table_schema as &#39;数据库&#39;,</span><br><span class="line">table_name as &#39;表名&#39;,</span><br><span class="line">table_rows as &#39;记录数&#39;,</span><br><span class="line">truncate(data_length&#x2F;1024&#x2F;1024, 2) as &#39;数据容量(MB)&#39;,</span><br><span class="line">truncate(index_length&#x2F;1024&#x2F;1024, 2) as &#39;索引容量(MB)&#39;</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema&#x3D;&#39;bgs&#39;</span><br><span class="line">order by data_length desc, index_length desc;</span><br></pre></td></tr></table></figure><h4 id="索引优化查询"><a href="#索引优化查询" class="headerlink" title="索引优化查询"></a>索引优化查询</h4><h5 id="1-相关表结构"><a href="#1-相关表结构" class="headerlink" title="1.相关表结构"></a>1.相关表结构</h5><p>日志记录表：共33687条数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031910440.png" alt="image-20220303191047146"></p><h5 id="2-优化思路：添加索引"><a href="#2-优化思路：添加索引" class="headerlink" title="2.优化思路：添加索引"></a>2.优化思路：添加索引</h5><p>关于索引的知识点这里不细说，推荐阅读：<a href="https://javaguide.cn/database/mysql/mysql-index/">MySQL 索引详解</a></p><p>由于日志表数据庞大，有3万条数据，为了达到快速通过用户名模糊查找到日志操作内容和操作时间，就需要用到索引，另外在模糊查询中，<strong>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用</strong></p><p>所以我将查询的模糊匹配由“%xxxx%”改为“xxxx%”，只模糊匹配前面部分</p><h5 id="3-优化操作"><a href="#3-优化操作" class="headerlink" title="3.优化操作"></a>3.优化操作</h5><p>这里直接使用Navicat可视化添加索引，因为后台查询日志是需要用用户名模糊查找到日志操作内容和操作时间，所以需要添加的索引为log_realnam</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031939750.png" alt="image-20220303193939350"></p><p>更改mybatis的sql映射，解决sql注入和索引失效问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE &quot;%$&#123;log_name&#125;%&quot;;  </span><br></pre></td></tr></table></figure><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE concat(‘%’,#&#123;log_name&#125;, ‘%’)   </span><br></pre></td></tr></table></figure><h5 id="4-优化结果-1"><a href="#4-优化结果-1" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>添加索引前使用用户名模糊查询日志，耗时大约0.045s，添加索引后耗时大约0.032s，减少了磁盘IO，提高了查询速度</li><li>修改mybatis中模糊查询的sql语句，解决索引失效的问题，并解决了模糊查询中拼接字符串的sql注入问题</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://bynss.com/linux/476637.html">怎样在 Debian 11 / Debian 10 上安装 MySQL 8.0 / 5.7</a></p><p><a href="https://stackoverflow.com/questions/20259036/mysql-package-mysql-server-has-no-installation-candidate">install.packages - MySQL: Package ‘mysql-server’ has no installation candidate - Stack Overflow</a></p><p><a href="https://javaguide.cn/database/mysql/a-thousand-lines-of-mysql-study-notes/">一千行 MySQL 学习笔记</a></p><p><a href="https://javaguide.cn/database/mysql/transaction-isolation-level/">事务隔离级别(图文详解)</a></p><p><a href="https://juejin.cn/post/6844903688553627661">你的like语句为啥没索引？</a></p><p><a href="https://juejin.cn/post/6911101492497743879#heading-3">MySQL是如何优化模糊匹配like的SQL</a></p><p><a href="https://www.cnblogs.com/hoojo/archive/2011/07/15/2107740.html">Transact-SQL 编程</a></p><p><a href="https://segmentfault.com/a/1190000039248897">针对新手的MYSQL存储过程详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202203041310207.png&quot; alt=&quot;image-20220304131032975&quot; style=&quot;zoom: 33%;&quot;&gt;

&lt;p&gt;MySQL  ❎&lt;/p&gt;
&lt;p&gt;OurSQL ✅&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="数据库" scheme="https://autovy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://autovy.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java|Java多线程案例</title>
    <link href="https://autovy.github.io/2022/02/04/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
    <id>https://autovy.github.io/2022/02/04/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/</id>
    <published>2022-02-04T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.178Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.staticdn.net/Autovy/Image/master/img/202203022103663.jpeg" alt="Multithreading | threading-memes, multithreading-memes | ProgrammerHumor.io" style="zoom:80%;"><p>卷！</p><span id="more"></span><h3 id="线程的创建及状态"><a href="#线程的创建及状态" class="headerlink" title="线程的创建及状态"></a>线程的创建及状态</h3><h4 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1.线程的生命周期"></a>1.线程的生命周期</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202260851266.png" alt="Java 线程的状态 "></p><h4 id="2-创建一个线程"><a href="#2-创建一个线程" class="headerlink" title="2.创建一个线程"></a>2.创建一个线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(<span class="string">&quot;1- &quot;</span> + thread.getState());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;2- &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 主线程睡眠等待线程执行结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;3- &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建有任务线程"><a href="#3-创建有任务线程" class="headerlink" title="3.创建有任务线程"></a>3.创建有任务线程</h4><p>创建有任务线程有以下三种方式：</p><ul><li>重写Thread的run()方法</li><li>实现Runnable接口，在创建Thread对象时传入</li><li>使用FutureTask，在创建Thread对象的时候传入</li></ul><h5 id="重写run-方法"><a href="#重写run-方法" class="headerlink" title="重写run()方法"></a>重写run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;一个子线程任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Runnable实现"><a href="#Runnable实现" class="headerlink" title="Runnable实现"></a>Runnable实现</h5><p>Runnable是一个函数式接口，可以作为Thread构造函数的参数</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202260915940.png" alt="image-20220226091533448"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202260916952.png" alt="image-20220226091616762"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="comment">// lambda表达式可以为函数式接口创建匿名对象(类型是Runnable)</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;一个子线程任务&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="FutureTask实现"><a href="#FutureTask实现" class="headerlink" title="FutureTask实现"></a>FutureTask实现</h5><p>上面两者方式中，子线程没有返回值也没有抛出异常（这是由其中的run方法决定的），所以主线程对子线程的状况一无所知，而接下来的FutureTask可以解决这两个问题</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202260928525.png" alt="image-20220226092833201"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202260926628.png" alt="image-20220226092625296"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadFutureTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现Callable接口，写入任务，放入FutureTask中</span></span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;一个子线程任务&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;sub task done&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造FutureTask类（其实质是Runnable的一个实现）</span></span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程获得子线程返回值并捕捉异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// get()获得子线程返回值</span></span><br><span class="line">            String subResult = task.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程返回值：&quot;</span> + subResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">            <span class="comment">// getCause获得子线程发生的异常</span></span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程调用get方法后，会不断询问子线程的情况，直到子线程执行完毕。FutureTask适用于多个任务需要同时完成的情况（主线程做完自己的任务后，一直等待子线程直到它完成任务，然后一起结束）</p><h3 id="CompleteFuture"><a href="#CompleteFuture" class="headerlink" title="CompleteFuture"></a>CompleteFuture</h3><p>CompleteFuture和FutureTask都是Future接口的实现类，但是CompleteFuture的使用姿势更加优雅。建议及时抛弃FutureTask，拥抱CompleteFuture🥰</p><h4 id="1-必备工具类"><a href="#1-必备工具类" class="headerlink" title="1.必备工具类"></a>1.必备工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程小工具</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallTool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 让当前线程睡眠n毫秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleepMillis</span><span class="params">(<span class="keyword">long</span> millis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间戳+线程信息+消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTimeAndThread</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">        String res = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;\t|\t&quot;</span>)</span><br><span class="line">                .add(String.valueOf(System.currentTimeMillis()))</span><br><span class="line">                .add(String.valueOf(Thread.currentThread().getId()))</span><br><span class="line">                .add(Thread.currentThread().getName())</span><br><span class="line">                .add(tag)</span><br><span class="line">                .toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-CompletableFuture入门"><a href="#2-CompletableFuture入门" class="headerlink" title="2.CompletableFuture入门"></a>2.CompletableFuture入门</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261121903.png" alt="image-20220226112153973"></p><ul><li>开启：supplyAsync</li><li>连接：thenCompose</li><li>合并：thenCombine</li></ul><h5 id="异步任务的开启"><a href="#异步任务的开启" class="headerlink" title="异步任务的开启"></a>异步任务的开启</h5><p>supplyAsync方法开启一个异步任务</p><p><strong>场景模拟</strong></p><ul><li>顾客进入餐厅</li><li>顾客点菜</li><li>顾客刷手机等待 <ul><li>（线程2）厨师炒菜</li><li>（线程2）厨师打饭</li></ul></li><li>顾客开始干饭</li></ul><p>这里的等待队列是 顾客任务 -&gt; 厨师任务</p><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureSupplyAsync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客进入餐厅&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客点菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplyAsync方法需要一个supplier作为参数</span></span><br><span class="line">        <span class="comment">// 为函数式接口，无入参，这里只有一个String类型的返回值（作为CompletableFuture的泛型）</span></span><br><span class="line">        <span class="comment">// 调用supplyAsync，supplier中的代码会跑到子线程中执行</span></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">                    <span class="comment">// 炒菜耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师打饭&quot;</span>);</span><br><span class="line">                    <span class="comment">// 打饭耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;饭菜已备好&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        <span class="comment">// join方法返回值类型为CompletableFuture泛型的类型</span></span><br><span class="line">        <span class="comment">// join方法返回值即为supplier的返回值</span></span><br><span class="line">        <span class="comment">// join方法会等待子线程执行结束，并获得其返回值</span></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，顾客开始干饭&quot;</span>, sub.join()));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261031080.png" alt="image-20220226103120810"></p><h5 id="异步任务的连接"><a href="#异步任务的连接" class="headerlink" title="异步任务的连接"></a>异步任务的连接</h5><p>thenCompose连接两个任务当做一个线程提交到线程池，thenComposeAsync连接两个任务分别单独提交到线程池处理</p><p><strong>场景模拟</strong></p><ul><li>顾客进入餐厅</li><li>顾客点菜</li><li>顾客刷手机等待 <ul><li>（线程2）厨师炒菜，将菜交给服务员</li><li>（线程3）服务员拿到菜并去打饭</li></ul></li><li>顾客开始干饭</li></ul><p>这里的等待队列是 顾客任务 -&gt; 厨师任务 -&gt; 服务员任务</p><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenCompose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客进入餐厅&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客点菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplyAsync方法需要一个supplier作为参数</span></span><br><span class="line">        <span class="comment">// 为函数式接口，无入参，这里只有一个String类型的返回值（作为CompletableFuture的泛型）</span></span><br><span class="line">        <span class="comment">// 调用supplyAsync，supplier中的代码会跑到子线程中执行</span></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">               <span class="comment">// 厨师任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">                    <span class="comment">// 炒菜耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;鱼香肉丝&quot;</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// dish即传入厨师任务的返回值</span></span><br><span class="line">                <span class="comment">// 菜做好后，开启服务员线程拿得饭菜并打饭</span></span><br><span class="line">                <span class="comment">// thenCompose会在前一个线程完成后，开启另一个线程</span></span><br><span class="line">        ).thenCompose(dish -&gt; CompletableFuture.supplyAsync(</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务员任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">                    <span class="comment">// 打饭耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> dish + <span class="string">&quot; 米饭已备好&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        <span class="comment">// join方法返回值类型为CompletableFuture泛型的类型</span></span><br><span class="line">        <span class="comment">// join方法返回值即为supplier的返回值</span></span><br><span class="line">        <span class="comment">// join方法会等待子线程执行结束，并获得其返回值</span></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，顾客开始干饭&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261134832.png" alt="image-20220226113453404"></p><h5 id="异步任务的结合"><a href="#异步任务的结合" class="headerlink" title="异步任务的结合"></a>异步任务的结合</h5><p>thenCombine合并两个任务，同时执行他们</p><p><strong>场景模拟</strong></p><ul><li>顾客进入餐厅</li><li>顾客点菜</li><li>顾客刷手机等待 <ul><li>（线程2）厨师炒菜</li><li>（线程3）服务员蒸饭</li><li>（线程3）菜和饭都备好了，服务员打饭上菜</li></ul></li><li>顾客开始干饭</li></ul><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenCombine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客进入餐厅&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客点菜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// supplyAsync方法需要一个supplier作为参数</span></span><br><span class="line">        <span class="comment">// 为函数式接口，无入参，这里只有一个String类型的返回值（作为CompletableFuture的泛型）</span></span><br><span class="line">        <span class="comment">// 调用supplyAsync，supplier中的代码会跑到子线程中执行</span></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                <span class="comment">// 厨师任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;厨师炒菜&quot;</span>);</span><br><span class="line">                    <span class="comment">// 炒菜耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;鱼香肉丝&quot;</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// thenCombine将两个线程一起执行</span></span><br><span class="line">        ).thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务员任务</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员蒸饭&quot;</span>);</span><br><span class="line">                    <span class="comment">// 蒸饭耗时</span></span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">300</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;米饭&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ), (dish, rice) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 两个并行的线程都完成任务后，合并两个结果后结束两个任务</span></span><br><span class="line">           SmallTool.printTimeAndThread(<span class="string">&quot;服务员打饭&quot;</span>);</span><br><span class="line">           SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">           <span class="keyword">return</span> String.format(<span class="string">&quot;%s + %s 已备好&quot;</span>, dish, rice);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        <span class="comment">// join方法返回值类型为CompletableFuture泛型的类型</span></span><br><span class="line">        <span class="comment">// join方法返回值即为supplier的返回值</span></span><br><span class="line">        <span class="comment">// join方法会等待子线程执行结束，并获得其返回值</span></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，顾客开始干饭&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261117831.png" alt="image-20220226111744105"></p><h4 id="3-CompletableFuture进阶"><a href="#3-CompletableFuture进阶" class="headerlink" title="3.CompletableFuture进阶"></a>3.CompletableFuture进阶</h4><h5 id="任务的后置处理"><a href="#任务的后置处理" class="headerlink" title="任务的后置处理"></a>任务的后置处理</h5><p><strong>场景模拟</strong></p><ul><li>顾客就餐完毕</li><li>顾客结账并要求开发票</li><li>顾客刷手机等待<ul><li>（线程2）服务员收款500元</li><li>（线程3）服务员开发票</li></ul></li><li>顾客拿到发票</li></ul><p><strong>thenApply的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenApply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客就餐完毕&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客结账并要求开发票&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员收款500元&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;500&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thenApply将前面异步任务的结果交给后面的Function</span></span><br><span class="line">        <span class="comment">// 前后两个任务都是一个服务员完成的（在同一线程中）        </span></span><br><span class="line">        ).thenApply(money -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            SmallTool.printTimeAndThread(String.format(<span class="string">&quot;服务员开发票，面额%s元&quot;</span>, money));</span><br><span class="line">            SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s元发票&quot;</span>, money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;顾客拿到%s&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261152150.png" alt="image-20220226115245885"></p><p>可以看到使用thenApply，收款和开发票都在同一个线程不符合要求，我们只需要将thenApply更改为thenApplyAsync即可实现开启另一个线程运行</p><p><strong>thenApplyAsync的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureThenApply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客就餐完毕&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客结账并要求开发票&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; sub = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;服务员收款500元&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;500&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thenApplyAsync将前面异步任务的结果交给后面的Function，并开启一个新的线程</span></span><br><span class="line">        ).thenApplyAsync(money -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            SmallTool.printTimeAndThread(String.format(<span class="string">&quot;服务员开发票，面额%s元&quot;</span>, money));</span><br><span class="line">            SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s元发票&quot;</span>, money);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;顾客正在刷手机等待&quot;</span>);</span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;顾客拿到%s&quot;</span>, sub.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="获得最先完成的任务"><a href="#获得最先完成的任务" class="headerlink" title="获得最先完成的任务"></a>获得最先完成的任务</h5><p><strong>场景模拟</strong></p><ul><li>老王走出餐厅，来到公交车站</li><li>等待700路或800路公交到来<ul><li>（线程2）700路公交正在赶来</li><li>（线程3）800路公交正在赶来</li></ul></li><li>老王坐最先到的公交回家</li></ul><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFutureToEither</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;老王走出餐厅，来到公交车站&quot;</span>);</span><br><span class="line">        <span class="comment">// 700路公交和800路公交哪一个先到，就先上哪一辆车</span></span><br><span class="line">        SmallTool.printTimeAndThread(<span class="string">&quot;等待700路或800路公交到来&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; bus = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;700路公交正在赶来&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;700路公交已到站&quot;</span>;</span><br><span class="line">                    <span class="comment">// applyToEither连接两个任务，哪个任务先完成就传到Function（即firstComeBus中）</span></span><br><span class="line">                    <span class="comment">// 返回输出到bus</span></span><br><span class="line">                &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(<span class="string">&quot;800路公交正在赶来&quot;</span>);</span><br><span class="line">                    SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;800路公交已到站&quot;</span>;</span><br><span class="line">                &#125;), firstComeBus -&gt; firstComeBus);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(<span class="string">&quot;%s，老王坐车回家&quot;</span>, bus.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261335892.png" alt="image-20220226133508092"></p><h5 id="处理发生的异常情况"><a href="#处理发生的异常情况" class="headerlink" title="处理发生的异常情况"></a>处理发生的异常情况</h5><p><strong>场景模拟</strong></p><ul><li><p>老王走出餐厅，来到公交车站</p></li><li><p>等待700路或800路公交到来</p><ul><li>（线程2）700路公交正在赶来</li><li>（线程3）800路公交正在赶来</li></ul></li><li><p>老王坐最先到的公交回家</p></li><li><p>700路公交出现故障，老王叫出租车回家</p></li></ul><p><strong>代码案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line">public class CompleteFutureToEither &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SmallTool.printTimeAndThread(&quot;老王走出餐厅，来到公交车站&quot;);</span><br><span class="line">        &#x2F;&#x2F; 700路公交和800路公交哪一个先到，就先上哪一辆车</span><br><span class="line">        SmallTool.printTimeAndThread(&quot;等待700路或800路公交到来&quot;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; bus &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(&quot;700路公交正在赶来&quot;);</span><br><span class="line">                    SmallTool.sleepMillis(100);</span><br><span class="line">                    return &quot;700路公交已到站&quot;;</span><br><span class="line">                    &#x2F;&#x2F; applyToEither连接两个任务，哪个任务先完成就传到Function（即firstComeBus中）</span><br><span class="line">                    &#x2F;&#x2F; 返回输出到bus</span><br><span class="line">                &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(&quot;800路公交正在赶来&quot;);</span><br><span class="line">                    SmallTool.sleepMillis(200);</span><br><span class="line">                    return &quot;800路公交已到站&quot;;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 先到的车如果是700路，其中途会抛出异常</span><br><span class="line">                &#125;), firstComeBus -&gt; &#123;</span><br><span class="line">                    SmallTool.printTimeAndThread(firstComeBus);</span><br><span class="line">                    if(firstComeBus.startsWith(&quot;700&quot;))</span><br><span class="line">                    &#123;</span><br><span class="line">                        throw new RuntimeException(&quot;公交车发生故障&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    return firstComeBus;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 上面任任意的链式调用中出现异常都会触发这里的事件</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            SmallTool.printTimeAndThread(e.getMessage());</span><br><span class="line">            SmallTool.printTimeAndThread(&quot;老王叫出租车&quot;);</span><br><span class="line">            return &quot;出租车到了&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SmallTool.printTimeAndThread(String.format(&quot;%s，老王坐车回家&quot;, bus.join()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261347003.png" alt="image-20220226134731888"></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-线程池的创建"><a href="#1-线程池的创建" class="headerlink" title="1.线程池的创建"></a>1.线程池的创建</h4><h5 id="使用构造函数创建"><a href="#使用构造函数创建" class="headerlink" title="使用构造函数创建"></a>使用构造函数创建</h5><p>我们可以使用ThreadPoolExecutor的构造函数创建一个线程池，其构造函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>拒绝策略如下：</p><p><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出异常</p><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：谁提交谁执行</p><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：直接丢弃</p><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 替换掉工作队列中最后一个</p><h5 id="使用工具类创建"><a href="#使用工具类创建" class="headerlink" title="使用工具类创建"></a>使用工具类创建</h5><p>一般不推荐使用，因为它无法适应多变的业务需求，而且容易导致OOM</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261635984.png" alt="通过Executor 框架的工具类Executors来实现"></p><h4 id="2-线程中断"><a href="#2-线程中断" class="headerlink" title="2.线程中断"></a>2.线程中断</h4><p>在一个线程中可以通过中断唤醒另一个在睡眠中的线程，达到线程间通信的目的。不建议使用中断</p><p><strong>场景模拟</strong></p><p>两车过独木桥场景</p><p><strong>代码案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoCarCrossBridge</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread carTwo  = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"></span><br><span class="line">            SmallTool.printTimeAndThread(<span class="string">&quot;二号车辆准备过桥&quot;</span>);</span><br><span class="line">            SmallTool.printTimeAndThread(<span class="string">&quot;发现一号车正在过桥，开始等待&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 二号车线程进入TIMED_WAITING状态</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一号车发出中断通知，可以通过捕捉IE异常接收</span></span><br><span class="line">            <span class="comment">// sleep和wait方法会抛出InterruptedException异常</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                SmallTool.printTimeAndThread(<span class="string">&quot;二号车开始过桥&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            SmallTool.sleepMillis(<span class="number">200</span>);</span><br><span class="line">            SmallTool.printTimeAndThread(<span class="string">&quot;二号车过桥完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread carOne = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           SmallTool.printTimeAndThread(<span class="string">&quot;一号车开始过桥&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> timeSpend = <span class="keyword">new</span> Random().nextInt(<span class="number">500</span>) + <span class="number">1000</span>;</span><br><span class="line">           SmallTool.sleepMillis(timeSpend);</span><br><span class="line">           SmallTool.printTimeAndThread(<span class="string">&quot;二号车过桥完毕，耗时：&quot;</span> + timeSpend);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 一号车过桥完毕后，利用中断通知二号车</span></span><br><span class="line">            carTwo.interrupt();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一号车，二号车同时起步</span></span><br><span class="line">        carOne.start();</span><br><span class="line">        carTwo.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但线程处于blocked，waiting，timed_waiting状态，或者从上述三个状态转为runnable状态的过程中，如果被中断就会收到InterruptedException异常</p><p><strong>运行结果</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202261712019.png" alt="image-20220226171200852"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://space.bilibili.com/51950540/channel/collectiondetail?sid=20808">Java并发编程合集</a></p><p><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary/">Java 线程池详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202203022103663.jpeg&quot; alt=&quot;Multithreading | threading-memes, multithreading-memes | ProgrammerHumor.io&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;p&gt;卷！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://autovy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java|Socket编程指南</title>
    <link href="https://autovy.github.io/2022/01/20/Java/Java-Socket%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://autovy.github.io/2022/01/20/Java/Java-Socket%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</id>
    <published>2022-01-20T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.172Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202252305878.png" alt="That is a good excuse"></p><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Socket编程是指编写在多台计算机上执行的程序，其中的设备都使用网络相互连接</p><p>Socket常用的通信协议有UDP和TCP，本文主要介绍通过TCP/IP网络协议进行Socket编程</p><h3 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a>Socket通信流程</h3><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202251212126.png" alt="img"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭；</li></ul><p>服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>Socket是网络上不同计算机运行的两个程序之间双向通信链路的一个端点。Socket需要绑定端口号，一遍传输层可以标识数据要发送到的应用程序</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端会用到两个socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong></p><p>目前的服务器不能保证通信的连续性，它会在发送完消息后关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// （监听socket）</span></span><br><span class="line">            <span class="comment">// 绑定指定端口，使服务器的Socket在指定端口号上运行</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// （已连接socket）</span></span><br><span class="line">            <span class="comment">// 服务器遇到accept进入阻塞，等待客户端发出连接</span></span><br><span class="line">            <span class="comment">// 连接成功后，服务器将获得绑定到同一本地端口6666的新socket，用于传输数据</span></span><br><span class="line">            clientSocket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出流，可发送消息到客户端</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 输入流，可接收客户端消息</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String greeting = in.readLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(greeting.equals(<span class="string">&quot;hello server&quot;</span>))&#123;</span><br><span class="line">                out.println(<span class="string">&quot;hello client&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                out.println(<span class="string">&quot;unrecognised greeting&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        <span class="comment">// 开启服务器</span></span><br><span class="line">        server.start(<span class="number">6666</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端只需要创建一个socket以保持连接，最终客户端的输入流连接到服务端的输出流，服务器的输入流连接到客户端的输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.javafx.iio.ios.IosDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConnection</span><span class="params">(String ip, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 客户端需要知道服务端的ip和其正在监听的端口号，才能发起连接</span></span><br><span class="line">            <span class="comment">// 服务器接收连接后创建客户端socket</span></span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取socket的输入输出流，以便与服务端通信</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端输出请求消息</span></span><br><span class="line">        out.println(msg);</span><br><span class="line">        String resp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 客户端接收响应消息</span></span><br><span class="line">            resp = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>先手动启动服务端，然后运行以上测试案例即可完成一次连接和一次消息发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="comment">// 客户端对服务端发起连接</span></span><br><span class="line">        client.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 客户端发送消息到服务端并接收响应结果</span></span><br><span class="line">        String response = client.sendMessage(<span class="string">&quot;hello server&quot;</span>);</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若启动服务端时出现以下报错，是出现了端口占用，可以修改端口也可以关闭占用端口的进程</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202251257783.png" alt="image-20220225125717019"></p><p>Windows下使用命令行关闭占用端口的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 参看端口号含6666的条目</span><br><span class="line">netstat -ano|findstr &quot;6666&quot;</span><br><span class="line"></span><br><span class="line">// 根据pid查询对应的应用程序</span><br><span class="line">tasklist|findstr &quot;1828&quot;</span><br><span class="line"></span><br><span class="line">// 杀死进程</span><br><span class="line">taskkill /f /pid 1828</span><br></pre></td></tr></table></figure><h3 id="持续连接优化"><a href="#持续连接优化" class="headerlink" title="持续连接优化"></a>持续连接优化</h3><p>在前一个案例中，服务器会阻塞直到客户端连接它。在单个消息后，连接就会关闭，客户端和服务端无法持续沟通，因此仅仅会出现在ping请求中</p><p>如果要实现一个聊天服务器，客户端和服务端之间就需要连续的来回通信</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p>在优化中我在服务端创建一个while循环来连续观察传来消息的服务器输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// （监听socket）</span></span><br><span class="line">            <span class="comment">// 绑定指定端口，使服务器的Socket在指定端口号上运行</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// （已连接socket）</span></span><br><span class="line">            <span class="comment">// 服务器遇到accept进入阻塞，等待客户端发出连接</span></span><br><span class="line">            <span class="comment">// 连接成功后，服务器将获得绑定到同一本地端口4444的新socket，用于传输数据</span></span><br><span class="line">            clientSocket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出流，可发送消息到客户端</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 输入流，可接收客户端消息</span></span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String inputLine;</span><br><span class="line">            <span class="comment">// while循环连续观察从客户端传来消息的服务器输入流</span></span><br><span class="line">            <span class="comment">// 直到读取到exit断开连接</span></span><br><span class="line">            <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(inputLine.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                    out.println(<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(inputLine.replace(<span class="string">&quot;req&quot;</span>, <span class="string">&quot;res&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoServer server = <span class="keyword">new</span> EchoServer();</span><br><span class="line">        <span class="comment">// 开启服务器</span></span><br><span class="line">        server.start(<span class="number">4444</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>客户端不需要进行优化修改，这里为了方区分创建一个新的类EchoClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConnection</span><span class="params">(String ip, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 客户端需要知道服务端的ip和其正在监听的端口号，才能发起连接</span></span><br><span class="line">            <span class="comment">// 服务器接收连接后创建客户端socket</span></span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取socket的输入输出流，以便与服务端通信</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端输出请求消息</span></span><br><span class="line">        out.println(msg);</span><br><span class="line">        String resp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 客户端接收响应消息</span></span><br><span class="line">            resp = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>在初始示例中，我们只在服务器关闭连接之前进行一次通信。现在，我们发送一个终止信号，以便在会话完成时告诉服务器，以此关闭服务器的socket进程</p><p>开启EchoServer服务器运行以下测试案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EchoClient client = <span class="keyword">new</span> EchoClient();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        client.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        client.stopConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String resp1 = client.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>@BeforeClass – 表示在类中的任意public static void方法执行之前执行</li><li>@AfterClass – 表示在类中的任意public static void方法执行之后执行</li><li>@Before – 表示在任意使用@Test注解标注的public void方法执行之前执行</li><li>@After – 表示在任意使用@Test注解标注的public void方法执行之后执行</li><li>@Test – 使用该注解标注的public void方法会表示为一个测试方法</li></ul><h3 id="多客户端优化"><a href="#多客户端优化" class="headerlink" title="多客户端优化"></a>多客户端优化</h3><p>在实际情况中，服务端常常要处理多个客户端的请求，为此我们要在服务端为每一个客户端请求创建一个新的socket线程，即提供服务的客户端数将等于服务端正在运行的线程数</p><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><p>仍然用一个<strong>监听socket</strong>在主线程监听端口，而需要多线程存储<strong>已连接socket</strong>以保持与多个客户端的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoMultiSever</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 仍然使用一个socket在主线程中监听端口</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 每次循环中，accept会阻塞调用，直到新的客户端调用</span></span><br><span class="line">                <span class="comment">// 连接成功后，EchoMultiServer会将已连接的socket委托给 EchoClientHandler</span></span><br><span class="line">                <span class="keyword">new</span> EchoClientHandler(serverSocket.accept()).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个单独的线程EchoClientHandler</span></span><br><span class="line">    <span class="comment">// 保存已连接的socket与客户端交流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">        <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">        <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EchoClientHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程执行start直到运行run方法，与目标客户端进行交流</span></span><br><span class="line">        <span class="comment">// 其内部发生的情况与EchoSever相同</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">                in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(inputLine.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                        out.println(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.println(inputLine.replace(<span class="string">&quot;req&quot;</span>, <span class="string">&quot;res&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                clientSocket.close();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoMultiSever server = <span class="keyword">new</span> EchoMultiSever();</span><br><span class="line">        <span class="comment">// 开启服务器</span></span><br><span class="line">        server.start(<span class="number">5555</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p>客户端不需要进行优化修改，与上面的相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoMultiClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientSocket;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter out;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConnection</span><span class="params">(String ip, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 客户端需要知道服务端的ip和其正在监听的端口号，才能发起连接</span></span><br><span class="line">            <span class="comment">// 服务器接收连接后创建客户端socket</span></span><br><span class="line">            clientSocket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取socket的输入输出流，以便与服务端通信</span></span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        out.println(msg);</span><br><span class="line">        String resp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp = in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>测试类中需要发起多个客户端请求</p><p>运行EchoMultiSever后，运行以下案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试方法开启多个客户端请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoMultiTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClient1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EchoClient client1 = <span class="keyword">new</span> EchoClient();</span><br><span class="line">        client1.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">        String resp1 = client1.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client1.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client1.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClient2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EchoClient client2 = <span class="keyword">new</span> EchoClient();</span><br><span class="line">        client2.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">        String resp1 = client2.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client2.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client2.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClient3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EchoClient client3 = <span class="keyword">new</span> EchoClient();</span><br><span class="line">        client3.startConnection(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">        String resp1 = client3.sendMessage(<span class="string">&quot;req:hello&quot;</span>);</span><br><span class="line">        String resp2 = client3.sendMessage(<span class="string">&quot;req:world&quot;</span>);</span><br><span class="line">        String resp3 = client3.sendMessage(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(resp1);</span><br><span class="line">        System.out.println(resp2);</span><br><span class="line">        System.out.println(resp3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.baeldung.com/a-guide-to-java-sockets">Java 套接字</a></p><p><a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">TCP/IP图解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202202252305878.png&quot; alt=&quot;That is a good excuse&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="开发实战" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|深入理解TCP/IP</title>
    <link href="https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/"/>
    <id>https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/</id>
    <published>2021-12-22T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.161Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222123110.png" alt="Packets incoming "></p><span id="more"></span><h3 id="深入TCP连接"><a href="#深入TCP连接" class="headerlink" title="深入TCP连接"></a>深入TCP连接</h3><p>参考资料：<a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg</a></p><h4 id="1-TCP基本认识"><a href="#1-TCP基本认识" class="headerlink" title="1.TCP基本认识"></a>1.TCP基本认识</h4><h5 id="（1）TCP头部结构"><a href="#（1）TCP头部结构" class="headerlink" title="（1）TCP头部结构"></a>（1）TCP头部结构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111172102110.png" alt="image-20211117210224727"></p><p>下面介绍其中较为重要的部分：</p><ul><li><strong>序列号</strong>：建立连接时计算生成的随机数作为其初始值，通过SYN包传给接收端主机。每发送一次数据就会<strong>累加</strong>一次该<strong>数据字节数</strong>的大小，所以可以用来<strong>解决网络包乱序</strong>的问题</li><li><strong>确认应答号</strong>：即下一次<strong>期望</strong>收到的数据序列号，发送端接收到这个确认应答就可以认为这个序号之前的数据已被正常接收，用以解决<strong>不丢包的问题</strong></li><li><strong>控制位（状态位）</strong>：该字段中的每个比特分别表示以下通信控制含义<ul><li>ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></li><li>RST：<strong>强制断开</strong>连接，用于异常中断的情况</li><li>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作</li><li>FIN：表示<strong>断开</strong>连接</li></ul></li><li><strong>窗口大小</strong>：接收方告知发送方窗口大小（窗口大小即缓存大小，标识当前处理能力，用于<strong>流量控制</strong>，<strong>拥塞控制</strong>）</li></ul><h5 id="（2）TCP基本定义"><a href="#（2）TCP基本定义" class="headerlink" title="（2）TCP基本定义"></a>（2）TCP基本定义</h5><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的</strong></p><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p><ul><li>面向连接：十分专一，只支持一对一连接</li><li>可靠的：不管网络链路出现怎样的链路变化，TCP都可以保证一个报文一定能到达中断</li><li>字节流：消息无论多大都可以传输，而且一定是<strong>有序的</strong>，<strong>顺序不对</strong>的，<strong>重复</strong>的报文会被自动丢弃</li></ul><p>TCP连接即<strong>用于保证可靠性和流量控制维护</strong>的某些状态信息包括：</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><p>TCP四元组可以唯一确定一个连接：</p><ul><li><p>源地址</p></li><li><p>源端口</p></li><li><p>目标地址</p></li><li><p>目标端口</p></li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111172153405.png" alt="img"></p><p>地址储存在IP头部中，作用是通过IP协议发送报文给对方主机</p><p>端口存储在TCP头部，作用是告诉TCP协议应该把报文发给哪个进程</p><p>服务器通常固定在某个本地端口监听（如80，443等），等待客户端的连接请求</p><p>TCP理论上的最大连接数与客户端的IP数和客户端的端口数有关<br>$$<br>最大TCP连接数 = 客户端的IP数 × 客户端的端口数<br>$$<br>当实际上服务端最大TCP连接还会受到<strong>文件描述符</strong>和<strong>内存</strong>限制</p><h5 id="（3）TCP与UDP的区别"><a href="#（3）TCP与UDP的区别" class="headerlink" title="（3）TCP与UDP的区别"></a>（3）TCP与UDP的区别</h5><p>TCP与UDP的结构对比：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110091935607.png" alt="img" style="zoom:50%;"><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111172209140.png" alt="image-20211117220850428" style="zoom: 67%;"></p><ul><li>首部长度：TCP有首部长度，UDP则没有。因为TCP有可变长的<strong>选项</strong>字段，所以需要首部长度来记录；UDP的头部长度是不会变化的，所以需要去记录首部长度</li></ul><ul><li>包长度：UDP有首部长度，UDP则没有。TCP和UDP的数据长度都可以通过下面公式计算出来，所以包长度是不需要的，这里的UDP可能纯属是补全UDP的首部长度为4字节<br>$$<br>TCP/UDP数据长度 = IP总长度 - IP首部长度 - TCP/UDP首部长度<br>$$</li></ul><p>TCP和UDP协议的应用：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090832758.jpeg" alt="TCP/UDP常见应用"></p><p>TCP/UDP比较：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p><p>咳咳，正经详细的比较如下：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131209573.png" alt="image-20211013120922107"></p><p>TCP/UDP编程模型对比：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090836254.jpeg" alt="TCP/UDP编程模型"></p><h4 id="2-TCP连接建立"><a href="#2-TCP连接建立" class="headerlink" title="2.TCP连接建立"></a>2.TCP连接建立</h4><h5 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h5><p>TCP三次握手其实就是<strong>建立一个TCP连接</strong>，客户端和服务器之间需要<strong>3个数据包</strong>，握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110091957945.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></p><ul><li>初始状态下，客户端和服务端都处在<strong>CLOSED</strong>状态，先是服务端主动监听某个端口，处于<strong>LISTEN</strong>状态</li></ul><ul><li>第一次握手：客户端发送<strong>SYN</strong>报文，并进入<strong>SYN-SENT</strong>状态，等待服务器确认</li></ul><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111181640784.png" alt="img" style="zoom: 67%;"><ul><li>第二次握手：服务器收到<strong>SYN</strong>报文后，需要向客户端发送<strong>ACK</strong>确认<strong>收到</strong>的报文；同时服务端也向客户端发送一个<strong>SYN报文</strong>（也就是说服务端向客户端发送了<strong>SYN+ACK</strong>报文），然后服务端进入<strong>SYN_RCVD</strong>状态</li></ul><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111181640604.png" alt="img" style="zoom: 67%;"><ul><li><p>第三次握手：客户端收到<strong>SYN+ACK</strong>报文后，向服务端发送<strong>ACK</strong>确认<strong>收到</strong>的报文，客户端进入<strong>ESTABLISHED</strong>状态； 服务端收到客户端的<strong>ACK</strong>包后也会进入<strong>ESTABLISHED</strong>状态，完成三次握手</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130593.png" alt="img" style="zoom: 67%;"></li></ul><p><strong>第三次握手是可以携带数据的，前面两次握手是不可以携带数据的</strong>，完成三次握手后，双方都处于<strong>ESTABLISHED</strong>状态，至此连接就已经建立完成了</p><p>在Linux系统可以通过<code>netstat -napt</code>命令查看TCP连接状态</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110092029731.png" alt="img"></p><h5 id="（2）需要三次握手的原因"><a href="#（2）需要三次握手的原因" class="headerlink" title="（2）需要三次握手的原因"></a>（2）需要三次握手的原因</h5><p>我们需要三次握手才能初始化Socket，序列号和窗口大小并建立TCP连接，才能保证双方具有接收和发送的能力</p><p>需要三次握手的原因如下：</p><ul><li>三次握手才能阻止历史重复连接的初始化</li><li>三次握手才能同步双方的初始序列化</li><li>三次握手才可以避免资源浪费</li></ul><p><strong>避免历史连接</strong>：防止旧的重复连接初始化造成混乱</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130449.png" alt="img" style="zoom: 67%;"><p>网络环境错综复杂，在网络拥堵的情况下，一个「旧 SYN 报文」可能会比「最新的 SYN 」 报文早到达了服务端</p><p>第三次握手可以用来判断是否收到了自己期望的ACK：</p><ul><li>如果是历史连接（序列号过期或超时）就发送<strong>RST报文</strong>中止历史连接</li><li>如果不是历史连接则第三次发送的报文是<strong>ACK报文</strong>，通信双方就会成功建立连接</li></ul><p>如果是两次握手将无法判断出历史连接</p><p><strong>同步双方初始序列号</strong>：TCP协议通信双方，都必须维护一个序列号，只有客户端和服务端之间通过<strong>SYN和ACK</strong>一来一回的确认，才能确保双方的初始化序列号能被可靠的同步</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111181742784.png" alt="img" style="zoom:67%;"><p>如果是两次握手只能保证一方的初始序列号可以被对方接收，没办法保证双方的初始序列号都能被确认接受</p><p><strong>避免资源浪费</strong>：二次握手会建立多个冗杂的无效的连接，造成不必要的资源浪费</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130170.png" alt="img" style="zoom:67%;"><p>两次握手会造成消息滞留的情况，服务器接收到无用的SYN报文，因为没有ACK确认信号，服务器就会造成重复的资源分配</p><h5 id="（3）初始化序列号ISN"><a href="#（3）初始化序列号ISN" class="headerlink" title="（3）初始化序列号ISN"></a>（3）初始化序列号ISN</h5><p>客户端和服务端的初始序列号ISN是不相同的，因为网络的<strong>报文会延迟，会复制重发，也可能丢失</strong>。为了避免相互影响，客户端和服务端的初始序列号是随机且不同的</p><p>初始序列号ISN的随机生成算法是基于时钟的，如下<br>$$<br>ISN = M + F (localhost, localport, remotehost, remoteport)<br>$$</p><ul><li><code>M</code> 是一个<strong>计时器</strong>，这个计时器每隔 4 毫秒加 1</li><li><code>F</code> 是一个 Hash 算法，根据<strong>源 IP、目的 IP、源端口、目的端口生成一个随机数值</strong>。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择</li></ul><h5 id="（4）MTU与MSS"><a href="#（4）MTU与MSS" class="headerlink" title="（4）MTU与MSS"></a>（4）MTU与MSS</h5><p>IP层分片的大小为MTU，TCP层分段的大小为MSS</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110092031256.png" alt="image-20211009203103835"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>既然IP层可以将大于MTU数据进行分片，为什么还需要TCP层将大于MSS的数据分段呢？</p><p>因为IP层本身并没有超时重传机制，如果一个IP分片丢失了，那么整个IP报文的<strong>所有分片都要进行重传</strong></p><p>所有为了达到最佳的传输效能，TCP协议在<strong>建立连接时通常要协商双方的MSS值</strong>，当TCP发现数据超过MSS时就会对数据进行分段，这样它生成的IP包长度就不会大于MTU了，当然也不需要IP层进行分片。</p><p>如果一个TCP分片丢失，就可以以MSS为单位重发数据</p><h5 id="（5）TCP接收队列"><a href="#（5）TCP接收队列" class="headerlink" title="（5）TCP接收队列"></a>（5）TCP接收队列</h5><p>​    在TCP三次握手中，我们如何分辨：哪些连接是半连接，哪些连接是全连接呢？</p><p>​    Linux通过维护两个队列来解决问题：</p><ul><li>半连接队列（SYN队列）</li><li>全连接队列（accepet队列）</li></ul><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110261926809.png" alt="img" style="zoom:80%;"><ul><li>服务端收到客户端发起的<strong>SYN</strong>后，内核会将连接存储到<strong>半连接队列</strong></li><li>服务端向客户端发送<strong>SYN+ACK</strong></li><li>客户端收到<strong>SYN+ACK</strong>后，发送<strong>ACK</strong>到服务端</li><li>服务端收到客户端的<strong>ACK</strong>后，内核会把连接从<strong>半连接队列</strong>移除，将其添加到<strong>全连接队列</strong>，等待进程调用<strong>accept函数</strong>时把连接取出来</li><li>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接<strong>丢弃</strong>，或<strong>返回 RST 包</strong></li></ul><h5 id="（6）SYN攻击与避免方式"><a href="#（6）SYN攻击与避免方式" class="headerlink" title="（6）SYN攻击与避免方式"></a>（6）SYN攻击与避免方式</h5><p>SYN攻击实际上就是对服务端一直发送SYN包，但是不回第三次握手ACK，这样会使服务端有大量的处于 <code>SYN_RECV</code> 状态的 TCP 连接（即<strong>半连接状态</strong>），久而久之就会导致<strong>TCP半连接队列溢出</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111221558394.jpeg" alt="img"></p><p><strong>避免SYN方法</strong>如下</p><p>方法一：调整Linux相关参数</p><p>通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</p><ul><li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog</span><br></pre></td></tr></table></figure><ul><li>SYN_RCVD 状态连接的最大个数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><ul><li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p>方法二：<strong>开启tcp_syncookies</strong></p><p>当syncookies=1时，服务端开启 syncookies 功能，其可以在不使用 SYN 半连接队列的情况下成功建立连接（默认配置）</p><p>SYN队列即半连接队列        Accept队列即全连接队列</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130712.png" alt="img" style="zoom: 50%;">                                <img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130242.png" alt="img" style="zoom: 50%;"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130175.png" alt="img" style="zoom:50%;">                                <img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130600.png" alt="img" style="zoom: 50%;"> </p><p>syncookies的运行原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功。其处理流程如下：</p><ul><li>「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接</li></ul><h4 id="3-TCP连接断开"><a href="#3-TCP连接断开" class="headerlink" title="3.TCP连接断开"></a>3.TCP连接断开</h4><h5 id="（1）四次挥手"><a href="#（1）四次挥手" class="headerlink" title="（1）四次挥手"></a>（1）四次挥手</h5><p>当我们的应用不再需要数据通信，就会发起断开TCP连接，建立一个连接需要<strong>三次握手</strong>，而终止一个连接需要经过<strong>四次挥手</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111551532.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong>；    FIN：表示<strong>断开</strong>连接</p><ul><li>第一次挥手：客户端发起<strong>FIN</strong>包，客户端进入<strong>FIN_WAIT_1</strong>状态（虽然FIN包不携带数据，也需要消耗一个序号u）</li><li>第二次挥手：服务端收到<strong>FIN</strong>包，发出确认包<strong>ACK</strong>（ack=u+1），并带上自己的序号seq=v，服务端进入<strong>CLOSE_WAIT</strong>状态（这个时候客户端仍需要接收服务器发送的数据）；客户端接收到服务端发送的<strong>ACK</strong>后，进入<strong>FIN_WAIT_2</strong>状态</li><li>第三次挥手：服务端数据发送完毕后，向客户端发送<strong>FIN</strong>包（seq=w，ack=u+1），<strong>半连接状态</strong>下服务器可能又发送一些数据，服务端此时进入<strong>LAST_ACK</strong>状态</li><li>第四次挥手：客户端收到服务端的<strong>FIN</strong>包后，发出确认包ACK（ACK=1， ack=w+1），此时客户端进入<strong>TIME_WAIT</strong>状态；服务端收到客户端确认包后进入<strong>CLOSED</strong>状态，而客户端需要等待2MSL后才进入<strong>CLOSED</strong>状态</li></ul><p>四次挥手的本质是——客户端和服务器通过<strong>两对FIN-ACK报文</strong>通知对方自己要关闭了</p><p>三次握手中，在第二次握手时，接收端将一个<strong>ACK</strong>包和一个<strong>SYN</strong>包合并一起发送，所以减少了一次包的发送</p><p>四次挥手中，在主动关闭方（客户端）发送FIN包后，接收方（服务端）可能还要发送数据，不能立即关闭数据通道，所以服务端要先确认ACK，然后等到自己把数据发无可发后再发送<strong>FIN</strong>包</p><h5 id="（2）需要四次挥手的原因"><a href="#（2）需要四次挥手的原因" class="headerlink" title="（2）需要四次挥手的原因"></a>（2）需要四次挥手的原因</h5><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能<strong>还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接</li></ul><p>服务端的<strong>ACK</strong>和<strong>FIN</strong>需要分开发送，是因为通常需要等待完成数据的发送和处理，所以会比三次握手多一次</p><h5 id="（3）TIME-WAIT状态功能"><a href="#（3）TIME-WAIT状态功能" class="headerlink" title="（3）TIME_WAIT状态功能"></a>（3）TIME_WAIT状态功能</h5><p>为什么客户端在关闭连接时需要一个TIME_WAIT的状态呢？</p><p>其主要有以下两个原因：</p><ul><li>防止旧连接的数据包</li><li>保证「被动关闭连接」的一方能被正确的关闭</li></ul><p><strong>防止旧连接的数据包</strong>：</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222021036.png" alt="img" style="zoom:67%;"><p>如果没有TIME_WAIT或TIME_WAIT的时间过短，那么图中被延迟的过期的数据包可能会被客户端正常接收</p><p>而经过TIME_WAIT的<code>2MSL</code> 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</p><p><strong>保证连接正确关闭</strong>：</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222130617.png" alt="img" style="zoom:67%;"><p>TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</p><p>一旦客户端最后的ACK报文在网络丢失，如果没有TIME_WAIT或TIME_WAIT的时间过短，客户端很快就会进入了则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。这时如果客户端要发起新的连接，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止</p><p>如果 TIME-WAIT 等待足够长时，一旦服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文</p><h5 id="（4）TIME-WAIT深入讲解"><a href="#（4）TIME-WAIT深入讲解" class="headerlink" title="（4）TIME_WAIT深入讲解"></a>（4）TIME_WAIT深入讲解</h5><p><strong>为什么TIME_WAIT等待的时间是两秒</strong>？</p><p>MSL：<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p><p>TTL： <strong>IP 数据报可以经过的最大路由数</strong>，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机</p><p>如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， <strong>一来一去正好 2 MSL</strong></p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong></p><p><strong>TIME_WAIT 过多有什么危害？</strong></p><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是内存资源占用；</li><li>第二是对端口资源的占用，如果<strong>TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接</strong></li></ul><p><strong>TIME_WAIT 优化</strong></p><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项：可以复用<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>，引入时间戳后，重复的数据包会因为时间戳过期而被自然丢弃，同时<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong></li><li>net.ipv4.tcp_max_tw_buckets：这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置</strong></li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭（也是一个危险行为，不推荐使用）</li></ul><h5 id="（5）TCP保活机制"><a href="#（5）TCP保活机制" class="headerlink" title="（5）TCP保活机制"></a>（5）TCP保活机制</h5><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>这时候就要提到TCP的<strong>保活机制</strong>了</p><p>在一个<strong>规定的时间段</strong>（tcp_keepalive_time：保活时间）内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<strong>每隔一个时间间隔</strong>（tcp_keepalive_intvl：每次检测间隔），发送一个「探测报文」，该探测报文包含的数据非常少，如果<strong>连续几个探测报文</strong>（tcp_keepalive_probes：检测次数）都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p><p>  相关参数如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110271337578.png" alt="image-20211023214647732">    </p><p>按照系统默认的设置来计算在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232154413.png" alt="img"></p><p>开启了TCP保活可以考虑以下三种情况：</p><ul><li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来</li><li>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置</li><li>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong></li></ul><p><strong>前方施工中。。。</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111222117832.webp" alt></p><h3 id="深入TCP机制"><a href="#深入TCP机制" class="headerlink" title="深入TCP机制"></a>深入TCP机制</h3><p>参考资料：<a href="https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA">https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA</a></p><h4 id="1-重传机制"><a href="#1-重传机制" class="headerlink" title="1.重传机制"></a>1.重传机制</h4><h4 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h4><h4 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3.流量控制"></a>3.流量控制</h4><h4 id="4-拥堵控制"><a href="#4-拥堵控制" class="headerlink" title="4.拥堵控制"></a>4.拥堵控制</h4><h3 id="TCP关键参数与优化"><a href="#TCP关键参数与优化" class="headerlink" title="TCP关键参数与优化"></a>TCP关键参数与优化</h3><p>参考文章：<a href="https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw">https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw</a></p><h4 id="1-TCP三次握手参数"><a href="#1-TCP三次握手参数" class="headerlink" title="1.TCP三次握手参数"></a>1.TCP三次握手参数</h4><h4 id="2-TCP四次挥手参数"><a href="#2-TCP四次挥手参数" class="headerlink" title="2.TCP四次挥手参数"></a>2.TCP四次挥手参数</h4><h4 id="3-TCP数据传输参数"><a href="#3-TCP数据传输参数" class="headerlink" title="3.TCP数据传输参数"></a>3.TCP数据传输参数</h4><h3 id="IP基本知识"><a href="#IP基本知识" class="headerlink" title="IP基本知识"></a>IP基本知识</h3><h3 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h3><h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><h3 id="Ping工作原理"><a href="#Ping工作原理" class="headerlink" title="Ping工作原理"></a>Ping工作原理</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202111222123110.png&quot; alt=&quot;Packets incoming &quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="https://autovy.github.io/tags/TCP/"/>
    
      <category term="IP" scheme="https://autovy.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>开发工具|Git的使用与工作原理</title>
    <link href="https://autovy.github.io/2021/11/16/Tool/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://autovy.github.io/2021/11/16/Tool/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-16T14:57:00.000Z</published>
    <updated>2022-08-30T08:07:45.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122115839.jpeg" alt="img"></p><span id="more"></span><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/45510461">深入理解Git实现原理 </a></p><p><a href="https://jingsam.github.io/2018/06/03/git-objects.html">Git内部原理之Git对象 </a></p><p><a href="https://zhuanlan.zhihu.com/p/42929114">Git 误操作救命良方</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a></p><h3 id="Git基本知识"><a href="#Git基本知识" class="headerlink" title="Git基本知识"></a>Git基本知识</h3><h4 id="1-Git定义"><a href="#1-Git定义" class="headerlink" title="1.Git定义"></a>1.Git定义</h4><p>git的本质就是要实现<strong>对文件变更过程的存储</strong></p><p>Git是一种分布式版本控制系统：</p><ul><li>版本控制：git可以对文件<strong>变更过程</strong>进行管理，随时可以拿出所需要的版本</li><li>分布式：Git的数据不仅存在<strong>远程仓库</strong>（即Git平台的服务器），也存在<strong>本地仓库</strong>（即项目开发者的本地计算机），所以称为<strong>分布式</strong></li></ul><h4 id="2-Git功能列表"><a href="#2-Git功能列表" class="headerlink" title="2.Git功能列表"></a>2.Git功能列表</h4><ul><li>我们可以为每一次变更提交版本更新并且备注更新的内容</li><li>我们可以在项目的各个历史版本之间自如切换</li><li>我们可以一目了然的比较出两个版本之间的差异</li><li>我们可以从当前的修改中撤销一些操作</li><li>我们可以自如的创建分支、合并分支</li><li>我们可以和多人协作开发</li><li>我们可以采取自由多样的开发模式</li></ul><h4 id="3-Git基本术语"><a href="#3-Git基本术语" class="headerlink" title="3.Git基本术语"></a>3.Git基本术语</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122058851.webp" alt="img"></p><ul><li><p>工作区：在编辑器内可增加或修改文件等位置</p></li><li><p>缓存区：提交代码，解决冲突的<strong>中转站</strong></p></li><li><p>版本库：本地<code>.git/</code>目录，内含<strong>缓存区</strong></p></li><li><p>本地仓库：连接本地代码和远程代码的<strong>枢纽</strong>，在没有联网状态下，本地代码可先提交至该处</p></li><li><p>远程仓库：托管远程代码的<strong>中央服务器</strong></p></li></ul><h4 id="4-Git托管平台"><a href="#4-Git托管平台" class="headerlink" title="4.Git托管平台"></a>4.Git托管平台</h4><h5 id="（1）Github"><a href="#（1）Github" class="headerlink" title="（1）Github"></a>（1）Github</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171119482.png" alt="img" style="zoom:50%;"><p>网址：<a href="https://github.com/">https://github.com/</a></p><p>Gihub是全球最流行的代码托管平台，拥有大量非常知名的开源项目。github的服务器部署在国外，国内访问不友好，适合用于学习和开发开源项目</p><h5 id="（2）Gitlab"><a href="#（2）Gitlab" class="headerlink" title="（2）Gitlab"></a>（2）Gitlab</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171119389.png" alt="img" style="zoom:67%;"><p>网址：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p><p>Gitlab支持免费搭建私有库，功能强大，对企业级的内部开发友好，较为笨重不适合用于简单项目的搭建</p><h5 id="（3）Gitee"><a href="#（3）Gitee" class="headerlink" title="（3）Gitee"></a>（3）Gitee</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122135738.png" alt="logo_gitee_light (1)"></p><p>网址：<a href="https://gitee.com/">https://gitee.com/</a></p><p>俗称码云，国内知名的在线代码托管平台，基于gitlab</p><h5 id="（4）Coding"><a href="#（4）Coding" class="headerlink" title="（4）Coding"></a>（4）Coding</h5><img src="https://assets.codehub.cn/resources/logo2-png.png" alt="img" style="zoom: 150%;"><p>网址：<a href="https://coding.net/">https://coding.net/</a></p><p>Coding 是一个面向开发者的云端开发平台，提供git/svn 代码托管,并且面向个人提供私有库。</p><p>对国内小团队开发较为友好，个人比较推荐，下面的一些操作都会基于Coding平台</p><h3 id="Git快速入门"><a href="#Git快速入门" class="headerlink" title="Git快速入门"></a>Git快速入门</h3><h4 id="1-Git安装"><a href="#1-Git安装" class="headerlink" title="1.Git安装"></a>1.Git安装</h4><p>git官网地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122216111.png" alt="image-20200629224316821"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217579.png" alt="image-20200629224329147"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217315.png" alt="image-20200629224339198"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217952.png" alt="image-20200629224349811"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217176.png" alt="image-20200629224400914"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217277.png" alt="image-20200629224411947"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217903.png" alt="image-20200629224425378"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217019.png" alt="image-20200629224436646"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122217284.png" alt="image-20200629224446392"></p><h4 id="2-Git密钥"><a href="#2-Git密钥" class="headerlink" title="2.Git密钥"></a>2.Git密钥</h4><p>本地仓库与远程仓库通过SSH公私钥进行身份确认，</p><h5 id="（1）生成公钥"><a href="#（1）生成公钥" class="headerlink" title="（1）生成公钥"></a>（1）生成公钥</h5><p>终端输入命令生成公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure><p>连续三次回车使用默认设置</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122334723.png" alt="image-20211112233436546"></p><h5 id="（2）查看公钥"><a href="#（2）查看公钥" class="headerlink" title="（2）查看公钥"></a>（2）查看公钥</h5><p>旁边的id_rsa存的就是私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 【公钥保存位置】/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122342467.png" alt="image-20211112234254250"></p><h5 id="（3）上传公钥"><a href="#（3）上传公钥" class="headerlink" title="（3）上传公钥"></a>（3）上传公钥</h5><p>打开coding的个人设置页面即可上传公钥</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122349256.png" alt="image-20211112234911836"></p><h5 id="（4）Git连接测试"><a href="#（4）Git连接测试" class="headerlink" title="（4）Git连接测试"></a>（4）Git连接测试</h5><p>通过以下命令即可测试ssh连接是否成功（第一次连接需要一个输入yes的步骤）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122355195.png" alt="image-20211112235520804"></p><h4 id="3-Git项目创建实战"><a href="#3-Git项目创建实战" class="headerlink" title="3.Git项目创建实战"></a>3.Git项目创建实战</h4><h5 id="（1）Coding上创建项目"><a href="#（1）Coding上创建项目" class="headerlink" title="（1）Coding上创建项目"></a>（1）Coding上创建项目</h5><p>点击创建项目</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111122358086.png" alt="image-20211112235849036"></p><p>选择模板2中的代码托管即可</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130004964.png" alt="image-20211113000450682"></p><p>填写项目基本信息，即可完成创建</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130008061.png" alt="image-20211113000842644"></p><h5 id="（2）创建代码仓库"><a href="#（2）创建代码仓库" class="headerlink" title="（2）创建代码仓库"></a>（2）创建代码仓库</h5><p>在项目下创建代码仓库</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130012170.png" alt="image-20211113001242845"></p><p>基本设置如下：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130016365.png" alt="image-20211113001619059"></p><h5 id="（3）将项目克隆到本地"><a href="#（3）将项目克隆到本地" class="headerlink" title="（3）将项目克隆到本地"></a>（3）将项目克隆到本地</h5><p>复制仓库的ssh链接，将一个仓库内的代码使用ssh下载到本地</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130019611.png" alt="image-20211113001922314"></p><p>电脑上执行git clone命令，将远程仓库克隆为本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 【SSH链接】</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130044923.png" alt="image-20211113004407422"></p><p>有时会出现下载时权限不足的情况，但是ssh的连接测试又能成功，这时候可以尝试一下重新提交公钥</p><p>进入项目文件夹</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130047475.png" alt="image-20211113004735237"></p><p>在git bash下可以看到Test文件有master的符号</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130048748.png" alt="image-20211113004836580"></p><h5 id="（4）设置签名"><a href="#（4）设置签名" class="headerlink" title="（4）设置签名"></a>（4）设置签名</h5><p>设置签名以区分不同开发者的身份（与代码托管中心的账号，密码无关）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;Autovy&quot;</span><br><span class="line">git config user.email &quot;autovys@gmail.com&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130053370.png" alt="image-20211113005344281"></p><p>设置完成后，即可在配置文件看到相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./.git/config</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130055517.png" alt="image-20211113005519211"></p><h5 id="（5）代码提交流程"><a href="#（5）代码提交流程" class="headerlink" title="（5）代码提交流程"></a>（5）代码提交流程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130117765.png" alt="img"></p><p>修改项目文件</p><p>创建一个html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test&quot; &gt; index.html</span><br></pre></td></tr></table></figure><p>修改md文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131044670.png" alt="image-20211113104443895"></p><p>将工作区改动内容提交到缓存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br></pre></td></tr></table></figure><p>查看工作区和缓存区状态</p><p>可以看到文件改动情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130109179.png" alt="image-20211113010859895"></p><p>将缓存区的内容提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;v1.1：添加index文件&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130111345.png" alt="image-20211113011106112"></p><p>查看历史记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130112029.png" alt="image-20211113011224760"></p><p>将本地仓库的内容推送到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130113789.png" alt="image-20211113011323568"></p><p>最后可以看到Coding仓库变化</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130120323.png" alt="image-20211113012003368"></p><h3 id="Git高级使用"><a href="#Git高级使用" class="headerlink" title="Git高级使用"></a>Git高级使用</h3><h4 id="1-Git版本管理"><a href="#1-Git版本管理" class="headerlink" title="1.Git版本管理"></a>1.Git版本管理</h4><h5 id="（1）更新1-2为最新版"><a href="#（1）更新1-2为最新版" class="headerlink" title="（1）更新1.2为最新版"></a>（1）更新1.2为最新版</h5><p>重复上面步骤，修改并更新index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130856940.png" alt="image-20211113085631627"></p><p>修改md中的版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130858725.png" alt="image-20211113085813333"></p><p>将1.2版本的代码按步骤提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;v1.2：增加index文件标题&quot;</span><br></pre></td></tr></table></figure><p>这里先不推送远端仓库，方便后续切换版本</p><h5 id="（2）查看日志"><a href="#（2）查看日志" class="headerlink" title="（2）查看日志"></a>（2）查看日志</h5><p>git log 查看提交日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130908924.png" alt="image-20211113090846535"></p><p>commit后面一大段的字符串是commit id（版本号），这里<code>HEAD</code>是Git指向当前版本的指针，所以要切换版本就要移动<code>HEAD</code>到指定版本</p><h5 id="（3）修改未添加缓冲区"><a href="#（3）修改未添加缓冲区" class="headerlink" title="（3）修改未添加缓冲区"></a>（3）修改未添加缓冲区</h5><p>修改index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131239773.png" alt="image-20211113123920560"></p><p>在对文件使用<code>add ./</code>将项目添加缓存区之前，我反悔了，决定丢弃工作区的修改</p><p>查看当前状态,可以看到提示使用<code>git restore</code>丢弃修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131243158.png" alt="image-20211113124311037"></p><p>丢弃修改工作区的修改，文件恢复到最近一次<code>git commit</code>或<code>git add</code>时的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore ./</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131245744.png" alt="image-20211113124505502"></p><h5 id="（4）修改添加到缓存区"><a href="#（4）修改添加到缓存区" class="headerlink" title="（4）修改添加到缓存区"></a>（4）修改添加到缓存区</h5><p>修改index.html文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131239773.png" alt="image-20211113123920560"></p><p>添加修改到缓冲区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add ./</span><br></pre></td></tr></table></figure><p>查看当前状态,可以看到提示使用<code>git restore --staged</code>丢弃缓存内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131253728.png" alt="image-20211113125325665"></p><p>丢弃缓存内容后，再按上一种情况的流程恢复工作区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged ./</span><br><span class="line">git status</span><br><span class="line">git restore ./</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131257426.png" alt="image-20211113125708241"></p><h5 id="（5）修改提交到本地仓库"><a href="#（5）修改提交到本地仓库" class="headerlink" title="（5）修改提交到本地仓库"></a>（5）修改提交到本地仓库</h5><p>将版本回退到上一个版本即1.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130918240.png" alt="image-20211113091804033"></p><p>这时本地仓库就回退到了1.1版本</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130921002.png" alt="image-20211113092137541"></p><p>这时候查看git log，可以发现1.2的提交记录就移除</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131027386.png" alt="image-20211113102703410"></p><p>如果又需要回到1.2版本</p><p>先通过<code>git reflog</code>查看历史命令，可以找到1.2版本的id</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131029910.png" alt="image-20211113102934666"></p><p>同样可以使用git reset切换版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 【commit id】</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131034955.png" alt="image-20211113103418305"></p><p>这里的commit id不用填完整，填到后面的字母部分</p><p>这时本地仓库又切回了1.2</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131035167.png" alt="image-20211113103512977"></p><p>【注意】</p><p>如果已经将最新的代码推送过远端仓库（即远端仓库有最新的版本，要保持本地和远端的资源一致），会报以下错误、</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131037463.png" alt="image-20211113103733311"></p><h5 id="（6）修改推送到远程仓库"><a href="#（6）修改推送到远程仓库" class="headerlink" title="（6）修改推送到远程仓库"></a>（6）修改推送到远程仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD --edit //并修改提交信息</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130958874.png" alt="image-20211113095811776"></p><p>这时后查看记录git log，可以看到撤销的操作也被记录其中</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111130958447.png" alt="image-20211113095828085"></p><p>这时本地仓库就是回退到了版本1.1</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131003562.png" alt="image-20211113100356269"></p><p>直接推送到远程仓库，远程仓库也回退到1.1版本</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131006709.png" alt="image-20211113100641582"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131008429.png" alt="image-20211113100811889"></p><p>如果提交了1.1版本后，又需要回到1.2版本，这时候只要撤销掉对1.2的撤销即可</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131017882.png" alt="image-20211113101733694"></p><p>再git push推送到远程仓库即可</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131020252.png" alt="image-20211113102000137"></p><h5 id="（7）总结"><a href="#（7）总结" class="headerlink" title="（7）总结"></a>（7）总结</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131304234.webp" alt="img"></p><ul><li>工作区修改后：<code>git restore ./</code>恢复工作区</li><li><code>git add ./</code>添加到缓冲区后：<code>git restore --staged ./</code> 恢复缓存区</li><li><code>git commit</code>提交到本地仓库后：<code>git reset --hard HEAD^</code>恢复上个版本到缓存区</li><li><code>git push</code>推送到远程仓库后：<code>git revert HEAD --edit</code>撤销上一个推送操作，并恢复到缓存区</li></ul><h4 id="2-Git分支管理"><a href="#2-Git分支管理" class="headerlink" title="2.Git分支管理"></a>2.Git分支管理</h4><h5 id="（1）分支解决的问题"><a href="#（1）分支解决的问题" class="headerlink" title="（1）分支解决的问题"></a>（1）分支解决的问题</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131648459.png" alt="image-20200728190230431"></p><p>同时并行推进多个功能开发，提高开发效率</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</p><p>最后再将分支合并到master上</p><p>分支：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131704793.png" alt="git-br-dev-fd"></p><p>分支的合并（默认快速模式）：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131704428.png" alt="git-br-ff-merge"></p><p>分支的合并（普通模式）：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131923880.png" alt="git-no-ff-mode"></p><h5 id="（2）分支基本操作"><a href="#（2）分支基本操作" class="headerlink" title="（2）分支基本操作"></a>（2）分支基本操作</h5><p>创建dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure><p><code>git checkout -b dev</code>可以创建并切换到dev分支</p><p>查看当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131739936.png" alt="image-20211113173909862"></p><p>可以看到dev分支已经创建成功了，而当前位于master分支</p><p>切换到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131741071.png" alt="image-20211113174105689"></p><p>修改文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131743765.png" alt="image-20211113174328787"></p><p>将最新修改的内容提交到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;dev new test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131744195.png" alt="image-20211113174453991"></p><p>切换回master分支，并查看文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch master</span><br><span class="line">cat README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131747443.png" alt="image-20211113174734151"></p><p>可以看到主分支上没有dev的内容</p><p>合并分支</p><p>在master分支上合并dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131907625.png" alt="image-20211113190746514"></p><p>可以看到在dev上的修改在master上生效了</p><h5 id="（3）分支合并冲突问题"><a href="#（3）分支合并冲突问题" class="headerlink" title="（3）分支合并冲突问题"></a>（3）分支合并冲突问题</h5><p>前面的情况中，dev是在master基础上的，合并前master并没有修改，如果master再合并前与dev修改了同一行的内容就会出现冲突</p><p>先撤销一下合并</p><p>查看命令记录，可以看到合并记录中合并的方式是快速模式（即直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131917856.png" alt="image-20211113191710611"></p><p>撤销合并（未推送）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131928808.png" alt="image-20211113192813592"></p><p>修改master内容，并提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131936127.png" alt="image-20211113193624097"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;master new test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131933331.png" alt="image-20211113193330217"></p><p>再次合并dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>这时就会出现合并冲突的问题</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131937333.png" alt="image-20211113193742100"></p><p>解决冲突</p><p>编辑README.md文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p>删除特殊符号，修改内容</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131948656.png" alt="image-20211113194812446"></p><p>然后正常提交到master分支即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;master+dev&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131950140.png" alt="image-20211113195019152"></p><p>一般来说不会再本地仓库库对分支进行合并，而是在远程的代码平台进行分支的合并</p><p>推送内容到master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push </span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131954980.png" alt="image-20211113195444076"></p><p>由于远程仓库还没有创建dev分支，所以推送时要创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin dev</span><br></pre></td></tr></table></figure><p>这时即可在Coding上看到两个分支了</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111131959633.png" alt="image-20211113195934598"></p><p>代码平台上也可以合并分支，当如果有冲突就无法合并</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132004299.png" alt="image-20211113200419162"></p><h5 id="（3）分支中的多人协作"><a href="#（3）分支中的多人协作" class="headerlink" title="（3）分支中的多人协作"></a>（3）分支中的多人协作</h5><p>准备wsl模拟另一台电脑，一个新的coding账号，新的coding账号提交wsl中的ssh，然后使用两个浏览器登录分别登录两个账号</p><p>将第二个账号（二号机）邀请到主账号的团队中</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132151963.png" alt="image-20211113215154747"></p><p>将二号机拉入项目中</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132153673.png" alt="image-20211113215314621"></p><p>二号机wsl看到项目后克隆项目到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@e.coding.net:autovys/demo/Test.git</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132157453.png" alt="image-20211113215727175"></p><p>进入目录后查看分支，可以发现只能看到master分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132201201.png" alt="image-20211113220115181"></p><p>二号机要在dev基础上进行开发，就要创建远程<code>origin</code>的<code>dev</code>分支到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132204477.png" alt="image-20211113220445123"></p><p>二号机在dev基础上修改了文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132210496.png" alt="image-20211113221049407"></p><p>并且二号机还推送到了远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m&quot;edit something&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132214127.png" alt="image-20211113221447824"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132216488.png" alt="image-20211113221631576"></p><p>这时一号机也要对同样的文件修改一些内容，并尝试推送到dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132236484.png" alt="image-20211113223622153"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;add someting&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132238492.png" alt="image-20211113223826310"></p><p>可以发现远程推送失败了，因为二号机的最新提交和我推送的提交有冲突</p><p>这时就需要先<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132242133.png" alt="image-20211113224245383"></p><p>这时候解决的方法和分支管理中的解决冲突完全一样</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132245482.png" alt="image-20211113224352026"></p><p>编辑README.md文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p>删除特殊符号，修改内容</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132246382.png" alt></p><p>然后正常提交到dev分支即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;dev lastest&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111132248140.png" alt="image-20211113224806916"></p><h3 id="IDEA中的Git"><a href="#IDEA中的Git" class="headerlink" title="IDEA中的Git"></a>IDEA中的Git</h3><h4 id="1-基本代码提交流程"><a href="#1-基本代码提交流程" class="headerlink" title="1.基本代码提交流程"></a>1.基本代码提交流程</h4><h5 id="（1）创建空项目"><a href="#（1）创建空项目" class="headerlink" title="（1）创建空项目"></a>（1）创建空项目</h5><p>在Coding上创建新的空的代码仓库</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151520287.png" alt="image-20211115152050857"></p><p>idea克隆项目到本地</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151538447.png" alt="image-20211115153822099"></p><p>填写远程仓库的SSH地址和下载的本地位置完成下载</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151539643.png" alt="image-20211115153943646"></p><h5 id="（2）IDEA打开项目文件"><a href="#（2）IDEA打开项目文件" class="headerlink" title="（2）IDEA打开项目文件"></a>（2）IDEA打开项目文件</h5><p>IDEA打开项目文件后，可以看到IDEA自动识别了git，出现了以下的一些工具</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151525037.png" alt="image-20211115152526919"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151525272.png" alt="image-20211115152549962"></p><h5 id="（3）代码提交流程"><a href="#（3）代码提交流程" class="headerlink" title="（3）代码提交流程"></a>（3）代码提交流程</h5><p>修改README.md文件如下，即在工作区改动了代码</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151547945.png" alt="image-20211115154732860"></p><p>将代码添加到缓冲区（<strong>git add ./</strong>），这一步可以省略，直接提交idea会帮你做这一步操作</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151552952.png" alt="image-20211115155242753"></p><p>提交代码到本地仓库，注意填写提交信息（<code>git commit -m &quot;message&quot;</code>）</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171119189.png" alt="image-20211115155909225" style="zoom:67%;"><p>最后推送到远程仓库，即完成一次代码提交（<code>git push</code>）</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171120093.png" alt="image-20211115160154599" style="zoom:67%;"><p>关于提交的一些信息我们都可以在git工具栏的控制台进行查看，可以看到git工具的控制台帮我们输入的命令内容</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151604019.png" alt="image-20211115160454918"></p><h4 id="2-Git版本管理"><a href="#2-Git版本管理" class="headerlink" title="2.Git版本管理"></a>2.Git版本管理</h4><h5 id="（1）更新版本到1-2"><a href="#（1）更新版本到1-2" class="headerlink" title="（1）更新版本到1.2"></a>（1）更新版本到1.2</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151607155.png" alt="image-20211115160753928"></p><h5 id="（2）查看提交日志"><a href="#（2）查看提交日志" class="headerlink" title="（2）查看提交日志"></a>（2）查看提交日志</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151609447.png" alt="image-20211115160933261"></p><p>可以看到idea使用git不需要设置签名，而是默认使用了远程仓库平台的注册信息</p><h5 id="（3）修改未添加缓冲区-1"><a href="#（3）修改未添加缓冲区-1" class="headerlink" title="（3）修改未添加缓冲区"></a>（3）修改未添加缓冲区</h5><p>代码未添加到缓冲区，需要恢复工作区的内容（简单呀，疯狂ctrl + Z 😎）</p><p>可以使用回滚，即可恢复到最近一次<code>git commit</code>或<code>git add</code>时的状态</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151615806.png" alt="image-20211115161519696"></p><h5 id="（4）修改添加到缓存区-1"><a href="#（4）修改添加到缓存区-1" class="headerlink" title="（4）修改添加到缓存区"></a>（4）修改添加到缓存区</h5><p>版本1.2已经添加到了缓存区，同样可以通过上面的方法恢复工作区</p><h5 id="（5）修改提交到本地仓库-1"><a href="#（5）修改提交到本地仓库-1" class="headerlink" title="（5）修改提交到本地仓库"></a>（5）修改提交到本地仓库</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171120642.png" alt="image-20211115162500521" style="zoom:67%;"><p>这时候可以看到回滚的按钮变灰了，这时我们可以打开git工具区对master分支进行操作，idea提供了三种还原的方法，都可以让我们恢复1.1版本</p><p>还原提交，是多加一步撤销的操作，恢复内容到本地仓库，可以直接提交</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151635193.png" alt="image-20211115163502070"></p><p>撤销提交，是让1.2版本恢复到缓存区，这时候可以通过回滚恢复到1.1版本</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151638218.png" alt="image-20211115163801094"></p><p>删除提交，直接恢复1.1版本到工作区</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151642751.png" alt="image-20211115164217388"></p><p>所以推荐使用<strong>还原提交</strong>，如果要丢弃的版本就使用<strong>删除提交</strong>，否则idea无法恢复已<strong>撤销</strong>或<strong>删除</strong>的提交（命令行可以恢复）</p><h5 id="（6）修改推送到远程仓库-1"><a href="#（6）修改推送到远程仓库-1" class="headerlink" title="（6）修改推送到远程仓库"></a>（6）修改推送到远程仓库</h5><p>推送到远程仓库后，我们可以看到我们只剩下还原提交可以使用了，效果和上面的一样</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151654101.png" alt="image-20211115165440862"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111151655427.png" alt="image-20211115165553230"></p><p>idea还提供了将<strong>当前分支重置到此处</strong>的功能，其相当于进行多次的<strong>删除提交</strong>操作。在修改已提交到本地仓库的情况下，可以开始回溯到选择的版本；在修改已推送到远程的情况下可能会造成<strong>冲突</strong>问题，所以该功能慎重使用</p><p>​    <img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171119727.png" alt="image-20211115172549467">)<img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171119566.png" alt="image-20211115173345841"></p><h5 id="（7）还原提交的问题"><a href="#（7）还原提交的问题" class="headerlink" title="（7）还原提交的问题"></a>（7）还原提交的问题</h5><p>还原提交也可以还原更远的版本，但是会出现冲突问题，</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152003466.png" alt="image-20211115200310949"></p><p>接收他们的则回滚到对应版本，合并则解决两个修改的冲突</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171119845.png" alt="image-20211115200355899"></p><p>合并的页面如下，点击箭头即可自动修改冲突点</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152005861.png" alt="image-20211115200459979"></p><h4 id="3-Git分支管理"><a href="#3-Git分支管理" class="headerlink" title="3.Git分支管理"></a>3.Git分支管理</h4><h5 id="（1）分支基本操作"><a href="#（1）分支基本操作" class="headerlink" title="（1）分支基本操作"></a>（1）分支基本操作</h5><p>创建分支dev</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152012354.png" alt="image-20211115201204089"></p><p>git工作区右键选择分支<strong>签出</strong>（checkout,什么铸币翻译）即可切换分支，注意记得先切换好分支再对提交的路径图进行操作，否则它提交的到的是当前的分支，即便是在另一条分支上做的操作</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152025323.png" alt="image-20211115202549168"></p><p>这里在dev上操作的还原提交会被提交给master，所以要记得切换分支（这算不算一个小bug呢？），另外要删除一个分支时也要先切换到其他分支</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111171120317.png" alt="image-20211115203232293" style="zoom:67%;"><p>修改文件提交到dev</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152014852.png" alt="image-20211115201418871"></p><p>直接选择推送，远程仓库就可以发现dev分支被创建好了</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152156328.png" alt="image-20211115215649882"></p><p>合并master和dev分支，当前选择的是master分支，所以选择将<strong>当前合并到已选择</strong>（渣翻ks8）即为将dev合并到master</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152143774.png" alt="image-20211115214311537"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152145633.png" alt="image-20211115214548426"></p><h5 id="（2）分支合并冲突问题"><a href="#（2）分支合并冲突问题" class="headerlink" title="（2）分支合并冲突问题"></a>（2）分支合并冲突问题</h5><p>先删除合并的提交恢复master，修改master的文件并提交</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152148111.png" alt="image-20211115214855710"></p><p>这时候合并就会出现合并冲突现象</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152151512.png" alt="image-20211115215121774"></p><p>前面两个是对master修改的内容与dev修改的内容做一个选择，选择合并则需要手动修改解决冲突</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152153800.png" alt="image-20211115215351531"></p><p>点击箭头即可合并修改</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152154978.png" alt="image-20211115215421974"></p><h5 id="（3）分支中的多人协作-1"><a href="#（3）分支中的多人协作-1" class="headerlink" title="（3）分支中的多人协作"></a>（3）分支中的多人协作</h5><p>推送上面修改的master分支和dev分支，然后删除本地项目文件（即删除了本地仓库），进行一次remake</p><p>重新使用idea克隆项目到本地，可以看到本地只拉取了master分支</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152204429.png" alt="image-20211115220444280"></p><p>这时候就需要右键点击远程的分支，新建dev分支到本地</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152207194.png" alt="image-20211115220650353"></p><p>在Coding平台上改动dev分支的文件，模拟另一个开发人员在协同开发的情况下修改了文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152210219.png" alt="image-20211115221009031"></p><p>这时候我们在本地也修改了dev分支文件并推送</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152212003.png" alt="image-20211115221205796"></p><p>这时候idea会有弹窗提醒<strong>推送被拒绝</strong>，并在控制台提醒你用<code>git pull</code></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152213026.png" alt="image-20211115221318639"></p><p>idea是有git pull 这个按钮的</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152216055.png" alt="image-20211115221609871"></p><p>但是点击更新到dev时，会提示你本地的dev没有追踪远程的分支</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152217453.png" alt="image-20211115221717207"></p><p>点击提示选择上游分支同步远程的dev分支即可</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152218528.png" alt="image-20211115221849343"></p><p>如果其他开发者新的更新和我更新的有冲突，这时候就是我们熟悉的冲突页面啦</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111152219333.png" alt="image-20211115221925143"></p><p>解决冲突后我们就可以推送最新版到远程仓库了，这样的机制保证了git协同开发的可能性</p><h3 id="Git原理"><a href="#Git原理" class="headerlink" title="Git原理"></a>Git原理</h3><p><strong>Git本质是一个内容寻址的文件系统，其次才是一个版本控制系统</strong></p><p>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作是将被改写的文件保存为<strong>数据对象</strong>，更新暂存区，记录<strong>树对象</strong>，最后创建一个指明了顶层树对象和父提交的<strong>提交对象</strong></p><p>Git的核心是它的对象数据库（<strong>.git/objects</strong>文件），其中保存着git的对象：</p><ul><li><strong>blob对象</strong>：实现了对文件内容的记录</li><li><strong>tree对象</strong>：实现了对文件名、文件目录结构的记录</li><li><strong>commit对象</strong>：实现了对版本提交时间、版本作者、版本序列、版本说明等附加信息的记录</li></ul><h4 id="1-Git数据库"><a href="#1-Git数据库" class="headerlink" title="1.Git数据库"></a>1.Git数据库</h4><h5 id="（1）Git文件结构"><a href="#（1）Git文件结构" class="headerlink" title="（1）Git文件结构"></a>（1）Git文件结构</h5><p>新建文件夹并将其初始化为一个空的git仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Test</span><br><span class="line">git init Test</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161632587.png" alt="image-20211116163217085"></p><p>进入git文件使用以下命令查看git仓库的文件结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Test/.git</span><br><span class="line">tree/F</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161634477.png" alt="image-20211116163406004"></p><ul><li><strong>config</strong>是git基本配置文件</li><li><strong>description</strong>是GitWeb专用的文件</li><li><strong>info</strong>文件夹是全局性排除文件（与.gitignore互补）</li><li><strong>hooks</strong>存放钩子脚本</li><li><strong>HEAD</strong>记录当前checkout的分支</li><li><strong>refs</strong>提交对象的指针</li><li><strong>objects</strong>存放所有数据，这就是我们要找的数据库了</li></ul><h5 id="（2）Git数据库写入操作"><a href="#（2）Git数据库写入操作" class="headerlink" title="（2）Git数据库写入操作"></a>（2）Git数据库写入操作</h5><p>Git会根据文件内容计算出一个hash值，以hash值作为文件索引存储在Git文件系统中</p><p><code>git hash-object</code>可以用来计算文件内容的hash值，并将生成的数据对象存储到Git文件系统中</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161933764.png" alt="image-20211116193321631"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;version 1&quot; | git hash-object -w --stdin</span><br></pre></td></tr></table></figure><p><code>-w</code>表示将数据对象写入到Git文件系统中，<code>--stdin</code>表示从标准输入中获取文件内容</p><p>命令执行完成后返回一个哈希值，它就是git数据库中的<strong>键值（key）</strong>，通过键值我们可以再次检索到插入数据库的内容<strong>（value）</strong>，实际上git数据库就是一个简单的<strong>键值对</strong>数据库</p><p>查看object文件，可以看到新生成的文件，这个文件存储以新存入数据<strong>对应hash值前2位</strong>命名的文件夹内</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161934272.png" alt="image-20211116193416942"></p><h5 id="（3）Git数据库查询操作"><a href="#（3）Git数据库查询操作" class="headerlink" title="（3）Git数据库查询操作"></a>（3）Git数据库查询操作</h5><p>既然我们拿到了键值，那肯定可以查询到其对应的内容，复制hash值进行查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t d73e3875a8db6b402e2ce905c4a2222603c1f090</span><br><span class="line"></span><br><span class="line">git cat-file -p d73e3875a8db6b402e2ce905c4a2222603c1f090</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161935233.png" alt="image-20211116193551166"></p><p><code>-p</code>表示查看Git对象的内容，<code>-t</code>表示查看Git对象的类型</p><p>blob对象是git数据库中的<strong>数据对象</strong>，此外数据库中还有<strong>树对象</strong>（tree）和<strong>提交对象</strong>（commit）</p><h4 id="4-使用Git跟踪文件变更"><a href="#4-使用Git跟踪文件变更" class="headerlink" title="4.使用Git跟踪文件变更"></a>4.使用Git跟踪文件变更</h4><p>接下来我们将模拟一次文件变更过程，看看git的对象数据库能不能实现“跟踪文件变更”的功能</p><h5 id="（1）创建文件"><a href="#（1）创建文件" class="headerlink" title="（1）创建文件"></a>（1）创建文件</h5><p>创建一个txt文件写入内容“v1.1”，并写入到git数据库中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;version 1&quot; &gt; file.txt</span><br><span class="line">git hash-object -w file.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161937621.png" alt="image-20211116193749552"></p><h5 id="（2）修改文件"><a href="#（2）修改文件" class="headerlink" title="（2）修改文件"></a>（2）修改文件</h5><p>修改file.txt的内容，并再次提交到git数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;version 2&quot; &gt; file.txt</span><br><span class="line">git hash-object -w file.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161938803.png" alt="image-20211116193813071"></p><p>可以看到这次的hash值已经发生改变了，而objetcs内会多出一个文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161938498.png" alt="image-20211116193846013"></p><p>查询它们对应的内容如下</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161939714.png" alt="image-20211116193930700"></p><p>说明我们对同一个文件修改后的内容也会经过git数据库的哈希处理再数据库生成新的数据对象，以此记录文件的不同版本</p><h5 id="（3）恢复文件"><a href="#（3）恢复文件" class="headerlink" title="（3）恢复文件"></a>（3）恢复文件</h5><p>所以我们想要把文件恢复到文件修改前版本，只需要在数据库取回即可，这就是<strong>git版本回滚的实质</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br><span class="line">git cat-file -p 83baa &gt; file.txt</span><br><span class="line">cat file.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111161945593.png" alt="image-20211116194508507"></p><p>数据对象只是解决了文件内容存储的问题，而文件名的存储则需要通过树对象来解决</p><h4 id="5-Git的树对象"><a href="#5-Git的树对象" class="headerlink" title="5.Git的树对象"></a>5.Git的树对象</h4><p>Git通过树对象（tree）将数据（blob）对象组织起来——其类型于一种文件系统：blob对应文件内容，tree对象对应的目录和节点</p><p>有了数对象，我们就可以将文件系统任何时间点的状态保存在git数据库中</p><h5 id="（1）创建树对象（文件已提交数据库）"><a href="#（1）创建树对象（文件已提交数据库）" class="headerlink" title="（1）创建树对象（文件已提交数据库）"></a>（1）创建树对象（文件已提交数据库）</h5><p>Git根据某一个<strong>暂存区</strong>所表示的状态记录一个对应的树对象，git的暂存区是一个文件：<code>.git/index</code></p><p>这里要注意将file文件放在<code>.git</code>文件外，否则无法创建暂存区（上面的操作我都把file.txt放在了.git内🤧）,大概错误如下</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162013837.png" alt="image-20211116201312604"></p><p>创建暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git update-index --add file.txt</span><br><span class="line">cat .git\index</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162016844.png" alt="image-20211116201640442"></p><p>查看<strong>暂存区</strong>的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --stage</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162019086.png" alt="image-20211116201945864"></p><p>将<strong>暂存区</strong>的内容写入一个树对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git write-tree</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162023263.png" alt="image-20211116202313249"></p><p>这时候再查看git数据库，树对象也被存入git数据库内了</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162024659.png" alt="image-20211116202420483"></p><p>再查看该记录存储的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 79335</span><br><span class="line">git cat-file -p 79335</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162026758.png" alt="image-20211116202635361"></p><p>可以看到树对象中存储着<strong>文件名</strong>与<strong>文件内容对应的哈希值</strong>等</p><h5 id="（2）创建对象（文件未提交数据库）"><a href="#（2）创建对象（文件未提交数据库）" class="headerlink" title="（2）创建对象（文件未提交数据库）"></a>（2）创建对象（文件未提交数据库）</h5><p>上面我们是添加一个已经存在再git数据库的文件到暂存区，如果我们新建一个未曾保存到git数据库的文件到暂存区，进而保存为tree对象</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162053546.png" alt="image-20211116205331283"></p><ul><li>我们会发现新文件提交到暂存区后也会自动添加到数据库</li><li>添加文件到暂存区是追加操作，变更提交后，<strong>暂存区并没有清空</strong></li></ul><h5 id="（3）子文件夹保存到树对象"><a href="#（3）子文件夹保存到树对象" class="headerlink" title="（3）子文件夹保存到树对象"></a>（3）子文件夹保存到树对象</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_dir</span><br><span class="line">git update-index --add new_dir</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162056889.png" alt="image-20211116205602679"></p><p>可以发现，我们无法将一个空文件夹添加到暂存区，并且提示我们应该将文件夹中的文件加入<strong>暂存区</strong></p><p>接下来我们就试一下将文件夹中的文件添加进缓存区</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162100367.png" alt="image-20211116210040965"></p><p>可以发现文件夹是以一个tree对象添加进树中的</p><p>所以git的树对象的组织方式大致如下</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162102494.png" alt="img"></p><p>树对象相当于源代码的一次次快照，因此我们可以用树对象作为源代码版本管理，接下来我们还需要解决记录谁提交了代码、什么时候提交的、提交的说明信息等的问题，这就需要用到提交对象</p><h4 id="6-Git的提交对象"><a href="#6-Git的提交对象" class="headerlink" title="6.Git的提交对象"></a>6.Git的提交对象</h4><h5 id="（1）创建提交对象"><a href="#（1）创建提交对象" class="headerlink" title="（1）创建提交对象"></a>（1）创建提交对象</h5><p>将创建的树对象提交为commit对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git write-tree</span><br><span class="line">git commit-tree 15da -m &quot;frist commit&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162235396.png" alt="image-20211116223537292"></p><p>查看提交对象的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p dd7b6</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162236318.png" alt="image-20211116223657063"></p><p>我们可以看到一个提交对象包含提交版本的<strong>树对象hash键值</strong>，author和commiter，以及修改和提交时间，以及提交的注释信息</p><h5 id="（2）提交新版本"><a href="#（2）提交新版本" class="headerlink" title="（2）提交新版本"></a>（2）提交新版本</h5><p>生成新的文件的对象树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;new version&quot; &gt; file.txt</span><br><span class="line">git update-index file.txt</span><br><span class="line">git write-tree</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162248307.png" alt="image-20211116224816724"></p><p>在上一次提交的基础上提交对象树作为提交对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit-tree a4098 -p dd7b6 -m &quot;second commit&quot;</span><br><span class="line">98b0754a75a763db80ac689cd16e2665ced92589</span><br></pre></td></tr></table></figure><p><code>-p</code>对应上次提交对象的hash值</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162248268.png" alt="image-20211116224828288"></p><p>查看提交对象，可以看到多了一个父提交的记录</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162249974.png" alt="image-20211116224957926"></p><h5 id="（3）提交对象记录"><a href="#（3）提交对象记录" class="headerlink" title="（3）提交对象记录"></a>（3）提交对象记录</h5><p>通过git log 查看提交对象记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 98b0</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162253027.png" alt="image-20211116225317939"></p><p>至此我们可以看到git对象之间联系的全貌了</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162303582.png" alt="img"></p><h4 id="7-Git的引用"><a href="#7-Git的引用" class="headerlink" title="7.Git的引用"></a>7.Git的引用</h4><p>以上的操作，我们对版本和数据对象的操作都是基于hash键值的，但是这些字符串是毫无意义的，所以git引入了<strong>引用（reference）</strong>使用有意义的字符串<strong>对应</strong>哈希值来解决这个问题，其主要应用于<strong>分支</strong></p><h5 id="（1）创建引用"><a href="#（1）创建引用" class="headerlink" title="（1）创建引用"></a>（1）创建引用</h5><p>为最新的提交对象创建一个引用名为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log 98b0</span><br><span class="line">git update-ref refs/heads/master 98b0</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162328532.png" alt="image-20211116232811501"></p><h5 id="（2）查看"><a href="#（2）查看" class="headerlink" title="（2）查看"></a>（2）查看</h5><p>创建成功后，我们就可以使用master来代替hash值查看提交对象记录</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202111162329835.png" alt="image-20211116232919198"></p><p>这就是git分支的本质：一个指向某一系列提交之首的<strong>指针</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202111122115839.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="git" scheme="https://autovy.github.io/tags/git/"/>
    
      <category term="Coding" scheme="https://autovy.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|TCP可视化实验</title>
    <link href="https://autovy.github.io/2021/10/27/DevPrinciple/TCP%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E9%AA%8C/"/>
    <id>https://autovy.github.io/2021/10/27/DevPrinciple/TCP%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E9%AA%8C/</id>
    <published>2021-10-27T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.158Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.staticdn.net/Autovy/Image/master/img/202110271342730.webp" alt="I’m going to tell a joke | excel-memes, tcp-memes, udp-memes | ProgrammerHumor.io" style="zoom: 50%;"><p>TCP好复杂🤧，主要使用了Kali Linux上的一些网络工具来进行分析，希望能直观地解析TCP（备考中，更新缓慢…）</p><span id="more"></span><p>参考资料：<a href="https://wizardforcel.gitbooks.io/network-basic/content/0.html">网络基本功系列</a></p><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h4><h5 id="（1）Kali-Linux虚拟机安装"><a href="#（1）Kali-Linux虚拟机安装" class="headerlink" title="（1）Kali Linux虚拟机安装"></a>（1）Kali Linux虚拟机安装</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110181946991.png" alt="image-20211018194604769"></p><p>在<code>Kail Linux</code>的官网下载对应的系统镜像文件：<a href="https://www.kali.org/get-kali/">Get Kali </a>，这里我选择中间这个版本（2021.3-installer-amd64）</p><p>具体的虚拟机安装过程这里不赘述，我使用的是<code>VMware Workstation</code>，可以参照这篇文章进行安装：<a href="https://blog.csdn.net/Fengfeng__y/article/details/107376064">Vmware安装Kali Linux2020.2</a></p><p>之所以选择<strong>Kali Linux</strong>系统是因为其内置了<strong>Nginx</strong>，<strong>tcpdump</strong>，<strong>Wireshark</strong>这些我们需要用到的实验工具</p><h5 id="（2）VM与Hype-V不可共存"><a href="#（2）VM与Hype-V不可共存" class="headerlink" title="（2）VM与Hype-V不可共存"></a>（2）VM与Hype-V不可共存</h5><p>我使用的是VM15.5会与Windows的Hype-V发生冲突，所以需要关闭Hype-V</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231543739.png" alt="image-20211023154303399"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>重启电脑后，VM的虚拟机可以正常运行，但是wsl和docker就寄了</p><p>如果需要恢复的话，可以使用下面命令然后重启电脑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><h5 id="（3）准备客户端和服务端"><a href="#（3）准备客户端和服务端" class="headerlink" title="（3）准备客户端和服务端"></a>（3）准备客户端和服务端</h5><p>参考资料：<a href="https://blog.csdn.net/qq_44657899/article/details/107130729">linux修改ip地址</a></p><ul><li><p>克隆虚拟机</p><p>搭建好一个Kali虚拟机后，通过VM的克隆功能生成另一台虚拟机，为了节省空间可以直接克隆为链接虚拟机</p></li></ul><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192052996.png" alt="image-20211019205256464"></p><ul><li><p>修改网络模式</p><p>将两台虚拟机的网络模式设置为NAT模式</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192056463.png" alt="image-20211019205636065"></p></li></ul><ul><li>虚拟网络编辑器修改</li></ul><p>​    </p><p>​    <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192058546.png" alt="image-20211019205855124"></p><p>​    </p><p>​    使用管理员开始修改，并取消“使用本地DHCP服务将IP地址分配给虚拟机”的勾</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192100641.png" alt="image-20211019210009660"></p><ul><li><p>查看子网IP和网关IP</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192104783.png" alt="image-20211019210418389"></p></li></ul><ul><li><p>修改客户端和服务端的IP地址</p><p>分别进入客户端和服务器打开终端</p><p>打开网络配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces</span><br></pre></td></tr></table></figure></li></ul><p>  修改客户端配置文件，设定客户端IP为<strong>192.168.234.100</strong></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"><span class="comment">#静态设置ip</span></span><br><span class="line">iface eth0 inet static</span><br><span class="line"><span class="comment">#设置ip地址</span></span><br><span class="line">address 192.168.234.100</span><br><span class="line"><span class="comment">#设置子网掩码</span></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"><span class="comment">#设置网关</span></span><br><span class="line">gateway 192.168.234.2</span><br></pre></td></tr></table></figure><p>  修改服务端配置文件，设定服务端IP为<strong>192.168.234.200</strong></p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line"><span class="comment">#静态设置ip</span></span><br><span class="line">iface eth0 inet static</span><br><span class="line"><span class="comment">#设置ip地址</span></span><br><span class="line">address 192.168.234.200</span><br><span class="line"><span class="comment">#设置子网掩码</span></span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"><span class="comment">#设置网关</span></span><br><span class="line">gateway 192.168.234.2</span><br></pre></td></tr></table></figure><p>  分别重启网卡</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure><p>  分别查看IP信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192244070.png" alt="image-20211019224416761"></p><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192245918.png" alt="image-20211019224510781"></p><h5 id="（4）测试相关服务"><a href="#（4）测试相关服务" class="headerlink" title="（4）测试相关服务"></a>（4）测试相关服务</h5><ul><li><p>测试服务端端口占用</p><p>检测80端口是否被占用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:80</span><br></pre></td></tr></table></figure><p>如果被占用了使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure><p>关闭对应的进程</p></li></ul><ul><li><p>修改服务端nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在http块中添加server块</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server块</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>开启服务端nginx服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>默认在<strong>80端口</strong>开启</p></li></ul><ul><li><p>查看nginx状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192303593.png" alt="image-20211019230343549"></p></li></ul><ul><li><p>客户端访问服务端IP，即可看到部署在服务端的nginx页面</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110192306180.png" alt="image-20211019230646780"></p></li></ul><h4 id="2-基本工具介绍"><a href="#2-基本工具介绍" class="headerlink" title="2.基本工具介绍"></a>2.基本工具介绍</h4><h5 id="（1）tcpdump"><a href="#（1）tcpdump" class="headerlink" title="（1）tcpdump"></a>（1）tcpdump</h5><p>参考材料：<a href="https://www.eet-china.com/mp/a35364.html">https://www.eet-china.com/mp/a35364.html</a></p><p>tcpdump是常用的网络抓包和分析工具，常用于在Linux服务器</p><ul><li><p>tcp提供了以下<strong>选项</strong></p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTMxMjY1LzE1OTAwNjY0MzIwNTQtNzYwM2MzNmEtMDdhNC00MzVkLTk0NmYtMWM1MDE0YTk4OWNkLnBuZw?x-oss-process=image/format,png" alt="image.png" style="zoom: 50%;"></li></ul><ul><li><p>tcp提供了以下<strong>过滤表达式</strong></p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110200830168.png" alt="image.png" style="zoom:50%;"></li></ul><ul><li><p>在客户端终端进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i eth0 表示抓取eth1网口的数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip 表示抓取ip协议的数据包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> host 表示主机过滤，抓取对应域名/ip的数据报</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -nn 表示不解析ip地址和端口号的名称</span></span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 ip and host www.baidu.com  -nn</span><br></pre></td></tr></table></figure><p>通过curl或者浏览器请求 <a href="http://www.baidu.com">www.baidu.com</a> 即可获得数据包（百度——网络测试的神）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110200850299.png" alt="image-20211020085021073"></p></li></ul><p>tcpdump只是用来抓取数据包，并不用来分析数据包，所以我们还需要Wireshark工具进行数据包分析</p><h5 id="（2）Wireshark"><a href="#（2）Wireshark" class="headerlink" title="（2）Wireshark"></a>（2）Wireshark</h5><ul><li><p>先使用tcpdump抓取数据保存为pcap文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 ip and host www.baidu.com -c 8 -w baidu.pacp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>终端开启Wireshark</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wireshark</span><br></pre></td></tr></table></figure><p>注意开启Wireshark后，不要关闭该终端，而是开启新的终端</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110200904635.png" alt="image-20211020090446325"></p></li></ul><ul><li><p>Wireshark分析baidu.pacp文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110200906800.png" alt="image-20211020090612028"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110200907536.png" alt="img"></p></li></ul><p>当然了Wireshark自身也有抓包功能，但是它有自己的一套过滤方法，我还是采用tcpdump的方法进行抓包操作</p><h4 id="3-解密TCP连接"><a href="#3-解密TCP连接" class="headerlink" title="3.解密TCP连接"></a>3.解密TCP连接</h4><h5 id="（1）建立一次连接"><a href="#（1）建立一次连接" class="headerlink" title="（1）建立一次连接"></a>（1）建立一次连接</h5><ul><li><p>客户端抓取请求服务端的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 192.168.234.200 and port 80 -w tcp.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端请求服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.234.200</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>退出tcpdump抓包</p><p>Ctrl+C退出tcpdump抓包</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110201924467.png" alt="image-20211020192429846"></p></li></ul><h5 id="（2）Wireshark分析tcp"><a href="#（2）Wireshark分析tcp" class="headerlink" title="（2）Wireshark分析tcp"></a>（2）Wireshark分析tcp</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110202041879.png" alt="image-20211020204055955"></p><ul><li><p>一次连接的传输流程</p><ol><li>最开始的3个包就是<strong>TCP三次握手</strong>建立连接的包</li><li>中间是HTTP请求和响应的包</li><li>最后的3个包则是<strong>TCP三次挥手</strong>断开连接的包</li></ol></li></ul><ul><li><p>时序图显示数据包交互</p><p>在Wireshark点击统计 -&gt; 流量图，在流量类型选择TCP Flows</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110202051934.png" alt="image-20211020205139464"></p></li></ul><ul><li><p>显示真实seq值</p><p>事实上上面的序列号seq是相对值，并不是真实值（关于序列号的算法下文会介绍）</p><p>在<strong>协议首选项</strong>取消<strong>Relative Seq</strong>即可看到真实值</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110201953144.png" alt="img"></p></li></ul><p>再次查看流量图，可以看到真实的seq值</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110201957208.png" alt="image-20211020195708923"></p><h5 id="（3）TCP连接流程分析"><a href="#（3）TCP连接流程分析" class="headerlink" title="（3）TCP连接流程分析"></a>（3）TCP连接流程分析</h5><ul><li>TCP连接完整流程</li></ul><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110202003394.jpeg" alt="这里写图片描述" style="zoom: 67%;"><ul><li><p>三次握手</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110202105763.png" alt="image-20211020210505247"></p></li></ul><ul><li><p>传输数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110202105540.png" alt="image-20211020210523657"></p></li></ul><ul><li><p>四次挥手</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110202105988.png" alt="image-20211020210546911"></p><p>这里只有三次是因为服务器端收到客户端的 <code>FIN</code> 后，服务器端同时也要关闭连接，这样就可     以把 <code>ACK</code> 和 <code>FIN</code> 合并到一起发送，节省了一个包，变成了“三次挥手”</p><p>服务器端收到客户端的 <code>FIN</code> 后，很可能还没发送完数据，所以就会先回复客户端一个      <code>ACK</code> 包，稍等一会儿，完成所有数据包的发送后，才会发送 <code>FIN</code> 包，这也就是四次挥手了</p></li></ul><h4 id="4-TCP连接异常情况分析"><a href="#4-TCP连接异常情况分析" class="headerlink" title="4.TCP连接异常情况分析"></a>4.TCP连接异常情况分析</h4><p>参考资料：</p><p><a href="http://blog.51yip.com/linux/1404.html">iptables 添加，删除，查看，修改</a></p><p><a href="https://juejin.cn/post/6844904181795389454">TCP三次握手丢包实验记录</a></p><h5 id="（1）TCP第一次握手SYN丢包"><a href="#（1）TCP第一次握手SYN丢包" class="headerlink" title="（1）TCP第一次握手SYN丢包"></a>（1）TCP第一次握手SYN丢包</h5><p>向一个不存在的主机地址发起连接即可模拟TCP第一次握手SYN丢包的状况</p><ul><li><p>开启tcpdump监控47.48.49.50（不存在的地址）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 47.48.49.50  and port 80 -w tcp_sys_timeout.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发起对47.48.49.50的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date;curl 47.48.49.50;date</span><br></pre></td></tr></table></figure><p><strong>date</strong>显示当前时间用于记录tcp用时</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110210916070.png" alt="image-20211021091606451"></p></li></ul><ul><li><p>开启wireshark分析tcp_sys_timeout.pcap</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231551164.png" alt="image-20211023155134728"></p></li></ul><p>​        </p><ul><li><p>分析TCP重传过程</p><p>当客户端发起TCP第一次握手SYN包，在超时间没有收到ACK就会重传SYN数据包，而且时间会逐渐翻倍，</p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZciat6yMSZJ2QYWIldpAXY6VA5Y8s7UWYLIjx7TsaNBNX46H5BQSGVBzX8clDJLvz4X5IhEX9O4tNg/640?wx_fmt=png" alt="img" style="zoom:67%;"></li></ul><p>kali Liunx这里重传了4次SYN后，服务端就会发送<strong>RST复位报文</strong>给客户端表示终止这个握手过程和这个连接</p><ul><li><p>相关参数调整</p><p>重传的次数与tcp_syn_retries参数有关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231617350.png" alt="image-20211023161746849"></p></li></ul><p>  可以看到kali linux需要重传6次（所以为什么这里只重传了4次？🧐，我也妹开tcp_abort_on_overflow呀，不是队列满的问题吧）</p><p>  我们可以调小tcp_syn_retries重新测试</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231627059.png" alt="image-20211023162734954"></p><p>​    <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231632601.png" alt="image-20211023163211916"></p><p>可以看到SYN重传了2次</p><h5 id="（2）TCP第二次握手SYN、ACK丢包"><a href="#（2）TCP第二次握手SYN、ACK丢包" class="headerlink" title="（2）TCP第二次握手SYN、ACK丢包"></a>（2）TCP第二次握手SYN、ACK丢包</h5><ul><li><p>客户端添加防火墙</p><p>模拟客户端接收不到服务端的响应，可以在客户端添加防火墙设置，把<code>192.168.234.200</code>服务器ban掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.234.200 -j DROP</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可以查看清单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231652438.png" alt="image-20211023165234228"></p><ul><li><p>客户端开启tcpdump监控192.168.234.200</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 192.168.234.200 and port 80 -w tcp_two.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发起对192.168.234.200的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.234.200</span><br></pre></td></tr></table></figure><p>在这里kali linux就会卡住了，建议直接手动关闭该命令</p></li></ul><ul><li><p>wireshark分析数据包</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231718787.png" alt="image-20211023171847580"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110231720057.png" alt="image-20211023172006864"></p><p>​        客户端视角：客户端发起SYN请求后，由于防火墙屏蔽了服务器所有的数据包，所有无法接受到SYN，ACK包，所以和上一种情        况一样要重发SYN包</p><p>​            </p><p>​        服务器角度：服务端收到客户的SYN包后，就会回SYN、ACK包，但是客户端一直没有回ACK，服务端在超时后，重传了  SYN、        ACK 包，接着一会，客户端超时重传的SYN包又抵达了服务端，服务端收到后，<strong>超时定时器就重新计时</strong>，然后回SYN、ACK包</p></li></ul><p>  ​        当第二次握手的SYN、ACK丢包时，客户端会超时重发SYN包，服务端也会超时重传SYN、ACK包</p><ul><li><p>相关参数</p><p><code>tcp_syn_retries</code>：客户端SYN重传次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure></li></ul><p>  <code>tcp_synack_retries</code>：服务端重传ACK，SYN次数</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure><p>  更改次数</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置SYN重传次数为1</span></span><br><span class="line">echo 1 &gt;  /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置ACK,SYN重传次数为2</span></span><br><span class="line">echo 2 &gt;  /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure><p>   ​重新抓包分析</p><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232038388.png" alt="image-20211023203803972"></p><ul><li><p>移除防火墙规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 1</span><br></pre></td></tr></table></figure></li></ul><h5 id="（3）TCP第三次握手ACK丢包"><a href="#（3）TCP第三次握手ACK丢包" class="headerlink" title="（3）TCP第三次握手ACK丢包"></a>（3）TCP第三次握手ACK丢包</h5><ul><li><p>服务器添加防火墙屏蔽来自客户端的ACK包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 192.168.234.100 -p tcp --tcp-flag ACK ACK -j DROP</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端开启tcpdump监控192.168.234.200</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any tcp and host 192.168.234.200 and port 80 -w tcp_ack_timeout.pcap</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端向服务端发起telnet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.234.200</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232049340.png" alt="image-20211023204935552"></p><p>等待很长一段时间客户端的telent才断开连接…..</p><p>​    </p></li><li><p>查看客户端服务端状态</p><p>客户端已完成TCP连接建立处于处于 <code>ESTABLISHED</code> 状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt | grep 192.168.234.100</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232112825.png" alt="image-20211023211201535"></p></li></ul><p>  服务器收不到第三次握手的ACK包，所以一开始处于<code>SYN_RECV</code> 状态</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt | grep 192.168.234.200</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232117706.png" alt="image-20211023211703628"></p><p>  ​    </p><p>  过了一段时间后在查询服务端状态，tcp连接就消失了</p><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232117422.png" alt="image-20211023211752357"></p><p>​        而客户端还是处于 <code>ESTABLISHED</code> 状态（在不传输数据的情况下会持续大概两个小时😰）</p><ul><li><p>在客户端建立的telnet会话，输入字符消息进行发送</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232121444.png" alt="image-20211023212138121"></p></li></ul><p>  ​    这里要持续很长一段时间客户端telnet才断开连接</p><ul><li><p>Wireshark分析数据包</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232128604.png" alt="image-20211023212430427"></p></li></ul><p>​        <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232128478.png" alt="image-20211023212818747"></p><ul><li>客户端发送 SYN 包给服务端，服务端收到后，回了个 SYN、ACK 包给客户端，此时服务端的 TCP 连接处于 <code>SYN_RECV</code> 状态；</li><li>客户端收到服务端的  SYN、ACK 包后，给服务端回了个 ACK 包，此时客户端的 TCP 连接处于 <code>ESTABLISHED</code> 状态</li><li>服务端配置防火墙屏蔽了客户端的ACK包，以服务端会有一段时间处于 <code>SYN_RECV</code> 状态，没有进入  <code>ESTABLISHED</code> 状态</li><li>接着，服务端超时重传了 SYN、ACK 包，重传了 5 次后，也就是<strong>超过 tcp_synack_retries 的值，然后就没有继续重传了，此时服务端的 TCP 连接主动中止了，所以刚才处于 SYN_RECV 状态的 TCP 连接断开了</strong>，而客户端依然处于<code>ESTABLISHED</code> 状态</li><li>客户端依然处于<code>ESTABLISHED</code> 状态，于是就在客户端的 telnet 会话输入了 123456 字符</li><li>由于服务端已经断开连接，<strong>客户端发送的数据报文，一直在超时重传，每一次重传，RTO 的值是指数增长的，所以持续了好长一段时间，客户端的 telnet 才报错退出了，此时会重传了 15 次</strong></li></ul><ul><li><p>相关参数</p><p>TCP 建立连接后的数据包传输，客户端发送数据报文最大超时重传次数是由 <code>tcp_retries2</code> 指定，默认值是 15 次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_retries2</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232136629.png" alt="image-20211023213656516"></p><p>按照时间倍增原理重传了15次后终于是结束了</p></li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232137394.png" alt="image-20211023213751365"></p><p> 如果这种情况下客户端不发送数据，客户端什么时候才会断开处于 ESTABLISHED 状态的连接这里需要提到TCP的<strong>保活机制</strong>，在一个<strong>规定的时间段</strong>（tcp_keepalive_time：保活时间）内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<strong>每隔一个时间间隔</strong>（tcp_keepalive_intvl：每次检测间隔），发送一个「探测报文」，该探测报文包含的数据非常少，如果<strong>连续几个探测报文</strong>（tcp_keepalive_probes：检测次数）都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p><p>  相关参数如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110271337578.png" alt="image-20211023214647732">    </p><p>按照系统默认的设置来计算在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110232154413.png" alt="img"></p><h4 id="5-解密TCP快速建立连接"><a href="#5-解密TCP快速建立连接" class="headerlink" title="5.解密TCP快速建立连接"></a>5.解密TCP快速建立连接</h4><p>参考资料：<a href="https://juejin.cn/post/6951378103000268836">tcp fast open分析</a>（里面有详细的实验过程）</p><h5 id="（1）普通连接与快速连接的差别"><a href="#（1）普通连接与快速连接的差别" class="headerlink" title="（1）普通连接与快速连接的差别"></a>（1）普通连接与快速连接的差别</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110242022723.png" alt="img" style="zoom:67%;"><p>RTT即一个数据包往返的时间，所有一个握手过程为0.5RTT（第三次握手是可以携带数据的，所以ACK和HTTP请求一起发送）</p><p><strong>普通连接</strong>每次发起HTTP请求都要重新进行上次握手过程，经历的RTT都是一样的</p><p><strong>快速连接</strong>第一次建立连接时，第二次握手会产生一个<strong>Cookie</strong>（其中维护着TCP相关信息）发给客户端，客户端就会缓存着这个<strong>Cookie</strong>；下次请求时，客户端在SYN包带上<strong>Cookie</strong>，服务端可以直接通过<strong>Cookie</strong>获得TCP相关信息，从而跳过三次握手的过程</p><h5 id="（2）Fast-Open相关参数"><a href="#（2）Fast-Open相关参数" class="headerlink" title="（2）Fast Open相关参数"></a>（2）Fast Open相关参数</h5><p>tcp_fastopn参数可以设置Fast Open的模式：</p><ol><li>0 关闭</li><li>1 作为客户端使用 Fast Open 功能</li><li>2 作为服务端使用 Fast Open 功能</li><li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能</li></ol><p>查看kali linux的tcp_fastopn，可以看到kali已默认开启作为客户端使用 Fast Open 功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_fastopen</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110242042576.png" alt="image-20211024204230242"></p><h5 id="（3）wireshark分析数据包"><a href="#（3）wireshark分析数据包" class="headerlink" title="（3）wireshark分析数据包"></a>（3）wireshark分析数据包</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110242145575.png" alt="img"></p><h4 id="6-解密TCP重复确认和快速重传"><a href="#6-解密TCP重复确认和快速重传" class="headerlink" title="6.解密TCP重复确认和快速重传"></a>6.解密TCP重复确认和快速重传</h4><h5 id="（1）TCP乱序数据包处理方式"><a href="#（1）TCP乱序数据包处理方式" class="headerlink" title="（1）TCP乱序数据包处理方式"></a>（1）TCP乱序数据包处理方式</h5><p>​    但接收方收到<strong>乱序数据包</strong>时，会发送<strong>重复的ACK</strong>，以告知发送方要重发该数据包，当发送方收到3个重复ACK时就会触发<strong>快速重传</strong>，立即<strong>重发丢失的数据包</strong></p><p>​    <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251519335.png" alt="img"></p><h5 id="（2）wireshark分析数据包"><a href="#（2）wireshark分析数据包" class="headerlink" title="（2）wireshark分析数据包"></a>（2）wireshark分析数据包</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251521249.png" alt="img"></p><ul><li>数据包1期望下一个返回的的数据包seq为1，但是返回的数据包2的seq为10945，说明收到了乱序数据包</li><li>数据包3重发seq = 1， ack=1，表明这是重复的ACK</li><li>数据包4，6返回的仍然是乱序的数据包，于是5，7还是重发seq = 1， ack=1的重复ACK</li><li>当对方收到三次重复的ACK后，快速重传seq=1，len=168的数据包8</li><li>当收到重传的数据包后，发现seq=1是期望的数据包，预设发送确认报文ACK</li></ul><h5 id="（3）相关参数"><a href="#（3）相关参数" class="headerlink" title="（3）相关参数"></a>（3）相关参数</h5><p><strong>tcp_sack</strong>参数可以开启<strong>选择性SACK</strong>，一旦数据包丢失并收到重复ACK，即使在丢失数据包之后还成功接收了其他数据包，也只需要重    传丢失的数据包（简单来说，如果不开启SACK，丢失包之后的每个数据包都要进行重传）</p><p>查看kali linux的tcp_sack参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_sack</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251547408.png" alt="image-20211025154717887"></p><h4 id="7-解密TCP流量控制"><a href="#7-解密TCP流量控制" class="headerlink" title="7.解密TCP流量控制"></a>7.解密TCP流量控制</h4><h5 id="（1）TCP滑动窗口机制"><a href="#（1）TCP滑动窗口机制" class="headerlink" title="（1）TCP滑动窗口机制"></a>（1）TCP滑动窗口机制</h5><p>​    TCP有两大关键功能：</p><p>​    <strong>可靠传输</strong>：保证数据确实到达目的地，如果未到达，能够发现并重传</p><p>​    <strong>数据流控</strong>：管理数据的发送速率，以使接收设备不致于过载</p><p>​    TCP数据流控的关键是滑动窗口机制，它利用接收方的<strong>接收窗口</strong>控制发送方要发送数据量，发送方的<strong>接收窗口</strong>可以告诉发送方自己TCP    缓冲空间区大小</p><p>​    在客户端与服务器的连接中，客户端告知服务器它一次希望从服务器接收多少字节数据，这是客户端的<strong>接收窗口</strong>，即服务器的<strong>发送窗口</strong></p><ul><li>理想情况下的窗口大小    </li></ul><p>​    假如应用层很快地从缓冲区读取了数据，那么窗口大小会一直保持不变</p><p>​    <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251617330.png" alt="img"></p><p>​    </p><ul><li>现实情况下的窗口大小</li></ul><p>现实中服务器会出现繁忙的情况，当应用程序读取速度慢时，那么缓存空间会慢慢被占满，这时服务器会调整<strong>窗口大小</strong>的值，通过ACK    报文通知对方</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251620324.png" alt="img">    </p><h5 id="（2）零窗口通知与窗口探测"><a href="#（2）零窗口通知与窗口探测" class="headerlink" title="（2）零窗口通知与窗口探测"></a>（2）零窗口通知与窗口探测</h5><ul><li><strong>零窗口</strong>：当接收方的缓存被占满后，会发送值为0的接收窗口，当发送方接收到<strong>零窗口通知</strong>时，就会停止发送数据</li></ul><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251623436.png" alt="img"></p><ul><li><p><strong>窗口探测</strong>：发送方接收到<strong>零窗口通知</strong>后，会定时发送<strong>窗口大小探测报文</strong>，以便知道接收方窗口大小变化</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251630822.png" alt="img"></p><p>发送<strong>窗口大小探测报文</strong>的时间间隔与TCP的报文重传机制一样都是<strong>翻倍递增</strong>的</p></li></ul><h5 id="（3）发送窗口的分析"><a href="#（3）发送窗口的分析" class="headerlink" title="（3）发送窗口的分析"></a>（3）发送窗口的分析</h5><p>报文<code>win</code>字段表明的是自己的<strong>接收窗口</strong>，而不是<strong>发送窗口</strong></p><p>可以通过查看报文字段：Windos size value 和 Window size scaling factor 确认发送窗口的值，计算公式如下</p><p><code>「Window size value」 * 「Window size scaling factor」 = 「Caculated window size 」</code></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251655116.png" alt="img"></p><p><strong>发送窗口</strong>虽然是由<strong>接收窗口</strong>决定的，但是它是可以被网络因素影响的，所以实际上发送窗口的值是<code>min(拥塞窗口, 接收窗口)</code></p><p>TCP 有<strong>累计确认机制</strong>，所以当收到多个数据包时，只需要应答<strong>最后一个数据包</strong>的 ACK 报文就可以了</p><h4 id="8-TCP减少小报文传输"><a href="#8-TCP减少小报文传输" class="headerlink" title="8.TCP减少小报文传输"></a>8.TCP减少小报文传输</h4><p>当TCP报文承载的数据非常小的时候，整个网络效率就会很低（例如一个报文TCP头部为20字节，IP头部也是20个字节，但数据只有2字节，就相当于用大货车运一个小包裹）</p><p>TCP使用两种策略来减少小报文的传输：</p><ul><li><p>Nagle算法</p></li><li><p>延迟确认</p></li></ul><h5 id="（1）Nagle算法"><a href="#（1）Nagle算法" class="headerlink" title="（1）Nagle算法"></a>（1）Nagle算法</h5><p>Nagle算法数据发送策略：</p><ul><li><strong>没有已发送未确认报文</strong>时，立刻发送数据</li><li>存在未确认报文时，直到<strong>没有已发送未确认报文</strong>或<strong>数据长度达到MSS大小</strong>，再发送数据</li></ul><p>如果不满足任意一条，发送方会一直<strong>囤积数据</strong>，直到满足发送条件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251730068.png" alt="img"></p><ul><li>一开始没有<strong>已发送未确认</strong>的报文，H字符就会立即发出</li><li>在没有收到对H字符的确认报文时，发送方一直囤积数据，直到收到确认报文，此时就没有已发送未确认的报文，于是就把囤积后的 ELL 字符一起发给了接收方</li><li>待收到ELL字符的确认报文后，就把最后一个之后O发出</li></ul><p>Nagle算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法</p><p>关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭，如 Socket可以通过设置 <code>TCP_NODELAY</code> 选项来关闭这个算法</p><h5 id="（2）延迟确认"><a href="#（2）延迟确认" class="headerlink" title="（2）延迟确认"></a>（2）延迟确认</h5><p>延迟确认数据发送策略：</p><ul><li>当有响应数据要发送时，ACK会跟着一起发送给对方</li><li>当没有响应数据要发送时，ACK将延迟一段时间，以等待是否有响应数据一起发送</li><li>如果在ACK延迟等待发送期间，对方第二个数据报文到达了，这时就立即发送ACK</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251746044.png" alt="img"></p><p>延迟等待的时间在Linux内核中定义的，我们可以通过查看HZ（系统时钟频率）来确认</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251754102.png" alt="image-20211025175433959"></p><p>这里注意不同内核的配置文件名称不同，我的就是<code>config-5.10.0-kali9-amd64</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-5.10.0-kali9-amd64 | grep &#x27;CONFIG_HZ=&#x27; </span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110251752591.png" alt="image-20211025175239492"></p><p>我的这台机器的HZ=250，所以最大延迟确认时间为50ms，最小延迟确认时间为10ms</p><p>关闭延迟确认也没有全局参数，需要根据每个应用自己的特点来关闭，如TCP 延迟确认可以在 Socket 设置 <code>TCP_QUICKACK</code> 选项来关闭这个算法</p><h4 id="9-TCP全连接队列"><a href="#9-TCP全连接队列" class="headerlink" title="9.TCP全连接队列"></a>9.TCP全连接队列</h4><p>参考资料：<a href="https://segmentfault.com/a/1190000022792489">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</a></p><h5 id="（1）TCP半连接队列与全连接队列"><a href="#（1）TCP半连接队列与全连接队列" class="headerlink" title="（1）TCP半连接队列与全连接队列"></a>（1）TCP半连接队列与全连接队列</h5><p>​    在TCP三次握手中，我们如何分辨：哪些连接是半连接，哪些连接是全连接呢？</p><p>​    Linux通过维护两个队列来解决问题：</p><ul><li>半连接队列（SYN队列）</li><li>全连接队列（accepet队列）</li></ul><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110261926809.png" alt="img" style="zoom:80%;"><ul><li>服务端收到客户端发起的<strong>SYN</strong>后，内核会将连接存储到<strong>半连接队列</strong></li><li>服务端向客户端发送<strong>SYN+ACK</strong></li><li>客户端收到<strong>SYN+ACK</strong>后，发送<strong>ACK</strong>到服务端</li><li>服务端收到客户端的<strong>ACK</strong>后，内核会把连接从<strong>半连接队列</strong>移除，将其添加到<strong>全连接队列</strong>，等待进程调用<strong>accept函数</strong>时把连接取出来</li><li>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接<strong>丢弃</strong>，或<strong>返回 RST 包</strong></li></ul><h5 id="（2）全连接队列状态查询"><a href="#（2）全连接队列状态查询" class="headerlink" title="（2）全连接队列状态查询"></a>（2）全连接队列状态查询</h5><p>在服务端（192.168.234.200）查看全连接队列状况</p><p>查看<strong>LISTEN 状态</strong>的连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -l 显示状态为listen的socket</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 不解析服务名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 只显示tcp socket</span></span><br><span class="line">ss -lnt</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110261944427.png" alt="image-20211026194430102"></p><ul><li>Recv-Q：当前<strong>全连接队列的大小</strong>，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接个数；</li><li>Send-Q：当前<strong>全连接最大队列长度</strong>，上面的输出结果说明监听 80 端口的 TCP 服务进程，<strong>最大全连接长度为 511</strong></li></ul><p>查看<strong>非 LISTEN 状态</strong>的连接：</p><p>先在客户端对服务端发起请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.234.200 80</span><br></pre></td></tr></table></figure><p>这时可以在服务端查看<strong>非 LISTEN 状态</strong>的连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -n 不解析服务名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 只显示tcp socket</span></span><br><span class="line">ss -nt</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110261953764.png" alt="image-20211026195348911"></p><p>这时<code>Recv-Q/Send-Q</code> 表示的含义与<strong>LISTEN 状态</strong>的不同</p><ul><li>Recv-Q：已收到但未被应用进程读取的字节数；</li><li>Send-Q：已发送但未收到确认的字节数；</li></ul><h5 id="（3）全连接队列溢出"><a href="#（3）全连接队列溢出" class="headerlink" title="（3）全连接队列溢出"></a>（3）全连接队列溢出</h5><p>本次模拟实验，客户端（192.168.234.100）使用<strong>wrk工具</strong>（HTTP 压测工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，通过多线程和事件模式，对目标机器产生大量的负载）对服务端（192.168.234.100）发起大量请求，以此模拟TCP<strong>全连接队列溢出</strong>的状态</p><ul><li><p>客户端安装wrk工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install wrk</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端对服务端进行抗压测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 6 表示6个线程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 30000 表示3万个连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 60s 表示持续压测60秒</span></span><br><span class="line">wrk -t 6 -c 30000 -d 60s http://192.168.234.200</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262014446.png" alt="image-20211026201412323"></p></li></ul><ul><li><p>服务端多次执行ss命令查看全连接队列的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -lnt</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262021751.png" alt="image-20211026202152288"></p><p>可以看到TCP全链接队列逐渐上升到<strong>最大全连接长度为511</strong>，当全连接队列为<strong>512</strong>时即为<strong>全连接队列溢出</strong>，<strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接</strong>，所以下一个状态<strong>全连接队列</strong>又恢复了<strong>511</strong></p></li></ul><ul><li><p>查看被丢弃的连接个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep overflowed</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262031051.png" alt="image-20211026203156762"></p></li></ul><ul><li><p>结论</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262034104.png" alt="全连接队列溢出"></p></li></ul><p>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象</p><h5 id="（4）全连接队列溢出策略"><a href="#（4）全连接队列溢出策略" class="headerlink" title="（4）全连接队列溢出策略"></a>（4）全连接队列溢出策略</h5><ul><li><p>应对全连接队列溢出有以下两种应对策略：</p><ol><li>队列满了以后丢弃后续连接（Liunx默认策略）</li><li>向客户端发送RST复位报文，告诉客户端连接已经建立失败</li></ol></li></ul><ul><li><p>查看服务端<code>tcp_abort_on_overflow</code>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262047259.png" alt="image-20211026204705056"></p><ol><li>tcp_abort_on_overflow为0：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack</li><li>如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接</li></ol></li></ul><ul><li><p>将服务端的<code>tcp_abort_on_overflow</code>设为1进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_abort_on_overflow</span><br></pre></td></tr></table></figure></li></ul><p>  客户端再次对服务端进行抗压测试</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 6 表示6个线程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 30000 表示3万个连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 60s 表示持续压测60秒</span></span><br><span class="line">wrk -t 6 -c 30000 -d 60s http://192.168.234.200</span><br></pre></td></tr></table></figure><p>​    客户端异常中会查看到很多的<code>connection reset by peer</code>错误</p><p>通常情况下，应当把 <code>tcp_abort_on_overflow</code> 设置为 0，因为这样更有利于应对突发流量</p><h5 id="（5）增大全连接队列"><a href="#（5）增大全连接队列" class="headerlink" title="（5）增大全连接队列"></a>（5）增大全连接队列</h5><p>TCP全连接队列最大值取决于<strong>somaxconn</strong>（Linux内核参数）和<strong>backlog</strong>（Nginx中配置）之间的最小值</p><ul><li><p>查看服务端<strong>somaxconn</strong>的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262132994.png" alt="image-20211026213244511"></p></li></ul><ul><li><p>修改<strong>backlog</strong>的默认值</p><p>nginx的backlog默认值为511（配置文件可以不写出），现在修改为4000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在listen端口后面加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backlog=4000</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262301329.png" alt="image-20211026230115019"></p></li></ul><p>  重启nginx服务</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload  nginx</span><br></pre></td></tr></table></figure><p>  服务端再次执行ss命令，查看TCP全连接队列大小</p><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262304069.png" alt="image-20211026230418393"></p><ul><li><p>再次进行测压</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110262308892.png" alt="image-20211026230850636"></p></li></ul><p>如果看到溢出的次数不再增加，说明TCP全连接队列最大值为4000时可以抗住3万连接的并发请求</p><h4 id="10-TCP半连接队列"><a href="#10-TCP半连接队列" class="headerlink" title="10.TCP半连接队列"></a>10.TCP半连接队列</h4><h5 id="（1）查看TCP半连接队列长度"><a href="#（1）查看TCP半连接队列长度" class="headerlink" title="（1）查看TCP半连接队列长度"></a>（1）查看TCP半连接队列长度</h5><p>客户端运行wrk请求服务端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t 6 -c 30000 -d 60s http://192.168.234.200</span><br></pre></td></tr></table></figure><p>服务端运行以下命令查看当前TCP半连接队列长度</p><p>（ps：注意要将nginx的backlog调整回默认值，否则半连接队列会处理太快）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -natp | grep SYN_RECV | wc -l</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110270815566.png" alt="image-20211027081537300"></p><h5 id="（2）半连接队列溢出"><a href="#（2）半连接队列溢出" class="headerlink" title="（2）半连接队列溢出"></a>（2）半连接队列溢出</h5><p>模拟TCP半连接溢出的场景，实际上就是对服务端一直发送SYN包，但是不回第三次握手ACK，这样会使服务端有大量的处于 <code>SYN_RECV</code> 状态的 TCP 连接（即半连接状态），这也就是所谓的 SYN 洪泛、SYN 攻击、DDos 攻击</p><ul><li><p>首先要先关闭服务端的<strong>tcp_syncookies</strong>，tcp_syncookies 是Linux缓解 SYN 攻击其中一个手段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt;  &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syncookies</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端使用hping3工具模拟SYN攻击</p><p>kali linux已内置安装了hping3无须再次安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -S 指定TCP包的标志位SYN</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 80 指定探测的目的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---flood 以泛洪的方式攻击</span></span><br><span class="line">hping3 -S -p 80 --flood 192.168.234.200</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端循环查看当前TCP半连接队列大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while true; </span><br><span class="line">do </span><br><span class="line">sleep 0.5; </span><br><span class="line">echo &quot;当前半连接队列数：&quot;;</span><br><span class="line">    netstat -natp | grep SYN_RECV | wc -l;</span><br><span class="line">    echo &quot; &quot;;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端循环使用 <code>netstat -s</code> 查看半连接队列溢出情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while true; </span><br><span class="line">do </span><br><span class="line">sleep 1; </span><br><span class="line">echo &quot;半连接队列溢出数&quot;;</span><br><span class="line">    netstat -s | grep &quot;SYNs to LISTEN&quot;;</span><br><span class="line">    echo &quot; &quot;;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110270909570.png" alt="image-20211027090955138"></p><p>上面的数值是<strong>累计值</strong>，如果有上升的趋势，说明当前存在半连接队列溢出的现象</p></li></ul><h5 id="（3）增大半连接队列"><a href="#（3）增大半连接队列" class="headerlink" title="（3）增大半连接队列"></a>（3）增大半连接队列</h5><p>半连接队列最大值（max_qlen_log）不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110271303894.png" alt="img"></p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = max_syn_backlog * 2;</li><li>即 max_syn_backlog，somaxconn，backlog最小的一个数乘以2为半连接队列最大值</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110271322835.png" alt="image-20211027132147887"></p><p>因为nginx的backlog默认为511，所以该系统max_qlen_log的值为256</p><p>max_qlen_log 是<strong>理论</strong>半连接队列最大值，并不一定代表服务端处于 SYN_REVC 状态的最大个数</p><h5 id="（4）半连接队列溢出策略"><a href="#（4）半连接队列溢出策略" class="headerlink" title="（4）半连接队列溢出策略"></a>（4）半连接队列溢出策略</h5><p>半连接队列溢出有两种应对策略：</p><ul><li>当syncookies=0时，TCP会丢弃连接</li><li>当syncookies=1时，服务端开启 syncookies 功能，其可以在不使用 SYN 半连接队列的情况下成功建立连接（默认配置）</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110271326186.png" alt="img"></p><p>syncookies的运行原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功</p><p>我们可以使用下面的命令查看系统syncookies的值</p><p>为了应对SYN攻击，其默认为1（上面的实验我们改为了0）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure><p>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它</li><li>2 值，表示无条件开启功能</li></ul><h5 id="（5）SYN攻击应对方法"><a href="#（5）SYN攻击应对方法" class="headerlink" title="（5）SYN攻击应对方法"></a>（5）SYN攻击应对方法</h5><ul><li>增大半连接队列</li></ul><p>要注意需要同时增大<strong>tcp_max_syn_backlog</strong> ，<strong>somaxconn</strong> 和 <strong>backlog</strong>，其中最小值的两倍即为<strong>半连接队列</strong>的最大值，同时somaxconn 和 backlog的最小值为<strong>全连接队列</strong>的最大值</p><ul><li>开启 tcp_syncookies 功能（一般默认开启）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure><ul><li>减少 SYN+ACK 重传次数</li></ul><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接</p><p>所以我们也可以减少SYN+ACK的重传次数，以加快SYN_REVC状态的TCP连接端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置ACK,SYN重传次数为1</span></span><br><span class="line">echo 1 &gt;  /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202110271342730.webp&quot; alt=&quot;I’m going to tell a joke | excel-memes, tcp-memes, udp-memes | ProgrammerHumor.io&quot; style=&quot;zoom: 50%;&quot;&gt;



&lt;p&gt;TCP好复杂🤧，主要使用了Kali Linux上的一些网络工具来进行分析，希望能直观地解析TCP（备考中，更新缓慢…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="https://autovy.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java|项目深度解析</title>
    <link href="https://autovy.github.io/2021/10/25/Java/Java-%E9%A1%B9%E7%9B%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://autovy.github.io/2021/10/25/Java/Java-%E9%A1%B9%E7%9B%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</id>
    <published>2021-10-25T15:45:00.000Z</published>
    <updated>2022-09-01T06:08:24.657Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202209011353612.jpeg" alt="img"></p><span id="more"></span><h3 id="常用集合解析"><a href="#常用集合解析" class="headerlink" title="常用集合解析"></a>常用集合解析</h3><p>必看资料：</p><p><a href="https://autovy.github.io/2022/04/20/Java/Java-渐进式本地缓存框架开发总结/">渐进式本地缓存开发总结</a></p><p><a href="https://interview.javaguide.cn/#/./docs/b-2Java集合">Java集合面试题</a></p><p><a href="https://javaguide.cn/java/collection/arraylist-source-code.html#项目相关">Java集合源码分析</a></p><h3 id="JVM调试与栈溢出"><a href="#JVM调试与栈溢出" class="headerlink" title="JVM调试与栈溢出"></a>JVM调试与栈溢出</h3><p><strong>必看资料：</strong></p><p><a href="https://www.jianshu.com/p/a2f98f6d6fbd">循环依赖的解决方案</a></p><p><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html#jdk-命令行工具">JDK 监控和故障处理工具总结</a></p><p><a href="https://www.v2ex.com/t/701513">JVM 堆溢出抽丝剥茧定位的过程</a></p><p><a href="https://heapdump.cn/article/276879">JVM源码分析之栈溢出完全解读</a></p><h4 id="一-栈溢出应用场景：循环依赖"><a href="#一-栈溢出应用场景：循环依赖" class="headerlink" title="一.栈溢出应用场景：循环依赖"></a>一.栈溢出应用场景：循环依赖</h4><p>在Springboot + JPA的架构中，容易出现循环依赖问题，一般会出现在一对多的场景下，总结来说是一对多实体中都要引用对方来维持OnetoMany的关系，所以极容易出现循环依赖:(</p><h5 id="1-经典场景"><a href="#1-经典场景" class="headerlink" title="1.经典场景"></a>1.经典场景</h5><p>订单项中引用订单，以构成多对一关系（可以使用订单id查到订单项）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个订单可以有多个订单项（不同产品/不同用户，同一订单）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;oid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Order order;</span><br></pre></td></tr></table></figure><p>订单中引用订单项存储在集合中，用来存储从数据库查询来的结构（往往是因为要利用这些字段进行计算）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单项列表</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line"><span class="comment">// 订单总金额</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> total;</span><br><span class="line"><span class="comment">// 订单物品总数量</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalNumber;</span><br></pre></td></tr></table></figure><p>这样的结构就是循环依赖，导致数据重复加载，因为orderItems要调用方法填充，所以会为空（一般情况下会栈溢出）最终造成的数据是：Order含有orderItems，orderItems含有Order，Order的orderItem列表为空，所以这里的Order重复了一次</p><h5 id="2-方案一：-JsonBackReference注解"><a href="#2-方案一：-JsonBackReference注解" class="headerlink" title="2.方案一：@JsonBackReference注解"></a>2.方案一：@JsonBackReference注解</h5><p>JsonBackReference注解用在一（一对多的一）的一方，可以阻止其被序列化，前提是对应的接口不需要调用到它，而只是需要用它来查询</p><p>如：一个产品有多张图片，我们不需要在图片列表接口使用到产品信息，而只是需要用产品id查询其图片</p><p><strong>产品类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="comment">// 产品首图</span></span><br><span class="line"><span class="keyword">private</span> ProductImage firstProductImage;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productSingleImages;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productDetailImages;</span><br></pre></td></tr></table></figure><p><strong>产品图片类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="meta">@JsonBackReference</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ul><li>关系是双向的，使用了JsonBackReference，就无法使用根据图片找到其属于的产品的方法，只能单方向查询即根据产品查找到其图片列表</li><li>JsonBackReference标记的字段与Redis的整合会有冲突</li></ul><h5 id="3-方案二：及时清除法"><a href="#3-方案二：及时清除法" class="headerlink" title="3.方案二：及时清除法"></a>3.方案二：及时清除法</h5><p>在服务层定义清除方法，在控制层调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Orderitem中有Order字段，标注多对一关系</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，用于存储订单项列表</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，而Orderitem中又有Order字段，产生无穷的递归</span></span><br><span class="line"><span class="comment">// 所以这里需要设置Orderitem的Order设为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(List &lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">removeOrderFromOrderItem(order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">List&lt;OrderItem&gt; orderItems= order.getOrderItems();</span><br><span class="line"><span class="keyword">for</span> (OrderItem orderItem : orderItems) &#123;</span><br><span class="line">orderItem.setOrder(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充Order的orderItem列表</span></span><br><span class="line">orderItemService.fill(page.getContent());</span><br><span class="line"><span class="comment">// 清除orderItem中的Order字段</span></span><br><span class="line">orderService.removeOrderFromOrderItem(page.getContent());</span><br></pre></td></tr></table></figure><h3 id="多线程解析"><a href="#多线程解析" class="headerlink" title="多线程解析"></a>多线程解析</h3><p>必看资料：</p><p><a href="https://interview.javaguide.cn/#/./docs/b-3Java多线程">Java多线程核心知识</a></p><p><a href="http://gitbook.chenqiong.net/part10/1/9.html">多线程应用场景</a></p><p><a href="https://blog.csdn.net/u014044812/article/details/64919813">Spring多线程批量发送邮件</a></p><h3 id="Spring-AOP解析"><a href="#Spring-AOP解析" class="headerlink" title="Spring AOP解析"></a>Spring AOP解析</h3><p>必看资料：</p><p><a href="https://www.qetool.com/scripts/view/7573.html">Spring @Cacheable注解类内部调用失效的解决方案 </a></p><p><a href="https://zhuanlan.zhihu.com/p/83204146">Spring AOP应用</a></p><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop">AOP面试题</a></p><h4 id="一-缓存AOP拦截失效问题"><a href="#一-缓存AOP拦截失效问题" class="headerlink" title="一.缓存AOP拦截失效问题"></a>一.缓存AOP拦截失效问题</h4><p><a href="https://www.qetool.com/scripts/view/7573.html">Spring @Cacheable注解类内部调用失效的解决方案 </a></p><h5 id="1-问题出现原因"><a href="#1-问题出现原因" class="headerlink" title="1.问题出现原因"></a>1.问题出现原因</h5><p>因为Springboot的缓存机制是通过切面编程aop来实现，从fill方法中调用listByCategory即内部调用，aop是拦截不到的，自然不会走缓存，这里我们可以通过SpringContextUtil工具类诱发aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充分类中的产品集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过SpringContextUtil调用listByCategory上的缓存方法</span></span><br><span class="line">    <span class="comment">// 即 @Cacheable(key=&quot;&#x27;products-cid-&#x27;+ #p0.id&quot;)</span></span><br><span class="line">    <span class="comment">// 这样在方法内部的查询也能够使用缓存</span></span><br><span class="line">    ProductService productService = SpringContextUtil.getBean(ProductService.class);</span><br><span class="line">    List&lt;Product&gt; products = productService.listByCategory(category);</span><br><span class="line">    productImageService.setFirstProdutImages(products);</span><br><span class="line">    category.setProducts(products);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-问题解决方案"><a href="#2-问题解决方案" class="headerlink" title="2.问题解决方案"></a>2.问题解决方案</h5><p>SpringContextUtil工具类诱发aop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpringContextUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二-AOP与日志处理"><a href="#二-AOP与日志处理" class="headerlink" title="二.AOP与日志处理"></a>二.AOP与日志处理</h4><p><a href="https://zhuanlan.zhihu.com/p/83204146">Spring AOP应用</a></p><h3 id="MySQL解析"><a href="#MySQL解析" class="headerlink" title="MySQL解析"></a>MySQL解析</h3><p><strong>必看资料</strong>：</p><p><a href="https://interview.javaguide.cn/#/./docs/d-1-mysql?id=_42-mysql">MySQL常见面试题总结</a></p><p><a href="https://segmentfault.com/a/1190000024445924">谈谈 MySQL 的 JSON 数据类型 </a></p><p><a href="https://blog.csdn.net/qq_24468953/article/details/120758408">简单总结 mysql json类型的利与弊</a></p><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#一-mysql-基础架构分析">MySQL索引详解</a></p><h4 id="一-物资申请系统数据库信息"><a href="#一-物资申请系统数据库信息" class="headerlink" title="一.物资申请系统数据库信息"></a>一.物资申请系统数据库信息</h4><p><a href="https://interview.javaguide.cn/#/./docs/d-1-mysql?id=_42-mysql">MySQL常见面试题总结</a></p><h5 id="1-物资申请表"><a href="#1-物资申请表" class="headerlink" title="1.物资申请表"></a>1.物资申请表</h5><p><img src="https://fastly.jsdelivr.net/gh/Autovy/Image/img/202205041045668.png" alt="image-20220504104541342"></p><ul><li>用户id : 物资申请条目 = 1 : n</li><li>机构id : 物资申请条目 = 1 : n</li></ul><h5 id="2-物资申请详情表"><a href="#2-物资申请详情表" class="headerlink" title="2.物资申请详情表"></a>2.物资申请详情表</h5><p><img src="https://fastly.jsdelivr.net/gh/Autovy/Image/img/202205041053586.png" alt="image-20220504105313339"></p><ul><li>物资申请条目id : 物资申请详情条目 = n : n</li><li>物资id : 物资申请详情条目 = n : n</li><li>(物资申请条目id,物资id) : 物资申请详情条目 = 1 : n</li></ul><h5 id="3-物资表"><a href="#3-物资表" class="headerlink" title="3.物资表"></a>3.物资表</h5><p><img src="https://fastly.jsdelivr.net/gh/Autovy/Image/img/202205041059831.png" alt="image-20220504105953610"></p><h5 id="4-用户表"><a href="#4-用户表" class="headerlink" title="4.用户表"></a>4.用户表</h5><p><img src="https://fastly.jsdelivr.net/gh/Autovy/Image/img/202205041102927.png" alt="image-20220504110242618"></p><ul><li>用户信息条目 : 权限id = 1 : 1</li></ul><h5 id="5-权限表"><a href="#5-权限表" class="headerlink" title="5.权限表"></a>5.权限表</h5><p><img src="https://fastly.jsdelivr.net/gh/Autovy/Image/img/202205041104629.png" alt="image-20220504110408506"></p><h4 id="二-数据库分表"><a href="#二-数据库分表" class="headerlink" title="二.数据库分表"></a>二.数据库分表</h4><p><a href="https://segmentfault.com/a/1190000024445924">谈谈 MySQL 的 JSON 数据类型 </a></p><p><a href="https://blog.csdn.net/qq_24468953/article/details/120758408">简单总结 mysql json类型的利与弊</a></p><h5 id="1-相关表的结构"><a href="#1-相关表的结构" class="headerlink" title="1.相关表的结构"></a>1.相关表的结构</h5><p>此处展示的表结构为维护前</p><p>物资申请表：共4817条数据</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203031543098.png" alt="image-20220303154338625"></p><p>物资信息表：</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203031545235.png" alt="image-20220303154513022"></p><p>goods_count：当前仓库物品数（物理的）</p><p>good_leftCount：当前物品可借数（网络的：存在部分未借出，但已被预订仍在审核中的物品）</p><h5 id="2-优化思路：物资申请表分表"><a href="#2-优化思路：物资申请表分表" class="headerlink" title="2.优化思路：物资申请表分表"></a>2.优化思路：物资申请表分表</h5><p>改版前的系统使用的数据库是5.4版本，其默认的引擎是MyISAM 引擎，为了让数据库有更好的性能，我们将系统的数据库升级到了5.7.26版本，InnoDB 是 气的默认存储引擎</p><p>从上面的tw_apply表就可以知道：</p><ul><li><p>在用户提出申请后，物资申请信息被后端拼成了一个字符串存储在apply_content（同时利用了前端的数据执行了物品可借数的预扣除，所以这部分没有用到物资申请信息字符串的解析）</p></li><li><p>通过审核后，物品正式借出，这时候只留有物资申请信息的字符串存储在数据库，所以需要后端对该字符串解析提取出申请物资与其借用数量，再去操作数据库</p></li></ul><p>由于Mysql对JSON类型的支持是5.7以后的版本才有的，所以之前版本的物品申请内容字符串是以物品 + 申请数量并用逗号隔开多个物品申请内容这样的格式构成，我一开始也考虑其转换为JSON格式，但是在考虑到应用场景后，决定对其进行分表，将多对多关系分为了两个一对多关系</p><p>数据库设计十分不合理，甚至不符合第一范式，<strong>浪费数据库大量存储空间</strong>不说，而且后端拼接字符串解析字符串这一过程<strong>十分耗时且占用内存</strong>，而且最新的需求是需要增加一个审核过程申请物资调整功能</p><p>所以我将物资申请表进行分表（水平分表），分出物资申请详情表并联系物资信息表，其结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203031646110.png" alt="image-20220303164602406"></p><p>删除掉apply_content字段，节省数据库空间</p><p>分表后，通过tw_applydetail表，我们对物资申请信息的所以内容进行操作，省去了物资审核接口对字符串解析的耗时过程并且方便审核过程申请物资调整功能的开发（通过tw_appdetail找到物品信息和物品数量）</p><h5 id="3-优化操作：存储过程脚本"><a href="#3-优化操作：存储过程脚本" class="headerlink" title="3.优化操作：存储过程脚本"></a>3.优化操作：存储过程脚本</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象</p><p>这里值得注意的是在遍历游标的循环中，如果查询不存在或为空会跳出循环</p><p>当时经过一天的对存储过程的学习，我总结出了以下经验：存储过程非常不方便调试，而且报错信息只定位不报错误类型（sql是这样的）。如果能重来，对数据库的批量操作，首选Python或Shell</p><h5 id="4-优化结果"><a href="#4-优化结果" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>截至目前物资申请表已有4817条数据，考虑到后面数据会长期积累，这样的优化是有必要的</li><li>去掉后端耗时耗内存的字符串解析工作</li><li>节省数据库存储空间，优化前申请表内存占0.79MB，优化后占0.56MB</li></ul><p>另外附加一个容量查询小工具，可查询数据库各表容量大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">table_schema as &#39;数据库&#39;,</span><br><span class="line">table_name as &#39;表名&#39;,</span><br><span class="line">table_rows as &#39;记录数&#39;,</span><br><span class="line">truncate(data_length&#x2F;1024&#x2F;1024, 2) as &#39;数据容量(MB)&#39;,</span><br><span class="line">truncate(index_length&#x2F;1024&#x2F;1024, 2) as &#39;索引容量(MB)&#39;</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema&#x3D;&#39;bgs&#39;</span><br><span class="line">order by data_length desc, index_length desc;</span><br></pre></td></tr></table></figure><h4 id="三-数据库索引的使用"><a href="#三-数据库索引的使用" class="headerlink" title="三.数据库索引的使用"></a>三.数据库索引的使用</h4><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#一-mysql-基础架构分析">MySQL索引详解</a></p><p>由于日志表数据庞大，有3万条数据，为了达到快速通过用户名模糊查找到日志操作内容和操作时间，我一开始的方案是选择了使用索引，以操作人作为索引模糊查询操作日志</p><h5 id="1-相关表结构"><a href="#1-相关表结构" class="headerlink" title="1.相关表结构"></a>1.相关表结构</h5><p>日志记录表：共33687条数据</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203031910440.png" alt="image-20220303191047146"></p><h5 id="2-优化思路：添加索引"><a href="#2-优化思路：添加索引" class="headerlink" title="2.优化思路：添加索引"></a>2.优化思路：添加索引</h5><p>另外在模糊查询中，<strong>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用</strong></p><p>所以我将查询的模糊匹配由“%xxxx%”改为“xxxx%”，只模糊匹配前面部分</p><h5 id="3-优化操作"><a href="#3-优化操作" class="headerlink" title="3.优化操作"></a>3.优化操作</h5><p>这里直接使用Navicat可视化添加索引，因为后台查询日志是需要用用户名模糊查找到日志操作内容和操作时间，所以需要添加的索引为log_realnam</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203031939750.png" alt="image-20220303193939350"></p><p>更改mybatis的sql映射，解决sql注入和索引失效问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE &quot;%$&#123;log_name&#125;%&quot;;  </span><br></pre></td></tr></table></figure><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE concat(‘%’,#&#123;log_name&#125;, ‘%’) </span><br></pre></td></tr></table></figure><h5 id="4-优化结果-1"><a href="#4-优化结果-1" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>添加索引前使用用户名模糊查询日志，耗时大约0.045s，添加索引后耗时大约0.032s，减少了磁盘IO，提高了查询速度</li><li>修改mybatis中模糊查询的sql语句，解决索引失效的问题，并解决了模糊查询中拼接字符串的sql注入问题</li></ul><p>但是加索引这种方案没有被采纳，因为在系统上操作日志包括了，注册登录申请审批等操作，插入是非常频繁的，而日志查询只会被管理员少量使用，所以后续使用了ES来提高查询效率</p><h3 id="大数据框架解析"><a href="#大数据框架解析" class="headerlink" title="大数据框架解析"></a>大数据框架解析</h3><p><strong>必看资料：</strong></p><p><a href="https://www.cnblogs.com/ifme/p/12005026.html">Spring Data Elasticsearch基本使用</a></p><p><a href="https://onblogs.net/2019/05/29/史上最全面的Elasticsearch使用指南/">史上最全面的Elasticsearch使用指南</a></p><h3 id="一-ES搜索操作日志"><a href="#一-ES搜索操作日志" class="headerlink" title="一.ES搜索操作日志"></a>一.ES搜索操作日志</h3><p><a href="https://onblogs.net/2019/05/29/史上最全面的Elasticsearch使用指南/">史上最全面的Elasticsearch使用指南</a></p><h5 id="1-ES准备"><a href="#1-ES准备" class="headerlink" title="1.ES准备"></a>1.ES准备</h5><p><strong>ES是什么</strong></p><p>elasticsearch简写es，es是一个高扩展、开源的全文检索和分析引擎，它可以准实时地快速存储、搜索、分析海量的数据，而这正好符合我们的需求，物资申请系统的操作日志刚好是一个存储频繁，又需要对大量数据进行查询统计的场景</p><p><strong>什么是全文检索</strong></p><p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。全文搜索搜索引擎数据库中的数据。</p><p><strong>配置ES</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span> = <span class="string">127.0.0.1:9300</span></span><br></pre></td></tr></table></figure><p><strong>ES注解实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Document注解Category实体类，一个Category对象即为一个Document（相当于数据库的一行）</span></span><br><span class="line"><span class="comment">// 连接到es的tmall_springboot索引（相当于数据库），produt类（相当于表）上</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;tmall_springboot&quot;,type = &quot;product&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="2-esDAO的创建"><a href="#2-esDAO的创建" class="headerlink" title="2.esDAO的创建"></a>2.esDAO的创建</h5><p>由于整合了ES的JPA和操作数据库使用的JPA有冲突，所以不能放在同一个包下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.pojo.Product;</span><br><span class="line"><span class="comment">// 用于链接es的DAO</span></span><br><span class="line"><span class="comment">// esDAO和其他DAO不能放在一个包下否则会启动异常</span></span><br><span class="line"><span class="comment">// 主要使用es实现对产品的模糊查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductESDAO</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-ES与数据库同步"><a href="#3-ES与数据库同步" class="headerlink" title="3.ES与数据库同步"></a>3.ES与数据库同步</h5><p><strong>增删改操作</strong></p><p>增删改操作的数据需要同步ES和数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ProductDAO对数据库有影响的</span></span><br><span class="line"><span class="comment">// 都要通过productESDAO同步到es</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">productDAO.delete(id);</span><br><span class="line">productESDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ES初始化</strong></p><p>ES内数据为空，就将数据库中的数据同步到es</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据到es</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatabase2ES</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">Page&lt;Product&gt; page =productESDAO.findAll(pageable);</span><br><span class="line"><span class="comment">// 查询es中是否有数据</span></span><br><span class="line"><span class="keyword">if</span>(page.getContent().isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果数据为空，将数据从数据库同步到es中</span></span><br><span class="line">List&lt;Product&gt; products= productDAO.findAll();</span><br><span class="line"><span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">productESDAO.save(product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-ES查询"><a href="#4-ES查询" class="headerlink" title="4.ES查询"></a>4.ES查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过es进行查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">search</span><span class="params">(String keyword, <span class="keyword">int</span> start, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化es</span></span><br><span class="line">initDatabase2ES();</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryBuilders提供了大量静态方法，用于生成各种不同类型的查询对象</span></span><br><span class="line"><span class="comment">// 构建查询条件（多条件查询）</span></span><br><span class="line">FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()</span><br><span class="line"><span class="comment">// 为提供的字段名和文本创建一个通用查询</span></span><br><span class="line">.add(QueryBuilders.matchPhraseQuery(<span class="string">&quot;name&quot;</span>, keyword),</span><br><span class="line">ScoreFunctionBuilders.weightFactorFunction(<span class="number">100</span>))</span><br><span class="line"><span class="comment">// 设置权重分为求和模式</span></span><br><span class="line">.scoreMode(<span class="string">&quot;sum&quot;</span>)</span><br><span class="line"><span class="comment">// 设置权重分最低分</span></span><br><span class="line">.setMinScore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分页参数</span></span><br><span class="line">Sort sort  = <span class="keyword">new</span> Sort(Sort.Direction.DESC,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size,sort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分页参数和查询条件</span></span><br><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">.withPageable(pageable)</span><br><span class="line">.withQuery(functionScoreQueryBuilder).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询获取结果</span></span><br><span class="line">Page&lt;Product&gt; page = productESDAO.search(searchQuery);</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> page.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis解析"><a href="#Redis解析" class="headerlink" title="Redis解析"></a>Redis解析</h3><p><strong>必看资料：</strong></p><p><a href="https://www.yuque.com/books/share/04ac99ea-7726-4adb-8e57-bf21e2cc7183/fg8lgc">缓存基础常见面试题总结</a></p><p><a href="https://interview.javaguide.cn/#/./docs/d-2-redis">Redis常见面试题总结</a></p><p><a href="https://autovy.github.io/2022/04/20/Java/Java-渐进式本地缓存框架开发总结/">渐进式本地缓存开发总结</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存与数据库数据一致问题的解决</a></p><h4 id="一-Redis需求分析"><a href="#一-Redis需求分析" class="headerlink" title="一.Redis需求分析"></a>一.Redis需求分析</h4><p><strong>我们为了避免用户在请求数据的时候获取速度过于缓慢，同时也为了承受大量的并发请求，所以我们在数据库之上增加了缓存这一层来弥补</strong>，本系统主要使用的是Redis，将常用的数据存储在缓存中（如物品，用户信息等）</p><p>另外推荐使用RedisClient，数据一般都在db0中</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203102017619.png" alt="image-20220310201748019"></p><h4 id="二-Redis配置"><a href="#二-Redis配置" class="headerlink" title="二.Redis配置"></a>二.Redis配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h4 id="三-缓存的使用"><a href="#三-缓存的使用" class="headerlink" title="三.缓存的使用"></a>三.缓存的使用</h4><p>缓存的使用一般在服务层使用</p><h5 id="1-有序集合管理"><a href="#1-有序集合管理" class="headerlink" title="1.有序集合管理"></a>1.有序集合管理</h5><p>通过在服务层中注解@CacheConfig，创建一个有序集合类型的缓存，管理该服务下所有的keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类服务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// redis缓存一般都在服务层进行操作</span></span><br><span class="line"><span class="comment">// 分类服务下的所有keys都由categories来管理（数据存储与categories是平行关系）</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames=&quot;categories&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203102026158.png" alt="image-20220310202613389"></p><h5 id="2查询插入缓存"><a href="#2查询插入缓存" class="headerlink" title="2查询插入缓存"></a>2查询插入缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得单条分类服务</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-one- + 参数id为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Category对象</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-one-&#x27;+ #p0&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Category c= categoryDAO.findOne(id);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出单页分类表（提供分页组索引）</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-page- + 参数start + 参数size 为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Page4Navigator&lt;Category&gt;数组</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-page-&#x27;+#p0+ &#x27;-&#x27; + #p1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page4Navigator&lt;Category&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> size, <span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">   Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size, sort);</span><br><span class="line">Page pageFromJPA =categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Page4Navigator&lt;&gt;(pageFromJPA,navigatePages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的java对象或集合都会变成JSON字符串</p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203102031241.png" alt="image-20220310203123882"></p><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202203102032065.png" alt="image-20220310203207786"></p><h5 id="3-更新删除缓存"><a href="#3-更新删除缓存" class="headerlink" title="3.更新删除缓存"></a>3.更新删除缓存</h5><p>为了应对并发的申请请求提高，我们在Mysql数据库前加了一层Redis，所以在我开发后台物资储存量调整接口时遇到了缓存和数据库中物品数量不一致的问题</p><p>准确来说是插入，删除，更新删除缓存以保持数据一致性</p><p>使用@CacheEvict(allEntries=true)删除category~keys的所有keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加删除更新时</span></span><br><span class="line"><span class="comment">// 增加分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">categoryDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="微服务解析"><a href="#微服务解析" class="headerlink" title="微服务解析"></a>微服务解析</h3><h3 id="高并发高可用解析"><a href="#高并发高可用解析" class="headerlink" title="高并发高可用解析"></a>高并发高可用解析</h3><h3 id="系统设计与性能测试解析"><a href="#系统设计与性能测试解析" class="headerlink" title="系统设计与性能测试解析"></a>系统设计与性能测试解析</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202209011353612.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java|物资申请系统开发总结</title>
    <link href="https://autovy.github.io/2021/10/20/Java/Java-%E7%89%A9%E8%B5%84%E7%94%B3%E8%AF%B7%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://autovy.github.io/2021/10/20/Java/Java-%E7%89%A9%E8%B5%84%E7%94%B3%E8%AF%B7%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-20T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.182Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041947181.png" alt="image-20220504104541342"></p><span id="more"></span><h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><h3 id="数据库结构图"><a href="#数据库结构图" class="headerlink" title="数据库结构图"></a>数据库结构图</h3><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041042079.jpg" alt></p><h3 id="主要数据表信息"><a href="#主要数据表信息" class="headerlink" title="主要数据表信息"></a>主要数据表信息</h3><h4 id="一-物资申请表"><a href="#一-物资申请表" class="headerlink" title="一.物资申请表"></a>一.物资申请表</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041045668.png" alt="image-20220504104541342"></p><ul><li>用户id : 物资申请条目 = 1 : n</li><li>机构id : 物资申请条目 = 1 : n</li></ul><h4 id="二-物资申请详情表"><a href="#二-物资申请详情表" class="headerlink" title="二.物资申请详情表"></a>二.物资申请详情表</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041053586.png" alt="image-20220504105313339"></p><ul><li>物资申请条目id : 物资申请详情条目 = n : n</li><li>物资id : 物资申请详情条目 = n : n</li><li>(物资申请条目id,物资id) : 物资申请详情条目 = 1 : n</li></ul><h4 id="三-物资表"><a href="#三-物资表" class="headerlink" title="三.物资表"></a>三.物资表</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041059831.png" alt="image-20220504105953610"></p><h4 id="四-用户表"><a href="#四-用户表" class="headerlink" title="四.用户表"></a>四.用户表</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041102927.png" alt="image-20220504110242618"></p><ul><li>用户信息条目 : 权限id = 1 : 1</li></ul><h4 id="五-权限表"><a href="#五-权限表" class="headerlink" title="五.权限表"></a>五.权限表</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202205041104629.png" alt="image-20220504110408506"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><h4 id="一-前端"><a href="#一-前端" class="headerlink" title="一.前端"></a>一.前端</h4><ul><li>Vue.js：前端逻辑处理数据</li><li>Bootstrap：使用模板样式</li><li>Jquery</li><li>axios</li><li>Thymeleaf：主要使用其HTML包含技术，整合页面共用部分（Springboot官方推荐的视图）</li></ul><h4 id="二-后端"><a href="#二-后端" class="headerlink" title="二.后端"></a>二.后端</h4><ul><li>SpringBoot 1.5.9 RELEASE</li><li>Shiro安全框架</li><li>Maven</li><li>Hibernate</li><li>Elasticsearch搜索引擎</li></ul><h4 id="三-数据库"><a href="#三-数据库" class="headerlink" title="三.数据库"></a>三.数据库</h4><ul><li>MySQL数据库</li><li>Redis</li></ul><h3 id="相关依赖准备"><a href="#相关依赖准备" class="headerlink" title="相关依赖准备"></a>相关依赖准备</h3><p>pom.xml文件导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springboot web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springboot tomcat 支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 热部署 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- jpa：java持久层api，用于操作数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- redis：基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，一般说来，会被当作缓存使用。 因为它比数据库(mysql)快 --&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springboot test --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- thymeleaf： Thymeleaf 是一种模板语言，可以达到和JSP一样的效果，但是比起JSP 对于前端测试更加友好--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- elastic search：Elasticsearch是一个基于Lucene库的搜索引擎。它提供了一个分布式、支持多租户的全文搜索引擎 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用了 elasticsearch 就要加这么一个，不然要com.sun.jna.Native 错误 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- thymeleaf legacyhtml5 模式支持 --&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.nekohtml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nekohtml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 测试支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- tomcat的支持.--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mysql：数据库支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- junit：java自动测试工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span> 4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- commons-lang：提供常用工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- shiro：Java 当下常见的安全框架，主要用于用户验证和授权操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- hsqldb是一款Java内置的数据库，非常适合在用于快速的测试和演示的Java程序中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springfox-swagger依赖添加：文档化工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="开发内容"><a href="#开发内容" class="headerlink" title="开发内容"></a>开发内容</h2><h3 id="MySQL优化过程"><a href="#MySQL优化过程" class="headerlink" title="MySQL优化过程"></a>MySQL优化过程</h3><h4 id="一-T-SQL脚本分表优化"><a href="#一-T-SQL脚本分表优化" class="headerlink" title="一.T-SQL脚本分表优化"></a>一.T-SQL脚本分表优化</h4><h5 id="1-相关表的结构"><a href="#1-相关表的结构" class="headerlink" title="1.相关表的结构"></a>1.相关表的结构</h5><p>此处展示的表结构为维护前</p><p>物资申请表：共4817条数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031543098.png" alt="image-20220303154338625"></p><p>物资信息表：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031545235.png" alt="image-20220303154513022"></p><p>goods_count：当前仓库物品数（物理的）</p><p>good_leftCount：当前物品可借数（网络的：存在部分未借出，但已被预订仍在审核中的物品）</p><h5 id="2-优化思路：物资申请表分表"><a href="#2-优化思路：物资申请表分表" class="headerlink" title="2.优化思路：物资申请表分表"></a>2.优化思路：物资申请表分表</h5><p>从上面的tw_apply表就可以知道：</p><ul><li><p>在用户提出申请后，物资申请信息被后端拼成了一个字符串存储在apply_content（同时利用了前端的数据执行了物品可借数的预扣除，所以这部分没有用到物资申请信息字符串的解析）</p></li><li><p>通过审核后，物品正式借出，这时候只留有物资申请信息的字符串存储在数据库，所以需要后端对该字符串解析提取出申请物资与其借用数量，再去操作数据库</p></li></ul><p>还好后端大哥没有把物资申请信息的字符串直接发给前端，我真的哭死，设计数据库的那个出来挨打（前端不需要解析，但是要拼接展示字符串）</p><p>数据库设计十分不合理，甚至不符合第一范式，<strong>浪费数据库大量存储空间</strong>不说，而且后端拼接字符串解析字符串这一过程<strong>十分耗时且占用内存</strong>，而且最新的需求是需要增加一个审核过程申请物资调整功能</p><p>所以我将物资申请表进行分表（水平分表），分出物资申请详情表并联系物资信息表，其结构如下</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031646110.png" alt="image-20220303164602406"></p><p>删除掉apply_content字段，节省数据库空间</p><p>分表后，通过tw_applydetail表，我们对物资申请信息的所以内容进行操作，省去了物资审核接口对字符串解析的耗时过程并且方便审核过程申请物资调整功能的开发（通过tw_appdetail找到物品信息和物品数量）</p><h5 id="3-优化操作：存储过程脚本"><a href="#3-优化操作：存储过程脚本" class="headerlink" title="3.优化操作：存储过程脚本"></a>3.优化操作：存储过程脚本</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象</p><p>这里值得注意的是在遍历游标的循环中，如果查询不存在或为空会跳出循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`Autovy`@`localhost` <span class="keyword">PROCEDURE</span> `demo`()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 定义变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n TINYTEXT;</span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="type">INT</span>(<span class="number">11</span>);</span><br><span class="line"> # 求分割符号<span class="string">&#x27;,&#x27;</span>的位置</span><br><span class="line"><span class="keyword">DECLARE</span> _index <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息</span><br><span class="line"><span class="keyword">DECLARE</span> str TINYTEXT;</span><br><span class="line"></span><br><span class="line"># 单个物品申请信息长度</span><br><span class="line"><span class="keyword">DECLARE</span> strLength <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"># 物品名称</span><br><span class="line"><span class="keyword">DECLARE</span> goodName <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"># 物品数量</span><br><span class="line"><span class="keyword">DECLARE</span> goodCount <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"># 物品id</span><br><span class="line"><span class="keyword">DECLARE</span> goodId <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义游标，并将sql结果集赋值给游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> apply_id1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id, apply_content <span class="keyword">FROM</span> tw_apply <span class="keyword">WHERE</span> apply_content <span class="keyword">LIKE</span> &quot;本部%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明当游标遍历完后将标志变量置成1</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> s<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> apply_id1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将游标中的值赋值给变量，注意：变量名不要和返回列名同名，变量顺序要和sql结果顺序一致</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当s != 1,一直循环</span></span><br><span class="line">while s<span class="operator">&lt;&gt;</span><span class="number">1</span> do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过;分割单个物品的申请信息：北院—帐篷物品1个;北院—椅子物品1个;北院—桌子物品1个;</span></span><br><span class="line">while _index <span class="operator">&gt;</span> <span class="number">0</span>  do</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到单个物品申请信息：本部——桌子物品1个</span></span><br><span class="line"><span class="keyword">SET</span> str <span class="operator">=</span> <span class="keyword">LEFT</span>(n, _index<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> strLength <span class="operator">=</span> LENGTH(str) <span class="operator">/</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品名称</span></span><br><span class="line"><span class="keyword">SET</span> goodName <span class="operator">=</span> <span class="keyword">LEFT</span>(str, strLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拿到物品个数(类型转换为整数)</span></span><br><span class="line"><span class="keyword">SET</span> goodCount <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="keyword">LEFT</span>(<span class="keyword">RIGHT</span>(str, <span class="number">2</span>), <span class="number">1</span>) <span class="keyword">AS</span> signed) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> goodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按物品名称查到物品id并存储到goodId中</span></span><br><span class="line"><span class="comment">-- 这里如果查询不存在或为空会跳出游标循环，值得注意</span></span><br><span class="line"><span class="keyword">SELECT</span> goods_id <span class="keyword">into</span> goodId <span class="keyword">FROM</span> tw_goods <span class="keyword">WHERE</span> goods_show <span class="keyword">LIKE</span> goodName <span class="keyword">ORDER</span> <span class="keyword">BY</span> goods_count <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> tw_applydetail(apply_id, good_id, count) <span class="keyword">VALUES</span> (m, goodId, goodCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移动到下个分界点</span></span><br><span class="line"><span class="keyword">SET</span> n <span class="operator">=</span> SUBSTR(n <span class="keyword">FROM</span> _index<span class="operator">+</span><span class="number">1</span>);</span><br><span class="line"><span class="keyword">SET</span> _index <span class="operator">=</span> LOCATE(<span class="string">&#x27;;&#x27;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行业务逻辑</span></span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取下一条数据，读取完成置变量s=1</span></span><br><span class="line"><span class="keyword">FETCH</span> apply_id1 <span class="keyword">into</span> m, n;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">close</span> apply_id1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>当时经过一天的对存储过程的学习，我总结出了以下经验：存储过程非常不方便调试，而且报错信息只定位不报错误类型（sql是这样的）。如果能重来，对数据库的批量操作，首选Python或Shell</p><h5 id="4-优化结果"><a href="#4-优化结果" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>截至目前物资申请表已有4817条数据，考虑到后面数据会长期积累，这样的优化是有必要的</li><li>去掉后端耗时耗内存的字符串解析工作</li><li>节省数据库存储空间，优化前申请表内存占0.79MB，优化后占0.56MB</li></ul><p>另外附加一个容量查询小工具，可查询数据库各表容量大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">table_schema as &#39;数据库&#39;,</span><br><span class="line">table_name as &#39;表名&#39;,</span><br><span class="line">table_rows as &#39;记录数&#39;,</span><br><span class="line">truncate(data_length&#x2F;1024&#x2F;1024, 2) as &#39;数据容量(MB)&#39;,</span><br><span class="line">truncate(index_length&#x2F;1024&#x2F;1024, 2) as &#39;索引容量(MB)&#39;</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema&#x3D;&#39;bgs&#39;</span><br><span class="line">order by data_length desc, index_length desc;</span><br></pre></td></tr></table></figure><h4 id="二-索引优化查询"><a href="#二-索引优化查询" class="headerlink" title="二.索引优化查询"></a>二.索引优化查询</h4><h5 id="1-相关表结构"><a href="#1-相关表结构" class="headerlink" title="1.相关表结构"></a>1.相关表结构</h5><p>日志记录表：共33687条数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031910440.png" alt="image-20220303191047146"></p><h5 id="2-优化思路：添加索引"><a href="#2-优化思路：添加索引" class="headerlink" title="2.优化思路：添加索引"></a>2.优化思路：添加索引</h5><p>关于索引的知识点这里不细说，推荐阅读：<a href="https://javaguide.cn/database/mysql/mysql-index/">MySQL 索引详解</a></p><p>由于日志表数据庞大，有3万条数据，为了达到快速通过用户名模糊查找到日志操作内容和操作时间，就需要用到索引，另外在模糊查询中，<strong>like语句要使索引生效，like后不能以%开始，也就是说 （like %字段名%） 、（like %字段名）这类语句会使索引失效，而（like 字段名）、（like 字段名%）这类语句索引是可以正常使用</strong></p><p>所以我将查询的模糊匹配由“%xxxx%”改为“xxxx%”，只模糊匹配前面部分</p><h5 id="3-优化操作"><a href="#3-优化操作" class="headerlink" title="3.优化操作"></a>3.优化操作</h5><p>这里直接使用Navicat可视化添加索引，因为后台查询日志是需要用用户名模糊查找到日志操作内容和操作时间，所以需要添加的索引为log_realnam</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203031939750.png" alt="image-20220303193939350"></p><p>更改mybatis的sql映射，解决sql注入和索引失效问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE &quot;%$&#123;log_name&#125;%&quot;;  </span><br></pre></td></tr></table></figure><p>在这种情况下使用#程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT log_realname, log_content, log_time FROM tw_log WHERE log_realname LIKE concat(‘%’,#&#123;log_name&#125;, ‘%’) </span><br></pre></td></tr></table></figure><h5 id="4-优化结果-1"><a href="#4-优化结果-1" class="headerlink" title="4.优化结果"></a>4.优化结果</h5><ul><li>添加索引前使用用户名模糊查询日志，耗时大约0.045s，添加索引后耗时大约0.032s，减少了磁盘IO，提高了查询速度</li><li>修改mybatis中模糊查询的sql语句，解决索引失效的问题，并解决了模糊查询中拼接字符串的sql注入问题</li></ul><h3 id="Elasticsearch搜索"><a href="#Elasticsearch搜索" class="headerlink" title="Elasticsearch搜索"></a>Elasticsearch搜索</h3><h4 id="一-ES配置"><a href="#一-ES配置" class="headerlink" title="一.ES配置"></a>一.ES配置</h4><h5 id="1-ES可视化"><a href="#1-ES可视化" class="headerlink" title="1.ES可视化"></a>1.ES可视化</h5><p>kibana是es的可视化工具，开启后可以通过访问 <a href="http://127.0.0.1:5601/">http://127.0.0.1:5601/</a>  查看kibana页面</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203111029709.png" alt="image-20220311102937485"></p><h5 id="2-配置ES"><a href="#2-配置ES" class="headerlink" title="2.配置ES"></a>2.配置ES</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span> = <span class="string">127.0.0.1:9300</span></span><br></pre></td></tr></table></figure><h4 id="二-ES开发流程"><a href="#二-ES开发流程" class="headerlink" title="二.ES开发流程"></a>二.ES开发流程</h4><h5 id="1-ES注解实体类"><a href="#1-ES注解实体类" class="headerlink" title="1.ES注解实体类"></a>1.ES注解实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Document注解Category实体类，一个Category对象即为一个Document（相当于数据库的一行）</span></span><br><span class="line"><span class="comment">// 连接到es的tmall_springboot索引（相当于数据库），produt类（相当于表）上</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;tmall_springboot&quot;,type = &quot;product&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="2-esDAO的创建"><a href="#2-esDAO的创建" class="headerlink" title="2.esDAO的创建"></a>2.esDAO的创建</h5><p>由于整合了ES的JPA和操作数据库使用的JPA有冲突，所以不能放在同一个包下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.pojo.Product;</span><br><span class="line"><span class="comment">// 用于链接es的DAO</span></span><br><span class="line"><span class="comment">// esDAO和其他DAO不能放在一个包下否则会启动异常</span></span><br><span class="line"><span class="comment">// 主要使用es实现对产品的模糊查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductESDAO</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Product</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-Application引入ES"><a href="#3-Application引入ES" class="headerlink" title="3.Application引入ES"></a>3.Application引入ES</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// esJPA引入</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(basePackages = &quot;com.how2java.tmall.es&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JPA引入</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &#123;&quot;com.how2java.tmall.dao&quot;, &quot;com.how2java.tmall.pojo&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h5 id="4-服务层同步ES"><a href="#4-服务层同步ES" class="headerlink" title="4.服务层同步ES"></a>4.服务层同步ES</h5><p><strong>增删改操作</strong></p><p>增删改操作的数据需要同步ES和数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ProductDAO对数据库有影响的</span></span><br><span class="line"><span class="comment">// 都要通过productESDAO同步到es</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">productDAO.delete(id);</span><br><span class="line">productESDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Product bean)</span> </span>&#123;</span><br><span class="line">productDAO.save(bean);</span><br><span class="line">productESDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ES初始化</strong></p><p>ES内数据为空，就将数据库中的数据同步到es</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据到es</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatabase2ES</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">Page&lt;Product&gt; page =productESDAO.findAll(pageable);</span><br><span class="line"><span class="comment">// 查询es中是否有数据</span></span><br><span class="line"><span class="keyword">if</span>(page.getContent().isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果数据为空，将数据从数据库同步到es中</span></span><br><span class="line">List&lt;Product&gt; products= productDAO.findAll();</span><br><span class="line"><span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">productESDAO.save(product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-服务层查询ES"><a href="#5-服务层查询ES" class="headerlink" title="5.服务层查询ES"></a>5.服务层查询ES</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过es进行查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">search</span><span class="params">(String keyword, <span class="keyword">int</span> start, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化es</span></span><br><span class="line">initDatabase2ES();</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryBuilders提供了大量静态方法，用于生成各种不同类型的查询对象</span></span><br><span class="line"><span class="comment">// 构建查询条件（多条件查询）</span></span><br><span class="line">FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()</span><br><span class="line"><span class="comment">// 为提供的字段名和文本创建一个通用查询</span></span><br><span class="line">.add(QueryBuilders.matchPhraseQuery(<span class="string">&quot;name&quot;</span>, keyword),</span><br><span class="line">ScoreFunctionBuilders.weightFactorFunction(<span class="number">100</span>))</span><br><span class="line"><span class="comment">// 设置权重分为求和模式</span></span><br><span class="line">.scoreMode(<span class="string">&quot;sum&quot;</span>)</span><br><span class="line"><span class="comment">// 设置权重分最低分</span></span><br><span class="line">.setMinScore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分页参数</span></span><br><span class="line">Sort sort  = <span class="keyword">new</span> Sort(Sort.Direction.DESC,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size,sort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分页参数和查询条件</span></span><br><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">.withPageable(pageable)</span><br><span class="line">.withQuery(functionScoreQueryBuilder).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询获取结果</span></span><br><span class="line">Page&lt;Product&gt; page = productESDAO.search(searchQuery);</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> page.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h3><h4 id="一-Redis可视化工具"><a href="#一-Redis可视化工具" class="headerlink" title="一.Redis可视化工具"></a>一.Redis可视化工具</h4><p>推荐使用RedisClient，数据一般都在db0中</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203102017619.png" alt="image-20220310201748019"></p><h4 id="二-Redis配置"><a href="#二-Redis配置" class="headerlink" title="二.Redis配置"></a>二.Redis配置</h4><h5 id="1-Redis配置类"><a href="#1-Redis配置类" class="headerlink" title="1.Redis配置类"></a>1.Redis配置类</h5><p>该缓存配置类主要是使redis内的key和value转换为可读性的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//Redis 缓存配置类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate&lt;?,?&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        RedisSerializer stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.PUBLIC_ONLY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        redisTemplate.setKeySerializer(stringSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringSerializer);  </span><br><span class="line">         </span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);         </span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        CacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-Redis配置文件"><a href="#2-Redis配置文件" class="headerlink" title="2.Redis配置文件"></a>2.Redis配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h4 id="三-缓存启用与检测"><a href="#三-缓存启用与检测" class="headerlink" title="三.缓存启用与检测"></a>三.缓存启用与检测</h4><h5 id="1-缓存的启用"><a href="#1-缓存的启用" class="headerlink" title="1.缓存的启用"></a>1.缓存的启用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统启动入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 启动缓存</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(basePackages = &quot;com.how2java.tmall.es&quot;)</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &#123;&quot;com.how2java.tmall.dao&quot;, &quot;com.how2java.tmall.pojo&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 检测端口上的服务是否启动</span></span><br><span class="line">        PortUtil.checkPort(<span class="number">6379</span>,<span class="string">&quot;Redis 服务端&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        PortUtil.checkPort(<span class="number">9300</span>,<span class="string">&quot;ElasticSearch 服务端&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        PortUtil.checkPort(<span class="number">5601</span>,<span class="string">&quot;Kibana 工具&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-服务开启检测"><a href="#2-服务开启检测" class="headerlink" title="2.服务开启检测"></a>2.服务开启检测</h5><p>这里的PortUtil是一个检测端口上服务是否运行的简单工具类，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.how2java.tmall.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具类，检查某个端口对应的服务是否启动</span></span><br><span class="line"><span class="comment">// 可以用于检查redis服务和es服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PortUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">ss.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPort</span><span class="params">(<span class="keyword">int</span> port, String server, <span class="keyword">boolean</span> shutdown)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!testPort(port)) &#123;</span><br><span class="line"><span class="keyword">if</span>(shutdown) &#123;</span><br><span class="line">String message =String.format(<span class="string">&quot;在端口 %d 未检查得到 %s 启动%n&quot;</span>,port,server);</span><br><span class="line">JOptionPane.showMessageDialog(<span class="keyword">null</span>, message);</span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String message =String.format(<span class="string">&quot;在端口 %d 未检查得到 %s 启动%n,是否继续?&quot;</span>,port,server);</span><br><span class="line">    <span class="keyword">if</span>(JOptionPane.OK_OPTION != JOptionPane.showConfirmDialog(<span class="keyword">null</span>, message)) </span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-缓存的使用"><a href="#四-缓存的使用" class="headerlink" title="四.缓存的使用"></a>四.缓存的使用</h4><p>缓存的使用一般在服务层使用</p><h5 id="1-有序集合管理"><a href="#1-有序集合管理" class="headerlink" title="1.有序集合管理"></a>1.有序集合管理</h5><p>通过在服务层中注解@CacheConfig，创建一个有序集合类型的缓存，管理该服务下所有的keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类服务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// redis缓存一般都在服务层进行操作</span></span><br><span class="line"><span class="comment">// 分类服务下的所有keys都由categories来管理（数据存储与categories是平行关系）</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames=&quot;categories&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203102026158.png" alt="image-20220310202613389"></p><h5 id="2查询插入缓存"><a href="#2查询插入缓存" class="headerlink" title="2查询插入缓存"></a>2查询插入缓存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得单条分类服务</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-one- + 参数id为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Category对象</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-one-&#x27;+ #p0&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">Category c= categoryDAO.findOne(id);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出单页分类表（提供分页组索引）</span></span><br><span class="line"><span class="comment">// 添加一条缓存到redis中，以categories-page- + 参数start + 参数size 为key值</span></span><br><span class="line"><span class="comment">// 存储的主要数据为Page4Navigator&lt;Category&gt;数组</span></span><br><span class="line"><span class="meta">@Cacheable(key=&quot;&#x27;categories-page-&#x27;+#p0+ &#x27;-&#x27; + #p1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page4Navigator&lt;Category&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> size, <span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">   Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(start, size, sort);</span><br><span class="line">Page pageFromJPA =categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Page4Navigator&lt;&gt;(pageFromJPA,navigatePages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的java对象或集合都会变成JSON字符串</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203102031241.png" alt="image-20220310203123882"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203102032065.png" alt="image-20220310203207786"></p><h5 id="3-更新删除缓存"><a href="#3-更新删除缓存" class="headerlink" title="3.更新删除缓存"></a>3.更新删除缓存</h5><p>准确来说是插入，删除，更新删除缓存以保持数据一致性</p><p>使用@CacheEvict(allEntries=true)删除category~keys的所有keys</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加删除更新时</span></span><br><span class="line"><span class="comment">// 增加分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">categoryDAO.delete(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新分类服务</span></span><br><span class="line"><span class="meta">@CacheEvict(allEntries=true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Category bean)</span> </span>&#123;</span><br><span class="line">categoryDAO.save(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shiro登录验证"><a href="#Shiro登录验证" class="headerlink" title="Shiro登录验证"></a>Shiro登录验证</h3><p>由于本项目仅仅有用户一个权限，所以只需要判断用户是否登录，并不需要比较细粒度的权限分配</p><h4 id="一-JPARealm验证授权器"><a href="#一-JPARealm验证授权器" class="headerlink" title="一.JPARealm验证授权器"></a>一.JPARealm验证授权器</h4><p>Shiro与用户之间的中介，为Shiro提供验证和授权用户的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.realm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过JPA进行验证授权</span></span><br><span class="line"><span class="comment">// （相当于一个中介，拿着用户信息去数据库找用户拥有的角色和权限）</span></span><br><span class="line"><span class="comment">// 将Realm提供给Shiro，由其负责调用，不需要直接调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JPARealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 认证：查询用户身份与密码，解决你是谁的问题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="comment">// 从token中取出用户名称</span></span><br><span class="line">String userName = token.getPrincipal().toString();</span><br><span class="line"><span class="comment">// 查询用户表得到用户加密密码</span></span><br><span class="line">User user = userService.getByName(userName);</span><br><span class="line">String passwordInDB = user.getPassword();</span><br><span class="line"><span class="comment">// 获得用户表中的盐</span></span><br><span class="line">String salt = user.getSalt();</span><br><span class="line"><span class="comment">// 以用户名，加密密码，盐，真实信息，真正姓名作为认证信息</span></span><br><span class="line">SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(userName, passwordInDB, ByteSource.Util.bytes(salt),</span><br><span class="line">getName());</span><br><span class="line"><span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 授权：赋予用户权限，解决你能做什么的问题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SimpleAuthorizationInfo s = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二-Shiro配置"><a href="#二-Shiro配置" class="headerlink" title="二.Shiro配置"></a>二.Shiro配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.realm.JPARealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.LifecycleBeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shiro配置文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor <span class="title">getLifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器，实现对请求的拦截和跳转</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shirFilter</span><span class="params">(SecurityManager securityManager)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ShiroFilterFactoryBean 对象</span></span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean  = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           这里可以设置URL并为它们配置权限，本项目没有用到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// shiro核心组件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建DefaultWebSecurityManager对象</span></span><br><span class="line">        DefaultWebSecurityManager securityManager =  <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">// 设置其使用的Realm</span></span><br><span class="line">        securityManager.setRealm(getJPARealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载身份认证与授权模块</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JPARealm <span class="title">getJPARealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JPARealm myShiroRealm = <span class="keyword">new</span> JPARealm();</span><br><span class="line">        myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher());</span><br><span class="line">        <span class="keyword">return</span> myShiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定使用md5加密算法，并进行两次加密</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashedCredentialsMatcher <span class="title">hashedCredentialsMatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashedCredentialsMatcher hashedCredentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        hashedCredentialsMatcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        hashedCredentialsMatcher.setHashIterations(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> hashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  开启shiro aop注解支持.</span></span><br><span class="line"><span class="comment">     *  使用代理方式;所以需要开启代码支持;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span></span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三-注册接口"><a href="#三-注册接口" class="headerlink" title="三.注册接口"></a>三.注册接口</h4><p>Realm的验证需要对应注册里的加密方法即md5 * 2 + 盐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册接口</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/foreregister&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    String name =  user.getName();</span><br><span class="line">    String password = user.getPassword();</span><br><span class="line">    <span class="comment">// 对姓名中的特殊符号进行转义</span></span><br><span class="line">    name = HtmlUtils.htmlEscape(name);</span><br><span class="line">    user.setName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户名是否存在</span></span><br><span class="line">    <span class="keyword">boolean</span> exist = userService.isExist(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exist)&#123;</span><br><span class="line">        String message =<span class="string">&quot;用户名已经被使用,不能使用&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成盐</span></span><br><span class="line">    String salt = <span class="keyword">new</span> SecureRandomNumberGenerator().nextBytes().toString();</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 采用md5加密</span></span><br><span class="line">    String algorithmName = <span class="string">&quot;md5&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// md5 + 盐对用户密码进行加密得到加密密码</span></span><br><span class="line">    <span class="comment">// times = 2，表明进行两次的md5加密</span></span><br><span class="line">    String encodedPassword = <span class="keyword">new</span> SimpleHash(algorithmName, password, salt, times).toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将盐和加密密码存入数据库中</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    user.setPassword(encodedPassword);</span><br><span class="line"></span><br><span class="line">    userService.add(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-登录接口"><a href="#四-登录接口" class="headerlink" title="四.登录接口"></a>四.登录接口</h4><p>配置好Shiro后，登录验证时可以快速使用啦！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录接口</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/forelogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User userParam, HttpSession session)</span> </span>&#123;</span><br><span class="line">        String name =  userParam.getName();</span><br><span class="line">        name = HtmlUtils.htmlEscape(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shiro认证登录（你是谁？）</span></span><br><span class="line">        <span class="comment">// subject指的是:&quot;当前正在执行的用户的特定的安全视图&quot;</span></span><br><span class="line">        <span class="comment">// 可以把Subject看成是shiro的&quot;User&quot;概念</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(name, userParam.getPassword());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            User user = userService.getByName(name);</span><br><span class="line">            <span class="comment">// 将user存储进seesion中，后续可以随时取出用于验证登录</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">            <span class="keyword">return</span> Result.success();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            String message =<span class="string">&quot;账号密码错误&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截前端某些没有权限的访问，如没有登录权限的用户访问个人信息表，跳转到登录页</p><h4 id="一-拦截器"><a href="#一-拦截器" class="headerlink" title="一.拦截器"></a>一.拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录拦截器，用于拦截未登录情况下的访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpSession session = httpServletRequest.getSession();</span><br><span class="line">        String contextPath=session.getServletContext().getContextPath();</span><br><span class="line"><span class="comment">// 需要验证登录的页面</span></span><br><span class="line">        String[] requireAuthPages = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">&quot;buy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;alipay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;payed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bought&quot;</span>,</span><br><span class="line">        <span class="string">&quot;confirmPay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderConfirmed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forebuyone&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forebuy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foreaddCart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forecart&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forechangeOrderItem&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foredeleteOrderItem&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forecreateOrder&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forepayed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forebought&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foreconfirmPay&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foreorderConfirmed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foredeleteOrder&quot;</span>,</span><br><span class="line">        <span class="string">&quot;forereview&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foredoreview&quot;</span></span><br><span class="line">        </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取uri</span></span><br><span class="line">        String uri = httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除前缀/tmall_springboot</span></span><br><span class="line">        uri = StringUtils.remove(uri, contextPath+<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String page = uri;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链接名，是否以验证登录数组里的开头</span></span><br><span class="line"><span class="keyword">if</span>(begingWith(page, requireAuthPages))&#123;</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">// 如果是则跳转到login页面</span></span><br><span class="line"><span class="keyword">if</span>(!subject.isAuthenticated()) &#123;</span><br><span class="line">httpServletResponse.sendRedirect(<span class="string">&quot;login&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">begingWith</span><span class="params">(String page, String[] requiredAuthPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (String requiredAuthPage : requiredAuthPages) &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.startsWith(page, requiredAuthPage)) &#123;</span><br><span class="line">result = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过实现SpringMCV的HandlerInterceptor来实现拦截器，其中包含3个方法：</p><p><strong>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)</strong></p><p>该方法将在请求处理之前进行调用。SpringMVC中的Interceptor是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。</p><p>每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。</p><p>该方法的返回值是布尔值Boolean类型的，当它返回为false 时，表示请求结束，后续的Interceptor和Controller都不会再执行；</p><p>当返回值为true时就会继续调用下一个Interceptor的preHandle方法，如果已经是最后一个Interceptor的时候就会是调用当前请求的Controller方法</p><p><strong>postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)</strong><br>由preHandle方法的解释我们知道这个方法包括后面要说到的afterCompletion方法都只能是在当前所属的Interceptor的preHandle方法的返回值为true时才能被调用</p><p>postHandle方法，顾名思义就是在当前请求进行处理之后，也就是Controller方法调用之后执行，<br>但是它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。</p><p>postHandle方法被调用的方向跟preHandle是相反的，也就是说先声明的Interceptor 的postHandle方法反而会后执行，这和Struts2里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的</p><p><strong>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</strong><br>该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。</p><p>顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。<br>这个方法的主要作用是用于进行资源清理工作的。</p><h4 id="二-拦截器配置"><a href="#二-拦截器配置" class="headerlink" title="二.拦截器配置"></a>二.拦截器配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问拦截器配置</span></span><br><span class="line"><span class="keyword">package</span> com.how2java.tmall.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.how2java.tmall.interceptor.OtherInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 拦截器的配置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">getLoginIntercepter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h2><h3 id="循环依赖解决方案"><a href="#循环依赖解决方案" class="headerlink" title="循环依赖解决方案"></a>循环依赖解决方案</h3><h4 id="一-Springboot注解补充"><a href="#一-Springboot注解补充" class="headerlink" title="一.Springboot注解补充"></a>一.Springboot注解补充</h4><p>实体类中，@Transient注解的字段，是不与数据库映射的，可以额外添加到接口的字段即该字段不参与自动关联中的sql查询</p><p>这些字段可以用来存储：通过查询数据库得到的列表（不用另外建集合对象存储），需要经过计算的数据（也可以放在数据库），数据状态（也可以放在数据库）</p><p>订单表@Transient注解字段，在服务层进行赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单项列表</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line"><span class="comment">// 订单总金额</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> total;</span><br><span class="line"><span class="comment">// 订单物品总数量</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalNumber;</span><br><span class="line"><span class="comment">// 订单状态</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String statusDesc;</span><br></pre></td></tr></table></figure><p>使用</p><p>@ManyToOne<br>@JoinColumn(name=”pid”)</p><p>可以标注关系，就可以使用JPA的findBy等方法如：<code>findByProductOrderByIdDesc</code>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个产品有多个属性值</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个属性有多个属性值（属性 + 产品决定一条属性值）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;ptid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Property property;</span><br></pre></td></tr></table></figure><h4 id="二-数据库设计：多对多关系"><a href="#二-数据库设计：多对多关系" class="headerlink" title="二.数据库设计：多对多关系"></a>二.数据库设计：多对多关系</h4><p>在实际应用中，多对多关系会分解为两个一对多的关系</p><p>属性值由产品和属性共同决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个产品，有多个属性值（不同属性，同一产品）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个属性有多个属性值（不同产品，同一属性）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;ptid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Property property;</span><br></pre></td></tr></table></figure><p>订单项由订单，用户，产品共同决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个产品可以有多个订单项（不同用户/不同订单，同一产品）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个订单可以有多个订单项（不同产品/不同用户，同一订单）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;oid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用户可以有多个订单项（不同产品/不同订单，同一用户）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;uid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br></pre></td></tr></table></figure><p>在review类中的内对象如：prouct，user由于一对多的关联，在数据库中映射为pid，uid字段）</p><p>所以说JPA是一个ORM框架，对象和数据库无缝衔接</p><h4 id="三-循环依赖的解决"><a href="#三-循环依赖的解决" class="headerlink" title="三.循环依赖的解决"></a>三.循环依赖的解决</h4><p>在SpringBoot + JPA的架构中，容易出现循环依赖问题，一般会出现在一对多的场景下，总结来说是一对多实体中都要引用对方来维持OnetoMany的关系，所以极容易出现循环依赖:(</p><h5 id="1-经典场景"><a href="#1-经典场景" class="headerlink" title="1.经典场景"></a>1.经典场景</h5><p>订单项中引用订单，以构成多对一关系</p><p>可以使用订单项查找其属于的订单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个订单可以有多个订单项（不同产品/不同用户，同一订单）</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;oid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Order order;</span><br></pre></td></tr></table></figure><p>订单中引用订单项存储在集合中，用来存储从数据库查询来的结构（往往是因为要利用这些字段进行计算）</p><p>可以使用订单id查找订单项列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单项列表</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line"><span class="comment">// 订单总金额</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> total;</span><br><span class="line"><span class="comment">// 订单物品总数量</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalNumber;</span><br></pre></td></tr></table></figure><p>这样的结构就是循环依赖，导致数据重复加载，因为orderItems要调用方法填充，所以会为空（一般情况下会栈溢出）最终造成的数据是：Order含有orderItems，orderItems含有Order，Order的orderItem列表为空，所以这里的Order重复了一次</p><h5 id="2-方案一：-JsonBackReference注解"><a href="#2-方案一：-JsonBackReference注解" class="headerlink" title="2.方案一：@JsonBackReference注解"></a>2.方案一：@JsonBackReference注解</h5><p>JsonBackReference注解用在一（一对多的一）的一方，可以阻止其被序列化，前提是对应的接口不需要调用到它，而只是需要用它来查询</p><p>如：一个产品有多张图片，我们不需要在图片列表接口使用到产品信息，而只是需要用产品id查询其图片</p><p><strong>产品类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="comment">// 产品首图</span></span><br><span class="line"><span class="keyword">private</span> ProductImage firstProductImage;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productSingleImages;</span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductImage&gt; productDetailImages;</span><br></pre></td></tr></table></figure><p><strong>产品图片类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;pid&quot;)</span></span><br><span class="line"><span class="meta">@JsonBackReference</span></span><br><span class="line"><span class="keyword">private</span> Product product;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><ul><li>关系是双向的，使用了JsonBackReference，就无法使用根据图片找到其属于的产品的方法，只能单方向查询即根据产品查找到其图片列表</li><li>JsonBackReference标记的字段与Redis的整合会有冲突</li></ul><h5 id="3-方案二：及时清除法"><a href="#3-方案二：及时清除法" class="headerlink" title="3.方案二：及时清除法"></a>3.方案二：及时清除法</h5><p>在服务层定义清除方法，在控制层调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Orderitem中有Order字段，标注多对一关系</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，用于存储订单项列表</span></span><br><span class="line"><span class="comment">// Order中有Orderitem列表，而Orderitem中又有Order字段，产生无穷的递归</span></span><br><span class="line"><span class="comment">// 所以这里需要设置Orderitem的Order设为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(List &lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">removeOrderFromOrderItem(order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOrderFromOrderItem</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">List&lt;OrderItem&gt; orderItems= order.getOrderItems();</span><br><span class="line"><span class="keyword">for</span> (OrderItem orderItem : orderItems) &#123;</span><br><span class="line">orderItem.setOrder(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充Order的orderItem列表</span></span><br><span class="line">orderItemService.fill(page.getContent());</span><br><span class="line"><span class="comment">// 清除orderItem中的Order字段</span></span><br><span class="line">orderService.removeOrderFromOrderItem(page.getContent());</span><br></pre></td></tr></table></figure><h5 id="4-方案三：延迟加载"><a href="#4-方案三：延迟加载" class="headerlink" title="4.方案三：延迟加载"></a>4.方案三：延迟加载</h5><p>关于延迟加载：<a href="https://www.baeldung.com/hibernate-lazy-eager-loading">延迟加载介绍</a></p><p>使用<code>FetchType.LAZY</code>的方法，在不适用关系属性时，就不会自动获取，而一旦触发使用就会自动获取其属性 问题是<code>Jackson</code>对<code>Hibernate</code>的<code>LazyFetch</code>并不默认支持，需要一些额外支持</p><p>使用jackson-datatype-hibernate5插件使Jackson支持hibernate的lazyFetch</p><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-hibernate5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateModuleConfig</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title">mappingJackson2HttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              MappingJackson2HttpMessageConverter jsonConverter = <span class="keyword">new</span> MappingJackson2HttpMessageConverter();</span><br><span class="line">              ObjectMapper objectMapper = jsonConverter.getObjectMapper();</span><br><span class="line">              objectMapper.registerModule(<span class="keyword">new</span> Hibernate5Module());</span><br><span class="line">              <span class="keyword">return</span> jsonConverter;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实体上增加主键Id识别信息，防止出现循环引用 所有关系都为Lazy，直观上不会出现循环引用，但是当你通过一对多查询而多对一存在引用时仍会出现循环引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIdentityInfo(</span></span><br><span class="line"><span class="meta">      generator = ObjectIdGenerators.PropertyGenerator.class,</span></span><br><span class="line"><span class="meta">      property = &quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardModifyLog</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="5-其他方案"><a href="#5-其他方案" class="headerlink" title="5.其他方案"></a>5.其他方案</h5><ul><li>创建DTO，类似的思路还有创建接口投影或者实体视图，见<a href="https://www.baeldung.com/spring-data-jpa-named-entity-graphs">Spring Data JPA和命名实体图</a>、<a href="https://docs.spring.io/spring-data/jpa/docs/2.2.2.RELEASE/reference/html/#projections">Spring data jpa 投影</a>。 问题在于需要根据情况创建多个视图或者多个投影（DTO），由于各个实体间关系的复杂程度，不建议用此方式</li><li>使用<code>@Transient</code>注解使所有的关系不被存储即不与数据库的字段对应，同时存在于实体中，每次使用时，自己手动查询set 也许是一种好办法，但是失去了关系的约束，可能得不偿失</li></ul><h3 id="缓存AOP拦截失效问题"><a href="#缓存AOP拦截失效问题" class="headerlink" title="缓存AOP拦截失效问题"></a>缓存AOP拦截失效问题</h3><h4 id="一-问题出现原因"><a href="#一-问题出现原因" class="headerlink" title="一.问题出现原因"></a>一.问题出现原因</h4><p>Spring只有在代理对象之间进行调用时，可以触发切面逻辑才可以使用事务，在同一个class中，方法B调用方法A，调用的是原对象的方法，而不通过代理对象就无法使用事务,如果方法B有事务只会使用方法B的事务，不会去管方法A的事务所以一个类中方法调用当前类的其他拥有事务的方法时这个被调用方法事务会失效</p><p>一个类中方法调用当前类的其他拥有事务的方法时这个被调用方法事务会失效。在默认的代理模式下，只有目标方法由外部调用，才能被 Spring 的事务拦截器拦截</p><p>同理使用spring cache模块的@Cacheable等注解 在同一个class中互相调用是无法走缓存的 因为这样无法访问到spring容器中的那个代理对象</p><p>因为Springboot的缓存机制是通过切面编程aop来实现，从fill方法中调用listByCategory即内部调用，aop是拦截不到的，自然不会走缓存</p><h4 id="二-问题解决方案"><a href="#二-问题解决方案" class="headerlink" title="二.问题解决方案"></a>二.问题解决方案</h4><p>可以使用 AspectJ 取代 Spring AOP 代理来解决，也可以使用工具类诱发aop</p><p>fill方法调用诱发工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充分类中的产品集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过SpringContextUtil调用listByCategory上的缓存方法</span></span><br><span class="line">    <span class="comment">// 即 @Cacheable(key=&quot;&#x27;products-cid-&#x27;+ #p0.id&quot;)</span></span><br><span class="line">    <span class="comment">// 这样在方法内部的查询也能够使用缓存</span></span><br><span class="line">    ProductService productService = SpringContextUtil.getBean(ProductService.class);</span><br><span class="line">    List&lt;Product&gt; products = productService.listByCategory(category);</span><br><span class="line">    productImageService.setFirstProdutImages(products);</span><br><span class="line">    category.setProducts(products);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringContextUtil工具类诱发aop</p><p>我们需要在代码中需要动态获取其它bean，我们可以通过实现ApplicationContextAware接口来实现</p><p>ApplicationContextAware可以对当前bean传入对应的Spring上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.tmall.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取spring容器，以访问容器中定义的其他bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring应用上下文环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ApplicationContextAware接口的回调方法，设置上下文环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象 这里重写了bean方法，起主要作用</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(beanId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页动态数组开发"><a href="#分页动态数组开发" class="headerlink" title="分页动态数组开发"></a>分页动态数组开发</h3><h4 id="一-简单分页方法"><a href="#一-简单分页方法" class="headerlink" title="一.简单分页方法"></a>一.简单分页方法</h4><h5 id="1-Service层实现简单分页方法"><a href="#1-Service层实现简单分页方法" class="headerlink" title="1.Service层实现简单分页方法"></a>1.Service层实现简单分页方法</h5><p>这里使用JPA提供的Pageable类型对列表进行分页</p><p>Pageable是从0开始计算页数的，所以这里需要<code>pageNum - 1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Category&gt; <span class="title">getpage</span><span class="params">(<span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageLimit)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Pageable pageable = <span class="keyword">new</span> PageRequest(pageNum - <span class="number">1</span> , pageLimit);</span><br><span class="line">    <span class="keyword">return</span> categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Controller层调用分页方法"><a href="#2-Controller层调用分页方法" class="headerlink" title="2.Controller层调用分页方法"></a>2.Controller层调用分页方法</h5><p>通过@RequestParam设置从前台get方法发来的page和size信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/catepage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Category&gt; <span class="title">pageList</span><span class="params">(<span class="meta">@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;)</span> <span class="keyword">int</span> page ,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> categoryService.getpage(page, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h5><p>访问请求链接：<a href="http://localhost:8080/shopping_system/catepage?page=2&amp;size=5">http://localhost:8080/shopping_system/catepage?page=2&amp;size=5</a></p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203060908527.png" alt="image-20211215173655433" style="zoom:80%;"><h4 id="二-分页动态数组组类"><a href="#二-分页动态数组组类" class="headerlink" title="二.分页动态数组组类"></a>二.分页动态数组组类</h4><h5 id="1-分页功能进阶封装"><a href="#1-分页功能进阶封装" class="headerlink" title="1.分页功能进阶封装"></a>1.分页功能进阶封装</h5><p>JPA提供的分页类可以返回分割后的列表内容和分类信息如<strong>总共数据数（totalElements），总共分割的页面（totalPages）与当前访问的页面（number）</strong>，但是这些数据不能方便提供一个方便的接口让前端实现<strong>部分分页节点展示</strong>和<strong>分页节点遍历</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203060908268.png" alt="image-20220228201059144"></p><p>当前是第8页，前面要显示3个，后面要显示3个，总共7条分页点，Pageable默认就不提供了，即Pageable无法实现根据当前选择页调整接口返回的数据，而只能硬性分页</p><p>所以我们需要做了一个 PageNavigator， 首先对 Page 类进行了封装，然后在构造方法里提供了一个 navigatePages 参数作为区间分页节点数</p><p>在构造方法里，还调用了 calcNavigatepageNums， 就是用来计算这个数值，并返回到一个int 数组变量 navigatepageNums ，方便前端遍历展示，而这个数组的大小为navigatePages</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageNavigator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用Page类</span></span><br><span class="line">    Page&lt;T&gt; pageFromJPA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalPages;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">long</span> totalElements;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单页数据数</span></span><br><span class="line">    <span class="keyword">int</span> numberOfElements;</span><br><span class="line">    <span class="comment">// 分页数据</span></span><br><span class="line">    List&lt;T&gt; contents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为首尾判断</span></span><br><span class="line">    <span class="keyword">boolean</span> first;</span><br><span class="line">    <span class="keyword">boolean</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有数据</span></span><br><span class="line">    <span class="keyword">boolean</span> isHasContent;</span><br><span class="line">    <span class="comment">// 是否有前驱</span></span><br><span class="line">    <span class="keyword">boolean</span> isHasPrevious;</span><br><span class="line">    <span class="comment">// 是否有后续</span></span><br><span class="line">    <span class="keyword">boolean</span> isHasNext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定区间分页节点数</span></span><br><span class="line">    <span class="keyword">int</span> navigatePages;</span><br><span class="line">    <span class="comment">// 规定区间分页节点列表</span></span><br><span class="line">    <span class="keyword">int</span>[] navigatepageNums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageNavigator</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造规定分页区间大小的分页函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageNavigator</span><span class="params">(Page&lt;T&gt; pageFromJPA, <span class="keyword">int</span> navigatePages)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 引用Page里面的成员变量</span></span><br><span class="line">        <span class="keyword">this</span>.pageFromJPA = pageFromJPA;</span><br><span class="line">        <span class="keyword">this</span>.navigatePages = navigatePages;</span><br><span class="line"></span><br><span class="line">        totalPages = pageFromJPA.getTotalPages();</span><br><span class="line">        number = pageFromJPA.getNumber();</span><br><span class="line">        totalElements = pageFromJPA.getTotalElements();</span><br><span class="line">        size = pageFromJPA.getNumberOfElements();</span><br><span class="line">        contents = pageFromJPA.getContent();</span><br><span class="line">        isHasContent = pageFromJPA.hasContent();</span><br><span class="line">        first = pageFromJPA.isFirst();</span><br><span class="line">        last = pageFromJPA.isLast();</span><br><span class="line">        isHasNext = pageFromJPA.hasNext();</span><br><span class="line">        isHasPrevious = pageFromJPA.hasPrevious();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出分页节点列表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcNavigatepageNums</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] navigatepageNums;</span><br><span class="line">        <span class="comment">// 总页数</span></span><br><span class="line">        <span class="keyword">int</span> totalPages = getTotalPages();</span><br><span class="line">        <span class="comment">// 当前页</span></span><br><span class="line">        <span class="keyword">int</span> num = getNumber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总页数小于区间分页节点数</span></span><br><span class="line">        <span class="keyword">if</span>(totalPages &lt;= navigatePages)&#123;</span><br><span class="line">            navigatepageNums = <span class="keyword">new</span> <span class="keyword">int</span>[totalPages];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalPages; i++)&#123;</span><br><span class="line">                navigatepageNums[i] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            navigatepageNums = <span class="keyword">new</span> <span class="keyword">int</span>[ navigatePages];</span><br><span class="line">            <span class="comment">// 计算区间列表首尾索引</span></span><br><span class="line">            <span class="keyword">int</span> startNum = num - navigatePages / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> endNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(navigatePages % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                endNum = num + navigatePages / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                endNum = num + navigatePages / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首navigatePages页</span></span><br><span class="line">            <span class="keyword">if</span>(startNum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                startNum = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; navigatePages; i++)&#123;</span><br><span class="line">                    navigatepageNums[i] = startNum++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾navigatePages页</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(startNum &gt; navigatePages)&#123;</span><br><span class="line">                endNum = totalPages;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = navigatePages - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                    navigatepageNums[i] = endNum--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 中间navigatePages页</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; navigatePages; i++)&#123;</span><br><span class="line">                    navigatepageNums[i] = startNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.navigatepageNums = navigatepageNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量对应的Getter与Setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalPages</span><span class="params">(<span class="keyword">int</span> totalPages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalPages = totalPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalElements</span><span class="params">(<span class="keyword">long</span> totalElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalElements = totalElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberOfElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumberOfElements</span><span class="params">(<span class="keyword">int</span> numberOfElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numberOfElements = numberOfElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContents</span><span class="params">(List&lt;T&gt; contents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contents = contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(<span class="keyword">boolean</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(<span class="keyword">boolean</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasContent</span><span class="params">(<span class="keyword">boolean</span> hasContent)</span> </span>&#123;</span><br><span class="line">        isHasContent = hasContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasPrevious;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasPrevious</span><span class="params">(<span class="keyword">boolean</span> hasPrevious)</span> </span>&#123;</span><br><span class="line">        isHasPrevious = hasPrevious;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasNext</span><span class="params">(<span class="keyword">boolean</span> hasNext)</span> </span>&#123;</span><br><span class="line">        isHasNext = hasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNavigatePages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> navigatePages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNavigatePages</span><span class="params">(<span class="keyword">int</span> navigatePages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.navigatePages = navigatePages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNavigatepageNums() &#123;</span><br><span class="line">        <span class="keyword">return</span> navigatepageNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNavigatepageNums</span><span class="params">(<span class="keyword">int</span>[] navigatepageNums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.navigatepageNums = navigatepageNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上面的写法外，如果不需要修改方法名，完全可以在继承Page类的基础上进行拓展</p><h5 id="2-Service层实现进阶分页方法"><a href="#2-Service层实现进阶分页方法" class="headerlink" title="2.Service层实现进阶分页方法"></a>2.Service层实现进阶分页方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageNavigator&lt;Category&gt; <span class="title">getpage</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size, <span class="keyword">int</span> navigatePages)</span></span>&#123;</span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">    Pageable pageable = <span class="keyword">new</span> PageRequest(page, size, sort);</span><br><span class="line">    Page pageFrom = categoryDAO.findAll(pageable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageNavigator&lt;&gt;(pageFrom, navigatePages);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-Controller层调用进阶分页方法"><a href="#3-Controller层调用进阶分页方法" class="headerlink" title="3.Controller层调用进阶分页方法"></a>3.Controller层调用进阶分页方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/catepage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageNavigator&lt;Category&gt; <span class="title">pageList</span><span class="params">(<span class="meta">@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;)</span> <span class="keyword">int</span> page,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;)</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口初始页调整为从1开始</span></span><br><span class="line">        page = page &lt; <span class="number">1</span> ? <span class="number">1</span> : page;</span><br><span class="line">        PageNavigator&lt;Category&gt; list = categoryService.getpage(page - <span class="number">1</span>, size, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p>访问地址：<a href="http://localhost:8080/tmall_springboot/categories?start=3&amp;size=2">http://localhost:8080/tmall_springboot/categories?start=3&amp;size=2</a></p><p>可以看到最终实现了提供一个存储5个页面索引的数组</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202282106562.png" alt="image-20220228210601487"></p><h4 id="三-分页方法比较"><a href="#三-分页方法比较" class="headerlink" title="三.分页方法比较"></a>三.分页方法比较</h4><p>JPA提供的分页类——Page可以满足各种分页需求，大部分时候用它就足够了，但是Pageable无法实现根据当前选择页调整接口返回的数据，而只能硬性分页即 <code>页数（totalPage） =  数据数（totalElements） / 页大小（size）</code> </p><p>表现在前端所有的分页都在一组分页栏中，如果想部分显示分页栏就需要前端去定制分页分组方法</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202203060908527.png" alt="image-20211215173655433" style="zoom:80%;"><p>但是如果前端有需求让后端根据当前选择页，以当前页为中点返回n个页面为一组的索引供前端调用</p><p>这时候我们就要对Page类进行封装，构造一个分页组类，在构造方法中提供一个navigatePages参数（分页组大小），并提供calNavigateNums方法根据当前页计算出分到同一组的页面索引并存储到数组navigatepageNums中供前端遍历展示</p><p>表现在前端可以通过接口获得当前页同一组分页的索引方便遍历</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202282106562.png" alt="image-20220228210601487"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/ifme/p/12005026.html">Spring Data Elasticsearch基本使用</a></p><p><a href="https://onblogs.net/2019/05/29/史上最全面的Elasticsearch使用指南/">史上最全面的Elasticsearch使用指南</a></p><p><a href="https://juejin.cn/post/6844904002400813070">Spring data jpa中实体关系解决方案</a></p><p><a href="https://www.jianshu.com/p/a2f98f6d6fbd">Spring Data JPA 使用详解</a></p><p><a href="https://mp.weixin.qq.com/s/aUqH_lFxohMWPW4xOpPTcA">Redis实用指南</a></p><p><a href="https://www.baeldung.com/hibernate-lazy-eager-loading">延迟加载介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202205041947181.png&quot; alt=&quot;image-20220504104541342&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
      <category term="项目实战" scheme="https://autovy.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|HTTP与HTTPS</title>
    <link href="https://autovy.github.io/2021/10/17/DevPrinciple/HTTP%E4%B8%8EHTTPS/"/>
    <id>https://autovy.github.io/2021/10/17/DevPrinciple/HTTP%E4%B8%8EHTTPS/</id>
    <published>2021-10-17T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110172010735.webp" alt="Oh the fun of HTTP-based applications"></p><p>基于HTTP应用程序的乐趣，but…</p> <img src="https://raw.staticdn.net/Autovy/Image/master/img/202208300729665.jpeg" style="zoom:20%;"><span id="more"></span><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1.HTTP基本概念"></a>1.HTTP基本概念</h4><h5 id="（1）超文本传输协议"><a href="#（1）超文本传输协议" class="headerlink" title="（1）超文本传输协议"></a>（1）超文本传输协议</h5><p>HTTP是超文本传输协议（<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol），准确的定义为<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110140812679.png" alt="img"></p><ul><li>协议：HTTP确认了一种计算机之间交流<strong>通信规范</strong>，以及各种相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）</li><li>传输：HTTP是一个<strong>双向协议</strong>，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程（<strong>请求方-应答方</strong>）</li><li>超文本：超文本顾名思义就是超越了普通文本的文本，最常用的超文本是<strong>HTML</strong>，是文章、图片、视频以及可以跳转到其他超文本等的<strong>混合体</strong></li></ul><h5 id="（2）HTTP状态码"><a href="#（2）HTTP状态码" class="headerlink" title="（2）HTTP状态码"></a>（2）HTTP状态码</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110140831637.webp" alt="Quick guide to HTTP Status codes"></p><p>好像没毛病😂，更加具体的说明如下：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110140836668.png" alt="img"></p><ul><li>1xx：<strong>提示信息</strong>，是协议处理中的<strong>中间状态</strong>，实际用到比较少</li><li>2xx：服务器<strong>成功</strong>处理客户端的请求<ol><li>200 （<strong>OK</strong>）：最常见的<strong>成功</strong>状态码，表示一切正常，非HEAD请求，服务器返回的响应头都会<strong>有body</strong>数据</li><li>204（<strong>No Content</strong>）：与200基本相同，但是响应头<strong>没有body</strong>数据</li><li>206（<strong>Partial Content</strong>）：应用于HTTP<strong>分块下载</strong>或<strong>断电续传</strong>，表示响应返回的body数据并不是资源的全部</li></ol></li><li>3xx：客户端请求的资源发生了变动，需要进行<strong>重定向</strong>（在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL）<ol><li>301（<strong>Moved Permanently</strong>）：表示永久重定向，说明请求的资源已经<strong>不存在</strong>，需要改用新的URL再次访问</li><li>302（<strong>Moved Permanently</strong>）：表示临时重定向，说明请求的资源<strong>还在</strong>，但暂时需要用另一个URL来访问</li><li>304（<strong>Not Modified</strong>）：缓冲重定向，用于缓存控制，表示资源未修改，重定向到已存在的缓冲文件</li></ol></li><li>4xx：客户端发送的报文有误，服务器无法处理<ol><li>400（<strong>Bad Request</strong>）：表示客户端请求的报文有误，但是是个<strong>笼统</strong>的错误</li><li>403（<strong>Forbidden</strong>）：表示服务器<strong>禁止访问</strong>资源，并不是客户端请求出错</li><li>404（<strong>Not Found</strong>）：表示请求的资源在服务器上<strong>不存在</strong>或<strong>未找到</strong>，所以无法提供给客户端</li></ol></li><li>5xx：服务器处理时内部发生了错误<ol><li>500（<strong>Internal Server Error</strong>）：一个<strong>笼统</strong>通用的错误：是的，服务器发生错误了，我们也不到什么错误</li><li>501（<strong>Not Implemented</strong>）：客户端请求的功能暂不支持（敬请期待）</li><li>502（Bad Gateway）：服务器自身工作正常，访问后端服务器时发生了错误（通常时用作网关或代理时的错误码）</li><li>503（<strong>Service Unavailable</strong>）：服务器当前正忙，暂时无法响应</li></ol></li></ul><h5 id="（3）HTTP常见字段"><a href="#（3）HTTP常见字段" class="headerlink" title="（3）HTTP常见字段"></a>（3）HTTP常见字段</h5><p><strong>通用标头：</strong>通用标头可以出现在请求标头和响应标头</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110141947390.png" alt="image-20211014194734284"></p><ul><li><p>Date：表示创建报文时间（格林威治标准时间）</p><p><code>Date: Wed, 21 Oct 2015 07:28:00 GMT</code> </p></li></ul><ul><li><p>Cache-Control：可以表示<strong>可缓存性</strong>、阈值性、 重新验证并重新加载和其他特性</p><p><code>Cache-control: no-cache</code></p></li></ul><ul><li><p>Connection：决定当前事务（一次三次握手和四次挥手）完成后，是否关闭网络连接（即是否复用TCP连接）</p><p><code>Connection: keep-alive</code>：<strong>持久性</strong>连接，一次事务完成后<strong>不关闭</strong>网络连接</p><p><code>Connection: close</code>：<strong>非持久化</strong>连接，一次事务完成后<strong>关闭</strong>网络连接</p></li></ul><p><strong>实体标头：</strong>实体标头是描述消息正文内容的 HTTP 标头</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110141955891.png" alt="image-20211014195508646"></p><ul><li>Content-Length：指示实体主体的大小，以字节为单位，发送到接收方</li></ul><p>  <img src="https://raw.staticdn.net/Autovy/Image/master/img/202110142001859.jpeg" alt="img"></p><ul><li>Content-Type：用于描述数据类型（格式），与Accept配套</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110142006988.jpeg" alt="img"></p><ul><li><p>Content-Encoding：用来说明描述的压缩方法和编码类型，与Accept-Encoding配套</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110142003250.jpeg" alt="img"></p></li></ul><ul><li>Content-Language：描述了客户端或者服务端能够接受的语言，与Accept-Language配套</li></ul><p><strong>请求标头：</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110142011873.png" alt="image-20211014201122463"></p><ul><li><p>Host：指明服务器域名与TCP端口号（也有写作authority）</p><p><code>Host: autovy.github.io</code></p></li></ul><ul><li><p>Referer：告诉服务器该网页是从哪个页面链接跳转过来的</p><p><code>Referer: https://autovy.github.io/</code></p></li></ul><ul><li><p>If-None-Match：使请求标头成为<strong>条件请求</strong>，当与给定资源<strong>ETag</strong>不匹配时才会处理请求</p><p><code>if-none-match: W/&quot;61665f52-7ba7&quot;</code></p></li></ul><ul><li><p>If-Modified-Since：If-Modified-Since 通常会与 If-None-Match 搭配使用，用于确认代理或客户端拥有的本地资源的<strong>有效性</strong>（在 <code>Last-Modified</code> 之后更新了服务器资源，那么服务器会响应 200，如果在 <code>Last-Modified</code> 之后没有更新过资源，则返回 304）</p><p><code>If-Modified-Since: Sat, 09 Oct 2021 01:58:35 GMT</code></p></li></ul><ul><li><p>Accept：告知服务器客户端能够理解的<strong>MIME类型</strong>，与Content-Type配套</p><p><code>accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</code></p></li></ul><ul><li>Accept-Charset：规定服务器处理表单数据所接受的<strong>字符集</strong></li></ul><ul><li><p>Accept-Language ：用来告知服务器客户端能够处理的<strong>自然语言集</strong></p><p><code>accept-language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</code></p></li></ul><p><strong>响应标头：</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110141925192.png" alt="img"></p><ul><li>Access-Control-Allow-Origin： 指定一个来源，它告诉浏览器允许该来源进行资源访问</li></ul><ul><li><p>Keep-Alive：表示的是 Connection 非持续连接的存活时间，可以进行指定，与Connection配套</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUlhrVicZt4iaLPPibcD8KQV4z9vqwAaAjdtkjUo5fGlKOsTaicbtEDO4u1Q/640?wx_fmt=jpeg" alt="img"></p></li></ul><ul><li>Server：服务器标头包含有关<strong>原始服务器</strong>用来处理请求的软件的信息</li></ul><ul><li>Set-Cookie：用于服务器向客户端发送 <strong>sessionID</strong></li></ul><ul><li>Transfer-Encoding：规定了传输报文主体时采用的<strong>编码方式</strong></li></ul><ul><li>X-Frame-Options：用于控制网站内容在其他 Web 网站的 <strong>Frame 标签</strong>内的显示问题，其主要目的是为了防止点击<strong>劫持攻击</strong></li></ul><h5 id="（4）HTTP无状态分析"><a href="#（4）HTTP无状态分析" class="headerlink" title="（4）HTTP无状态分析"></a>（4）HTTP无状态分析</h5><p><strong>无状态协议</strong>指浏览器对于事务的处理没有<strong>记忆能力</strong>，HTTP连接之间彼此独立，不会对请求和响应之间的通信进行保存</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110161444685.png" alt="img"></p><p>而<strong>Cookie</strong>技术可以通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110161446059.png" alt="img"></p><ul><li>客户端第一次向服务端发起请求</li><li>服务端开辟一块<strong>Session空间</strong>，同时生成一个<strong>sessionId</strong>，通过响应头的<strong>Set-Cookie</strong>命令要求客户端设置<strong>Cookie</strong></li><li>客户端收到响应后，在本地设置<strong>JSESSIONID</strong>的<strong>Cookie</strong>信息，默认过期时间为浏览器会话结束；接下来客户端向同一个完整发送请求时都会携带该<strong>Cookie</strong>信息</li><li>服务端通过读取请求头的<strong>Cookie</strong>信息，获取<strong>JSESSIONID</strong>的值，与存储的<strong>Session</strong>内的<strong>seesionId</strong>匹配</li></ul><p>此外还有一种让浏览器有记忆能力的机制——<strong>JWT机制</strong>（JSON WEB TOKEN），与Cookie不同，JWT是保存在客户端的信息，广泛用于<strong>单点登录</strong>，这里先挖个坑以后会详细出一篇讲单点登录的文章</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110161506705.webp" alt="img"></p><p>JWT是基于token的鉴权机制，不需要服务端去保留用户的认证信息或者会话信息</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token（令牌）</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据（token一般存在数据库中，也可以放在内存中）</li></ul><h4 id="2-GET与POST"><a href="#2-GET与POST" class="headerlink" title="2.GET与POST"></a>2.GET与POST</h4><h5 id="（1）GET与POST区别"><a href="#（1）GET与POST区别" class="headerlink" title="（1）GET与POST区别"></a>（1）GET与POST区别</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110161530468.jpeg" alt="img"></p><p>GET请求报文：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.java67.blogspot.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>POST请求报文:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">content-type:application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line">host: https://importexport.amazonaws.com</span><br><span class="line">content-length:207</span><br><span class="line"></span><br><span class="line">Action=GetStatus&amp;SignatureMethod=HmacSHA256&amp;JobId=JOBID&amp;SignatureVersion=2</span><br><span class="line">&amp;Version=2010-06-03&amp;Signature=%2FVfkltRBOoSUi1sWxRzN8rw%3D</span><br><span class="line">&amp;Timestamp=2011-06-20T22%3A30%3A59.556Z</span><br></pre></td></tr></table></figure><ul><li><strong>GET</strong>方法的含义是从服务器获取<strong>资源</strong>，发送的内容添加在url后</li><li><strong>POST</strong>方法先<strong>URI</strong>指定资源提交数据，这些数据放在报文body中</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110161540496.png" alt="img"></p><h5 id="（2）安全与幂等"><a href="#（2）安全与幂等" class="headerlink" title="（2）安全与幂等"></a>（2）安全与幂等</h5><ul><li><p>安全：在HTTP协议中，<strong>安全</strong>即请求方法不全不会<strong>破坏</strong>服务器的资源</p></li><li><p>幂等：多次执行相同操作，结果<strong>相同</strong>即一次请求和重复的多次请求对系统资源的影响是一致的，幂等思想在开发中有多处应用，可参考文章<a href="https://os.51cto.com/art/202012/633886.htm">幂等本质</a>了解更多</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110161549945.png" alt="img"></p></li></ul><ul><li><p>GET： GET方法是<strong>安全且幂等</strong>的，它是<strong>只读</strong>操作，服务器上数据安全且每次结果<strong>相同</strong></p></li><li><p>POST：POST方法是<strong>不安全且不幂等</strong>，它是<strong>新增或提交数据</strong>操作会修改服务器上的资源，所以<strong>不安全</strong>；多次提交数据就会创建多个资源，所以不是<strong>幂等</strong>的</p></li></ul><h4 id="3-HTTP特性"><a href="#3-HTTP特性" class="headerlink" title="3.HTTP特性"></a>3.HTTP特性</h4><h5 id="（1）HTTP的优点"><a href="#（1）HTTP的优点" class="headerlink" title="（1）HTTP的优点"></a>（1）HTTP的优点</h5><ul><li>简单：HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong></li><li>灵活和易于扩展：HTTP协议中的各类请求方法、URI/URL、状态码、头字段等每个组成要求都允许开发人员<strong>自定义和扩充</strong>，并且HTTP工作在应用层，其下层可以随意变化</li><li>应用广泛和跨平台：HTTP的应用范围广泛，而且可以跨平台使用</li></ul><h5 id="（2）HTTP的缺点"><a href="#（2）HTTP的缺点" class="headerlink" title="（2）HTTP的缺点"></a>（2）HTTP的缺点</h5><ul><li><p>无状态双刃剑</p><ol><li>无状态的好处：服务器不需要记忆HTTP状态，不需要额外资源记录状态信息，减轻服务器负担</li><li>无状态的坏处：服务器在需要进行关联操作时会非常麻烦</li><li>无状态的问题可以配合Cookie或Token进行解决</li></ol></li></ul><ul><li><p>明文传输双刃剑</p><ol><li>明文传输好处：方便阅读，为<strong>调试</strong>提供极大的便利性</li><li>明文传输坏处：你能看到的信息别人也能看到，敏感信息直接就<strong>裸奔</strong>了</li></ol></li></ul><ul><li>不安全<ol><li>通信用明文，内容容易被窃听</li><li>不验证通信方的身份，可能遭遇伪装</li><li>无法验证报文的完整性，可以会被篡改</li></ol></li></ul><h5 id="（3）HTTP性能"><a href="#（3）HTTP性能" class="headerlink" title="（3）HTTP性能"></a>（3）HTTP性能</h5><p>主要针对目前应用广泛的HTTP/1.1进行评测</p><ul><li><p>长连接：提供持久连接，减少TCP连接的重复建立和断开所造成的额外开销</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162038444.jpeg" alt="img"></p></li></ul><ul><li><p>管道网络传输：客户端发起多个请求，发起了一个请求后不必等待响应，而是继续发送下一个请求，从而减少整体的响应时间</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162042091.jpeg" alt="img"></p></li></ul><ul><li><p>队头阻塞：当顺序发送时，请求序列中的一个请求被阻塞了，在后面排队的所有请求被阻塞了</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162044395.jpeg" alt="img"></p></li></ul><h4 id="4-HTTP版本比较"><a href="#4-HTTP版本比较" class="headerlink" title="4.HTTP版本比较"></a>4.HTTP版本比较</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162046556.jpeg" alt="img"></p><h5 id="（1）HTTP-1-1"><a href="#（1）HTTP-1-1" class="headerlink" title="（1）HTTP/1.1"></a>（1）HTTP/1.1</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162105544.png" alt="image-20211016210504151"></p><p>HTTP/1.1的性能改进：</p><ul><li>使用<strong>长连接</strong>改善短链接造成的性能开销</li><li>支持<strong>管道网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li></ul><p>HTTP/1.1 性能瓶颈：</p><ul><li>请求/响应<strong>头部未经压缩</strong>就发送，只压缩了Body部分，首部信息越多延迟越大</li><li>发送<strong>冗长的首部</strong>，每次互相发送相同的首部造成浪费较多</li><li>队头阻塞</li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="（2）HTTP-2"><a href="#（2）HTTP-2" class="headerlink" title="（2）HTTP/2"></a>（2）HTTP/2</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162104685.png" alt="image-20211016210448418"></p><p>HTTP/2的性能改进：</p><ul><li><p>头部压缩</p><p>利用<strong>HPACK算法</strong>压缩头部，如果同时发出多个请求，可以消除重复的部分（在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号）</p></li></ul><ul><li><p>二进制格式</p><p>报文采用<strong>二进制格式</strong>而不是纯文本的形式，头信息和数据体都是二进制统称为帧，增加数据传输的效率</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162058061.png" alt="img"></p></li></ul><ul><li><p>数据流</p><p>数据包不是按顺序发送，同一个连接里面连续的数据包，可能属于不同的回应</p><p>因此要对数据包做标记，每个请求或回应的所有数据包，称为一个<strong>数据流</strong>（<code>Stream</code>）</p><p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p><p>客户端还可以<strong>指定数据流的优先级</strong>，优先级高的请求，服务器就先响应该请求</p></li></ul><ul><li><p>多路复用</p><p>在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162107565.jpeg" alt="img"></p></li></ul><ul><li><p>服务器推送</p><p>服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息</p><p>在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是<strong>服务器推送</strong></p></li></ul><p>HTTP/2 性能瓶颈：</p><ul><li>多个HTTP请求复用一个TCP连接，下层的 TCP 协议是不知道有多少个 HTTP 请求</li><li>一旦发生丢包现象，就会触发<strong>重传机制</strong>，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong></li><li>这些都是基于TCP传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong></li></ul><h5 id="（3）HTTP-3"><a href="#（3）HTTP-3" class="headerlink" title="（3）HTTP/3"></a>（3）HTTP/3</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110162114689.png" alt="image-20211016211442384"></p><p>HTTP/3的性能改进：</p><ul><li><p><strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong>，UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p></li></ul><ul><li><p>UDP是不可靠的传输，所以HTTP/3使用的是基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</p><ol><li><p>QUIC协议当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响</p></li><li><p>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code></p></li><li><p>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong></p></li><li><p>QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议</p></li></ol></li></ul><pre><code>![img](https://raw.staticdn.net/Autovy/Image/master/img/202110162120028.jpeg)</code></pre><p>HTTP/3 性能瓶颈：</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，普及的进度非常的缓慢</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="1-HTTPS基本概念"><a href="#1-HTTPS基本概念" class="headerlink" title="1.HTTPS基本概念"></a>1.HTTPS基本概念</h4><h5 id="（1）HTTPS定义"><a href="#（1）HTTPS定义" class="headerlink" title="（1）HTTPS定义"></a>（1）HTTPS定义</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110170930547.png" alt="img"></p><p>HTTPS（HyperText Transfer Protocol Secure）超文本传输安全协议，数据通信仍然是HTTP，但利用<strong>SSL/TLS加密数据包</strong></p><h5 id="（2）HTTP的安全问题"><a href="#（2）HTTP的安全问题" class="headerlink" title="（2）HTTP的安全问题"></a>（2）HTTP的安全问题</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171058237.svg" alt="202110170933070 (1)"></p><p>HTTP的<strong>明文传输</strong>是一个致命缺陷，没有经过任何加密，而这些明文数据会经过<strong>WiFi、路由器、运营商、机房</strong>等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，，这一攻击手法叫做MITM（Man In The Middle）<strong>中间人</strong>攻击</p><h4 id="2-HTTPS实现原理"><a href="#2-HTTPS实现原理" class="headerlink" title="2.HTTPS实现原理"></a>2.HTTPS实现原理</h4><h5 id="（1）对称加密"><a href="#（1）对称加密" class="headerlink" title="（1）对称加密"></a>（1）对称加密</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110170959993.png" alt="img"></p><p>对称加密算法使用<strong>同一个密钥</strong>进行加密和解密</p><ul><li>优点：速度快，适合数据量比较大的数据进行加密</li><li>缺点：在HTTPS的传输场景下，服务端事先并不知道客户端是谁，必然需要一个<strong>密钥传输</strong>过程，这意味着该密钥必定会<strong>泄露</strong>，后续的加密就不起作用了</li></ul><h5 id="（2）非对称加密：一组公私钥"><a href="#（2）非对称加密：一组公私钥" class="headerlink" title="（2）非对称加密：一组公私钥"></a>（2）非对称加密：一组公私钥</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110170959312.png" alt="img"></p><p>非对称加密需要两个密钥，一个<strong>公开密钥（Public Key）</strong>,一个<strong>私有密钥（Private Key）</strong>。公钥和私钥是一对，如果使用公钥进行加密的数据，只有对应的私钥才能解密。相对的，如果是使用私钥加密的数据，只有对应的公钥才能解密</p><ul><li>优点：当客户端发起连接请求，服务端将公钥传输过去，客户端利用<strong>公钥加密</strong>好信息，再将密文发送给服务端，服务端里用<strong>私钥解密</strong>，从而基本保证了客户端发送信息是安全的（只有服务器的私钥可解）</li><li>缺点：服务器无法返回加密安全的数据，服务器有<strong>公钥和私钥</strong>，客户端只有<strong>公钥</strong>。如果服务器用公钥加密，客户端也没有私钥可以解密；如果服务器用私钥加密，但是公钥相当于公开的，这样数据就不安全了</li></ul><p>严格来说，私钥并不能用来加密，而一般用作<strong>签名</strong>使用，签名的功能也会应用在HTTPS中，后面再细嗦</p><h5 id="（3）非对称加密：两组公私钥"><a href="#（3）非对称加密：两组公私钥" class="headerlink" title="（3）非对称加密：两组公私钥"></a>（3）非对称加密：两组公私钥</h5><p>一组公钥私钥只能保证客户端到服务端的<strong>单程加解密</strong>，理论上使用两组公钥私钥是可以保证<strong>往返加解密</strong></p><ul><li>服务端有非对称加密的公钥A1，私钥A2</li><li>客户端有非对称加密的公钥B1，私钥B2</li><li>客户端向服务端发起请求，服务端将<strong>公钥A1</strong>返回给客户端</li><li>浏览器收到公钥A1，将自己保存的<strong>公钥B1</strong>发送给服务端</li><li>之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密</li><li>客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密</li></ul><p>虽然非对称加密两组公私钥可以让两条传输方向都经过非对称加密，都能保证安全性，但是<strong>非对称加密耗时远大于对称加密</strong>，对性能有很大的损耗</p><h5 id="（4）混合加密"><a href="#（4）混合加密" class="headerlink" title="（4）混合加密"></a>（4）混合加密</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171015628.jpeg" alt="img"></p><p>混合加密是对称加密和非对称加密的结合体，即<strong>传输密钥</strong>时（一般传输共享的<strong>对称密钥</strong>）使用<strong>非对称加密</strong>的公钥加密，<strong>传输数据</strong>时使用<strong>共享对称密钥</strong>加密</p><ul><li><strong>非对称加密</strong>交换<strong>对称加密</strong>的<strong>会话密钥</strong></li><li><strong>对称加密</strong>使用<strong>会话密钥</strong>加密并交换数据</li></ul><p>具体步骤如下：</p><ul><li>服务端有非对称加密的公钥A1，私钥A2</li><li>客户端发起请求，服务端将公钥A1返回给客户端</li><li>客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端</li><li>服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了<strong>安全的对称密钥交换</strong>，解决了对称加密时密钥传输被人窃取的问题</li><li>之后双方通信都使用<strong>密钥K进行对称加解密</strong></li></ul><h5 id="（5）CA与数字证书"><a href="#（5）CA与数字证书" class="headerlink" title="（5）CA与数字证书"></a>（5）CA与数字证书</h5><p>混合加密兼顾了安全性，但是仍然无法保证安全，<strong>非对称加密的算法</strong>是<strong>公开</strong>的，所有人都可以生成一对公钥私钥，我们仍需要考虑<strong>中间人攻击</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171034059.png" alt="img"></p><ul><li>服务端返回公钥A1的过程中，中间人<strong>替换</strong>成自己准备好的的公钥B1传送给客户端</li><li>客户端对篡改行为一无所知，傻傻地使用公钥B1加密了对称加密使用的<strong>会话密钥K</strong></li><li>中间人截获公钥B1加密的<strong>会话密钥K</strong>，利用自己的私钥B2简简单单解个密，<strong>会话密钥K</strong>就暴露了，再使用服务端的公钥A1加密K传送给服务端，成功欺骗服务端，完成了通信链路。此后的的通信数据和明文传输无异</li></ul><p>这一问题的核心是：客户端<strong>无法确认</strong>收到的公钥是不是真的来源于服务端，无法保证公钥不被<strong>篡改</strong>和其<strong>信任度</strong>，这时就需要第三方权威机构<strong>CA</strong>（数字证书认证机构）将<strong>服务器公钥放在数字证书</strong>中，只要证书可信，公钥就可信</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171059315.jpeg" alt="img"></p><p><strong>摘要算法（哈希处理）</strong>保证证书不被篡改的原理：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171635097.jpeg" alt="img"></p><ul><li><p>服务器的公钥要事先提交到<strong>CA</strong>进行注册，申请一份<strong>数字证书</strong>（数字证书包含证书持有者，证书有效期，服务器公钥，哈希算法等）</p></li><li><p><strong>CA</strong>在颁发<strong>数字证书</strong>前对证书明文信息进行哈希处理（信息摘要计算），并对哈希值用CA的<strong>私钥</strong>处理得到<strong>数字签名</strong>对数字证书进行<strong>加签</strong></p></li><li><p>CA的公钥会<strong>内置</strong>在浏览器或操作系统中，不需要额外的网络传输</p></li><li><p>客户端发送请求时，服务端通过发送<strong>数字证书</strong>传输服务器的公钥</p></li><li><p>客户端得到证书，分解为<strong>明文部分Text</strong>和<strong>数字签名Sig1</strong>，使用CA机构的公钥进行<strong>解签</strong>得到Sig2，用证书声明的哈希算法对明文部分Text进行<strong>哈希处理</strong>，再与Sig2对比，如果匹配成功表示证书可信即表示公钥可信</p></li></ul><h4 id="3-HTTPS工作流程"><a href="#3-HTTPS工作流程" class="headerlink" title="3.HTTPS工作流程"></a>3.HTTPS工作流程</h4><p>参考资料：（写的比我好😇）</p><p><a href="https://segmentfault.com/a/1190000021494676">HTTPS 详解一：附带最精美详尽的 HTTPS 原理图</a></p><p><a href="https://segmentfault.com/a/1190000021559557">HTTPS详解二：SSL / TLS 工作原理和详细握手过程</a></p><p><a href="https://razeencheng.com/post/ssl-handshake-detail.html">HTTPS篇之SSL握手过程详解</a></p><h5 id="（1）HTTPS加解密流程"><a href="#（1）HTTPS加解密流程" class="headerlink" title="（1）HTTPS加解密流程"></a>（1）HTTPS加解密流程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171621895.png" alt="preview"></p><ul><li>客户端发起HTTPS请求，默认使用服务器端的<strong>443端口</strong>进行连接</li><li>服务器收到请求，返回配好的包含<strong>公钥Pub</strong>的证书给客户端（对应的<strong>私钥Private</strong>保存在服务器不公开）</li><li>客户端收到证书，校验<strong>证书的合法性</strong>（包括证书的有效期，证书域名，请求域名，数字签名等），保证证书没有被篡改</li><li>客户端生成一个用于对称加密的<strong>随机key</strong>，并用证书内的<strong>公钥Pub</strong>进行解密，发送给服务端</li><li>服务端收到<strong>随机key</strong>的密文，使用<strong>公钥Pub</strong>对应的<strong>私钥Private</strong>解密得到客户端发送的<strong>随机key</strong></li><li>服务端使用客户端发送的<strong>随机key</strong>对需要传输的HTTP数据进行对称加密，将密文返回客户端</li><li>客户端使用<strong>随机key</strong>对称解密密文，得到HTTP数据明文</li><li>后续的HTTPS<strong>传输数据</strong>都使用交换好的<strong>随机key</strong>进行对称加解密保证了数据的安全</li></ul><h5 id="（2）HTTPS通信流程图"><a href="#（2）HTTPS通信流程图" class="headerlink" title="（2）HTTPS通信流程图"></a>（2）HTTPS通信流程图</h5><p>HTTPS握手过程即TCP三次握手 + TLS握手</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171537560.png" alt="img"></p><p>详细的TLS握手流程如下，其与<strong>HTTPS加解密的流程</strong>大致<strong>对应</strong>，但更侧重于TLS握手的概念</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171621720.png" alt="preview"></p><ul><li><p>客户端发送<strong>clienthello</strong>消息：客户端发送<strong>clienthello</strong>消息发起握手请求，该消息包含了客户端支持的<strong>TLS版本号</strong>和<strong>密码组合</strong>以及一个<strong>client random</strong>随机字符串，需要约定的密码组合如下</p><ol><li>握手期间所使用的的密钥交换和认证算法 (最常用的是 RSA 算法)</li><li>加密算法 (用于握手完成后的对称加密，常用的有 AES、3DES等)</li><li>信息摘要算法 (常用的有 SHA-256、SHA-1 和 MD5 等)</li></ol></li><li><p>服务端发送<strong>serverhello</strong>消息：服务器发送<strong>serverhello</strong>消息对客户端进行回应，该消息包含<strong>数字证书</strong>，服务器选择的<strong>密码组合</strong>和<strong>server random</strong>随机字符串</p></li><li><p>客户端验证<strong>数字证书</strong>：客户端对服务器发来的证书进行验证，确保对方的合法身份</p><ol><li><p>检查数字签名（前面有详细的讲解，<strong>数字签名</strong>即服务器对证书内容进行<strong>信息摘要计算</strong>后再用<strong>私钥</strong>加密的结果）</p></li><li><p>验证证书链（<strong>证书链</strong>也称为证书路径，用于认证实体合法身份的证书列表，可以验证服务器的合法身份，也可以保证根证书的安全）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171645010.png" alt="image-20211017164519690"></p></li><li><p>检查证书的有效期</p></li><li><p>检查证书的撤回状态 (撤回代表证书已失效)</p></li></ol></li><li><p>客户端发送<strong>premaster secret字符串</strong>密文：客户端生成随机字符串<strong>premaster secret</strong>（预主密钥），并用<strong>公钥</strong>进行加密发送给服务器，只有服务器的私钥可以解开</p></li><li><p>服务器解密<strong>premaster secret</strong>：服务器使用私钥解密<strong>premaster secret字符串</strong></p></li><li><p>客户端服务端生成<strong>共享密钥</strong>：客户端和服务器均使用 <strong>client random</strong>，<strong>server random</strong> 和 <strong>premaster secret</strong>，并通过相同的算法生成相同的共享密钥 <strong>KEY</strong></p></li><li><p>客户端就绪：客户端发送经过<strong>共享密钥KEY</strong>加密过的<strong>finished</strong>信号</p></li><li><p>服务端就绪：服务端发送经过<strong>共享密钥KEY</strong>加密过的<strong>finished</strong>信号</p></li><li><p>达成安全通信：握手完成，双方使用<strong>共享密钥KEY</strong>对称加密进行安全通信</p></li></ul><h3 id="HTTP-与-HTTPS对比"><a href="#HTTP-与-HTTPS对比" class="headerlink" title="HTTP 与 HTTPS对比"></a>HTTP 与 HTTPS对比</h3><h4 id="1-HTTPS与HTTP基本区别"><a href="#1-HTTPS与HTTP基本区别" class="headerlink" title="1.HTTPS与HTTP基本区别"></a>1.HTTPS与HTTP基本区别</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171931223.png!large" alt="img"></p><ul><li>HTTP 是<strong>超文本传输协议</strong>，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 <strong>SSL/TLS 安全协议</strong>，使得报文能够加密传输</li><li>HTTP 连接建立相对简单， <strong>TCP 三次握手</strong>之后便可进行 HTTP 的报文传输。而 HTTPS 在 <strong>TCP 三次握手</strong>之后，还需进行 <strong>SSL/TLS 的握手过程</strong>，才可进入加密报文传输</li><li>HTTP 的端口号是 <strong>80</strong>，HTTPS 的端口号是 <strong>443</strong></li><li>HTTPS 协议需要向 CA（证书权威机构）<strong>申请数字证书</strong>，来保证服务器的身份是可信的</li></ul><h4 id="2-HTTP与HTTPS网络模型"><a href="#2-HTTP与HTTPS网络模型" class="headerlink" title="2.HTTP与HTTPS网络模型"></a>2.HTTP与HTTPS网络模型</h4><h5 id="（1）OSI-七层网络模型"><a href="#（1）OSI-七层网络模型" class="headerlink" title="（1）OSI 七层网络模型"></a>（1）OSI 七层网络模型</h5><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="img" style="zoom: 80%;"><h5 id="（2）TCP-IP五层网络模型"><a href="#（2）TCP-IP五层网络模型" class="headerlink" title="（2）TCP/IP五层网络模型"></a>（2）TCP/IP五层网络模型</h5><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" alt="img" style="zoom:80%;"><p>TCP/IP网络模型着眼于<strong>传输过程</strong>，于是将应用层，表示层，会话层视为<strong>应用层</strong></p><p>也有分为四层的TCP/IP网络模型，将<strong>数据链路层和物理层都表示为网络接口层</strong></p><h5 id="（3）OSI七层模型与TCP-IP五层模型对比"><a href="#（3）OSI七层模型与TCP-IP五层模型对比" class="headerlink" title="（3）OSI七层模型与TCP/IP五层模型对比"></a>（3）OSI七层模型与TCP/IP五层模型对比</h5><p>各层设备：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171945314.png" alt="img"></p><p>各层协议：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171945281.png" alt="img"></p><h5 id="（4）HTTP与HTTPS网络模型"><a href="#（4）HTTP与HTTPS网络模型" class="headerlink" title="（4）HTTP与HTTPS网络模型"></a>（4）HTTP与HTTPS网络模型</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110171950558.png" alt="image-20211017195034373"></p><h4 id="3-HTTPS相比HTTP的升级"><a href="#3-HTTPS相比HTTP的升级" class="headerlink" title="3.HTTPS相比HTTP的升级"></a>3.HTTPS相比HTTP的升级</h4><img src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210613103539-https-essence.png" alt="image.png" style="zoom: 50%;"><h5 id="（1）HTTP的安全风险"><a href="#（1）HTTP的安全风险" class="headerlink" title="（1）HTTP的安全风险"></a>（1）HTTP的安全风险</h5><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容</li><li><strong>篡改风险</strong>，比如强制入垃圾广告，视觉污染</li><li><strong>冒充风险</strong>，比如一些仿真的钓鱼网站</li></ul><h5 id="（2）HTTPS解决方案"><a href="#（2）HTTPS解决方案" class="headerlink" title="（2）HTTPS解决方案"></a>（2）HTTPS解决方案</h5><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的<strong>「指纹」</strong>，指纹用于校验数据的完整性，解决了篡改的风险</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202110172010735.webp&quot; alt=&quot;Oh the fun of HTTP-based applications&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于HTTP应用程序的乐趣，but…&lt;/p&gt;
 &lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202208300729665.jpeg&quot; style=&quot;zoom:20%;&quot;&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|一个数据包的网络之旅</title>
    <link href="https://autovy.github.io/2021/10/13/DevPrinciple/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%97%85/"/>
    <id>https://autovy.github.io/2021/10/13/DevPrinciple/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%97%85/</id>
    <published>2021-10-13T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131214746.webp" alt="When the internet stops working! "></p><p>本文紧接上文，聚焦于<strong>网络线程</strong>连接并请求主机直至获得<strong>响应报文</strong>这个过程，主要研究一个<strong>数据包</strong>的网络之旅</p><span id="more"></span><p>整个过程如下图所示：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130822302.png" alt="image-20211013082245766"></p><p>参考资料：户根勤《网络是怎么连接的》</p><h3 id="浏览器生成消息"><a href="#浏览器生成消息" class="headerlink" title="浏览器生成消息"></a>浏览器生成消息</h3><h4 id="1-生成HTTP请求消息"><a href="#1-生成HTTP请求消息" class="headerlink" title="1.生成HTTP请求消息"></a>1.生成HTTP请求消息</h4><p>浏览器的第一步工作就是要对URL进行解析，并生成发送WEB服务器的请求信息</p><h5 id="（1）URL解析"><a href="#（1）URL解析" class="headerlink" title="（1）URL解析"></a>（1）URL解析</h5><ul><li>URL各个部分的含义：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082014448.png" alt="image-20211008201443231"></p><ul><li>对URL进行解析从而定位到Web服务器下对应的目录：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082017786.png" alt="image-20211008201702549"></p><p>我们常见的url中很多都是没有文件名的，例如<a href="https://www.baidu.com，这种情况往往是对文件名进行了省略，web服务器有默认指向的文件如index.html等，例如https://www.baidu.com/index.html">https://www.baidu.com，这种情况往往是对文件名进行了省略，web服务器有默认指向的文件如index.html等，例如https://www.baidu.com/index.html</a></p><h5 id="（2）HTTP请求消息生成"><a href="#（2）HTTP请求消息生成" class="headerlink" title="（2）HTTP请求消息生成"></a>（2）HTTP请求消息生成</h5><p>对URL进行解析后，浏览器确定了Web服务器和文件名，然后根据这些信息生成HTTP请求消息</p><ul><li>HTTP请求基本结构：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082026183.png" alt="image-20211008202601682"></p><ul><li>请求方法：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082038757.png" alt="img"></p><ul><li>请求报文：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082034679.png" alt="image-20211008203440385"></p><ul><li><p>HTTP状态码：</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110172023742.png" alt="image-20211008203622266" style="zoom:80%;"></li></ul><ul><li>响应报文：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082035607.png" alt="image-20211008203518461"></p><h4 id="2-DNS域名解析"><a href="#2-DNS域名解析" class="headerlink" title="2.DNS域名解析"></a>2.DNS域名解析</h4><p>通过浏览器解析URL并生成HTTP消息后，还需要查询服务器<strong>域名</strong>对应的<strong>IP</strong>地址，才能找到消息发送对象的地址位置</p><p><strong>DNS服务器</strong>就是专门用来保存WEB服务器域名与IP对应关系的服务器</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082113224.png" alt="image-20211008211346869"></p><h5 id="（1）IP地址知识"><a href="#（1）IP地址知识" class="headerlink" title="（1）IP地址知识"></a>（1）IP地址知识</h5><ul><li>IP地址结构</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082053217.png" alt="image-20211008205323963"></p><p>子网掩码表示IP地址中网络号与主机号的分界，子网掩码为1的部分为<strong>网络号</strong>，子网掩码为0的部分为<strong>主机号</strong></p><p>当主机号部分的比特全为0时表示整个子网（而不是某台设备）全为1表示向子网所以设备发送</p><ul><li>IP地址表示方法</li></ul><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110172023054.png" alt="image-20211008205140338" style="zoom: 80%;"><h5 id="（2）域名层级关系"><a href="#（2）域名层级关系" class="headerlink" title="（2）域名层级关系"></a>（2）域名层级关系</h5><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082116997.png" alt="img"></p><p>例如<a href="http://www.google.cn（上香）：">www.google.cn（上香）：</a></p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（cn）</li><li>权威 DNS 服务器（google.cn）</li><li>而<code>www</code> 是主机名 随意填写 域名解析的时候填写<strong>主机记录</strong>和<strong>记录值</strong> </li></ul><h5 id="（3）域名解析工作流程"><a href="#（3）域名解析工作流程" class="headerlink" title="（3）域名解析工作流程"></a>（3）域名解析工作流程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082129029.png" alt="image-20211008212953361"></p><ul><li>本地DNS服务器（离客户端最近的DNS服务器）运行的是<strong>递归查询</strong>：对客户端负责到底，不断去询问查找可以解析域名的服务器</li><li>其他DNS服务器运行的是<strong>迭代查询</strong>：奉行踢皮球原则，不主动询问其他服务器，而是把知道域名对应关系的服务器信息告诉给本地域名服务器</li></ul><h5 id="（4）域名解析内部原理"><a href="#（4）域名解析内部原理" class="headerlink" title="（4）域名解析内部原理"></a>（4）域名解析内部原理</h5><p>域名解析请求DNS服务器，与浏览器请求远程web服务器有类似的地方，后面含义再详细讲Socker库和协议栈</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110082104351.png" alt="image-20211008210454836"></p><h3 id="用电信号传输TCP-IP数据"><a href="#用电信号传输TCP-IP数据" class="headerlink" title="用电信号传输TCP/IP数据"></a>用电信号传输TCP/IP数据</h3><p>协议分层模型：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090830845.jpeg" alt="OSI协议模型、TCP/IP协议模型"></p><p>TCP/IP数据包封装：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090853102.png" alt="TCP/IP数据包的封装"></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）</p><p>通信操作中使用的控制信息分为两类：</p><ul><li>头部中记录的信息（即加载数据包前的控制信息）</li><li>套接字（协议栈中的内存空间）中记录的信息</li></ul><h4 id="1-委托协议栈发送消息"><a href="#1-委托协议栈发送消息" class="headerlink" title="1.委托协议栈发送消息"></a>1.委托协议栈发送消息</h4><p>通过DNS获取IP后，就可以把HTTP的传输工作交给<strong>操作系统</strong>中的<strong>协议栈</strong></p><p>委托的结果是：<strong>协议栈</strong>之间连接了一条数据通道，数据包能沿着这条通道流动（<strong>套接字</strong>则可以视为管道的出入口，<strong>套接字</strong>的实体就是通信控制信息）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090819495.png" alt="image-20211009081901393"></p><h5 id="（1）套接字结构"><a href="#（1）套接字结构" class="headerlink" title="（1）套接字结构"></a>（1）套接字结构</h5><p>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于<strong>控制通信操作的控制信息</strong>，我们可以认为这些控制信息就是套接字的实体</p><p>套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用（协议栈是根据套接字中记录的控制信息来工作的）</p><p>套接字内容查看：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090911172.png" alt="image-20211009091135737"></p><h5 id="（2）TCP-IP-软件分层结构"><a href="#（2）TCP-IP-软件分层结构" class="headerlink" title="（2）TCP/IP 软件分层结构"></a>（2）TCP/IP 软件分层结构</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090805877.png" alt="image-20211009080517915" style="zoom:80%;"><h5 id="（3）Socket库"><a href="#（3）Socket库" class="headerlink" title="（3）Socket库"></a>（3）Socket库</h5><p>浏览器通过调用<strong>Socket</strong>库，委托协议栈来工作</p><p>向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket 库中的程序组件：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090811908.png" alt="image-20211009081135594"></p><ul><li>创建套接字（创建套接字阶段）</li><li>将管道连接到服务器端的套接字上（连接阶段）</li><li>收发数据（通信阶段）</li><li>断开管道并删除套接字（断开阶段）</li></ul><h5 id="（4）TCP与UDP协议"><a href="#（4）TCP与UDP协议" class="headerlink" title="（4）TCP与UDP协议"></a>（4）TCP与UDP协议</h5><p>TCP和UDP协议，接收应用层的委托指向收发数据的操作</p><ul><li>TCP和UDP协议的运用：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090832758.jpeg" alt="TCP/UDP常见应用"></p><ul><li>TCP/UDP比较：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p><p>咳咳，正经详细的比较如下：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131209573.png" alt="image-20211013120922107"></p><ul><li>TCP/UDP编程模型</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110090836254.jpeg" alt="TCP/UDP编程模型"></p><h5 id="（5）IP协议"><a href="#（5）IP协议" class="headerlink" title="（5）IP协议"></a>（5）IP协议</h5><p>在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议：</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作</p><h4 id="2-TCP可靠传输"><a href="#2-TCP可靠传输" class="headerlink" title="2.TCP可靠传输"></a>2.TCP可靠传输</h4><p>参考资料：<a href="https://www.eet-china.com/mp/a44399.html">TCP三次握手</a></p><h5 id="（1）TCP包头格式"><a href="#（1）TCP包头格式" class="headerlink" title="（1）TCP包头格式"></a>（1）TCP包头格式</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110091935607.png" alt="img"></p><ul><li><p>源端口号：发送网络包的程序的端口号</p></li><li><p>目标端口号： 网络包的接收方程序的端口号</p></li><li><p>序号：<strong>发送方告知接收方</strong>，该网络包发送的数据相当于所有发送数据的第几个字节</p></li><li><p>ACK 号（确认号）：<strong>接收方告知发送方</strong>，接收方已经收到了所有数据的第几个字节</p></li><li><p>数据偏移量（首部长度）： 表示数据部分的起始位置，也可以认为表示头部的长度</p></li><li><p>保留：该字段为保留，现在未使用</p></li><li><p>控制位（状态位）：该字段中的每个比特分别表示以下通信控制含义</p><ul><li>URG：表示紧急指针字段有效</li><li>ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></li><li>PSH：表示通过flush 操作发送的数据</li><li>RST：<strong>强制断开</strong>连接，用于异常中断的情况</li><li>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作</li><li>FIN：表示<strong>断开</strong>连接</li></ul></li><li><p>窗口大小：接收方告知发送方窗口大小（窗口大小即缓存大小，标识当前处理能力，用于<strong>流量控制</strong>，<strong>拥塞控制</strong>）</p></li><li><p>校验和：用来检查是否出现错误</p></li><li><p>紧急指针：表示应紧急处理的数据位置</p></li><li><p>可选字段：除了上面的固定头部字段之外，还可以添加可选字段，但除了连接操作之外，很少使用可选字段</p></li></ul><h5 id="（2）TCP三次握手"><a href="#（2）TCP三次握手" class="headerlink" title="（2）TCP三次握手"></a>（2）TCP三次握手</h5><p>TCP三次握手其实就是<strong>建立一个TCP连接</strong>，客户端和服务器之间需要<strong>3个数据包</strong>，握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110091957945.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></p><ul><li>初始状态下，客户端和服务端都处在<strong>CLOSED</strong>状态，先是服务端主动监听某个端口，处于<strong>LISTEN</strong>状态</li><li>第一次握手：客户端发送<strong>SYN</strong>报文，并进入<strong>SYN-SENT</strong>状态，等待服务器确认</li><li>第二次握手：服务器收到<strong>SYN</strong>报文后，需要向客户端发送<strong>ACK</strong>确认<strong>收到</strong>的报文；同时服务端也向客户端发送一个<strong>SYN报文</strong>（也就是说服务端向客户端发送了<strong>SYN+ACK</strong>报文），然后服务端进入<strong>SYN_RCVD</strong>状态</li><li>第三次握手：客户端收到<strong>SYN+ACK</strong>报文后，向服务端发送<strong>ACK</strong>确认<strong>收到</strong>的报文，客户端进入<strong>ESTABLISHED</strong>状态； 服务端收到客户端的<strong>ACK</strong>包后也会进入<strong>ESTABLISHED</strong>状态，完成三次握手</li></ul><p>三次握手的本质是——客户端和服务器通过<strong>两对SYN-ACK报文</strong>互相确认能力正不正常</p><p>每次SYN发送一个随机数<strong>n</strong>（seq=n），则ACK需要返回<strong>n+1</strong>（ack=n+1）</p><h5 id="（3）TCP连接状态查看"><a href="#（3）TCP连接状态查看" class="headerlink" title="（3）TCP连接状态查看"></a>（3）TCP连接状态查看</h5><p>在Linux系统可以通过<code>netstat -napt</code>命令查看TCP连接状态</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110092029731.png" alt="img"></p><h5 id="（4）TCP分割数据"><a href="#（4）TCP分割数据" class="headerlink" title="（4）TCP分割数据"></a>（4）TCP分割数据</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110092031256.png" alt="image-20211009203103835"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110092036185.png" alt="image-20211009203651137"></p><p>HTTP请求消息比较长，超过MSS长度，TCP就会把HTTP消息的数据拆解成一块块的数据发送，数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中</p><h5 id="（5）TCP报文生成"><a href="#（5）TCP报文生成" class="headerlink" title="（5）TCP报文生成"></a>（5）TCP报文生成</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110092037127.jpeg" alt="img"></p><p>TCP 协议里面的两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>）</p><p>TCP报文即为TCP头部+HTTP头部+数据，组装好后交给下面的网络层（IP）处理</p><h5 id="（6）TCP四次挥手"><a href="#（6）TCP四次挥手" class="headerlink" title="（6）TCP四次挥手"></a>（6）TCP四次挥手</h5><p>当我们的应用不再需要数据通信，就会发起断开TCP连接，建立一个连接需要<strong>三次握手</strong>，而终止一个连接需要经过<strong>四次挥手</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111551532.png" alt="img"></p><p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong>；    FIN：表示<strong>断开</strong>连接</p><ul><li>第一次挥手：客户端发起<strong>FIN</strong>包，客户端进入<strong>FIN_WAIT_1</strong>状态（虽然FIN包不携带数据，也需要消耗一个序号u）</li><li>第二次挥手：服务端收到<strong>FIN</strong>包，发出确认包<strong>ACK</strong>（ack=u+1），并带上自己的序号seq=v，服务端进入<strong>CLOSE_WAIT</strong>状态（这个时候客户端仍需要接收服务器发送的数据）；客户端接收到服务端发送的<strong>ACK</strong>后，进入<strong>FIN_WAIT_2</strong>状态</li><li>第三次挥手：服务端数据发送完毕后，向客户端发送<strong>FIN</strong>包（seq=w，ack=u+1），<strong>半连接状态</strong>下服务器可能又发送一些数据，服务端此时进入<strong>LAST_ACK</strong>状态</li><li>第四次挥手：客户端收到服务端的<strong>FIN</strong>包后，发出确认包ACK（ACK=1， ack=w+1），此时客户端进入<strong>TIME_WAIT</strong>状态；服务端收到客户端确认包后进入<strong>CLOSED</strong>状态，而客户端需要等待2MSL后才进入<strong>CLOSED</strong>状态</li></ul><p>四次挥手的本质是——客户端和服务器通过<strong>两对FIN-ACK报文</strong>通知对方自己要关闭了</p><p>三次握手中，在第二次握手时，接收端将一个<strong>ACK</strong>包和一个<strong>SYN</strong>包合并一起发送，所以减少了一次包的发送</p><p>四次挥手中，在主动关闭方（客户端）发送FIN包后，接收方（服务端）可能还要发送数据，不能立即关闭数据通道，所以服务端要先确认ACK，然后等到自己把数据发无可发后再发送<strong>FIN</strong>包</p><h4 id="3-IP远程定位"><a href="#3-IP远程定位" class="headerlink" title="3.IP远程定位"></a>3.IP远程定位</h4><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象</p><h5 id="（1）IP包头格式"><a href="#（1）IP包头格式" class="headerlink" title="（1）IP包头格式"></a>（1）IP包头格式</h5><p>参考资料：<a href="https://www.malaoshi.top/show_1EF2boBn83hd.html">IP报头格式</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111650792.png" alt="img"></p><ul><li>版本号（Version）：标明了<strong>IP 协议的版本号</strong>，目前的协议版本号为4，下一代IP 协议的版本号为6</li><li>首部长度：指 <strong>IP 包头部长度</strong>，占4 位</li><li>区分类型（服务类型）：包括一个3 位的优先权字段（<strong>COS</strong>，Class of Service），4 位<strong>TOS</strong> 字段和1 位未用位。4 位TOS 分别代表最小时延、最大吞吐量、最高可靠性和最小费用</li><li>总长度：是整个<strong>IP 数据报长度</strong>，包括数据部分</li><li>标识：唯一的标识主机发送的每一份数据报，通常每发送一份报文它的值就会加1</li><li>Flag：3bite 它是用来<strong>标志数据包是否分段</strong>，其中包含<strong>DF（do not fragment）</strong>和<strong>MF(more fragment)</strong>，当DF的值为1时，则MF的值必为0，DF为1，则说明数据包有分段。同样可以知道当MF为1时，则DF为0，这表示的是数据包没有分段。当然也有可能MF和DF都为0的</li><li>Frag offset：<strong>段偏移</strong> 15bite 用于<strong>描述此分段在数据包中的位置</strong></li><li>生存时间：Time To Live（TTL），设置了数据包可以经过的 <strong>路由器数目</strong>。一旦经过一个路由器，TTL 值就会减1，当该字段值为0 时，数据包将被丢弃</li><li>协议：指示应当把这个数据包发往更高层的协议，<strong>TCP</strong> 协议的协议号为 <strong>6</strong>，<strong>UDP</strong> 协议的协议号为<strong>17</strong></li><li>报头校验和：计算IP 头部的校验和，<strong>检查报文头部的完整性</strong></li><li>源IP 地址：标识数据包的<strong>源端设备</strong>（即客户端输出的IP地址）</li><li>目的IP 地址：标识数据包的<strong>目的端设备</strong>（即通过DNS域名解析得到的WEB服务器IP）</li><li>IP选项：一般格式为1个字节的代码，1个字节的长度，1个字节的指针，指针的值从1开始计数，指向IP选项的内容，一般其值为4(跳过了前面的代码&amp;长度&amp;指针的三个字节)，长度包括前面3个字节在内的整个IP选项，最大值为40</li></ul><h5 id="（2）IP地址选择"><a href="#（2）IP地址选择" class="headerlink" title="（2）IP地址选择"></a>（2）IP地址选择</h5><p>客户端有多个网卡时，在填写源地址IP时就要根据<strong>路由表</strong>规则来判定应该使用哪一块网卡来发送包</p><p>在lInux系统，我们使用<code>route -n</code>，在windows系统则用 <code>route print</code>查看路由表</p><p>利用子网掩码与路由表判断源地址：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111928914.jpeg" alt="img"></p><p>假设目的IP 地址（web服务器）是<strong>192.168.10.200</strong>，与各条目的<strong>子网掩码</strong>做<strong>与运算</strong>，计算出IP和条目的<strong>网络目标IP</strong>（destination）匹配，则选择该条目的网卡作为IP包头的源地址</p><p>第三条目的目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器（Gateway即路由器的IP）</p><h5 id="（3）IP报文生成"><a href="#（3）IP报文生成" class="headerlink" title="（3）IP报文生成"></a>（3）IP报文生成</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111945739.jpeg" alt="img"></p><p>IP报文即为IP头部+TCP头部+HTTP头部+数据，组装好后IP模块还要进一步处理</p><h4 id="4-MAC传输"><a href="#4-MAC传输" class="headerlink" title="4.MAC传输"></a>4.MAC传输</h4><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong></p><h5 id="（1）MAC包头格式"><a href="#（1）MAC包头格式" class="headerlink" title="（1）MAC包头格式"></a>（1）MAC包头格式</h5><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的MAC 地址等信息</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111958982.png" alt="img"></p><ul><li>接收方MAC 地址：网络包接收方的MAC 地址，在<strong>局域网</strong>中使用这一地址来传输网络包</li><li>发送方MAC 地址：网络包发送方的MAC 地址，接收方通过它来判断是谁发送了这个包</li><li>以太类型：使用的<strong>协议类型</strong>，下面是一些常见的类型，一般在TCP/IP 通信中只使用0800 和0806这两种<ol><li>0000-05DC：IEEE 802.3</li><li>0800　　 ：IP 协议</li><li>0806　 ：ARP 协议</li><li>86DD　　　 IPv6</li></ol></li></ul><h5 id="（2）MAC地址确认"><a href="#（2）MAC地址确认" class="headerlink" title="（2）MAC地址确认"></a>（2）MAC地址确认</h5><p><strong>发送方</strong>：</p><p>发送方的MAC地址获取比较简单，MAC地址在网卡生产时写入<strong>ROM</strong>中的，只需将其读取出来放到MAC头部即可</p><p><strong>接收方</strong>：</p><p>发送IP网络包需要告诉以太网对方的MAC地址，IP 模块根<strong>据路由表Gateway</strong> 栏的内容判断应该把包发送给谁，然后在利用<code>ARP</code> 协议通过<strong>广播</strong>的方法帮我们找到路由器（目标设备与发送方在同一子网中）的 MAC 地址</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110112024487.png" alt="image-20211011202440537"></p><p>后续操作系统会将ARP的查询结果缓存在<strong>ARP缓存</strong>的内存空间内，可以通过<code>arp -a</code>命令进行查看</p><h5 id="（3）MAC报文生成"><a href="#（3）MAC报文生成" class="headerlink" title="（3）MAC报文生成"></a>（3）MAC报文生成</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110112029433.jpeg" alt="img"></p><p>MAC报文即为MAC头部+IP头部+TCP头部+HTTP头部+数据，至此网络包终于完整了，可以从本设备的大门（网卡）走出去开始真正的网络之旅</p><h4 id="5-网卡出口"><a href="#5-网卡出口" class="headerlink" title="5.网卡出口"></a>5.网卡出口</h4><h5 id="（1）网卡处理IP网络包"><a href="#（1）网卡处理IP网络包" class="headerlink" title="（1）网卡处理IP网络包"></a>（1）网卡处理IP网络包</h5><p>IP生成的<strong>网络包</strong>只是放在内存中的一串二进制数字信息，所以在其开始网络旅程之前还要经过<strong>网卡</strong>将<strong>数字信息转换为电信号</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110112051633.png" alt="img"></p><p>网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110112054908.png" alt="image-20211011205426437"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡将网络包转换为电信号，通过网线发送出去</p><h5 id="（2）以太网"><a href="#（2）以太网" class="headerlink" title="（2）以太网"></a>（2）以太网</h5><p>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，它可以让信号通过网线流过整个网络，最终到达所有的设备</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110121936474.png" alt="image-20211012193540441"></p><p>以太网的三个性质：</p><ul><li>包发送到MAC 头部的接收方MAC 地址代表的目的地</li><li>用发送方MAC地址识别发送方</li><li>用以太类型识别包的内容</li></ul><h5 id="（3）网络包传输"><a href="#（3）网络包传输" class="headerlink" title="（3）网络包传输"></a>（3）网络包传输</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110111956850.png" alt="image-20211011195613299"></p><p>经过网卡处理后的网络包会发往<strong>最近的网络转换设备</strong>，当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里</p><p>这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向</p><p>网络中有<strong>路由器</strong>和<strong>集线器</strong>两种不同的转发设备，它们在传输网络包时有着各自的分工</p><p>（1）路由器根据目标地址判断下一个路由器的位置（基于IP规则）</p><p>（2）集线器在子网中将网络包传输到下一个路由（以太网规则）</p><h3 id="从网线到网络设备"><a href="#从网线到网络设备" class="headerlink" title="从网线到网络设备"></a>从网线到网络设备</h3><p>参考资料：<a href="https://www.bilibili.com/video/BV1yt411d7Rd/">集线器，交换机，路由器的区别</a></p><p>网络数据包的网络之旅：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110121910213.png" alt="image-20211012191019888"></p><p>各设备处理数据包的方式：</p><ul><li><p>集线器：构建局域网的设备，它会将信号复制并发向连接同一个集线器（即同一局域网）的全部端口（广播）</p></li><li><p>交换机：构建局域网的设备，运行在MAC层，它会将信号发向指定MAC的端口</p></li><li><p>路由器：将局域网连接上互联网的设备，运行在IP层，路由器可以分析网络包的目标地址IP，如果该IP在自己负责的网络内则接收，如果不在的话就发向其他网络（本质上是一个网络网关）</p></li></ul><h4 id="1-集线器传输"><a href="#1-集线器传输" class="headerlink" title="1.集线器传输"></a>1.集线器传输</h4><p>集线器（Hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备</p><h5 id="（1）网卡与集线器的双绞线连接"><a href="#（1）网卡与集线器的双绞线连接" class="headerlink" title="（1）网卡与集线器的双绞线连接"></a>（1）网卡与集线器的双绞线连接</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110121922490.png" alt="img"></p><p>网线周围的电磁波会产生<strong>噪声</strong>混淆<strong>信号</strong>导致信号的波形发生<strong>失真</strong>，所以用<strong>双绞线</strong>移植噪声</p><h5 id="（2）集线器将信号发往所有线路"><a href="#（2）集线器将信号发往所有线路" class="headerlink" title="（2）集线器将信号发往所有线路"></a>（2）集线器将信号发往所有线路</h5><p>当电信号（网络包经过网卡转换后的形态）到达集线器后，<strong>集线器将信号发送给所有连接在它上面的线路</strong>，会被广播到整个网络中</p><p><strong>集线器</strong>将包发到所有的设备，然后由设备根据接收方MAC 地址来判断应该接收哪些包</p><h4 id="2-交换机包转发"><a href="#2-交换机包转发" class="headerlink" title="2.交换机包转发"></a>2.交换机包转发</h4><p>交换机意为“开关”，是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路</p><p>交换机工作在<strong>MAC层</strong>，也称为<strong>二层网络设备</strong></p><h5 id="（1）交换机包接收操作"><a href="#（1）交换机包接收操作" class="headerlink" title="（1）交换机包接收操作"></a>（1）交换机包接收操作</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110122048818.png" alt="image-20211012204847117"></p><ul><li>电信号进入交换器模块后，<strong>电信号</strong>转换为<strong>数字信号</strong></li><li>通过包末尾的<strong>FCS</strong>校验错误，无误后信号放入缓冲区</li><li>交换机的端口<strong>不具有MAC地址</strong>，所以会将接收到所有的包存放再缓冲区中</li></ul><h5 id="（2）交换机MAC地址查找"><a href="#（2）交换机MAC地址查找" class="headerlink" title="（2）交换机MAC地址查找"></a>（2）交换机MAC地址查找</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110122049533.png" alt="image-20211012204902267"></p><ul><li>包存入的缓冲区后，就需要查询<strong>MAC地址表</strong>找到包的接收发<strong>MAC地址</strong>对应的<strong>端口</strong>，从而准确发送到连接该端口的设备</li><li>如果地址表找不到指定的MAC地址（可能是该地址没有向交换机发送过包，或者这个设备一段时间没有工作导致地址从地址表删除了），就将包复制并发向其他所有的端口（和集线器同样的转发方法），然后<strong>只有相应的接收者才接收包，其他设备会忽略这个包</strong></li><li>如果接受方MAC地址是一个<strong>广播地址</strong>，交换机也会将包复制并发向其他所有的端口</li></ul><h4 id="3-路由器包转发"><a href="#3-路由器包转发" class="headerlink" title="3.路由器包转发"></a>3.路由器包转发</h4><p>经过交换机后，网络包终于走出了子网，再经过路由器这个关口正式进入互联网</p><p>路由器，是连接因特网中各局域网、广域网的设备</p><h5 id="（1）交换机与路由器"><a href="#（1）交换机与路由器" class="headerlink" title="（1）交换机与路由器"></a>（1）交换机与路由器</h5><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址</li></ul><h5 id="（2）路由器基本原理"><a href="#（2）路由器基本原理" class="headerlink" title="（2）路由器基本原理"></a>（2）路由器基本原理</h5><p>路由器的端口具有MAC地址，因此它可以成为以太网的发送方和接收方；同时还具有IP地址，从这个意义上说，它和计算机的网卡是一样的</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的<strong>端口</strong>作为发送方将以太网包发送出去</p><h5 id="（3）路由器包接收操作"><a href="#（3）路由器包接收操作" class="headerlink" title="（3）路由器包接收操作"></a>（3）路由器包接收操作</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110122126261.png" alt="image-20211012212606988"></p><ul><li>电信号到达网线接口部分，路由器模块会将<strong>电信号转成数字信号</strong></li><li>通过包末尾的<strong>FCS</strong>进行错误校验</li><li>检查MAC头部<strong>接收方MAC地址</strong>，如果是发给自己的就放到<strong>接收缓冲区</strong>中，否则就丢弃这个包</li><li>路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃</li></ul><h5 id="（4）路由表查询确认输出端口"><a href="#（4）路由表查询确认输出端口" class="headerlink" title="（4）路由表查询确认输出端口"></a>（4）路由表查询确认输出端口</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110122136962.jpeg" alt="img"></p><p>完成包接收操作后，路由器就会<strong>去掉</strong>MAC头部（MAC头部的作用就是将包送达路由器，接收方 MAC 地址就是路由器端口的 MAC 地址）</p><p> 然后查询<strong>路由表</strong>判断转发目标，如图<code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这里的<strong>路由匹配</strong>与之前讲的<strong>IP地址的选择</strong>一样，即用目标IP与各条目的<strong>子网掩码</strong>做<strong>与运算</strong>，直到找到计算出IP和条目的<strong>网络目标IP</strong>（destination）匹配，则该条目的记录作为转发目标</p><p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」</p><h5 id="（5）路由器包发送操作"><a href="#（5）路由器包发送操作" class="headerlink" title="（5）路由器包发送操作"></a>（5）路由器包发送操作</h5><ul><li><p>路由器包发送操作需要根据<strong>路由表</strong>的<strong>网关列</strong>来判断：</p><ol><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ol></li><li><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址</p></li><li><p>发送方 MAC 地址字段，填写输出端口的 MAC 地址</p></li><li><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去（与计算机的网卡的操作是一致的）</p></li><li><p>经过多个路由器的大接力，层层转发最终到达目的地</p></li></ul><p>在网络包传输的过程中，源 IP 和目标 IP 始终不变，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输</p><h3 id="通过接入网进入互联网内部"><a href="#通过接入网进入互联网内部" class="headerlink" title="通过接入网进入互联网内部*"></a>通过接入网进入互联网内部*</h3><p>（对于这部分我只做简单介绍，详细资料可参考<a href="https://www.tuhd.top/2017/07/12/2017-07-12-4network/">接入网进入互联网内部——探索接入网和网络运营商 </a>）</p><p>网络包出了局域网后通过接入网进入互联网。和局域网一样，互联网也是通过路由器来转发包的，因此我们可以将互联网视为局域网络的放大版</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130828926.png" alt="image-20211013082847731"></p><h4 id="1-ADSL接入网"><a href="#1-ADSL接入网" class="headerlink" title="1.ADSL接入网"></a>1.ADSL接入网</h4><p>连接用户与互联网的接入网，所谓接入网，就是指连接互联网与家庭、公司网络的通信线路</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130833348.png" alt="image-20211013083304491"></p><h4 id="2-光纤接入网"><a href="#2-光纤接入网" class="headerlink" title="2.光纤接入网"></a>2.光纤接入网</h4><p>另外一种接入网技术光纤接入网（FTTH），通过光纤分路来降低传输成本</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130840845.png" alt="image-20211013084030599"></p><p>用户发送的网络包会通过ADSL 和FTTH 等接入网到达运营商的BAS，通过ADSL 接入网和BAS 之后，网络包就到达了互联网内部</p><h4 id="3-接入网中使用的PPP和隧道"><a href="#3-接入网中使用的PPP和隧道" class="headerlink" title="3.接入网中使用的PPP和隧道"></a>3.接入网中使用的PPP和隧道</h4><p>ADSL和FTTH接入网中，都需要先输入用户名和密码，而BAS就是登录操作的窗口，而<strong>BAS</strong>使用<strong>PPPoE</strong>（以太网点对点协议，是将PPP 消息装入以太网包进行传输的方式）来实现这个功能</p><h5 id="（1）PPPE协议"><a href="#（1）PPPE协议" class="headerlink" title="（1）PPPE协议"></a>（1）PPPE协议</h5><p>拨号上网中的PPP：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130849163.png" alt="image-20211013084900996"></p><p>ASDL中的PPP：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130849724.png" alt="image-20211013084922601"></p><p>FTTH中的PPP：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130849315.png" alt="image-20211013084954950"></p><h5 id="（2）隧道"><a href="#（2）隧道" class="headerlink" title="（2）隧道"></a>（2）隧道</h5><p><strong>BAS</strong> 除了作为用户认证的窗口之外，还可以使用<strong>隧道</strong>方式来传输网络<br>包，通过隧道网络包被发向运营商</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130854580.png" alt="image-20211013085445301"></p><h4 id="4-网络运营商内部"><a href="#4-网络运营商内部" class="headerlink" title="4.网络运营商内部"></a>4.网络运营商内部</h4><p>网络包通过接入网之后，到达运营商POP（Point of Presense，接入点）的路由器</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130859348.png" alt="image-20211013085913670"></p><p>NOC是运营商的核心设备，从POP 传来的网络包都会集中到这里，<br>并从这里被转发到离目的地更近的POP，或者是转发到其他的运营商</p><h4 id="5-跨越运营商的网络包"><a href="#5-跨越运营商的网络包" class="headerlink" title="5.跨越运营商的网络包"></a>5.跨越运营商的网络包</h4><p>无论最终目的地是否属于同一家运营商，都可以从路由表中查到，因此只要一次接一次按照路由表中的目标地址来转发包，最终一定可以到达Web服务器所在的POP</p><p>运营商之间的路由信息交换：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130902623.png" alt="image-20211013090254375"></p><p>通过连接到中心设备IX的方式来减少线路数量：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130904552.png" alt="image-20211013090415545"></p><h3 id="进入服务端"><a href="#进入服务端" class="headerlink" title="进入服务端"></a>进入服务端</h3><p>通过互联网，我们可以到达旅途终点的大门前，我们的目标服务器就在这个局域网中</p><h5 id="1-服务端所在地"><a href="#1-服务端所在地" class="headerlink" title="1.服务端所在地"></a>1.服务端所在地</h5><p>一般都是（b）这种结构，经过接入网还要通过<strong>防火墙</strong>的<strong>审查</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130909533.png" alt="img"></p><h5 id="2-服务端处理数据包"><a href="#2-服务端处理数据包" class="headerlink" title="2.服务端处理数据包"></a>2.服务端处理数据包</h5><p>请求终于到达了Web 服务器，短短几秒的“漫长旅程”迎来终点</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110130916831.jpeg" alt="img"></p><p>最后服务端一层一层剥开数据包获得HTTP请求，也派出了他的使节（<strong>响应消息</strong>）赶往客户端……</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131159356.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202110131214746.webp&quot; alt=&quot;When the internet stops working! &quot;&gt;&lt;/p&gt;
&lt;p&gt;本文紧接上文，聚焦于&lt;strong&gt;网络线程&lt;/strong&gt;连接并请求主机直至获得&lt;strong&gt;响应报文&lt;/strong&gt;这个过程，主要研究一个&lt;strong&gt;数据包&lt;/strong&gt;的网络之旅&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机网络" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|深入理解浏览器工作原理</title>
    <link href="https://autovy.github.io/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>https://autovy.github.io/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2021-10-07T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110131222149.webp" alt="Internet Explorer"></p><p>浏览器笑话90%都和IE有关，没了IE的浏览器世界总归是少很多乐趣😭</p><span id="more"></span><h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><p>参考资料：<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#disqus_thread">现代网络浏览器幕后揭秘</a></p><h4 id="1-浏览器分层结构"><a href="#1-浏览器分层结构" class="headerlink" title="1.浏览器分层结构"></a>1.浏览器分层结构</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061003492.png" alt="image-20211006094545491"></p><ul><li>User Interface（用户界面）：包括工具栏，地址栏，前进后退按钮，书签等（用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信）</li><li>Brower Engine（浏览器引擎）：在用户界面和渲染引擎之间传送指令</li><li>Rendering Engine（渲染引擎）：负责显示请求的内容（解析HTML和CSS渲染在页面上）</li><li>Networking（网络）：用于网络调用如HTTP请求（其接口与平台无关，并为所有平台提供底层实现）</li><li>JavaScript Interpreter（JavaScript解释器）：用于接解释和执行JavaScript代码</li><li>XML Parser（XML 解析器）：将XML文档解析成文档对象模型树（DOM）</li><li>Display Backend（用户界面后端）：用于绘制基本的窗口小部件，比如组合框和窗口（其接口与平台无关，底层使用了操作系统的用户界面方法）</li><li>Data Persistence（数据持久化）：浏览器内数据库，将各种数据保存在硬盘上（如书签，工具栏，Cookie，缓存等）</li></ul><h4 id="2-浏览器进程架构"><a href="#2-浏览器进程架构" class="headerlink" title="2.浏览器进程架构"></a>2.浏览器进程架构</h4><p>参考资料：<a href="https://segmentfault.com/a/1190000022633988">浏览器工作原理</a></p><h5 id="（1）浏览器多进程"><a href="#（1）浏览器多进程" class="headerlink" title="（1）浏览器多进程"></a>（1）浏览器多进程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061103852.png" alt="image-20211006110300456"></p><p>单进程的浏览器需要处理的事情过多，极度不稳定和安全——如果多个页面共享一个进程，单某个tab页崩溃，将导致同进程中的其他页面也会崩溃，影响用户体验</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061104938.png" alt="image-20211006110439788" style="zoom:67%;"><p>现代浏览器更多采用多进程架构，进程之间不会共享资源和地址空间，所以不会存在太多安全问题，当然，多进程相对于单进程而言，内存等资源的消耗更大</p><h5 id="（2）浏览器主要进程"><a href="#（2）浏览器主要进程" class="headerlink" title="（2）浏览器主要进程"></a>（2）浏览器主要进程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061035469.png" alt="img"></p><ul><li>浏览器进程 (Browser Process)：浏览器主进程（无论打开几个tab，几个弹窗浏览器进程只有一个），负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问</li><li>渲染进程 (Renderer Process)：浏览器渲染进程（Render 进程），即通常说的浏览器内核，负责一个Tab内的显示相关的工作（页面渲染、脚本执行、事件处理），每个 tab 页的打开都会创建一个 Render 进程，并且互不影响</li><li>插件进程 (Plugin Process)：负责控制网页使用到的插件（每种类型的插件对应一个进程，仅当使用该插件时才创建）</li><li>GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务（网页、Chrome 的 UI 界面都选择采用 GPU 来绘制）</li><li>网络进程（Network Process）：主要负责页面的网络资源加载（在以前的架构中是整合进浏览器进程中作为一个线程，本文的后续内容会将网络这一部分视作线程）</li></ul><h5 id="（3）进程模式"><a href="#（3）进程模式" class="headerlink" title="（3）进程模式"></a>（3）进程模式</h5><p>浏览器不同的进程模式会对tab进程做不同的处理：</p><ul><li><strong>Process-per-site *<em>：同一个 *</em>site</strong> 使用一个进程（site即相同注册域名，比如a.baidu.com和b.baidu.com就可以理解为同一个 site）</li><li><strong>Process-per-site-instance</strong> (default) ：同一个 <strong>site-instance</strong> 使用一个进程（site-instance即来自同一站点的连接页面，满足<strong>site</strong>的连接且通过a标签或js代码打开的新页面）</li><li>*<em>Process-per-tab *</em>： 每个 tab 使用一个进程</li><li>*<em>Single process *</em> ：所有 tab 共用一个进程</li></ul><h5 id="（4）进程间关系"><a href="#（4）进程间关系" class="headerlink" title="（4）进程间关系"></a>（4）进程间关系</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061104938.png" alt="image-20211006110439788" style="zoom:67%;"><ul><li>用户在浏览器地址栏输入url，并按下Enter</li><li><strong>浏览器进程</strong>向URL发送请求，获取这个URL的HTML内容并交给<strong>渲染进程</strong></li><li><strong>渲染进程</strong>解析HTML内容，解析遇到网络资源再返回来交给<strong>浏览器进程</strong>进行加载；</li><li><strong>渲染进程</strong>同时还通知<strong>浏览器进程</strong>去启动<strong>插件进程</strong>，执行插件代码</li><li>解析完成后，<strong>渲染进程</strong>将计算得到的数据帧交给<strong>GPU进程</strong>，<strong>GPU进程</strong>将其转换为图像显示到屏幕上</li></ul><h3 id="浏览器工作流程"><a href="#浏览器工作流程" class="headerlink" title="浏览器工作流程"></a>浏览器工作流程</h3><p>从我们再浏览器键入一个URL地址，到最后网页呈现在浏览器上，经过了那些过程？</p><h4 id="1-浏览器页面加载"><a href="#1-浏览器页面加载" class="headerlink" title="1.浏览器页面加载"></a>1.浏览器页面加载</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110070837877.png" alt="image-20211007083755446"></p><p>浏览器进程针对工作的不同有以下的工作线程：</p><ul><li>UI线程：控制浏览器的按钮与输入框</li><li>网络线程：处理网络请求</li><li>存储线程：控制文件访问</li></ul><h5 id="（1）输入处理"><a href="#（1）输入处理" class="headerlink" title="（1）输入处理"></a>（1）输入处理</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061321788.png" alt="处理输入"></p><p>当我们在浏览器的地址栏输入内容按下回车时，<strong>UI 线程</strong>会根据输入内容判断输入内容是<strong>搜索关键字</strong>还是<strong>URL</strong></p><p>如果判定为搜索关键字，则跳转到默认搜索引擎的搜索URL</p><p>如果判定为URL，则开始请求URL</p><h5 id="（2）开始导航"><a href="#（2）开始导航" class="headerlink" title="（2）开始导航"></a>（2）开始导航</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061321242.png" alt="开始导航"></p><p><strong>UI线程将</strong>URL交给网络线程，<strong>网络线程</strong>则负责联系目标主机获取信息（其中发生了DNS域名解析，TLS连接等操作都是计算机网络相关内容）</p><h5 id="（3）读取响应"><a href="#（3）读取响应" class="headerlink" title="（3）读取响应"></a>（3）读取响应</h5><img src="/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20211006133826626.png" alt="image-20211006133826626" style="zoom:80%;"><p><strong>网络线程</strong>接收到目标主机的响应后，解析HTTP响应报文，响应分为header（响应相关信息）和payload（真实数据内容）两部分</p><p>如果状态码为301或302，则需要取得响应头中Location地址，<strong>重新发起请求</strong></p><p>如果状态码为200，则可以进行下面的步骤：</p><p>浏览器根据响应头中的<code>Content-Type</code>来确定相应主体的媒体类型（MIME Type）：如果是text/html时则将相应数据交给<strong>渲染进程</strong>来进行下一步工作（解析HTML内容等），<code>image/png</code>则调用图片渲染器</p><p>读取响应的过程中会有以下的安全机制：</p><ul><li>浏览器并不完全信任<code>Content-Type</code>，所以当收到响应主体（payload）时，网络线程会在必要时检查数据的前几个字节，以确保数据内容与 header 里标识的数据类型（Content-Type）一致。如果不一致，那么就需要进行 MIME 类型嗅探来猜测该数据的类型</li><li>浏览器会进行 <code>Safe Browsing</code>安全检查，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页</li><li>网络线程还会做 <code>CORB（Cross Origin Read Blocking）</code>检查来确定那些敏感的跨站数据不会被发送至渲染进程</li></ul><h5 id="（4）查找渲染进程"><a href="#（4）查找渲染进程" class="headerlink" title="（4）查找渲染进程"></a>（4）查找渲染进程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110061958151.png" alt="查找渲染进程"></p><p><strong>网络线程</strong>确认浏览器可以导航到请求网页后，会通知<strong>UI线程</strong>去查找<strong>渲染进程</strong>进行网页的渲染</p><p>考虑到网络请求获取响应需要时间，<strong>UI线程</strong>可以<strong>并行</strong>查找和启动一个<strong>渲染进程</strong>，当<strong>网络线程</strong>接收到数据时，<strong>渲染进程</strong>就已经准备好了</p><h5 id="（5）确认导航"><a href="#（5）确认导航" class="headerlink" title="（5）确认导航"></a>（5）确认导航</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110062013638.png" alt="提交导航"></p><ul><li>数据和渲染进程都准备了，<strong>浏览器进程</strong>会向<strong>渲染进程</strong>发送IPC消息（进程间通信）来确认导航</li><li><strong>浏览器进程</strong>将数据发送给<strong>渲染进程</strong></li><li><strong>渲染进程</strong>接收到数据后，又发送IPC消息给<strong>浏览器进程</strong>，表明导航已提交，页面开始加载</li><li>地址栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面</li></ul><h5 id="（6）初始化加载完成"><a href="#（6）初始化加载完成" class="headerlink" title="（6）初始化加载完成"></a>（6）初始化加载完成</h5><p>导航提交后，渲染进程开始加载资源及渲染页面（具体<strong>页面渲染原理</strong>见下文），页面渲染完成后，会向浏览器进程发送IPC消息，这时UI线程停止展示tab加载中图标</p><h4 id="2-浏览器页面渲染"><a href="#2-浏览器页面渲染" class="headerlink" title="2.浏览器页面渲染"></a>2.浏览器页面渲染</h4><p>参考资料：</p><p><a href="https://blog.csdn.net/weixin_43816287/article/details/115767313">页面渲染流程</a></p><p><a href="https://juejin.cn/post/6844904020193067015">浏览器页面的渲染流程</a></p><p>浏览器页面渲染步骤：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110070838171.png" alt="image-20211007083830907"></p><p><strong>浏览器进程</strong>把数据交给了<strong>渲染进程</strong>，<strong>渲染进程</strong>将HTML/CSS/JS代码，转化为用户可进行交互的web页面</p><p><strong>渲染进程</strong>包含以下线程：</p><ul><li>一个主线程（main thread）</li><li>多个工作线程（work thread）</li><li>一个合成器线程（compositor thread）</li><li>多个光栅化线程（raster thread）</li></ul><p>浏览器页面渲染进程：</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110062110095.png" style="zoom:67%;"><ul><li>渲染进程将HTML内容转换为能够读懂的<code>DOM树</code>结构</li><li>渲染引擎将CSS样式表转化为浏览器可以理解的<code>styleSheets</code>，计算出DOM节点的样式。</li><li>创建<code>布局树</code>，并计算元素的布局信息</li><li>对布局树进行分层，并生成<code>分层树</code></li><li>为每个图层生成<code>绘制列表</code>，并将其提交到合成线程</li><li>合成线程将图层分成<code>图块</code>，并在<code>光栅化线程池</code>中将图块转换成位图</li><li>合成线程发送绘制图块命令<code>DrawQuad</code>给浏览器进程</li><li>浏览器进程根据DrawQuad消息生成页面，并<code>显示</code>到显示器上</li></ul><h5 id="（1）构建DOM"><a href="#（1）构建DOM" class="headerlink" title="（1）构建DOM"></a>（1）构建DOM</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110062124865.png" alt="在这里插入图片描述"></p><p><strong>渲染进程</strong>接受到导航确认信息后，开始接受来自<strong>浏览器进程</strong>数据（请求响应），渲染进程的<strong>主线程</strong>解析数据化为DOM对象，</p><p>构建DOM过程中：</p><ul><li>子资源加载：解析到图片，CSS，JS脚本等资源，<strong>主线程</strong>逐一交给<strong>浏览器进程</strong>发起请求去获取。为了提升效率，浏览器往往会运行<strong>预加载扫描程序</strong>，如果html中存在<strong>img，link</strong>等标签，预加载扫描程序会把这些请求传递给<strong>浏览器进程</strong>的<strong>网络线程</strong>去下载</li><li>Javascript的下载与执行：解析遇到<code>&lt;script&gt;</code>标签，主线程停止对HTML的解析，而去加载执行JS代码（在<code>&lt;script&gt;</code>标签添加上<strong>async</strong>或<strong>defer</strong>等属性，浏览器会异步加载和执行JS代码，而不会阻塞渲染）</li></ul><h5 id="（2）样式计算"><a href="#（2）样式计算" class="headerlink" title="（2）样式计算"></a>（2）样式计算</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110062125412.png" alt="在这里插入图片描述"></p><ul><li><strong>主线程</strong>在解析页面时，遇到<code>&lt;style&gt;</code>标签或者<code>&lt;link&gt;</code>标签的CSS资源，会加载CSS代码</li><li>根据CSS代码构建styleSheets树</li><li>样式计算规则：继承规则（当前标签的样式继承了其所有父标签的样式），层叠规则（多个样式同时作用于该标签时，进行样式层叠）</li></ul><h5 id="（3）布局"><a href="#（3）布局" class="headerlink" title="（3）布局"></a>（3）布局</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110062125756.png" alt="在这里插入图片描述"></p><ul><li>对DOM树和styleSheets树进行合并，生成render树（布局树），生成<strong>布局树</strong>时浏览器会遍历<strong>DOM树</strong>所有可见的节点添加到布局树中，而不可见的节点会被忽略掉</li><li>渲染进程还需要计算出每个标签对应的<strong>物理位置</strong>并存储在render树中</li></ul><h5 id="（4）分层"><a href="#（4）分层" class="headerlink" title="（4）分层"></a>（4）分层</h5><img src="/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20211007091607012.png" alt="image-20211007091607012"><p>页面上还涉及许多复杂的样式：transform， animation 动画、scroll，z-indexing改变层级等等，浏览器则为这些特殊的节点建立一个对应图层，生成<strong>图层树（LayerTree）</strong>，将这些图层合并在一起，就是一整个页面的样式</p><p>分层规则：</p><ul><li>拥有层叠上下文属性的元素即使用了z-index的元素</li><li>需要剪裁的地方也会被创建为图层（当父容器的宽高不足以撑起子容器的宽高，出现滚动条或者设置父容器为overflow :hode 等等，子容器页面就会被裁剪）</li></ul><h5 id="（5）绘制"><a href="#（5）绘制" class="headerlink" title="（5）绘制"></a>（5）绘制</h5><img src="/2021/10/07/DevPrinciple/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20211007091651791.png" alt="image-20211007091651791" style="zoom:80%;"><p>将图层拆分成一条条指令，逐条执行绘制图形</p><h5 id="（6）分块"><a href="#（6）分块" class="headerlink" title="（6）分块"></a>（6）分块</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110070943457.png" alt="image-20211007094342822"></p><p>当页面内容很长时，页面就会出现滚动条。这时的视口大小有限（在当前屏幕区域能看到的模块就叫视口），在这种情况下要绘制所有图层内容开销太大，所以需要将<strong>图层分成很多图块</strong></p><h5 id="（7）光栅化"><a href="#（7）光栅化" class="headerlink" title="（7）光栅化"></a>（7）光栅化</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110062110095.png" style="zoom:67%;"><ul><li>渲染进程将这些图层分成很多图块后，然后按照<strong>视口附近</strong>的<strong>图块</strong>来通过<strong>光栅化</strong>优先生成位图（即屏幕上的像素），所以图块是<strong>光栅化</strong>执行的最小单位</li><li>当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果</li><li>之前的生成DOM树、styleSheets树、render树（Layout）、分层(Layer)、绘制（Paint）都是在渲染引起的主线程中运行的， 绘制列表记录好绘制顺序和绘制指令的列表后，将其<strong>提交</strong>给渲染引擎中的<strong>合成线程</strong></li><li>合成线程再交给光栅化线程池对图块进行处理</li><li>光栅化过程往往使用GPU来加速生成即快速光栅化，生成的位图保存在GPU内存中</li></ul><h5 id="（8）合成与显示"><a href="#（8）合成与显示" class="headerlink" title="（8）合成与显示"></a>（8）合成与显示</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110071019064.gif" alt="合成的光栅化过程"></p><ul><li>一旦所有图块都被光栅化，<strong>合成线程</strong>就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程</li><li><strong>浏览器进程</strong>里面有一个叫 viz 的组件，用来接收<strong>合成线程</strong>发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上</li></ul><h4 id="3-浏览器页面交互"><a href="#3-浏览器页面交互" class="headerlink" title="3.浏览器页面交互"></a>3.浏览器页面交互</h4><h5 id="（1）浏览器对事件处理"><a href="#（1）浏览器对事件处理" class="headerlink" title="（1）浏览器对事件处理"></a>（1）浏览器对事件处理</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110071102089.png" alt="点击事件从浏览器进程路由到渲染进程"></p><p><strong>浏览器进程</strong>首先接收到事件信息和事件发生的坐标，随后便把信息传递给<strong>渲染进程</strong>，<strong>渲染进程</strong>根据事件发生的坐标找到<strong>目标对象（target）</strong>，然后运行这个<strong>目标对象</strong>的绑定事件对应的<strong>监听函数（listener）</strong></p><h5 id="（2）合成线程接收事件"><a href="#（2）合成线程接收事件" class="headerlink" title="（2）合成线程接收事件"></a>（2）合成线程接收事件</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110071129764.png" alt="非快速滚动区域有用户事件发生"></p><p>合成线程接收事件的情况主要针对<strong>页面滚动</strong>相关的事件，合成线程可以独立于主线程之外通过已光栅化的层创建组合帧</p><p>当渲染进程中的<strong>合成线程</strong>接收到事件信息，要进行以下判定：</p><ul><li>页面合成时，合成器线程会标记页面中绑定有<strong>页面滚动</strong>事件处理器的区域为<strong>非快速滚动区域</strong>（non-fast scrollable region)</li><li>如果事件发生在这些存在标注的区域，合成线程会把事件信息发送给主线程，等待主线程进行事件处理</li><li>如果事件不是发生在这些区域，合成线程则会直接合成新的帧而不用等到主线程的响应</li></ul><h5 id="（3）查找事件的目标对象"><a href="#（3）查找事件的目标对象" class="headerlink" title="（3）查找事件的目标对象"></a>（3）查找事件的目标对象</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110071138363.png" alt="当整个页面都是非快速滚动区域时页面的事件处理示意图"></p><p>当<strong>合成线程</strong>接收到事件信息，判定到事件发生不在非快速滚动区域后，合成器线程会向<strong>主线程</strong>发送这个时间信息，<strong>主线程</strong>获取到事件信息的第一件事就是通过<strong>命中测试（hit test）</strong>去找到事件的目标对象</p><p>具体的命中测试流程是遍历在绘制阶段生成的<strong>绘画记录（paint records）</strong>来找到包含了事件发生坐标上的元素对象</p><h5 id="（4）事件处理优化"><a href="#（4）事件处理优化" class="headerlink" title="（4）事件处理优化"></a>（4）事件处理优化</h5><p>为了浏览流畅，浏览器需要保证渲染进程的渲染速度与屏幕刷新率一致（大概每秒 60 帧），但是存在某些事件触发频率超过了这个数值（比如wheel，mousewheel，mousemove，pointermove，touchmove，这些连续性的事件一般每秒会触发60~120次）</p><p>事件淹没了屏幕刷新的时间轴，导致页面很卡顿：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110071149864.png" alt="事件淹没了屏幕刷新的时间轴，导致页面很卡顿"></p><p>假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对来说较低，这样使得主线程会<strong>触发过量</strong>的命中测试以及JS代码，使得性能有了没必要是<strong>损耗</strong></p><p>和之前相同的事件轴，可是这次事件被合并并延迟调度了：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202110071149521.png" alt="和之前相同的事件轴，可是这次事件被合并并延迟调度了"></p><p>浏览器会<strong>合并</strong>这些连续的事件，延迟到下一帧渲染再执行，达到事件处理优化的目的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202110131222149.webp&quot; alt=&quot;Internet Explorer&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器笑话90%都和IE有关，没了IE的浏览器世界总归是少很多乐趣😭&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
      <category term="计算机系统" scheme="https://autovy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="web" scheme="https://autovy.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>开发原理|后端架构基础知识</title>
    <link href="https://autovy.github.io/2021/09/30/DevPrinciple/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://autovy.github.io/2021/09/30/DevPrinciple/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-09-30T15:45:00.000Z</published>
    <updated>2022-08-30T08:07:45.160Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109302345178.jpeg" alt="Image"></p><p>抓住9月的尾巴，终于整理完毕🥳。</p><span id="more"></span><h3 id="互联网架构演化进程"><a href="#互联网架构演化进程" class="headerlink" title="互联网架构演化进程"></a>互联网架构演化进程</h3><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271633102.jpeg" alt="img"></p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>参考资料：<a href="https://blog.csdn.net/wangshihuidev/article/details/98896812">https://blog.csdn.net/wangshihuidev/article/details/98896812</a></p><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h4><p>但访问系统的用户越来越多，系统资源就需要更多的<strong>CPU</strong>，<strong>内存</strong>去处理请求，需要更大的<strong>网络带宽</strong>去处理数据的传输，需要更多<strong>磁盘空间</strong>存储数据，有以下两种方法：<strong>垂直伸缩 水平伸缩</strong></p><h4 id="2-垂直伸缩"><a href="#2-垂直伸缩" class="headerlink" title="2.垂直伸缩"></a>2.垂直伸缩</h4><h5 id="（1）垂直伸缩简介"><a href="#（1）垂直伸缩简介" class="headerlink" title="（1）垂直伸缩简介"></a>（1）垂直伸缩简介</h5><p>垂直伸缩的核心思想是：提升<strong>单台</strong>服务器计算处理的性能（个人主义）</p><p>但是单台服务器的<strong>计算处理能力是有限</strong>的，而且也会严重受到计算机硬件水平的制约，即便用更快频率的CPU，更快的网卡，塞更多的磁盘也总会有天花板</p><h5 id="（2）垂直伸缩系统优化"><a href="#（2）垂直伸缩系统优化" class="headerlink" title="（2）垂直伸缩系统优化"></a>（2）垂直伸缩系统优化</h5><p>增加CPU后，要进行以下调整以保证计算能力有效增长：</p><ul><li>开启多线程</li><li>调大并发量</li><li>防止锁竞争</li></ul><p>增加内存后后，要进行以下调整以保证服务能力有效增长：</p><ul><li>调大堆参数</li><li>调大本地缓存</li></ul><p>除此之外对数据库的优化如分表等操作也是一种垂直伸缩</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271621445.png" alt="在这里插入图片描述"></p><h4 id="3-水平伸缩"><a href="#3-水平伸缩" class="headerlink" title="3.水平伸缩"></a>3.水平伸缩</h4><h5 id="（1）水平伸缩简介"><a href="#（1）水平伸缩简介" class="headerlink" title="（1）水平伸缩简介"></a>（1）水平伸缩简介</h5><p>水平伸缩的核心思想是：用<strong>多台</strong>服务器合并进行计算处理（集体主义）</p><p>通过多台服务器构成<strong>分布式集群</strong>从而提升系统的整体处理能力</p><h5 id="（2）水平伸缩系统优化"><a href="#（2）水平伸缩系统优化" class="headerlink" title="（2）水平伸缩系统优化"></a>（2）水平伸缩系统优化</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271624231.png" alt="在这里插入图片描述"></p><h4 id="4-方案比较"><a href="#4-方案比较" class="headerlink" title="4.方案比较"></a>4.方案比较</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271621772.png" alt="在这里插入图片描述"></p><h4 id="5-分布式架构"><a href="#5-分布式架构" class="headerlink" title="5.分布式架构"></a>5.分布式架构</h4><p>将单体服务进行以下改造，可获得一个简单的高性能系统：</p><ul><li>数据库与应用分离：系统程序，文件服务，数据库服务部署在不同服务器</li><li>加一个缓存：将应用程序需要的热点数据存在缓冲中，而不是每一次都要去连接数据库</li><li>多台服务器构成单一服务的集群：如数据库集群，应用程序集群，缓存服务集群</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271901457.png" alt="img"></p><h3 id="缓存架构"><a href="#缓存架构" class="headerlink" title="缓存架构"></a>缓存架构</h3><h4 id="1-计算机中的缓存"><a href="#1-计算机中的缓存" class="headerlink" title="1.计算机中的缓存"></a>1.计算机中的缓存</h4><ul><li>CPU和主内存之间有缓存</li><li>内存和硬盘之间也有磁盘缓存</li><li>在硬盘与网络之间也有某种意义上的缓存</li></ul><p>缓存的关键指标是<strong>缓存命中率</strong>，其有以下影响要素：</p><ul><li>缓存键集合大小（键数越少，缓存效率越高）</li><li>缓存可使用内存空间（缓存对象越多，缓存命中率越高）</li><li>缓存对象生存时间（缓存时间越长，缓存对象被重用的可能性越高）</li></ul><p>缓存分为两种：一种是通读缓存，一种是旁路缓存</p><h4 id="2-通读缓存"><a href="#2-通读缓存" class="headerlink" title="2.通读缓存"></a>2.通读缓存</h4><h5 id="（1）通读缓存简介"><a href="#（1）通读缓存简介" class="headerlink" title="（1）通读缓存简介"></a>（1）通读缓存简介</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271925956.png" alt="img"></p><p>通读缓存：客户端请求通读缓存服务器，若缓存命中则直接返回数据，否则由通读缓存服务器<strong>代理</strong>请求到原始服务器获得数据</p><p><strong>客户端连接的是通读缓存</strong>，而不是生成相应的原始服务器，客户端只能通过通读缓存进行<strong>代理</strong>去访问原始服务器</p><p>比较常见的通读缓存有：Nginx反向代理缓存，fastly缓存</p><h5 id="（2）Nginx反向代理缓存"><a href="#（2）Nginx反向代理缓存" class="headerlink" title="（2）Nginx反向代理缓存"></a>（2）Nginx反向代理缓存</h5><p>Nginx不仅能作为Web Server，还具有反向代理、负载均衡和缓存的功能</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271938014.png" alt="img"></p><h5 id="（3）fastly缓存"><a href="#（3）fastly缓存" class="headerlink" title="（3）fastly缓存"></a>（3）fastly缓存</h5><img src="https://img.alifastly.com/tfs/TB1eV4wKa6qK1RjSZFmXXX0PFXa-1149-1328.png" alt="什麼是fastly" style="zoom: 67%;"><p>fastly即内容分发网络，它们是一组分布在不同地理位置的服务器。其利用遍布全球各地数据中心的缓存，使用户可以通过最近地点的fastly服务器获得网络内容</p><p>可以将fastly理解为遍布大街小巷的ATM机，人们不用去银行排长队而是去离自己最近的ATM去取现金</p><h4 id="3-旁路缓存"><a href="#3-旁路缓存" class="headerlink" title="3.旁路缓存"></a>3.旁路缓存</h4><h5 id="（1）旁路缓存简介"><a href="#（1）旁路缓存简介" class="headerlink" title="（1）旁路缓存简介"></a>（1）旁路缓存简介</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109271926138.png" alt="img"></p><p>旁路缓存：客户端向访问旁路缓存是否有命中的数据，若没有就自己去访问原始服务器获得数据</p><p>旁路缓存通常是一个<strong>独立的键值对存储</strong>（key-value）</p><p>比较常见的旁路缓存：Redis</p><h5 id="（2）Redis缓存"><a href="#（2）Redis缓存" class="headerlink" title="（2）Redis缓存"></a>（2）Redis缓存</h5><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/315103766">https://zhuanlan.zhihu.com/p/315103766</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109272020654.jpeg" alt="img"></p><ul><li>缓存命中：Redis中有相应数据，直接返回数据</li><li>缓存缺失：Redis中没有保存相应数据，需要请求数据库服务器，而且要将缺失数据写入Redis（缓存更新）</li></ul><h4 id="4-缓存优缺点"><a href="#4-缓存优缺点" class="headerlink" title="4.缓存优缺点"></a>4.缓存优缺点</h4><h5 id="（1）缓存的好处"><a href="#（1）缓存的好处" class="headerlink" title="（1）缓存的好处"></a>（1）缓存的好处</h5><ul><li>缓存数据存储在内存中，相比硬盘和网络获取效率更高，响应时间更快，性能更好</li><li>降低服务器的负载能力</li><li>缓存通常会记录计算结果，缓存也减少CPU的计算消耗加快处理速度</li></ul><h5 id="（2）缓存的缺点"><a href="#（2）缓存的缺点" class="headerlink" title="（2）缓存的缺点"></a>（2）缓存的缺点</h5><ul><li>数据库中的源数据被修改，缓存中的数据变成脏数据</li><li>每次写入缓存数据都要标记失效时间</li></ul><h4 id="5-缓存的合理使用"><a href="#5-缓存的合理使用" class="headerlink" title="5.缓存的合理使用"></a>5.缓存的合理使用</h4><h5 id="（1）缓存关注要点"><a href="#（1）缓存关注要点" class="headerlink" title="（1）缓存关注要点"></a>（1）缓存关注要点</h5><ul><li>关注频繁修改的数据，如果一个数据经常被修改，那么使用缓存的价值不大</li><li>缓存要有热点，存储空间有限，要选取热门的被访问数据放在缓存</li><li>注意缓存雪崩，缓存击穿与缓存穿透</li><li>关注缓存的数据一致性</li></ul><h5 id="（2）缓存异常与解决方案"><a href="#（2）缓存异常与解决方案" class="headerlink" title="（2）缓存异常与解决方案"></a>（2）缓存异常与解决方案</h5><p>参考资料：<a href="https://www.sohu.com/a/473442725_115128">https://www.sohu.com/a/473442725_115128</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109272244518.png" alt="img"></p><h5 id="（3）缓存雪崩"><a href="#（3）缓存雪崩" class="headerlink" title="（3）缓存雪崩"></a>（3）缓存雪崩</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109272042116.png" alt="img"></p><p>缓存雪崩：由于<strong>大量缓存数据过期或redis故障</strong>，大量用户请求无法在redis中处理而是全部打向了数据库，数据库被乱棒打死后（宕机），会引发一系列连锁反应，造成系统崩溃，故称为<strong>雪崩</strong></p><p><strong>大量缓存数据过期</strong>应对方法</p><ul><li>均匀设置过期时间：<strong>避免</strong>将大量数据设为<strong>同一个过期时间</strong>，可以给过期时间加上一个随机数</li><li>互斥锁：如果发现访问的数据不在 Redis 里，就加个互斥锁，保证<strong>同一时间内只有一个请求来更新缓存</strong>（互斥锁最好设置<strong>超时时间</strong>，不然如果拿到锁的请求发生阻塞，一直不释放锁，其他请求也拿不到锁，整个系统就无响应了）</li><li>双 key 策略：我们对缓存数据可以使用两个 key，一个是 <strong>主 key，会设置过期时间，</strong>一个是 <strong>备 key，不会设置过期</strong>，相当于给缓存数据做了个副本（副本的副本）</li><li>后台更新缓存：让缓存<strong>“永久有效”</strong>，并将更新缓存的工作交由后台线程<strong>定时更新</strong>（某些缓存会在系统内存紧张的时候被淘汰，所以不存在真正的永久有效，当业务线程发现缓存数据失效了，过消息队列发送一条消息通知后台线程更新缓存）</li><li>通过后台更新缓存进行<strong>缓存预热</strong>，即提取把数据缓存起来而不是等待用户访问才来触发缓存构建</li></ul><p><strong>Redis 故障宕机</strong>应对方法</p><ul><li>服务熔断：<strong>服务熔断</strong>机制， 暂停业务应用对缓存服务的访问，直接返回错误</li><li>请求限流机制：启用 <strong>请求限流</strong>机制， 只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</li><li>构建 Redis 缓存高可靠集群：通过 <strong>主从节点</strong>的方式构建 Redis 缓存高可靠集群，如果 Redis 缓存的主节点故障宕机，<strong>从节点可以切换成为主节点</strong>，继续提供缓存服务</li></ul><h5 id="（4）缓存击穿"><a href="#（4）缓存击穿" class="headerlink" title="（4）缓存击穿"></a>（4）缓存击穿</h5><img src="https://p6.itc.cn/q_70/images03/20210622/e18ac966425f4dfe9533dd6a127b0fbb.png" alt="img"><p>缓存击穿：如果缓存中的 <strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是 <strong>缓存击穿</strong>的问题</p><p>缓存击穿应对方法（也是前面提到的两种方法）</p><ul><li>互斥锁：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li><li>后台更新缓存：不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间</li></ul><h5 id="（5）缓存穿透"><a href="#（5）缓存穿透" class="headerlink" title="（5）缓存穿透"></a>（5）缓存穿透</h5><img src="https://p9.itc.cn/q_70/images03/20210622/a1b8b0927ad7484286fa965e9dc90a09.png" alt="img"><p>缓存穿透：用户访问的数据即不在缓存中，也不在数据库中，有以下两种诱因：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务</li></ul><p>缓存传递应对方法</p><ul><li>非法请求的限制：在API网关处筛选请求，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库</li><li>缓存空值或者默认值：针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库</li><li>布隆过滤器：在写入数据数据时使用布隆过滤器做个标记，通过查询布隆过滤器可以快速判断数据是否存在，避免通过查询数据库来判断数据是否存在（Redis本身也是支持布隆过滤器的）</li></ul><h5 id="（6）缓存数据一致性"><a href="#（6）缓存数据一致性" class="headerlink" title="（6）缓存数据一致性"></a>（6）缓存数据一致性</h5><p>参考资料：<a href="https://blog.51cto.com/u_14983647/2548012">https://blog.51cto.com/u_14983647/2548012</a></p><p>缓存与数据库存在一致性问题的根本原因是：多个线程同时操作相同数据</p><p>在<strong>读</strong>的情况下表现为两个同时查询缓存的线程<strong>同时不命中</strong>，在写的情况下表现为多个线程并发回写缓存的值不同，发生<strong>缓存和数据库不一致</strong></p><p>有以下几种不同的写入策略</p><ul><li><p>先更新数据库，再更新缓存（普通低并发）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109280831554.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_mysql_05"></p><p>更新mysql成功，更新redis缓存失败会造成<strong>数据不一致</strong></p></li></ul><ul><li><p>先删除缓存，再写入数据库（低并发优化）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109280833664.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_redis_06"></p><p>先将缓存删除，下个进程再请求更新后的数据库来更新缓存，这种方案只适合低并发中使用，在高并发中一旦下一个进程在前一个进程更新数据库前就去更新缓存，那缓存中放入的依旧是旧数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109280843114.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_数据一致性_07"></p></li><li><p>延时双删策略</p></li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109280844096.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_数据一致性_08"></p><p>先将缓存删除，在更新数据库后再次删除缓存，可以很快解决不一致的问题，但是仍然有第二次删除错误，多写多读高并发情况下对 MySQL访问的压力（这时候其实可以加入消息队列异步解决，后面会讲到<strong>异步架构</strong>）</p><ul><li>直接操作缓存，定期写入sql（适合高并发）</li></ul><img src="https://bigsai.oss-cn-shanghai.aliyuncs.com/img/image-20201106192531468.png" alt="8 张图带你分析 Redis 与 MySQL 数据一致性问题_redis_09" style="zoom: 50%;"><p>在高并发的情况下，最佳的方法是直接更新缓存，将缓存定期更新到数据库</p><h3 id="异步架构"><a href="#异步架构" class="headerlink" title="异步架构"></a>异步架构</h3><h4 id="1-异步架构简介"><a href="#1-异步架构简介" class="headerlink" title="1.异步架构简介"></a>1.异步架构简介</h4><h5 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>缓存实际上更多解决了<strong>读</strong>的问题，因为缓存很难保证数据的持久性和一致性，所以我们通常不会将数据直接写入缓存中，而是写入 RDBMAS 等数据中，这时候我们使用<strong>消息队列</strong>的<strong>异步架构</strong>提升系统的<strong>写</strong>的性能</p><h5 id="（2）同步架构与异步架构"><a href="#（2）同步架构与异步架构" class="headerlink" title="（2）同步架构与异步架构"></a>（2）同步架构与异步架构</h5><p>同步架构：应用程序调用服务时，阻塞进程等待服务完成，直到返回服务结果才会继续执行</p><img src="https://mmbiz.qpic.cn/mmbiz_png/NdsdouZwicac3O5p5TVPt4OwoCeI8CEaIibdELIzMiaRPrmvKlcZjMYAtPI749qIqO07O4PxJNtEg8yV9wsdHUkpw/640?wx_fmt=png" alt="img" style="zoom:67%;"><p>这样的阻塞会带来以下问题：</p><ul><li>不能释放占用的系统资源，导致系统资源不足，影响系统性能</li><li>无法快速给用户响应结果</li></ul><p>异步架构：应用程序将调用信息发给消息队列就直接返回，应用程序收到返回后继续执行，快速响应用户释放资源。有专门的消费队列程序从中消息队列取出消息发送给邮箱服务器最后将返回结果通知消息队列</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109281929483.png" alt="img"></p><ul><li></li></ul><h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2.消息队列"></a>2.消息队列</h4><h5 id="（1）消息队列模型"><a href="#（1）消息队列模型" class="headerlink" title="（1）消息队列模型"></a>（1）消息队列模型</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109281946207.png" alt="img"></p><p>消息队列模型有三个角色：</p><ul><li>生产者：产生数据封装发给消息队列</li><li>消息队列：存储接收到的消息</li><li>消费者：从消息队列中取出数据，消费数据</li></ul><h5 id="（2）消费模式"><a href="#（2）消费模式" class="headerlink" title="（2）消费模式"></a>（2）消费模式</h5><p>参考资料：<a href="https://segmentfault.com/a/1190000019411260">https://segmentfault.com/a/1190000019411260</a></p><ul><li><p>点对点模式：不可重复消费，Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109281957502.jpeg" alt="img" style="zoom:67%;"></li></ul><ul><li><p>订阅模式：可以重复消费，发布到topic的消息会被所有订阅者消费</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109281957275.jpeg" alt="img" style="zoom: 60%;"></li></ul><h5 id="（3）消息队列的优点"><a href="#（3）消息队列的优点" class="headerlink" title="（3）消息队列的优点"></a>（3）消息队列的优点</h5><ul><li><strong>实现异步处理，提升处理性能</strong>：不再阻塞客户端程序，提高客户端程序的处理性能</li><li><strong>可以让系统获得更好的伸缩性</strong>：耗时的任务可以通过分布式消息队列，向多台消费者服务器并行发送消息，然后在很多台消费者服务器上<strong>并行处理消息</strong>，也就是说可以在多台物理服务器上运行消费者</li><li><strong>可以平衡流量峰值，削峰填谷</strong>：通过消息队列的缓冲，将访问的高峰消掉，而将访问的低谷填平，使系统处在一个最佳的处理状态之下，不会对系统的负载产生太大的冲击</li><li><strong>失败隔离和自我修复</strong>：生产者不直接依赖消费者，所以分布式消息队列可以将消费者系统产生的错误异常与生产者系统隔离开来，生产者不受消费者失败的影响</li><li><strong>生产者和消费者的代码实现解耦合</strong>：多个生产者发布消息，多个消费者处理消息，共同完成完整的业务处理逻辑，但是它们的不需要直接的交互调用，没有代码的依赖耦合</li></ul><h4 id="3-异步架构总结"><a href="#3-异步架构总结" class="headerlink" title="3.异步架构总结"></a>3.异步架构总结</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109281953133.png" alt="img"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是一种将请求分发到不同服务器以分散高并发计算压力的策略</p><h4 id="1-负载均衡方案"><a href="#1-负载均衡方案" class="headerlink" title="1.负载均衡方案"></a>1.负载均衡方案</h4><p>参考资料：<a href="https://segmentfault.com/a/1190000022328323">https://segmentfault.com/a/1190000022328323</a></p><h5 id="（1）HTTP重定向负载均衡"><a href="#（1）HTTP重定向负载均衡" class="headerlink" title="（1）HTTP重定向负载均衡"></a>（1）HTTP重定向负载均衡</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109282037827.png" alt="img"></p><p>用户请求到HTTP重定向负载均衡服务器，用一套负载均衡算法<strong>计算到后端服务器的地址</strong>，然后将新的地址给用户浏览器，浏览器收到重定向响应后发送请求到新的应用服务器从而实现负载均衡</p><p>缺点：</p><ul><li>加大请求的工作量，用户端要进行两次请求</li><li>集群IP地址需要暴露在公网，安全性低</li></ul><h5 id="（2）DNS负载均衡"><a href="#（2）DNS负载均衡" class="headerlink" title="（2）DNS负载均衡"></a>（2）DNS负载均衡</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109282038685.png" alt="img"></p><p>用户通过浏览器发起HTTP请求的时候，DNS 通过对域名进行解析得到 IP 地址，用户委托协议栈的 IP 地址建立HTTP 连接访问真正的服务器，不同的用户进行域名解析将会获取不同的IP地址从而实现负载均衡</p><ul><li>通过 <strong>DNS 解析</strong>获取负载均衡集群某台服务器的<strong>地址</strong></li><li>不用每次都请求负载的ip,可以<strong>缓存</strong>起来，重复使用，提高性能</li><li>DNS不用暴露实际计算的服务器IP（不是采用重定向的方式暴露在浏览器，而且做了二次负载均衡，内网的IP不会暴露出来）</li></ul><h5 id="（3）反向代理负载均衡"><a href="#（3）反向代理负载均衡" class="headerlink" title="（3）反向代理负载均衡"></a>（3）反向代理负载均衡</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109282040480.png" alt="img"></p><p>客户端请求反向代理服务器，服务器根据算法得到负载的IP，由反向代理服务器代理客户端请求内网的应用服务器集群，最后将结果返回给客户端</p><p>常用的反向代理有：nignx，apache</p><p>基于http层做的负载均衡，是一个比较重的协议，效率略低，一般适用于比较小的集群，10+规模</p><h5 id="（4）IP负载均衡"><a href="#（4）IP负载均衡" class="headerlink" title="（4）IP负载均衡"></a>（4）IP负载均衡</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109290839127.png" alt="img"></p><p>客户端请求负载均衡服务器，服务器修改目标IP为内网机器的IP，最后返回响应数据并修改响应地址为公网ip</p><p>对网络层的IP地址进行替换，不需要在http层工作，直接在操作系统内核的IP数据包中替换地址。效率比基于HTTP层的反向代理高</p><p>请求和响应度需要经过负载均衡服务器进行ip层替换，响应数据会成为后期的瓶颈</p><h5 id="（5）数据链路负载均衡"><a href="#（5）数据链路负载均衡" class="headerlink" title="（5）数据链路负载均衡"></a>（5）数据链路负载均衡</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109282038248.png" alt="img"></p><p>客户端请求负载均衡服务器，负载均衡服务器替换mac地址应用服务器，ip为负载均衡服务器ip，计算服务器直接响应数据到客户端；</p><p>解决响应数据体量过大效率低的问题，通过修改数据链路层的mac地址，ip使用的是虚拟IP，来实现负载均衡</p><p>该负载均衡方式吞吐量高，适合大型互联网公司使用</p><h4 id="2-负载均衡算法"><a href="#2-负载均衡算法" class="headerlink" title="2.负载均衡算法"></a>2.负载均衡算法</h4><p>参考资料：</p><p><a href="http://www.zhengdexing.org/2019/04/16/LoadBalancing">负载均衡算法介绍</a></p><p><a href="https://segmentfault.com/a/1190000022799223">负载均衡算法实现</a></p><h5 id="（1）轮询访问"><a href="#（1）轮询访问" class="headerlink" title="（1）轮询访问"></a>（1）轮询访问</h5><p>将请求按照顺序轮流的分配到服务器上，均衡的对待每一台后端的服务器,不关心服务器的的连接数和负载情况，可能导致性能高的服务器无法完全发挥实力，性能低的服务器无法承载过大的负载</p><p>如下图：来自客户端的6个请求被均匀分发给两台应用服务器</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109290902293.png" alt="img"></p><h5 id="（2）随机访问"><a href="#（2）随机访问" class="headerlink" title="（2）随机访问"></a>（2）随机访问</h5><p>根据服务器列表的大小来随机获取其中的一台来访问，随着调用量的增大，实际效果越来越近似于平均分配到没一台服务器，和轮询的效果类似，比较适合服务器性能差不多的场景</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109290912846.png" alt="img"></p><h5 id="（3）加权轮询"><a href="#（3）加权轮询" class="headerlink" title="（3）加权轮询"></a>（3）加权轮询</h5><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值</p><p>如下图：来自客户端的请求按5:1的权重分发给两台应用服务器</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109290907944.png" alt="img"></p><h5 id="（4）最少连接"><a href="#（4）最少连接" class="headerlink" title="（4）最少连接"></a>（4）最少连接</h5><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡，这时我们可以采用最少连接算法：将请求发送给当前最少连接数的服务器上</p><p>如下图：当前服务器1当前连接数最小，那么最新的请求将会发给服务器1</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109290913344.png" alt="img"></p><p>在最少连接的基础上，也有加权最少连接算法：根据服务器的性能为每台服务器分配权重以计算出每台服务器能处理的连接数</p><h5 id="（5）源地址哈希法"><a href="#（5）源地址哈希法" class="headerlink" title="（5）源地址哈希法"></a>（5）源地址哈希法</h5><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上，这种机制也称为粘滞会话）<img src="https://raw.staticdn.net/Autovy/Image/master/img/202109290915683.png" alt="img"></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>参考资料：<a href="https://www.cnblogs.com/linuxk/p/9366838.html">https://www.cnblogs.com/linuxk/p/9366838.html</a></p><h4 id="1-数据库主从复制"><a href="#1-数据库主从复制" class="headerlink" title="1.数据库主从复制"></a>1.数据库主从复制</h4><h5 id="（1）一主多重"><a href="#（1）一主多重" class="headerlink" title="（1）一主多重"></a>（1）一主多重</h5><p>为了降低数据库的压力，数据库服务器常常使用<strong>一主多重</strong>结构，对于<strong>容灾、可扩展性和高可用性</strong>，都是有好处，一主多重结构主要依赖于<strong>主从复制</strong>与<strong>读写分离</strong></p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291452911.png" alt="image-20210929145219480" style="zoom:67%;"><h5 id="（2）主从复制"><a href="#（2）主从复制" class="headerlink" title="（2）主从复制"></a>（2）主从复制</h5><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM0OTUzOS8yMDE4MDcvMTM0OTUzOS0yMDE4MDcyNTE2NDY0Njk1MS05NTkzODQ4MS5wbmc" alt="img"><p>主从复制即要让主库和从库的数据一致，其实现步骤为：</p><ul><li>从库IO线程通过主库创建的授权用户连接上master</li><li>应用程序发送SQL更新命令到主库，主库将该命令同步记录到Binlog中</li><li>主库IO线程对从库IO线程的请求进行验证后，将命令和下一个指定更新的位置（position）发送到从库</li><li>从库接收更新日志后加入到自己的RelayLog文件末端，并将读取到的主库Binlog文件名和position记录到master.info文件</li><li>从库SQL线程检测到RelayLog中的内容有更新，会立刻解析内容并执行解析后的SQL语句</li></ul><h5 id="（3）读写分离"><a href="#（3）读写分离" class="headerlink" title="（3）读写分离"></a>（3）读写分离</h5><p>主从复制需要时间，向主库写入数据后，如果直接从从库读取，很可能读不到最新值，所以读写分离主要用于对实时性要求不高的业务场景</p><ul><li>数据库主机负责读写操作，从机只负责读操作</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li><li>应用服务器将写操作发给数据库主机，将读操作发给数据库从机</li></ul><h4 id="2-数据库分片"><a href="#2-数据库分片" class="headerlink" title="2.数据库分片"></a>2.数据库分片</h4><p>参考资料<a href="https://segmentfault.com/a/1190000015627336">https://segmentfault.com/a/1190000015627336</a></p><h5 id="（1）分片简介"><a href="#（1）分片简介" class="headerlink" title="（1）分片简介"></a>（1）分片简介</h5><p>分片是解决数据库存储容量限制的直接途径。分片包括<strong>垂直分片</strong>与<strong>水平分片</strong>两种方式</p><h5 id="（2）垂直分片"><a href="#（2）垂直分片" class="headerlink" title="（2）垂直分片"></a>（2）垂直分片</h5><p>垂直分片又叫纵向分割，把原有数据库切分成按业务多个数据库。垂直拆分后业务清晰，拆分规则明确，系统之间容易整合与扩展</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291543889.png" alt="图片描述"></p><h5 id="（3）水平分片"><a href="#（3）水平分片" class="headerlink" title="（3）水平分片"></a>（3）水平分片</h5><p>水平分片又叫横向分割，即以表中的数据行记录为单位，把原有逻辑数据库切分成多个物理数据库分片，表数据记录分布存储在各个分片上</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291545069.png" alt="图片描述"></p><p>常用水平分片的规则：哈希取模算法<code>H(Key(OrderId)) = Hash(Key(OrderId))%N</code>，将键值相同的行放在一个数据库中</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>参考资料：<a href="https://leetcode-cn.com/circle/article/7qT9CA/">https://leetcode-cn.com/circle/article/7qT9CA/</a></p><h4 id="1-搜索引擎架构"><a href="#1-搜索引擎架构" class="headerlink" title="1.搜索引擎架构"></a>1.搜索引擎架构</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291608846.png" alt="img"></p><h4 id="2-搜索引擎工作原理分析"><a href="#2-搜索引擎工作原理分析" class="headerlink" title="2.搜索引擎工作原理分析"></a>2.搜索引擎工作原理分析</h4><h5 id="（1）搜集"><a href="#（1）搜集" class="headerlink" title="（1）搜集"></a>（1）搜集</h5><p>网络爬虫的起点是一组优质的种子网页的链接（新浪主页，腾讯主页等），通过广度优先遍历不断遍历这些网页，爬取网页内容，提取其中的链接，并又将这些链接加入待爬队列中，重复上面操作（递归了属于是）</p><p><strong>待爬url队列：</strong></p><p>待爬取的url放入Redis中，保证高性能。Redis开启持久化功能，支持断点续爬，即便Redis寄了，也可以从上一个待爬url重新开始爬</p><p><strong>url判重：</strong></p><p>为了避免网页被重复爬取，我们使用布隆过滤器（上面应对缓存穿透也提到过，可以快速判断数据是否存在数据库中）进行去重操作</p><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成，将数据（url）经过多个哈希函数处理用位图数组表示，查询url是否被爬过时，只要查到位图数组对应的值是否全为1，只要有一个0，就认为该url未被爬过</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291639347.png" alt="img"></p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时存在哈希冲突的可能性，<strong>查询布隆过滤器说数据存在，并不一定证明该数据被处理过，但是查询到数据不存在，这个数据一定是没有处理过的</strong>，针对这种情况我们可以通过<strong>调整布隆过滤器的哈希函数</strong>或其<strong>底层的位图大小</strong>来尽可能地降低误判的概率，至于发生误判的少量url，let it go！（就是这么粗暴）</p><p><strong>网页存储文件：</strong></p><p>网页信息存储文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291654266.png" alt="img"></p><p>网页id-url对应文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291654439.png" alt="img"></p><h5 id="（2）预处理"><a href="#（2）预处理" class="headerlink" title="（2）预处理"></a>（2）预处理</h5><p>参考资料：<a href="https://mah93.github.io/2019/08/08/string-matching/">字符串匹配算法</a></p><p>爬取完一个网页的html代码后，需要将<code>&lt;script&gt;,&lt;style&gt;,&lt;option&gt;</code>这些无用的标签及标签包含的内容给去掉，然后把其他标签也去掉但是保留里面的内容，最后得到<strong>纯文本</strong>（内容包含用户要搜索的关键词），所以我们需要使用<strong>字符串匹配算法</strong>对html内容进行<strong>预处理</strong>，对于字符串匹配算法这里列个清单自己去查罢 :(</p><p>单模式串匹配算法：</p><ul><li>BF算法</li><li>RK算法</li><li>BM算法</li><li>KMP算法</li></ul><p>上面的查询算法查询单个字符串效率确实不错，但是我们要一次性查出<code>&lt;script&gt;,&lt;style&gt;,&lt;option&gt;</code>这些字段串，多模式串匹配算法更加高效</p><p>多模式串匹配算法：</p><ul><li>AC自动机</li></ul><h5 id="（3）分词并创建倒排索引"><a href="#（3）分词并创建倒排索引" class="headerlink" title="（3）分词并创建倒排索引"></a>（3）分词并创建倒排索引</h5><p><strong>分词：</strong></p><p>预处理获得纯文本后，要对文本内容进行分词即把一段文本切分为一个个词。英语的分词比较简单，每一个单词基本都是用空格隔开的，中文的分词比较难分割，一般是根据现成的词库进行匹配，有兴趣可以研究一下github上有名的<a href="https://github.com/fxsjy/jieba">jieba</a>分词开源库</p><p><strong>组织：</strong></p><p>分词后，将单词与网页信息存储文件（文档）对应起来组成以下矩阵</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291737670.png" alt="img"></p><p><strong>倒排索引：</strong></p><p>再按照单词-文档组织起来就叫做<strong>倒排索引</strong></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109291955544.png" alt="img"></p><p>这样我们只要搜索<strong>单词</strong>，就能找到单词对应的<strong>文档id</strong>，从而定位url（上面分词+倒排索引的处理流程，就是 ElasticSearch 搜索引擎干的事，也是 ES 能达到毫秒级响应的关键）</p><p><strong>排序：</strong></p><p>根据词语我们获得了一组网页的id，那哪些网页应该排在前面呢？</p><p>Google使用了一种叫做”<strong>PageRank</strong>“的算法，通过计算每个网页的权重，并按照权重排序。它以网页之间的超链接个数和质量作为主要因素粗略地分析网页重要性以便对其进行打分。</p><p>在PageRank中，如果网页A包含网页B说明A认可了B，即为页面B投了一票</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109292017540.png" alt="img"></p><p>如上图：ABCD 初始值都为1，然后根据关系计算权重。比如此时B包含了AD两个网页，那么权重1被分为两个1/2分别给A和D，此时A包含BCD，那么此时A页面新的权重为1/2 + 1/3 + 1 = 11/6</p><p>此外还有通过<strong>词频TF</strong>进行排序</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109292024700.png" alt="img"></p><h5 id="（4）查询过程"><a href="#（4）查询过程" class="headerlink" title="（4）查询过程"></a>（4）查询过程</h5><ul><li>用户输入搜索内容，首先经过分词器处理</li><li>按获得的词语去倒排索引里查询相应文档</li><li>得到网页id后，去网页存储文件中提取出网页的链接和内容，再按权重从大到小排序即可</li></ul><h5 id="（5）寻找热门搜索字符串"><a href="#（5）寻找热门搜索字符串" class="headerlink" title="（5）寻找热门搜索字符串"></a>（5）寻找热门搜索字符串</h5><p>现在的搜索引擎还有一项功能：搜索提示词，其主要利用Trie树来实现（字典树，前缀树，单词查询树），如下图</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109292042845.png" alt="img"></p><p>这颗多叉树表示了关键字集合 <code>[&quot;to&quot;，&quot;tea&quot;，&quot;ted&quot;，&quot;ten&quot;，&quot;a&quot;，&quot;i&quot;，&quot;in&quot;, &quot;inn&quot;]</code>，</p><p>一般搜索引擎会维护一个词库，假设这个词库由所有搜索次数大于某个阈值（如 1000）的字符串组成，我们就可以用这个词库构建一颗 Trie 树，这样当用户输入字母的时候，就可以以这个字母作为前缀去 Trie 树中查找</p><p>哪如何获得热门的搜索提示词放在最前面呢？</p><p>通常在实现Trie树的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词，该标记也可以设置为<strong>搜索次数</strong></p><p>依次遍历 Trie 树的节点，将节点（字符串+次数）传给一个<strong>小顶堆</strong>，根据搜索次数不断调整小顶堆，这样遍历完 Trie 树的节点后，小顶堆里的 10 个节点即是最热门的搜索字符</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="1-软件架构"><a href="#1-软件架构" class="headerlink" title="1.软件架构"></a>1.软件架构</h4><p>参考资料：<a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构</a></p><h5 id="（1）单体架构"><a href="#（1）单体架构" class="headerlink" title="（1）单体架构"></a>（1）单体架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121533917.png" alt="image-20210912153357714"></p><p>典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层</p><p>单体架构出现的问题：</p><ul><li>代码分支管理困难</li><li>新增功能麻烦</li><li>容易耗尽数据库连接</li></ul><h5 id="（2）分布式架构"><a href="#（2）分布式架构" class="headerlink" title="（2）分布式架构"></a>（2）分布式架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121532105.png" alt="img"></p><p>将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上</p><h5 id="（3）微服务架构"><a href="#（3）微服务架构" class="headerlink" title="（3）微服务架构"></a>（3）微服务架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121533619.png" alt="img"></p><p>将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用</p><p>微服务的特点：</p><ul><li>大应用拆分为小模块</li><li>小模块不属于集群中</li><li>通过远程调用的方式依赖各个独立的模块完成业务的处理</li></ul><p>这些小模块就是一个微服务了</p><h4 id="2-微服务技术选型"><a href="#2-微服务技术选型" class="headerlink" title="2.微服务技术选型"></a>2.微服务技术选型</h4><p>参考资料：<a href="https://xie.infoq.cn/article/23d55563fdda52771571807e9">2020微服务架构技术选型</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109292309972.png" alt="img"></p><p>微服务的内容有点庞大😰，各种技术选型方案也很多，可以查看我的前一篇博文（SpringCloud + Netflix OSS）做一个了解：<a href="https://autovy.github.io/2021/09/20/Java/Java-SpringCloud/">Java|SpringCloud + Netflix OSS Demo</a></p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="1-高可用简介"><a href="#1-高可用简介" class="headerlink" title="1.高可用简介"></a>1.高可用简介</h4><p>系统高可用意味着在一台服务器挂掉的情况下，系统仍然无中断地执行其功能的能力</p><h4 id="2-高可用策略"><a href="#2-高可用策略" class="headerlink" title="2.高可用策略"></a>2.高可用策略</h4><h5 id="（1）冗余备份"><a href="#（1）冗余备份" class="headerlink" title="（1）冗余备份"></a>（1）冗余备份</h5><p>冗余备份是指复制关键部件或者系统的主要功能，当意外发生时，可以快速安全地恢复原有的系统，在一定的范围内保障业务的正常运行</p><h5 id="（2）负载均衡"><a href="#（2）负载均衡" class="headerlink" title="（2）负载均衡"></a>（2）负载均衡</h5><p>负载均衡也可以保证高可用，使用多台服务器分担一台服务器的压力，负载均衡服务器一旦发现集群中某台服务器出现问题，立刻停止对其的请求分发</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109300822419.png" alt="img"></p><h5 id="（3）限流降级"><a href="#（3）限流降级" class="headerlink" title="（3）限流降级"></a>（3）限流降级</h5><p>限流是对部分请求进行丢弃处理，保证大部分的用户可以正常的请求完成任务</p><p>降级即可以屏蔽部分当前看来不是很有用的任务</p><h5 id="（5）异地多活"><a href="#（5）异地多活" class="headerlink" title="（5）异地多活"></a>（5）异地多活</h5><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/32009822">饿了么异地多活技术实现</a></p><p>大型的系统多会在各个地方部署数据中心，采用异地多活的多机房策略</p><p>异地多活下，各个地域独立隔离，业务流量可以不均等的分配到各个地域和可用区里面</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109300837226.jpeg" alt="img"></p><ul><li>gzs是一个全局的（所有机房都可以访问的）服务，保存和推送sharding信息。</li><li>API router复制路由外网流量</li><li>SOAProxy实现跨机房调用</li><li>强一致数据库 / 数据库层的拦截 由DAL实现（图上没展示）</li><li>DRC实现Mqsql的双向复制</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h4 id="1-数据加密"><a href="#1-数据加密" class="headerlink" title="1.数据加密"></a>1.数据加密</h4><p>参考资料：<a href="https://www.jianshu.com/p/94dc5186746d">对称加密、单向加密和非对称加密</a></p><h5 id="（1）单向散列加密"><a href="#（1）单向散列加密" class="headerlink" title="（1）单向散列加密"></a>（1）单向散列加密</h5><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109300857948.png" alt="img"><p>单向加密有以下特征：</p><ul><li>输入一样，输出必然相同</li><li>雪崩效应，输入的微小改变，将会引起结果的巨大变化</li><li>定长输出，无论原始数据多大，结果大小都是相同的</li><li>不可逆，无法根据特征码还原原来的数据</li></ul><p>常用的单向加密算法有：MD5，SHA，CRC</p><p>单向加密通常应用在用户密码加密中，经过加密后的密码存储在数据库中，即便被脱库了也无法解密出密码（鉴于有些用户会用一些弱密码，容易被彩虹表暴杀，索引单向加密常常也要加一点盐）</p><h5 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109300857192.png" alt="img"></p><p>采用单钥密码的加密方法，同一个密钥可以同时用来加密和解密</p><p>对称加密有以下特点：</p><ul><li>加密方和解密方使用同一个密钥</li><li>加密解密的速度比较快，适合数据比较长时的使用</li><li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦</li></ul><p>常用的对称加密算法有：DES，3DES，AES，Blowfish</p><h5 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109300857820.png" alt></p><p>非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的</p><p>可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密；也可以用私钥加密，用公钥解密，常用于数字签名</p><p>非对称加密的<strong>主要功能就是加密和数字签名</strong></p><p>常用的非对称加密：RSA，DSA，ECC</p><h4 id="2-HTTP攻击与防护"><a href="#2-HTTP攻击与防护" class="headerlink" title="2.HTTP攻击与防护"></a>2.HTTP攻击与防护</h4><h5 id="（1）SQL注入"><a href="#（1）SQL注入" class="headerlink" title="（1）SQL注入"></a>（1）SQL注入</h5><p>SQL注入是攻击者在提交请求参数的时候，包含了恶意的SQL脚本</p><p>一阶sql注入：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109301727816.png" alt="image-20210930172727417"></p><p>二阶sql注入：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109301728597.png" alt="image-20210930172812394"></p><p>SQL注入防御方法（来源于wiki）：</p><ul><li>在设计应用程序时，完全使用<a href="https://zh.wikipedia.org/wiki/參數化查詢">参数化查询</a>（Parameterized Query）来设计资料访问功能（最有效的方式）</li><li>在组合SQL字符串时，先针对所传入的参数加入其他字符（将单引号字符前加上转义字符）。</li><li>如果使用<a href="https://zh.wikipedia.org/wiki/PHP">PHP</a>开发网页程序的话，需加入转义字符之功能（自动将所有的网页传入参数，将单引号字符前加上转义字符）。</li><li>使用php开发，可写入html特殊函数，可正确阻挡<a href="https://zh.wikipedia.org/wiki/XSS">XSS</a>攻击。</li><li>其他，使用其他更安全的方式连接SQL数据库。例如已修正过SQL注入问题的数据库连接组件，例如<a href="https://zh.wikipedia.org/wiki/ASP.NET">ASP.NET</a>的SqlDataSource对象或是 <a href="https://zh.wikipedia.org/wiki/语言集成查询">LINQ</a> to SQL。</li><li>增强<a href="https://zh.wikipedia.org/w/index.php?title=Web_application_firewall&action=edit&redlink=1">WAF</a>的防御力</li></ul><h5 id="（2）XSS攻击"><a href="#（2）XSS攻击" class="headerlink" title="（2）XSS攻击"></a>（2）XSS攻击</h5><p>跨站点脚本攻击，攻击者通过构造恶意的浏览器脚本文件注入到网页上，使其在其他用户的浏览器运行进而进行攻击</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109301732875.png" alt="xss.gif"></p><p>XSS攻击防御方法：</p><ul><li>过滤特殊字符</li><li>使用HTTP头指定类型即，可强行指定输出内容为文本或JavaScript脚本（顺便指定了内容编码），而非可以引发攻击的HTML</li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>参考资料：<a href="https://www.hadoopdoc.com/hdfs/hdfs-tutorial">https://www.hadoopdoc.com/hdfs/hdfs-tutorial</a></p><p>（本文只做简单介绍，大数据的内容也挺多的，有兴趣的可以点入上面链接深入学习）</p><h4 id="1-文件存储HDFS架构"><a href="#1-文件存储HDFS架构" class="headerlink" title="1.文件存储HDFS架构"></a>1.文件存储HDFS架构</h4><h5 id="（1）HDFS简介"><a href="#（1）HDFS简介" class="headerlink" title="（1）HDFS简介"></a>（1）HDFS简介</h5><p>HDFS是一种分布式文件系统，设计用于在商用硬件上商用，管理数以千计的服务器，数以万计的磁盘，将大规模的服务器资源当做一个单一的出承诺函系统进行管理，操作大批量数据就像使用普通文件系统一样</p><h5 id="（2）HDFS节点"><a href="#（2）HDFS节点" class="headerlink" title="（2）HDFS节点"></a>（2）HDFS节点</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109302252992.png" alt="HDFS架构图"></p><ul><li>Namenode会规范客户端对文件的访问，它维护和管理Slave节点，并把读写任务分配给Slave节点（部署在高可靠的硬件上面）</li><li>Datanode负责数据存储，它是真正干活的节点，比如响应客户端的数据读写请求，根据Namenode的指令创建和删除block（可以部署在价格低廉的商用机器上）</li></ul><h5 id="（3）HDFS进程"><a href="#（3）HDFS进程" class="headerlink" title="（3）HDFS进程"></a>（3）HDFS进程</h5><p>HDFS有2个守护进程：</p><ul><li><strong>Namenode</strong>：该进程运行在master节点上，Namenode节点存储元数据，比如文件名，块数量，块副本数量，块的存储位置，以及块ID等</li><li><strong>Datanode</strong>：该进程运行在Slave节点，这些节点是真正对数据进行处理和存储的节点</li></ul><h5 id="（4）HDFS数据存储"><a href="#（4）HDFS数据存储" class="headerlink" title="（4）HDFS数据存储"></a>（4）HDFS数据存储</h5><p><img src="/2021/09/30/DevPrinciple/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C:%5CUsers%5Clinghao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210930225658950.png" alt="image-20210930225658950"></p><p>把文件写入到HDFS的时候，HDFS会把文件分割成很多分片，也就是块（block），文件分割成块之后，HDFS会把他们以分布式方式存储在集群的不多节点上</p><h5 id="（5）HDFS机架感知"><a href="#（5）HDFS机架感知" class="headerlink" title="（5）HDFS机架感知"></a>（5）HDFS机架感知</h5><p>为了数据容错，NameNode把块的副本放在多个机架上，NameNode尽量会在每个机架都存储至少一个块副本，这样如果其中一个机架发生故障，系统还是可用的</p><p>机架感知策略的目的是提升数据可用性、可靠性和网络带宽利用率</p><h5 id="（6）HDFS架构"><a href="#（6）HDFS架构" class="headerlink" title="（6）HDFS架构"></a>（6）HDFS架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109301755744.jpeg" alt="HDFS 1.0 架构图"></p><ul><li><p>Namenode负责存储元数据而Datanode负责存储实际的数据。执行任何任务，客户端都得和Namenode进行交互，因为Namenode是整个集群的中心</p></li><li><p>Datanode是把数据存储在本地磁盘的，它会定期给Namenode发送心跳信息，以此来表明自己处在工作状态，Datanode还会根据副本因子负责把block拷贝到其他Datanode</p></li></ul><h4 id="2-大数据处理框架"><a href="#2-大数据处理框架" class="headerlink" title="2.大数据处理框架"></a>2.大数据处理框架</h4><h5 id="（1）Mapreduce"><a href="#（1）Mapreduce" class="headerlink" title="（1）Mapreduce"></a>（1）Mapreduce</h5><p>MapReduce 是 Hadoop 生态下面的计算层，它把任务分割成小任务并分发到集群的机器上并行执行，其分为Map和Reduce两个阶段</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109302309030.png" alt="img"></p><p>map和reduce进程在分布式集群中启动过程如下：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109302313905.png" alt="img"></p><h5 id="（2）Hive"><a href="#（2）Hive" class="headerlink" title="（2）Hive"></a>（2）Hive</h5><p>Hive 是一个架构在 Hadoop 之上的数据仓库基础工具，它可以处理结构化和半结构化数据，它使得查询和分析存储在 Hadoop 上的数据变得非常方便</p><p>有了 Hive，你只要开发简单的 SQL 查询就可以达到 MapReduce 作业同样的查询功能</p><p><img src="https://www.hadoopdoc.com/media/editor/file_1570081501000_20191003134501543078.png" alt="Hive架构组件"></p><h5 id="（3）Spark"><a href="#（3）Spark" class="headerlink" title="（3）Spark"></a>（3）Spark</h5><p>Spark 是一种高效且多用途的集群计算平台，它提供了一整套开发 API，包括流计算、机器学习或者SQL并支持支持批处理和流处理</p><p>Spark已经逐步替代MapReduce、Hive、Storm 等传统的大数据计算框架</p><p><img src="https://www.hadoopdoc.com/media/editor/file_1571152729000_20191015231852727918.png" alt="spark运行架构及流程"></p><p>Spark应用程序涉及了driver，master，worker三个节点：</p><ul><li>Driver：运行Application的main函数并创建SparkContext（运行环境），Driver同时负责将SparkContext关闭</li><li>Worker：集群中任何一个可以运行spark应用代码的节点</li><li>Executor：一个应用程序运行的监控和执行容器</li></ul><h5 id="（4）Flink"><a href="#（4）Flink" class="headerlink" title="（4）Flink"></a>（4）Flink</h5><p>参考资料：<a href="https://flink.apache.org/zh/">Apache Flink</a></p><p>Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算</p><p>作为流式数据流执行引擎，针对数据流的分布式计算提供数据分布，数据通信以及容错机制等功能。同时Flink也提供了机器学习库，图计算库等</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109302330786.png" alt="image-20210930233007590"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109302345178.jpeg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p&gt;抓住9月的尾巴，终于整理完毕🥳。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发原理" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="开发原理" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="深度系列" scheme="https://autovy.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java|SpringCloud + Netflix OSS Demo</title>
    <link href="https://autovy.github.io/2021/09/20/Java/Java-SpringCloud/"/>
    <id>https://autovy.github.io/2021/09/20/Java/Java-SpringCloud/</id>
    <published>2021-09-20T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.174Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109201109518.png" alt="image-20210920110949198"></p><p>Netflix OSS已在新版的SpringCloud中移除了，SpringCloud Netflix已经落后版本了🤯，但是不妨通过其掌握微服务的思想，理解SpringCloud的核心思想，核心组件</p><span id="more"></span><h4 id="分布式与集群"><a href="#分布式与集群" class="headerlink" title="分布式与集群"></a>分布式与集群</h4><h5 id="（1）微服务概念"><a href="#（1）微服务概念" class="headerlink" title="（1）微服务概念"></a>（1）微服务概念</h5><p>微服务简单来说，一个springboot就是一个微服务，不同的是这个springboot只做一项单纯的任务</p><h5 id="（2）服务注册"><a href="#（2）服务注册" class="headerlink" title="（2）服务注册"></a>（2）服务注册</h5><p>springcloud有个微服务注册中eureka server，通过它把微服务注册起来以供来调用</p><h5 id="（3）服务访问"><a href="#（3）服务访问" class="headerlink" title="（3）服务访问"></a>（3）服务访问</h5><p>微服务直接可以通过注册中心的定位相互访问</p><h5 id="（4）分布式概念"><a href="#（4）分布式概念" class="headerlink" title="（4）分布式概念"></a>（4）分布式概念</h5><p> 简单说，原来是在一个 springboot里就完成的事情，现在分布在多个 springboot里做，这就是初步具备分布式雏形了</p><ul><li>如果我要更新数据微服务，视图微服务是不受影响的</li><li>可以让不同的团队开发不同的微服务，他们之间只要约定好接口，彼此之间是低耦合的。</li><li>如果视图微服务挂了，数据微服务依然可以继续使用<br>等等</li></ul><h5 id="（5）集群"><a href="#（5）集群" class="headerlink" title="（5）集群"></a>（5）集群</h5><p>提供相同功能，只是端口不一样的微服务称为集群</p><ul><li>比起一个 springboot, 两个springboot 可以分别部署在两个不同的机器上，那么理论上来说，能够承受的负载就是 x 2. 这样系统就具备通过横向扩展而提高性能的机制</li><li>如果 8001 挂了，还有 8002 继续提供微服务，这就叫做高可用 </li></ul><h4 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h4><p>参考资料：<a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构</a></p><h5 id="（1）单体架构"><a href="#（1）单体架构" class="headerlink" title="（1）单体架构"></a>（1）单体架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121533917.png" alt="image-20210912153357714"></p><p>典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层</p><h5 id="（2）分布式架构"><a href="#（2）分布式架构" class="headerlink" title="（2）分布式架构"></a>（2）分布式架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121532105.png" alt="img"></p><p>将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上</p><h5 id="（3）微服务架构"><a href="#（3）微服务架构" class="headerlink" title="（3）微服务架构"></a>（3）微服务架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121533619.png" alt="img"></p><p>将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用</p><h5 id="（4）SpringCloud组成"><a href="#（4）SpringCloud组成" class="headerlink" title="（4）SpringCloud组成"></a>（4）SpringCloud组成</h5><p>SpringCloud 就是一套工具，帮助我们很容易地搭建出这么一个 集群和分布式的架子出来，Spring Cloud 专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121619055.png" alt="img"></p><ul><li>Spring Cloud Netflix：cloud各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的主要有组成有Eureka, Hystrix, Zuul</li><li>Eureka注册中心服务：SpringCloud服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移</li><li>Microservice：微服务，在springcloud可以简单理解为专职做一项任务的springboot，微服务之间可以通过Ribbon和Feign两种方式进行微服务之间的访问（Feign是主流方式）</li><li>Zipkin链路跟踪：从属于Spring Cloud Sleuth（日志收集工具包），为SpringCloud应用实现了一种分布式追踪解决方案，可以查看微服务之间的复杂的调用关系</li><li>Config Server 配置服务器：俗称配置中心，配置管理工具包，让你可以把配置放到远程服务器（比如集中放在git），集中化管理集群配置</li><li>Bus 消息总线：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Config Server 联合，再使用RabbitMQ实现热部署（所谓热部署即不需要重启微服务，对配置信息自动更新）</li><li>断路器Hystrix：容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力，简单来说就是提供异常或错误的处理微服务，比如说某个微服务寄了，断路器就可以调用其他微服务顶上（一般是错误处理的微服务）</li><li>Hystrix dashboard 断路器监控：通过turbine将集群中多个实例汇聚在一起，对微服务进行断路器监控</li><li>网关Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架，通过网关简化了对各个服务的访问：不再需要记录各个微服务的地址和端口，而是通过网关去访问他们</li></ul><h4 id="Springcloud-启动测试"><a href="#Springcloud-启动测试" class="headerlink" title="Springcloud 启动测试"></a>Springcloud 启动测试</h4><h5 id="（1）项目启动"><a href="#（1）项目启动" class="headerlink" title="（1）项目启动"></a>（1）项目启动</h5><ul><li><p>启动RabbitMQ（访问<a href="http://127.0.0.1:15672/#">http://127.0.0.1:15672/#</a> 即已开启）</p></li><li><p>启动链路追踪服务器（这里开启的端口要与微服务中的配置一致）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin-server-2.10.1-exec.jar  --server.port=8050 --zipkin.collector.rabbitmq.addresses=localhost</span><br></pre></td></tr></table></figure></li><li><p>访问配置仓库<a href="https://github.com/Autovy/SpringCloudConfig/">https://github.com/Autovy/SpringCloudConfig/</a> （也可以在config-server模块的配置文件修改成自己的仓库）</p></li><li><p>运行EurekaServerApplication，启动注册中心服务（端口为8761）</p></li><li><p>运行ConfigServerApplication，启动配置服务器（端口为8030）</p></li><li><p>运行ProductDataServiceApplication，启动数据微服务（端口填写8001，8002形成集群）</p></li><li><p>运行ProductViewServiceFeignApplication，启动视图微服务（端口可填写8012，8013）</p></li><li><p>运行ProductServiceHystrixDashboardApplication，开启断路器监控，监控单个微服务（端口为8020）</p></li><li><p>运行ProductServiceTurbineApplication，开启聚合断路器监控以监控集群（端口为8021）</p></li><li><p>运行视图微服务里的 AccessViewService 来周期性地访问 <code>http://127.0.0.1:8012/products</code> 和 <code>http://127.0.0.1:8013/products</code>，以提供监控数据</p></li><li><p>运行ProductServiceZuulApplication，开启网关服务（端口为8060）</p></li></ul><h5 id="（2）测试服务注册中心"><a href="#（2）测试服务注册中心" class="headerlink" title="（2）测试服务注册中心"></a>（2）测试服务注册中心</h5><p>打开链接<a href="http://127.0.0.1:8761/">http://127.0.0.1:8761/</a>   ，即可查看到注册服务中心Eureka</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191356386.png" alt="image-20210919135602819"></p><h5 id="（3）测试数据微服务"><a href="#（3）测试数据微服务" class="headerlink" title="（3）测试数据微服务"></a>（3）测试数据微服务</h5><p>打开链接<a href="http://127.0.0.1:8001/products">http://127.0.0.1:8001/products</a> 和 <a href="http://127.0.0.1:8002/products">http://127.0.0.1:8002/products</a> 都可以访问到返回的数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><h5 id="（4）测试视图微服务"><a href="#（4）测试视图微服务" class="headerlink" title="（4）测试视图微服务"></a>（4）测试视图微服务</h5><p>打开链接<a href="http://127.0.0.1:8012/products">http://127.0.0.1:8012/products</a> 和 <a href="http://127.0.0.1:8013/products">http://127.0.0.1:8013/products</a> 可以访问到视图页面，并且可以发现视图微服务会随机选择端口访问数据微服务实现负载均衡</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191401332.png" alt="image-20210919140106927"></p><h5 id="（5）测试服务链路追踪"><a href="#（5）测试服务链路追踪" class="headerlink" title="（5）测试服务链路追踪"></a>（5）测试服务链路追踪</h5><p>打开链接<a href="http://127.0.0.1:8050/zipkin/dependency/">http://127.0.0.1:8050/zipkin/dependency/</a>  即可访问到</p><p>Zipkin链路跟踪服务页面，即可看到微服务间的访问关系</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191404204.png" alt="image-20210919140414948"></p><h5 id="（6）测试Bus消息总线"><a href="#（6）测试Bus消息总线" class="headerlink" title="（6）测试Bus消息总线"></a>（6）测试Bus消息总线</h5><p>可访问<a href="http://127.0.0.1:8030/version/dev">http://127.0.0.1:8030/version/dev</a> 查看到配置服务器的信息</p><p>访问视图查看当前版本号</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191407817.png" alt="image-20210919140727703"></p><p>修改配置服务器git上的版本号，这里我的仓库地址为<a href="https://github.com/Autovy/SpringCloudConfig/">https://github.com/Autovy/SpringCloudConfig/</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191411510.png" alt="image-20210919141137143"></p><p>启动视图微服务中的FreshConfigUtil使用 post 的方式访问 <a href="http://localhost:8012/actuator/bus-refresh">http://localhost:8012/actuator/bus-refresh</a>  地址，更新配置信息</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191414604.png" alt="image-20210919141416336"></p><p>最后再查看视图上的更新</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191415873.png" alt="image-20210919141503558"></p><p>可以访问RabbitMQ页面：<a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a> ，查看队列，连接，还有交换机</p><h5 id="（7）测试Hystrix断路器及其监控"><a href="#（7）测试Hystrix断路器及其监控" class="headerlink" title="（7）测试Hystrix断路器及其监控"></a>（7）测试Hystrix断路器及其监控</h5><p>打开链接<a href="http://localhost:8020/hystrix">http://localhost:8020/hystrix</a> 即可进入Hystrix断路器的监控入口</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191417418.png" alt="image-20210919141754328"></p><p>框内输入<a href="http://localhost:8012/actuator/hystrix.stream">http://localhost:8012/actuator/hystrix.stream</a> 即可对8012端口的视图微服务进行监控</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191419460.png" alt="image-20210919141940229"></p><p>框内输入<a href="http://localhost:8021/turbine.stream">http://localhost:8021/turbine.stream</a> 即可实现对整个集群的视图微服务进行监控</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191421059.png" alt="image-20210919142137829"></p><p><strong>停止数据微服务</strong>ProductDataServiceApplication集群，触发断路器：</p><p>访问视图可得</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191429890.png" alt="image-20210919142903819"></p><p>访问单个微服务监控页面可得</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191432572.png" alt="image-20210919143250565"></p><p>访问聚合集群微服务监控页面可得</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191431299.png" alt="image-20210919143120242"></p><h5 id="（8）网关测试"><a href="#（8）网关测试" class="headerlink" title="（8）网关测试"></a>（8）网关测试</h5><p>可以在zuul的配置文件中修改微服务的访问路由，我绑定的路由如下：</p><p><a href="http://localhost:8060/api-data/products">http://localhost:8060/api-data/products</a>  ：访问数据微服务集群</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><p><a href="http://localhost:8060/api-view/products">http://localhost:8060/api-view/products</a>  ：访问视图微服务集群</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191426987.png" alt="image-20210919142625877"></p><p>可以发现其访问集群的端口也是负载均衡的</p><h4 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h4><h5 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>通过服务注册中心管理微服务，并且让微服务直接可以相互定位交流</p><h5 id="（2）相关依赖"><a href="#（2）相关依赖" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        添加eureka服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置"><a href="#（3）相关配置" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eureka服务配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sring微服务模块命名</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>hostname: localhost 表示主机名称</li><li>registerWithEureka：false 表示是否注册到服务器。 因为它本身就是服务器，所以就无需把自己注册到服务器</li><li>fetchRegistry: false 表示是否获取服务器的注册信息，和上面同理，这里也设置为 false</li><li>defaultZone： <code>http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</code> 自己作为服务器，公布出来的地址。 比如后续某个微服务要把自己注册到 eureka server, 那么就要使用这个地址： <a href="http://localhost:8761/eureka/">http://localhost:8761/eureka/</a></li></ul><h5 id="（4）服务启动"><a href="#（4）服务启动" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 注解标注为Eureka服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8761</span>;</span><br><span class="line">        <span class="comment">// 启动EurekaServer管理页面</span></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(EurekaServerApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><h5 id="（1）需求-1"><a href="#（1）需求-1" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>微服务要做集群，这就意味着，会有多个微服务实例。 在业务上有时候需要修改一些配置信息，比如说 版本信息，倘若没有配置服务， 那么就需要挨个修改微服务，挨个重新部署微服务，这样就比较麻烦。</p><p>我们可以把这些配置信息放在一个公共的地方，比如git，然后通过配置服务器把它获取下来，然后微服务再从配置服务器上取下来</p><h5 id="（2）git准备"><a href="#（2）git准备" class="headerlink" title="（2）git准备"></a>（2）git准备</h5><p>在github上新建仓库，并创建respo目录，在目录下添加 product-view-service-feign-dev.properties文件并写入版本信息</p><p>如我创建的仓库：<a href="https://github.com/Autovy/SpringCloudConfig">https://github.com/Autovy/SpringCloudConfig</a></p><h5 id="（3）相关依赖"><a href="#（3）相关依赖" class="headerlink" title="（3）相关依赖"></a>（3）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- eureka客户端注册依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot web支持 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置服务支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（4）相关配置"><a href="#（4）相关配置" class="headerlink" title="（4）相关配置"></a>（4）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务名与配置服务器的配置信息（这里用git作为配置服务器）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/Autovy/SpringCloudConfig/</span> <span class="comment">#github仓库地址</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">respo</span>  <span class="comment"># 仓库下的目录</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">main</span>  <span class="comment"># 分支名改为了main</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h5 id="（5）服务启动"><a href="#（5）服务启动" class="headerlink" title="（5）服务启动"></a>（5）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span>  <span class="comment">// 注解标注为Eureka客户端，实现注册</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span>  <span class="comment">// 使用该注解表明该springboot是个配置服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8030</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ConfigServerApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span>+port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="（1）-RabbitMQ的介绍"><a href="#（1）-RabbitMQ的介绍" class="headerlink" title="（1） RabbitMQ的介绍"></a>（1） RabbitMQ的介绍</h5><p>通过RabbitMQ与消息总线Bus实现配置服务器热部署即自动更新配置信息</p><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p><code>AMQP</code>(<code>Advanced Message Queuing Protocol</code>)，顾名思义，它是一个消息协议，能够使得遵循该协议的客户端和消息中间件(<code>Broker</code>)进行通讯</p><h5 id="（2）RabbitMQ安装"><a href="#（2）RabbitMQ安装" class="headerlink" title="（2）RabbitMQ安装"></a>（2）RabbitMQ安装</h5><p>首先要安装erlang，并配置环境，才继续安装RabbitMQ</p><p>配置插件后重启RabbitMQ</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109160921566.png" alt="image-20210916092150386"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109160922543.png" alt="image-20210916092243391"></p><h5 id="（3）RabbitMQ页面无法访问问题"><a href="#（3）RabbitMQ页面无法访问问题" class="headerlink" title="（3）RabbitMQ页面无法访问问题"></a>（3）RabbitMQ页面无法访问问题</h5><p>一般来说开启了RabbitMQ服务后，可以通过链接<a href="http://127.0.0.1:15672/进行访问">http://127.0.0.1:15672/进行访问</a></p><p>如果页面无法访问到，可以自行下列语句重新生成相关配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop rabbitmq &amp;&amp; rabbitmq-server -detached &amp;&amp; net start rabbitmq</span><br></pre></td></tr></table></figure><p>这样即可访问到RabbitMQ的页面（用户与密码默认为guest/guest）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109160935154.png" alt="image-20210916093536018"></p><h5 id="（4）消息路由过程"><a href="#（4）消息路由过程" class="headerlink" title="（4）消息路由过程"></a>（4）消息路由过程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109160946397.png" alt="image-20210916094610081"></p><p>消息<code>(message)</code>发布给交换机<code>(Exchange)</code></p><p><code>Exchange</code>相当于邮局或者信箱，它接收到消息后会根据不同的规则(称为<code>Bindings</code>)来确定要发给哪个队列<code>(queue)</code></p><p>最后AMQP代理会将消息投递给订阅了此队列的消费者，或者是消费者依据需求自行获取</p><h5 id="（5）模式分类"><a href="#（5）模式分类" class="headerlink" title="（5）模式分类"></a>（5）模式分类</h5><p>RabbitMQ提供了四种Exchange模式：fanout,direct,topic,header 。header在实际使用中很少用到，故我们只介绍前面三种</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109160953038.png" alt="img"></p><ul><li>Direct 模式就是指定队列模式， 消息来了，只发给指定的 Queue, 其他Queue 都收不到</li><li>Topic 模式就是主题模式，Queue 按照某种主题分类接收消息</li><li>Fanout 模式就是广播模式，消息来了，会发给所有的队列</li></ul><p>在本项目中，我们让config-server去git获取最新配置信息，并将该信息广播给集群中的所有视图微服务</p><h4 id="断路器监控"><a href="#断路器监控" class="headerlink" title="断路器监控"></a>断路器监控</h4><h5 id="（1）需求-2"><a href="#（1）需求-2" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>前面我们了解了断路器， 当数据服务不可用的时候， 断路器就会发挥作用</p><p>而我们可以使用断路器监控来可视化断路器运行情况</p><h5 id="（2）相关依赖-1"><a href="#（2）相关依赖-1" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在eureka注册微服务依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加web支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息总线依赖，用于访问路径/actuator/bus-refresh --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 增加断路器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 增加断路器依赖监控面板依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-1"><a href="#（3）相关配置-1" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务并命名</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hystrix-dashboard</span></span><br></pre></td></tr></table></figure><h5 id="（4）服务启动-1"><a href="#（4）服务启动-1" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceHystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8020</span>;</span><br><span class="line">        <span class="keyword">if</span>(!NetUtil.isUsableLocalPort(port)) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;端口%d被占用了，无法启动%n&quot;</span>, port );</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造服务</span></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductServiceHystrixDashboardApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断路器聚合监控"><a href="#断路器聚合监控" class="headerlink" title="断路器聚合监控"></a>断路器聚合监控</h4><h5 id="（1）需求-3"><a href="#（1）需求-3" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>上面的内容只能针对一个微服务进行断路器监控，但是一个微服务通常由多个实例组成，监控起来十分不方便；springcloud提供了turbine可以把一个集群里的多个实例汇聚在一个turbine里，这样就能够在集群层面进行监控了</p><h5 id="（2）相关依赖-2"><a href="#（2）相关依赖-2" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在eureka注册微服务依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息总线依赖，用于访问路径/actuator/bus-refresh --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加断路器依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加断路器依赖监控面板依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加turbine --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-2"><a href="#（3）相关配置-2" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">turbine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置turbine</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line">  <span class="attr">aggregator:</span></span><br><span class="line">    <span class="attr">cluster-config:</span> <span class="string">default</span></span><br><span class="line">  <span class="comment"># 配置Eureka中的serviceId列表，表明监控哪些服务</span></span><br><span class="line">  <span class="comment">#（这样就会把微服务名称为product-view-service-feign的实例信息收集起来）</span></span><br><span class="line">  <span class="attr">app-config:</span> <span class="string">product-view-service-feign</span></span><br><span class="line">  <span class="attr">cluster-name-expression:</span> <span class="string">new</span> <span class="string">String(&quot;default&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应（注册）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h5 id="（4）服务启动-2"><a href="#（4）服务启动-2" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span> <span class="comment">// 开启Turbine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceTurbineApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8021</span>;</span><br><span class="line">        <span class="keyword">if</span>(!NetUtil.isUsableLocalPort(port))&#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;端口%d被占用，无法启动%n&quot;</span>, port);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductServiceTurbineApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span>+ port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网关Zuul"><a href="#网关Zuul" class="headerlink" title="网关Zuul"></a>网关Zuul</h4><h5 id="（1）需求-4"><a href="#（1）需求-4" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>微服务有可能放在不同的 ip 地址上，有可能是不同的端口</p><p>为了访问他们，就需要记录这些地址和端口。 而地址和端口都可能会变化，这就增加了访问者的负担</p><p>这时候我们就可以通过网关简化对微服务的访问，仅需要一个地址一个端口就可以实现对一个微服务集群的访问</p><h5 id="（2）相关依赖-3"><a href="#（2）相关依赖-3" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 微服务注册中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web服务支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 增加zuul网关 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-3"><a href="#（3）相关配置-3" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product-service-zuul</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应（注册）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对zuul进行路由映射</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">api-a:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/api-data/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">PRODUCT-DATA-SERVICE</span></span><br><span class="line">    <span class="attr">api-b:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/api-view/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">PRODUCT-VIEW-SERVICE-FEIGN</span></span><br></pre></td></tr></table></figure><h5 id="（4）服务启动-3"><a href="#（4）服务启动-3" class="headerlink" title="（4）服务启动"></a>（4）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 网关服务</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 注册服务客户端</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8060</span>;</span><br><span class="line">        <span class="keyword">if</span>(!NetUtil.isUsableLocalPort(port))&#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;端口%d被占用了，无法启动%d&quot;</span>, port);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductServiceZuulApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据微服务"><a href="#数据微服务" class="headerlink" title="数据微服务"></a>数据微服务</h4><h5 id="（1）需求-5"><a href="#（1）需求-5" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>访问数据库为视图微服务提供数据（在本项目中为了配置方便，不设dao层直接在service层提供假数据），真正意义上完整的springboot</p><h5 id="（2）相关依赖-4"><a href="#（2）相关依赖-4" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web服务用于提供控制层 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--增加zipkin，使服务可以被追踪到--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-4"><a href="#（3）相关配置-4" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务名与配置服务链路追踪</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product-data-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:8050</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中性的地址要与Eureka的配置对应</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h5 id="（4）实体类"><a href="#（4）实体类" class="headerlink" title="（4）实体类"></a>（4）实体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 默认构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用该构造方法，可以声明一个由默认值的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）服务层"><a href="#（5）服务层" class="headerlink" title="（5）服务层"></a>（5）服务层</h5><p>不接入dao层，直接在服务层提供假数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务层（这里不接入dao层，而是提供假数据）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得配置中的端口号</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    String port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; ps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 提供假数据，list方法没有对应dao层相应的数据库操作方法</span></span><br><span class="line">        ps.add(<span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;product a from port:&quot;</span>+port, <span class="number">50</span>));</span><br><span class="line">        ps.add(<span class="keyword">new</span> Product(<span class="number">2</span>,<span class="string">&quot;product b from port:&quot;</span>+port, <span class="number">150</span>));</span><br><span class="line">        ps.add(<span class="keyword">new</span> Product(<span class="number">3</span>,<span class="string">&quot;product c from port:&quot;</span>+port, <span class="number">250</span>));</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）控制层"><a href="#（6）控制层" class="headerlink" title="（6）控制层"></a>（6）控制层</h5><p>接入服务层并映射路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自动装配服务层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射url路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/products&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">products</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用服务层的方法</span></span><br><span class="line">        List&lt;Product&gt; ps = productService.list();</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（7）服务启动"><a href="#（7）服务启动" class="headerlink" title="（7）服务启动"></a>（7）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 服务注册中心客户端，微服务注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDataServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让用户输入端口号，开启多个服务形成集群</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入开启服务的端口号：&quot;</span>);</span><br><span class="line">        Scanner strpost = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        port = strpost.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动ProductDataService服务</span></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductDataServiceApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置zipkin:在启动类里配置 Sampler 抽样策略： ALWAYS_SAMPLE 表示持续抽样*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sampler <span class="title">defaultSampler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sampler.ALWAYS_SAMPLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视图微服务"><a href="#视图微服务" class="headerlink" title="视图微服务"></a>视图微服务</h4><h5 id="（1）需求-6"><a href="#（1）需求-6" class="headerlink" title="（1）需求"></a>（1）需求</h5><p>访问数据微服务（这里主要用feign的方式），将数据发送到视图层展示</p><h5 id="（2）相关依赖-5"><a href="#（2）相关依赖-5" class="headerlink" title="（2）相关依赖"></a>（2）相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务注册依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持 Feign 方式的微服务访问--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web支持依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图层依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--增加zipkin，使服务可以被追踪到--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加一个 spring-cloud-starter-config 用于访问配置服务器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息总线依赖，用于访问路径/actuator/bus-refresh --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于支持rabbitmq --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于支持断路器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（3）相关配置-5"><a href="#（3）相关配置-5" class="headerlink" title="（3）相关配置"></a>（3）相关配置</h5><p>这里的微服务由于要通过rabbitMQ访问到配置服务器，需要系统层面上的配置，故需要两个配置文件：<strong>bootstrap.yml 和 application.yml</strong></p><p>参考资料：<a href="https://www.jianshu.com/p/c955c44ae534">application.yml与bootstrap.yml的区别</a></p><ul><li>bootstrap.yml 和 application.yml 都可以用来配置参数</li><li>bootstrap.yml 用来程序引导时执行，应用于更加早期配置信息读取。可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。一旦bootStrap.yml 被加载，则内容不会被覆盖</li><li>application.yml 可以用来定义应用级别的， 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等</li></ul><p><strong>bootstrap.yml文件</strong></p><p>主要提供了 serviceId: config-server, 这个是配置服务器在 eureka server 里的服务名称，这样就可以定位 config-server了</p><p>在注册服务中心的注册也移到了bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 config-server（服务端）的信息</span></span><br><span class="line"><span class="attr">spring :</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line">    <span class="comment"># 增加总线配置</span></span><br><span class="line">    <span class="attr">bus:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">trace:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 新增rabbitMQ配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置注册中心的地址要与Eureka的配置对应（注册）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>application.yml文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置微服务名与配置服务链路追踪</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">product-view-service-feign</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:8050</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 配置thymeleaf</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">servlet:</span></span><br><span class="line">      <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启断路器</span></span><br><span class="line"><span class="attr">feign.hystrix.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增路径访问允许，这样才能访问 /actuator/bus-refresh,用于访问配置服务器更新配置信息</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">      <span class="attr">cors:</span></span><br><span class="line">        <span class="attr">allowed-origins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="attr">allowed-methods:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（4）实体类-1"><a href="#（4）实体类-1" class="headerlink" title="（4）实体类"></a>（4）实体类</h5><p>与数据微服务的一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）客户端"><a href="#（5）客户端" class="headerlink" title="（5）客户端"></a>（5）客户端</h5><p>视图微服务作为客户端去访问数据微服务这个服务端，并利用断路器提供访问失败后的异常处理信息</p><p><strong>Feign客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Feign 客户端， 通过 注解方式访问PRODUCT-DATA-SERVICE服务的 products路径</span></span><br><span class="line"><span class="comment">// 如果访问的 PRODUCT-DATA-SERVICE 不可用的话，就调用 ProductClientFeignHystrix 来进行反馈信息</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;, fallback = ProductClientFeignHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClientFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;products&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hystrix断路器处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了 ProductClientFeign 接口，并提供了 list() 方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductClientFeignHystrix</span> <span class="keyword">implements</span>  <span class="title">ProductClientFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> Product(<span class="number">0</span>, <span class="string">&quot;产品数据微服务不可用&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）服务层"><a href="#（6）服务层" class="headerlink" title="（6）服务层"></a>（6）服务层</h5><p>接入客户端，自动装配客户端请求到的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductClientFeign productClientFeign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务类的数据从ProductClientRibbon（客户端）中获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productClientFeign.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（7）控制层"><a href="#（7）控制层" class="headerlink" title="（7）控制层"></a>（7）控制层</h5><p>接入服务层，映射访问路径，发送数据到视图层并输出视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在配置服务器获得版本号</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;version&#125;&quot;)</span></span><br><span class="line">    String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制器将数据放入product.html</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/products&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">products</span><span class="params">(Model m)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Product&gt; ps = productService.list();</span><br><span class="line">        <span class="comment">// 发送到视图</span></span><br><span class="line">        m.addAttribute(<span class="string">&quot;version&quot;</span>, version);</span><br><span class="line">        m.addAttribute(<span class="string">&quot;ps&quot;</span>, ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;products&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（8）视图层"><a href="#（8）视图层" class="headerlink" title="（8）视图层"></a>（8）视图层</h5><p>使用thymeleaf可接入java动态化数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>products<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">table</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-collapse</span>:collapse;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>:<span class="number">20px</span> auto;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">td</span>,<span class="selector-tag">th</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>:<span class="number">1px</span> solid gray;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;workingArea&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>产品名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;p: $&#123;ps&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;p.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;p.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;p.price&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;version&#125;&quot;</span> &gt;</span>how2j springcloud version unknown<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（9）网络访问"><a href="#（9）网络访问" class="headerlink" title="（9）网络访问"></a>（9）网络访问</h5><p><strong>更新配置信息</strong></p><p>使用 post 的方式访问配置服务器的 <a href="http://localhost:8012/actuator/bus-refresh">http://localhost:8012/actuator/bus-refresh</a> 地址，用于更新配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 post 的方式访问 http://localhost:8012/actuator/bus-refresh 地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshConfigUntil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 增加请求头</span></span><br><span class="line">          HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          headers.put(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 因为要去git获取，还要刷新config-server, 会比较卡，所以一般会要好几秒才能完成</span></span><br><span class="line">          System.out.println(<span class="string">&quot;请耐心等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 发送post请求</span></span><br><span class="line">          String result = HttpUtil.createPost(<span class="string">&quot;http://localhost:8012/actuator/bus-refresh&quot;</span>)</span><br><span class="line">                  .addHeaders(headers).execute().body();</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">&quot;result&quot;</span> + result);</span><br><span class="line">          System.out.println(<span class="string">&quot;refresh 完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提供监控数据</strong></p><p>不断对视图层进行访问，以提供断路器监控的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个不断访问视图服务的类，以便在监控中观察到现象</span></span><br><span class="line"><span class="comment">// 访问集群的8012和8013端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessViewService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">            access(<span class="number">8012</span>);</span><br><span class="line">            access(<span class="number">8013</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String html = HttpUtil.get(String.format(<span class="string">&quot;http://127.0.0.1:%d/products&quot;</span>, port));</span><br><span class="line">            System.out.println(<span class="string">&quot;html length:&quot;</span> + html.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d地址的视图服务无法访问%n&quot;</span>, port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（10）服务启动"><a href="#（10）服务启动" class="headerlink" title="（10）服务启动"></a>（10）服务启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 注册服务中信息注册客户端</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>   <span class="comment">//表明使用Feign方式</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span> <span class="comment">// 共享信息给断路监控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductViewServiceFeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加rabbitmq是否启动判断</span></span><br><span class="line">        <span class="keyword">int</span> rabbitMQPort = <span class="number">5672</span>;</span><br><span class="line">        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(rabbitMQPort))&#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;未在端口%d发现rabbitMQ服务，请检查&quot;</span>, rabbitMQPort);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让用户输入端口号，开启多个服务形成集群</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入开启服务的端口号：&quot;</span>);</span><br><span class="line">        Scanner strpost = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        port = strpost.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ProductViewServiceFeignApplication.class)</span><br><span class="line">                .properties(<span class="string">&quot;server.port=&quot;</span> + port)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置zipkon:在启动类里配置 Sampler 抽样策略： ALWAYS_SAMPLE 表示持续抽样*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sampler <span class="title">defaultSampler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sampler.ALWAYS_SAMPLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109201109518.png&quot; alt=&quot;image-20210920110949198&quot;&gt;&lt;/p&gt;
&lt;p&gt;Netflix OSS已在新版的SpringCloud中移除了，SpringCloud Netflix已经落后版本了🤯，但是不妨通过其掌握微服务的思想，理解SpringCloud的核心思想，核心组件&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="开发实战" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="框架学习" scheme="https://autovy.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://autovy.github.io/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="https://autovy.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java|JavaWeb入门讲解</title>
    <link href="https://autovy.github.io/2021/09/14/Java/Java-JavaWeb%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>https://autovy.github.io/2021/09/14/Java/Java-JavaWeb%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-09-14T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.171Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109140841902.png" alt="pngkey.com-java-logo-png-2232144"></p><span id="more"></span><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学会本地搭建环境，运行springboot项目</li><li>了解javaweb开发基本技术与工具使用</li><li>了解spring重要概念</li><li>清楚基本的开发架构</li><li>学会开发Springboot入门实例</li><li>学会开发SpringBoot JPA 持久层支持实例</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://autovy.github.io/JavaWebDemo.zip">Demo下载</a></p><p><a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis中文文档</a></p><p><a href="https://lfvepclr.gitbooks.io/spring-framework-5-doc-cn/content/">Spring Framework 5 中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-documentation.html">SpringBoot中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/spring-cloud/Greenwich.RELEASE/reference/">SpringCloud中文文档</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰Java教程博客</a></p><p><a href="https://autovy.github.io/2021/06/30/Java/Java-%E5%9F%BA%E4%BA%8ESSM%E8%AF%84%E8%AE%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/">autovy博客：基于SSM评论管理系统开发</a></p><h3 id="基本工具的使用"><a href="#基本工具的使用" class="headerlink" title="基本工具的使用"></a>基本工具的使用</h3><h4 id="IDE推荐"><a href="#IDE推荐" class="headerlink" title="IDE推荐"></a>IDE推荐</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110902451.png" alt="image-20210911090207325"></p><p>推荐JetBrains公司的IDE全家桶，保持风格一致，减少对IDE的学习成本</p><p>使用<a href="https://www.jetbrains.com/toolbox-app/">toolbox</a>下载更方便</p><h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><p>使用构建工具管理java项目的依赖项并实现自动化构建</p><h5 id="（1）基本介绍"><a href="#（1）基本介绍" class="headerlink" title="（1）基本介绍"></a>（1）基本介绍</h5><p>Maven </p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110852517.png" alt="Apache_Maven_logo.svg"></p><p>Ant</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110848712.png" alt="1024px-Apache-Ant-logo.svg" style="zoom: 50%;"><p>Gradle</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110847529.png" alt="Gradle_logo"></p><h5 id="（2）比较"><a href="#（2）比较" class="headerlink" title="（2）比较"></a>（2）比较</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110854847.png" alt="image-20210911085448524"></p><ul><li>Ant：纯java编写，需要自定义构建过程</li><li>Maven：实现了自动化构建，并内置了依赖管理</li><li>Gradle：Gradle结合了前两者的优点，是Android Studio指定构建工具</li></ul><p>通过自动化构建工具，springboot大大减少了依赖项的添加工作</p><h5 id="（3）Maven结构"><a href="#（3）Maven结构" class="headerlink" title="（3）Maven结构"></a>（3）Maven结构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110937736.jpeg" alt="img"></p><h5 id="（4）Maven基本使用操作"><a href="#（4）Maven基本使用操作" class="headerlink" title="（4）Maven基本使用操作"></a>（4）Maven基本使用操作</h5><p>IDEA创建Maven项目：</p><ul><li>左边选择Maven</li><li>创建空Maven项目</li></ul><p>查看配置文件pom.xml：</p><p>配置jar包的仓库地址</p><p>maven的仓库默认在国外，这里可以更换为阿里云的仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> # 仓库地址       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加依赖项：</p><p>在mvnrepository查找依赖项：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p>查找并复制junit 4.12的依赖配置信息</p><p>增加依赖标签<code>&lt;dependencies&gt;</code>后</p><p>在idea中导入依赖项</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110954913.png" alt="image-20210911095458093"></p><p>查看外部库：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109110955224.png" alt="image-20210911095520948"></p><h4 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h4><p>Web服务器一般指网站服务器，是指驻留于[因特网]上某种类型计算机的程序，可以处理浏览器等Web客户端的请求并返回相应响应</p><h5 id="（1）Tomcat介绍"><a href="#（1）Tomcat介绍" class="headerlink" title="（1）Tomcat介绍"></a>（1）Tomcat介绍</h5><p>Java学习中常常使用<strong>Tomcat</strong>，这个个小型、轻量级的支持JSP和Servlet 技术的Web服务器，新版的springboot直接就内嵌了这个web服务器放在了启动项中</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111020941.png" alt="img" style="zoom: 25%;"><h5 id="（2）Tomcat下载"><a href="#（2）Tomcat下载" class="headerlink" title="（2）Tomcat下载"></a>（2）Tomcat下载</h5><p>新版的springboot已内嵌tomcat，不需要再下载，所以这块做简单的介绍，了解一下运行的原理就好</p><p>官网下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><h5 id="（3）Tomcat运行"><a href="#（3）Tomcat运行" class="headerlink" title="（3）Tomcat运行"></a>（3）Tomcat运行</h5><ul><li><p>新建文件html文件在webapps\www文件夹</p></li><li><p>启动bin/startup.bat</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111044774.png" alt="image-20210911104424694"></p></li><li><p>访问<code>http://127.0.0.1:8080/www/test.html</code></p></li></ul><p>tomcat的默认端口是8080端口，所以springboot启动的网页服务默认也是8080端口</p><h5 id="（4）Tomcat修改端口"><a href="#（4）Tomcat修改端口" class="headerlink" title="（4）Tomcat修改端口"></a>（4）Tomcat修改端口</h5><p>网页的默认端口使80端口</p><ul><li>查看文件<code>conf\server.xml</code></li><li>修改端口为80端口</li><li>重新启动bin/startup.bat</li><li>80端口占用问题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 参看端口号含80的条目</span><br><span class="line">netstat -ano|findstr &quot;80&quot;</span><br><span class="line"></span><br><span class="line">// 根据pid查询对应的应用程序</span><br><span class="line">tasklist|findstr &quot;1828&quot;</span><br><span class="line"></span><br><span class="line">// 杀死进程</span><br><span class="line">taskkill /f /pid 1828</span><br></pre></td></tr></table></figure><ul><li><p>如果是被系统占用，可以进入服务中心<code>services.msc</code>，停止或禁用SQL Server Reporting Services (MSSQLSERVER) （日志服务，一般用不上）</p></li><li><p>访问<code>http://127.0.0.1/www/test.html</code></p></li></ul><h4 id="本地数据库环境搭建"><a href="#本地数据库环境搭建" class="headerlink" title="本地数据库环境搭建"></a>本地数据库环境搭建</h4><h5 id="（1）PHPstudy介绍"><a href="#（1）PHPstudy介绍" class="headerlink" title="（1）PHPstudy介绍"></a>（1）PHPstudy介绍</h5><p>phpstudy集成了web服务（apache和nginx）,数据库服务（mysql），还有数据库缓存工具redis等。</p><p>能比较方便得搭建本地环境（如果没有docker进行容器化的话，确实是最佳选择）</p><p>下载地址：<a href="https://www.xp.cn/">https://www.xp.cn/</a></p><h5 id="（2）创建数据库"><a href="#（2）创建数据库" class="headerlink" title="（2）创建数据库"></a>（2）创建数据库</h5><p>这里使用mysql8.0.12版本</p><p>无代码创建好数据库</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111420500.png" alt="image-20210911142052336"></p><h5 id="（3）数据库连接"><a href="#（3）数据库连接" class="headerlink" title="（3）数据库连接"></a>（3）数据库连接</h5><p>在idea中连接数据库，测试连接后出现时区问题则填写<code>GMT</code>等时区,推荐使用<code>serverTimezone=Asia/Shanghai</code></p><p>创建数据表student，可在类型处填入长度例如<code>char(20)</code></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111444220.png" alt="image-20210911144428199"></p><h3 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h3><p>Java EE是一系列技术标准所组成的平台，它定义了动态Web页面功能（Servlet和Jsp）、商业组件（EJB）、异步消息传输机制（JMS）、名称和目录定位服务（JNDI）、数据库访问（JDBC）、与子系统的连接器（JCA）和安全服务等</p><p>这里主要介绍Servlet（服务端程序，可处理请求生成动态web内容），JDBC（数据库访问连接），java的web开发框架都是在此基础上的延拓</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109132024561.png" alt="image-20210913202431607"></p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><h5 id="（1）浏览器访问Servlet流程"><a href="#（1）浏览器访问Servlet流程" class="headerlink" title="（1）浏览器访问Servlet流程"></a>（1）浏览器访问Servlet流程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111454488.png" alt="image-20210911145431318"></p><h5 id="（2）Servlet-demo-开发"><a href="#（2）Servlet-demo-开发" class="headerlink" title="（2）Servlet demo 开发"></a>（2）Servlet demo 开发</h5><p>1.新建一个空maven的项目</p><p>2.maven导入Servlet依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.编写Servlet类</p><p>编写Servlet类接收请求，返回内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Servlet提供的http处理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写doGet方法，处理get请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉http请求异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 返回响应输出到页面</span></span><br><span class="line">            response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Hello Servlet&lt;h1&gt;&quot;</span>);</span><br><span class="line">            response.getWriter().println(<span class="keyword">new</span> Date().toString());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.编写web.xml配置文件</p><p>编写web.xml配置Servlet</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111532343.png" alt="image-20210911153159249"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    配置servlet信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    配置http处理类与url映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.将Servlet部署到tomcat上</p><p>打开模块设置(F4) &gt;  工件  &gt;  创建web工件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111539001.png" alt="image-20210911153909470"></p><p>添加配置 &gt; tomcat本地服务器 &gt; 添加刚刚创建的工件 &gt; 注意修改应用程序上下文（影响访问的url）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111541291.png" alt="image-20210911154152177"></p><p>开启服务进行测试</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111556434.png" alt="image-20210911155646449"></p><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p><strong>JDBC</strong> (<strong>J</strong>ava <strong>D</strong>ata<strong>B</strong>ase <strong>C</strong>onnection) 是通过JAVA访问数据库</p><h5 id="（1）Java连接数据库流程"><a href="#（1）Java连接数据库流程" class="headerlink" title="（1）Java连接数据库流程"></a>（1）Java连接数据库流程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111653998.png" alt="undefined"></p><h5 id="（2）JDBC查询数据库开发"><a href="#（2）JDBC查询数据库开发" class="headerlink" title="（2）JDBC查询数据库开发"></a>（2）JDBC查询数据库开发</h5><p>1.新建一个空maven的项目</p><p>2.添加mysql-connector-java依</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.注意开启phpstudy的mysql服务，并在idea中连接，记录jdbc链接</p><p>4.编写JDBC查询demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 导入数据库驱动包</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立与数据库的连接</span></span><br><span class="line">            <span class="comment">// 数据库名称， 账号，密码</span></span><br><span class="line">            Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Statement，用于执行sql语句</span></span><br><span class="line">            Statement s = c.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 编写sql语句</span></span><br><span class="line">            String sql  = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行sql语句，并返回结果</span></span><br><span class="line">            ResultSet res = s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理返回结果</span></span><br><span class="line">            <span class="keyword">while</span>(res.next())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> id = res.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = res.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d.%s\n&quot;</span>, id, name);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库加载异常</span></span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库连接异常</span></span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）JDBC-ORM-持久化存储"><a href="#（3）JDBC-ORM-持久化存储" class="headerlink" title="（3）JDBC ORM 持久化存储"></a>（3）JDBC ORM 持久化存储</h5><p>ORM=Object Relationship Database Mapping</p><p>对象和关系数据库的映射 简单说，<strong>一个对象</strong>，对应数据库里的<strong>一条记录</strong>，使用Java对象来将数据库内的数据持久化</p><p>JDBC 是面向 SQL 的，使用起来比较繁琐。所以就有了 ORM 框架，建立了 Java 对象与数据库表之间的映射关系，可以通过直接操作对象来实现持久化，简化了操作的繁杂度</p><p>java目前流行的数据库访问框架都是ORM框架</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109132026779.jpeg" alt="img"></p><p>1.创建Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般将一个数据表抽象为一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将表中的字段作为类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供外界操作属性的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在idea中实体类的创建有以下三种方法：</p><ul><li><p>选定类的字段生成setter和getter方法</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109200954096.png" alt="image-20210920095441605"></p></li></ul><ul><li><p>使用数据库工具创建实体类</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041650556.png" alt="image-20210904165034192" style="zoom: 67%;"></li></ul><ul><li>使用Lombok工具自动生成getter和setter方法</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041657535.png" alt="image-20210904165746685"></p><p>2.修改demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 导入数据库驱动包</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立与数据库的连接</span></span><br><span class="line">            <span class="comment">// 数据库名称， 账号，密码</span></span><br><span class="line">            Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Statement，用于执行sql语句</span></span><br><span class="line">            Statement s = c.createStatement();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt; 修改sql语句</span></span><br><span class="line">            String sql  = <span class="string">&quot;select * from student where id = 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行sql语句，并返回结果</span></span><br><span class="line">            ResultSet res = s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  &gt;&gt;&gt;&gt;去掉while处理返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(res.next())&#123;</span><br><span class="line">                <span class="comment">//&gt;&gt;&gt;&gt;&gt;&gt; 实例化一个对象，用于存储一条数据</span></span><br><span class="line">                Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将数据库中的值存储在对象中</span></span><br><span class="line">                student.setId(res.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                student.setName(res.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                System.out.println(student);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库加载异常</span></span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 捕捉数据库连接异常</span></span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.打断点参看student对象</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111751277.png" alt="image-20210911175137132"></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring重要概念"><a href="#Spring重要概念" class="headerlink" title="Spring重要概念"></a>Spring重要概念</h4><p>参考资料：<a href="https://blog.csdn.net/qq_40587575/article/details/79901550">https://blog.csdn.net/qq_40587575/article/details/79901550</a></p><h5 id="（1）IoC与DI概念"><a href="#（1）IoC与DI概念" class="headerlink" title="（1）IoC与DI概念"></a>（1）IoC与DI概念</h5><p>IoC：</p><ul><li>Ioc—Inversion of Control，即“控制反转”</li><li>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制</li><li>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由<strong>IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找</strong></li></ul><table><thead><tr><th>Ioc特点</th><th>传统java程序</th><th>Ioc设计</th></tr></thead><tbody><tr><td>控制</td><td>在对象内部通过new进行创建对象，是程序主动去创建依赖对象</td><td>IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建</td></tr><tr><td>反转</td><td>由我们自己在对象中主动控制去直接获取依赖对象，也就是正转</td><td>反转则是由容器来帮忙创建及注入依赖对象，对象只是被动的接受依赖对象</td></tr></tbody></table><p>DI：</p><ul><li>DI—Dependency Injection，即“依赖注入”</li><li>组件之间依赖关系由容器在运行期决定，由容器动态的将某个依赖关系注入到组件之中</li><li>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现</li><li>“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”</li></ul><h5 id="（2）IoC与DI概念图例"><a href="#（2）IoC与DI概念图例" class="headerlink" title="（2）IoC与DI概念图例"></a>（2）IoC与DI概念图例</h5><p>传统的java程序</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109120728738.png" alt="image-20210912072844684"></p><p>使用了loC/DI的程序</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109120729641.png" alt="image-20210912072938515"></p><h5 id="（3）Spring的应用"><a href="#（3）Spring的应用" class="headerlink" title="（3）Spring的应用"></a>（3）Spring的应用</h5><p>只需要理解一点：Spring帮我们完成了类的创建，多个类的合作的工作，即将IoC容器与其在其中注册的类看作黑盒，通过<strong>注解</strong>和<strong>配置文件</strong>，可以让类在平台上注册，而这些注册的类叫<strong>Bean</strong>，我们要做的工作实际上就是注册类和拿到IoC装配好的类</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109120939057.png" alt="image-20210912093936648"></p><h5 id="（4）Spring模块"><a href="#（4）Spring模块" class="headerlink" title="（4）Spring模块"></a>（4）Spring模块</h5><p>参考资料：</p><p><a href="https://blog.csdn.net/u010648555/article/details/76299467">Spring常用注解</a></p><p><a href="https://blog.csdn.net/qq_44543508/article/details/103718958">Spring的@bean注解</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121039116.png" alt="spring-overview"></p><p>Spring提供了一堆组件，通过拼接这些组件我们可以组装出web应用（比较经典的缝合怪有：SSI，SSH，SSM，他们的首字母就代表Spring）</p><p>Spring怎么知道应该把哪些Java类当成bean注册到容器中呢？<br>使用配置文件或者注解的方式进行标识需要处理的java类!</p><p>放在具体的实例中可以这样理解：将数据库的配置信息注册在容器中，在需要访问数据库的对象中用户通过注解（java程序中的特殊标记）让该对象依赖注入了数据库配置信息，从而可以访问到数据库；</p><h4 id="开发架构"><a href="#开发架构" class="headerlink" title="开发架构"></a>开发架构</h4><h5 id="（1）业务逻辑"><a href="#（1）业务逻辑" class="headerlink" title="（1）业务逻辑"></a>（1）业务逻辑</h5><p><strong>Controller–&gt;service接口–&gt;serviceImpl–&gt;dao接口–&gt;daoImpl–&gt;mapper–&gt;db</strong></p><h5 id="（2）执行流程"><a href="#（2）执行流程" class="headerlink" title="（2）执行流程"></a>（2）执行流程</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041811913.png" alt="img"></p><p>而<code>pojo</code>则是实体类作为各层次处理传递的对象：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041811687.png" alt="image-20210629104056016"></p><h5 id="（3）各层职能"><a href="#（3）各层职能" class="headerlink" title="（3）各层职能"></a>（3）各层职能</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109120951753.png" alt="image-20210912095119480"></p><ul><li>dao/mapper层即数据持久层，dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务</li><li>service层调用dao层的接口进行业务逻辑应用的处理，封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性</li><li>controller层即控制层，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程</li><li>view层即视图层，用户可以看到并操作，可以理解为前端</li></ul><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>SpringBoot让Spring应用更加轻量化，并简化了了配置，实现自动化配置</p><p>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序</p><p>总而言之，Springboot是Spring的一套快速开发整合包</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109140739880.gif" alt="img"></p><h5 id="（1）SpringBoot启动原理"><a href="#（1）SpringBoot启动原理" class="headerlink" title="（1）SpringBoot启动原理"></a>（1）SpringBoot启动原理</h5><p>参考资料：</p><p><a href="https://www.cnblogs.com/theRhyme/p/11057233.html">https://www.cnblogs.com/theRhyme/p/11057233.html</a></p><p><a href="https://juejin.cn/post/6895341123816914958#heading-1">https://juejin.cn/post/6895341123816914958#heading-1</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111934807.png" alt="img"></p><ul><li><p>启动过程中，将注册类装配到Ioc容器，到时候我们可以直接获得装配好的类</p></li><li><p>反射：通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的</p></li><li><p>@ComponentScan ：<strong>扫描所在类的package</strong>；告诉Spring扫描哪个包下面类，加载符合条件的组件(比如@Component和@Repository以及@RestController，@Service等类)</p></li><li><p>@EnableAutoConfiguration：<strong>开启自动配置</strong>；经过层层调用，最终通过loadSpringFactories()方法加载META-INF/spring.factories中的配置类</p></li><li><p>@SpringBootConfiguration：<strong>标注当前类是配置类</strong>；将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名</p></li></ul><h5 id="（2）SpringBoot-Web-Demo"><a href="#（2）SpringBoot-Web-Demo" class="headerlink" title="（2）SpringBoot Web Demo"></a>（2）SpringBoot Web Demo</h5><p>1.新建Spring Initializr项目</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111939355.png" alt="image-20210911193904203"></p><p>2.勾选web模块</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109111940650.png" alt="image-20210911194039612"></p><p>3.查看pom.xml</p><p>查看pom.xml等待依赖下载完毕（springboot内置的依赖项过多，下载时间较长，start-web简化了Maven的依赖加载）</p><p>4.查看SpringbootApplication.java文件</p><p>项目创建好之后，就自带一个SpringbootApplication, 其被@SpringBootApplication 所标记，表示这个是一个Springboot 应用，其为Springboot 应用的入口</p><p>5.新建web文件存放控制器</p><p>新建HelloController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解为控制器</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解为映射url</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello SpringBoot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就相当于实现了Servlet的功能：处理http请求，返回响应内容</p><p>而这里的注解就相当于实现了Servlet的web.xml配置文件的功能</p><p>注解是java一个强大的特性，简单来说可以理解为代码中的特殊标记，开发人员可以在不改变原有代码情况下，在源代码中嵌入补充信息</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109112001559.png" alt="image-20210911200155436"></p><p>6.运行测试</p><p>访问链接：<code>http://localhost:8080/hello</code></p><p>感觉少了什么……我的tomcat呢？好像没有配web服务器😰</p><p>原来tomcat已经内嵌在SpringbootApplication中一起启动了</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109112009212.png" alt="image-20210911200952174"></p><p>也可以看到依赖项中也加载了tomcat，Tomcat的属性都在<code>org.springframework.boot.autoconfigure.web.ServerProperties</code>配置类中做了定义</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109112026994.png" alt="image-20210911202642854"></p><p>7.修改端口和上下文</p><p>在<code>resources/application.properties</code>文件修改配置（可以修改端口和上下文以及视图定位）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/test</span></span><br></pre></td></tr></table></figure><p>测试访问<code>http://localhost/test/hello</code>，如果出现了端口占用情况，可以参考tomcat的处理方法</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109112044412.png" alt="image-20210911204412242"></p><h5 id="（3）持久层支持"><a href="#（3）持久层支持" class="headerlink" title="（3）持久层支持"></a>（3）持久层支持</h5><p><strong>Hibernate</strong></p><p>Hibernate是jpa的具体实现，springboot默认使用的就是Hibernate，可以让我们不写一句sql，便于移植，同时也缺乏灵活性</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109140808602.png" alt="image-20210912105841614" style="zoom:50%;"><p><strong>MyBatis</strong></p><p>MyBatis也是一个持久化框架，不完全是一个ORM框架（Mybatis是将java方法与sql语句关联起来，而没有将java对象与数据库关联起来）不是依照的JPA规范，可以进行更细致的SQL优化，比较灵活适合处理大量数据的业务，推荐学习</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121103990.png" alt="@mybatis"></p><h5 id="（4）SpringBoot-JPA-Demo"><a href="#（4）SpringBoot-JPA-Demo" class="headerlink" title="（4）SpringBoot  JPA Demo"></a>（4）SpringBoot  JPA Demo</h5><p>JPA(Java Persistence API)是Sun官方提出的Java持久化规范，用来方便大家操作数据库</p><p>1.准备数据库，参考本地服务器环境搭建章节</p><p>2.在前一个demo中进行修改（或新建一个spring项目）</p><p>3.增加对mysql和jpa的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jpa--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>4.修改springboot配置文件，连接数据库</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库配置信息（注意配置数据库的编码和时区）</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 数据库连接驱动</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>5.根据orm创建实体类Entity</p><p>实体层是各层次用于输入输出处理的数据对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记为实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;student&quot;)</span> <span class="comment">// 表明类对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类的私有属性</span></span><br><span class="line">  <span class="meta">@Id</span> <span class="comment">// 标记为主键</span></span><br><span class="line">  <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 表明为自增长方式</span></span><br><span class="line">  <span class="meta">@Column(name = &quot;id&quot;)</span> <span class="comment">// 表明对应的数据库字段名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供外界操作属性的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.编写DAO层</p><p>DAO与选择的数据库框架有关</p><p>DAO层提供与数据库交互的接口，继承JpaRepository父接口,提供了一系列操作数据库方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承JpaRepository父接口,提供了一系列操作数据库方法</span></span><br><span class="line"><span class="comment">// 并且提供了泛型&lt;类 , 主键类型&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Student</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.编写Service层</p><p>定义会用到的操作数据库接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义会用到的操作数据库接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找所有</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">listAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 查找指定id</span></span><br><span class="line">    <span class="function">Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现接口中具体的操作数据库的方法</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServicempl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDAO studentDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">listAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDAO.findAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDAO.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.编写控制器</p><p>负责调用服务层的方法，并映射路径提供给客户端使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">// 注解为控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自动装配service层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentServicempl studentServicempl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 存储数据库返回的列表</span></span><br><span class="line">        List&lt;Student&gt; list = studentServicempl.listAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出的字符串</span></span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历列表,获得对象属性的值</span></span><br><span class="line">        <span class="keyword">for</span> (Student item: list) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拼接为字符串输出</span></span><br><span class="line">            str += item.getId() + <span class="string">&quot;.&quot;</span> + item.getName() + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 映射get url</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student student = studentServicempl.get(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> student.getName() + student.getId();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.编写单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试controller层</span></span><br><span class="line">    MockMvc mockMvc;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebApplicationContext context;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(context);</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/list&quot;</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试Dao层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = dao.findAll();</span><br><span class="line">        <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试service层</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentServicempl studentServicempl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = studentServicempl.listAll();</span><br><span class="line">        <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）SpringBoot-Mybatis-Demo"><a href="#（5）SpringBoot-Mybatis-Demo" class="headerlink" title="（5）SpringBoot  Mybatis  Demo"></a>（5）SpringBoot  Mybatis  Demo</h5><p>修改JPA Demo的dao层与实体类，为service提供操作数据库的方法，有注解法和xml两种方式</p><p>这里采用比较方便的注解法</p><ul><li><p>修改Dao，映射sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标注为mybatis的mapper接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用@Select注解表示调用方法会去执行对应的sql语句</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from student&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from student where id= #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Student <span class="title">getById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改pojo</p><p>Mybatis是将java方法与sql语句关联起来，而没有将java对象与数据库关联起来。所以不需要注解实体类与数据库的联系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">long</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="SpringCloud-Netflix"><a href="#SpringCloud-Netflix" class="headerlink" title="SpringCloud Netflix"></a>SpringCloud Netflix</h3><h4 id="分布式与集群"><a href="#分布式与集群" class="headerlink" title="分布式与集群"></a>分布式与集群</h4><h5 id="（1）微服务概念"><a href="#（1）微服务概念" class="headerlink" title="（1）微服务概念"></a>（1）微服务概念</h5><p>微服务简单来说，一个springboot就是一个微服务，不同的是这个springboot只做一项单纯的任务</p><h5 id="（2）服务注册"><a href="#（2）服务注册" class="headerlink" title="（2）服务注册"></a>（2）服务注册</h5><p>springcloud有个微服务注册中eureka server，通过它把微服务注册起来以供来调用</p><h5 id="（3）服务访问"><a href="#（3）服务访问" class="headerlink" title="（3）服务访问"></a>（3）服务访问</h5><p>微服务直接可以通过注册中心的定位相互访问</p><h5 id="（4）分布式概念"><a href="#（4）分布式概念" class="headerlink" title="（4）分布式概念"></a>（4）分布式概念</h5><p> 简单说，原来是在一个 springboot里就完成的事情，现在分布在多个 springboot里做，这就是初步具备分布式雏形了</p><ul><li>如果我要更新数据微服务，视图微服务是不受影响的</li><li>可以让不同的团队开发不同的微服务，他们之间只要约定好接口，彼此之间是低耦合的。</li><li>如果视图微服务挂了，数据微服务依然可以继续使用<br>等等</li></ul><h5 id="（5）集群"><a href="#（5）集群" class="headerlink" title="（5）集群"></a>（5）集群</h5><p>提供相同功能，只是端口不一样的微服务称为集群</p><ul><li>比起一个 springboot, 两个springboot 可以分别部署在两个不同的机器上，那么理论上来说，能够承受的负载就是 x 2. 这样系统就具备通过横向扩展而提高性能的机制</li><li>如果 8001 挂了，还有 8002 继续提供微服务，这就叫做高可用 </li></ul><h4 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h4><p>参考资料：<a href="https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/">四种软件架构</a></p><h5 id="（1）单体架构"><a href="#（1）单体架构" class="headerlink" title="（1）单体架构"></a>（1）单体架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121533917.png" alt="image-20210912153357714"></p><p>典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层</p><h5 id="（2）分布式架构"><a href="#（2）分布式架构" class="headerlink" title="（2）分布式架构"></a>（2）分布式架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121532105.png" alt="img"></p><p>将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上</p><h5 id="（3）微服务架构"><a href="#（3）微服务架构" class="headerlink" title="（3）微服务架构"></a>（3）微服务架构</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121533619.png" alt="img"></p><p>将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用</p><h5 id="（4）SpringCloud基本组成"><a href="#（4）SpringCloud基本组成" class="headerlink" title="（4）SpringCloud基本组成"></a>（4）SpringCloud基本组成</h5><p>Spring将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p><p>SpringCloud 就是一套工具，帮助我们很容易地搭建出这么一个 集群和分布式的架子出来，Spring Cloud 专注于为典型用例提供良好的开箱即用体验，并为其他用户提供可扩展性机制</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109121619055.png" alt="img"></p><ul><li>Spring Cloud Netflix：cloud各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的主要有组成有Eureka, Hystrix, Zuul</li><li>Eureka注册中心服务：SpringCloud服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移</li><li>Microservice：微服务，在springcloud可以简单理解为专职做一项任务的springboot，微服务之间可以通过Ribbon和Feign两种方式进行微服务之间的访问（Feign是主流方式）</li><li>Zipkin链路跟踪：从属于Spring Cloud Sleuth（日志收集工具包），为SpringCloud应用实现了一种分布式追踪解决方案，可以查看微服务之间的复杂的调用关系</li><li>Config Server 配置服务器：俗称配置中心，配置管理工具包，让你可以把配置放到远程服务器（比如集中放在git），集中化管理集群配置</li><li>Bus 消息总线：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Config Server 联合，再使用RabbitMQ实现热部署（所谓热部署即不需要重启微服务，对配置信息自动更新）</li><li>断路器Hystrix：容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力，简单来说就是提供异常或错误的处理微服务，比如说某个微服务寄了，断路器就可以调用其他微服务顶上（一般是错误处理的微服务）</li><li>Hystrix dashboard 断路器监控：通过turbine将集群中多个实例汇聚在一起，对微服务进行断路器监控</li><li>网关Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架，通过网关简化了对各个服务的访问：不再需要记录各个微服务的地址和端口，而是通过网关去访问他们</li></ul><h4 id="Springcloud-启动测试"><a href="#Springcloud-启动测试" class="headerlink" title="Springcloud 启动测试"></a>Springcloud 启动测试</h4><h5 id="（1）项目启动"><a href="#（1）项目启动" class="headerlink" title="（1）项目启动"></a>（1）项目启动</h5><ul><li><p>启动RabbitMQ（访问<a href="http://127.0.0.1:15672/#即已开启）">http://127.0.0.1:15672/#即已开启）</a></p></li><li><p>启动链路追踪服务器（这里开启的端口要与微服务中的配置一致）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin-server-2.10.1-exec.jar  --server.port=8050 --zipkin.collector.rabbitmq.addresses=localhost</span><br></pre></td></tr></table></figure></li><li><p>访问配置仓库<a href="https://github.com/Autovy/SpringCloudConfig/（也可以在config-server模块的配置文件修改成自己的仓库）">https://github.com/Autovy/SpringCloudConfig/（也可以在config-server模块的配置文件修改成自己的仓库）</a></p></li><li><p>运行EurekaServerApplication，启动注册中心服务（端口为8761）</p></li><li><p>运行ConfigServerApplication，启动配置服务器（端口为8030）</p></li><li><p>运行ProductDataServiceApplication，启动数据微服务（端口填写8001，8002形成集群）</p></li><li><p>运行ProductViewServiceFeignApplication，启动视图微服务（端口可填写8012，8013）</p></li><li><p>运行ProductServiceHystrixDashboardApplication，开启断路器监控，监控单个微服务（端口为8020）</p></li><li><p>运行ProductServiceTurbineApplication，开启聚合断路器监控以监控集群（端口为8021）</p></li><li><p>运行视图微服务里的 AccessViewService 来周期性地访问 <code>http://127.0.0.1:8012/products</code> 和 <code>http://127.0.0.1:8013/products</code>，以提供监控数据</p></li><li><p>运行ProductServiceZuulApplication，开启网关服务（端口为8060）</p></li></ul><h5 id="（2）测试服务注册中心"><a href="#（2）测试服务注册中心" class="headerlink" title="（2）测试服务注册中心"></a>（2）测试服务注册中心</h5><p>打开链接<a href="http://127.0.0.1:8761/，即可查看到注册服务中心Eureka">http://127.0.0.1:8761/，即可查看到注册服务中心Eureka</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191356386.png" alt="image-20210919135602819"></p><h5 id="（3）测试数据微服务"><a href="#（3）测试数据微服务" class="headerlink" title="（3）测试数据微服务"></a>（3）测试数据微服务</h5><p>打开链接<a href="http://127.0.0.1:8001/products">http://127.0.0.1:8001/products</a> 和 <a href="http://127.0.0.1:8002/products">http://127.0.0.1:8002/products</a> 都可以访问到返回的数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><h5 id="（4）测试视图微服务"><a href="#（4）测试视图微服务" class="headerlink" title="（4）测试视图微服务"></a>（4）测试视图微服务</h5><p>打开链接<a href="http://127.0.0.1:8012/products">http://127.0.0.1:8012/products</a> 和 <a href="http://127.0.0.1:8013/products">http://127.0.0.1:8013/products</a> 可以访问到视图页面，并且可以发现视图微服务会随机选择端口访问数据微服务实现负载均衡</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191401332.png" alt="image-20210919140106927"></p><h5 id="（5）测试服务链路追踪"><a href="#（5）测试服务链路追踪" class="headerlink" title="（5）测试服务链路追踪"></a>（5）测试服务链路追踪</h5><p>打开链接<a href="http://127.0.0.1:8050/zipkin/dependency/">http://127.0.0.1:8050/zipkin/dependency/</a> 即可访问到</p><p>Zipkin链路跟踪服务页面，即可看到微服务间的访问关系</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191404204.png" alt="image-20210919140414948"></p><h5 id="（6）测试Bus消息总线"><a href="#（6）测试Bus消息总线" class="headerlink" title="（6）测试Bus消息总线"></a>（6）测试Bus消息总线</h5><p>可访问<a href="http://127.0.0.1:8030/version/dev查看到配置服务器的信息">http://127.0.0.1:8030/version/dev查看到配置服务器的信息</a></p><p>访问视图查看当前版本号</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191407817.png" alt="image-20210919140727703"></p><p>修改配置服务器git上的版本号，这里我的仓库地址为<a href="https://github.com/Autovy/SpringCloudConfig/">https://github.com/Autovy/SpringCloudConfig/</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191411510.png" alt="image-20210919141137143"></p><p>启动视图微服务中的FreshConfigUtil使用 post 的方式访问 <a href="http://localhost:8012/actuator/bus-refresh">http://localhost:8012/actuator/bus-refresh</a> 地址，更新配置信息</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191414604.png" alt="image-20210919141416336"></p><p>最后再查看视图上的更新</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191415873.png" alt="image-20210919141503558"></p><p>可以访问RabbitMQ页面：<a href="http://127.0.0.1:15672/，查看队列，连接，还有交换机">http://127.0.0.1:15672/，查看队列，连接，还有交换机</a></p><h5 id="（7）测试Hystrix断路器及其监控"><a href="#（7）测试Hystrix断路器及其监控" class="headerlink" title="（7）测试Hystrix断路器及其监控"></a>（7）测试Hystrix断路器及其监控</h5><p>打开链接<a href="http://localhost:8020/hystrix即可进入Hystrix断路器的监控入口">http://localhost:8020/hystrix即可进入Hystrix断路器的监控入口</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191417418.png" alt="image-20210919141754328"></p><p>框内输入<a href="http://localhost:8012/actuator/hystrix.stream即可对8012端口的视图微服务进行监控">http://localhost:8012/actuator/hystrix.stream即可对8012端口的视图微服务进行监控</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191419460.png" alt="image-20210919141940229"></p><p>框内输入<a href="http://localhost:8021/turbine.stream即可实现对整个集群的视图微服务进行监控">http://localhost:8021/turbine.stream即可实现对整个集群的视图微服务进行监控</a></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191421059.png" alt="image-20210919142137829"></p><p><strong>停止数据微服务</strong>ProductDataServiceApplication集群，触发断路器：</p><p>访问视图可得</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191429890.png" alt="image-20210919142903819"></p><p>访问单个微服务监控页面可得</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191432572.png" alt="image-20210919143250565"></p><p>访问聚合集群微服务监控页面可得</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191431299.png" alt="image-20210919143120242"></p><h5 id="（8）网关测试"><a href="#（8）网关测试" class="headerlink" title="（8）网关测试"></a>（8）网关测试</h5><p>可以在zuul的配置文件中修改微服务的访问路由，我绑定的路由如下：</p><p><a href="http://localhost:8060/api-data/products">http://localhost:8060/api-data/products</a> ：访问数据微服务集群</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191358031.png" alt="image-20210919135818137"></p><p><a href="http://localhost:8060/api-view/products">http://localhost:8060/api-view/products</a> ：访问视图微服务集群</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109191426987.png" alt="image-20210919142625877"></p><p>可以发现其访问集群的端口也是负载均衡的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109140841902.png&quot; alt=&quot;pngkey.com-java-logo-png-2232144&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="入门教程" scheme="https://autovy.github.io/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="框架学习" scheme="https://autovy.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SpringBoot" scheme="https://autovy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Go|Go语言修炼手册</title>
    <link href="https://autovy.github.io/2021/09/08/Go/Go%E8%AF%AD%E8%A8%80%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C/"/>
    <id>https://autovy.github.io/2021/09/08/Go/Go%E8%AF%AD%E8%A8%80%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C/</id>
    <published>2021-09-08T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.166Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109070837021.jpeg" alt="img"></p><p>Go的吉祥物Gopher也太可爱了叭！！！</p><span id="more"></span><p>参考文章：</p><p>Go语言标准库：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p><p>Go案例代码：<a href="https://gobyexample-cn.github.io/">https://gobyexample-cn.github.io/</a></p><p>Go语言学习手册：<a href="https://www.topgoer.com/">https://www.topgoer.com/</a></p><h3 id="HelloGo"><a href="#HelloGo" class="headerlink" title="HelloGo"></a>HelloGo</h3><h4 id="1-Golang的主要特征"><a href="#1-Golang的主要特征" class="headerlink" title="1.Golang的主要特征"></a>1.Golang的主要特征</h4><ul><li><p>自动立即回收</p></li><li><p>更丰富的内置类型</p></li><li><p>函数多返回值</p></li><li><p>错误处理</p></li><li><p>匿名函数和闭包</p></li><li><p>类型和接口</p></li><li><p>并发编程</p></li><li><p>反射</p></li><li><p>语言交互性</p></li></ul><h4 id="2-第一个Go程序"><a href="#2-第一个Go程序" class="headerlink" title="2.第一个Go程序"></a>2.第一个Go程序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要导入main包才能运行main函数</span></span><br><span class="line"><span class="comment">// 而且一个项目中只能有一个文件导入main包使用main函数（类似于C语言）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;HelloGo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Go的值运算"><a href="#3-Go的值运算" class="headerlink" title="3.Go的值运算"></a>3.Go的值运算</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value 数据值的一些运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Value</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;go&quot;</span>+<span class="string">&quot;lang&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;go&quot;</span>,<span class="string">&quot;lang&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;1+1=&quot;</span>, <span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;7.0/3.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)</span><br><span class="line">fmt.Println(<span class="literal">true</span> || <span class="literal">false</span>)</span><br><span class="line">fmt.Println(!<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109070857530.png" alt="image-20210907085705239"></p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h4><h5 id="（1）标准声明"><a href="#（1）标准声明" class="headerlink" title="（1）标准声明"></a>（1）标准声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go语言用var声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// go推断变量类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;TestString&quot;</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  变量名后声明变量类型</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(b, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量赋给默认值</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">int</span></span><br><span class="line">fmt.Println(e)</span><br></pre></td></tr></table></figure><h5 id="（2）批量声明"><a href="#（2）批量声明" class="headerlink" title="（2）批量声明"></a>（2）批量声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="（3）短变量声明"><a href="#（3）短变量声明" class="headerlink" title="（3）短变量声明"></a>（3）短变量声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 化简写法声明字符串变量f（相当于 var f string = &quot;apple&quot;）</span></span><br><span class="line">f := <span class="string">&quot;apple&quot;</span></span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure><h4 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明恒定值</span></span><br><span class="line"><span class="keyword">const</span> s <span class="keyword">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constants</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n  = <span class="number">500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">3e20</span> / n</span><br><span class="line"></span><br><span class="line">fmt.Println(d)</span><br><span class="line"><span class="comment">// 转换类型</span></span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(d))</span><br><span class="line"><span class="comment">// 数学运算</span></span><br><span class="line">fmt.Println(math.Sin(n))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常量的声明只是将变量声明中的<code>var</code>更改为<code>const</code></p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><h4 id="1-数组Array"><a href="#1-数组Array" class="headerlink" title="1.数组Array"></a>1.数组Array</h4><h5 id="（1）声明默认数组"><a href="#（1）声明默认数组" class="headerlink" title="（1）声明默认数组"></a>（1）声明默认数组</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明默认数组</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// 数组元素赋值</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(a[<span class="number">4</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure><h5 id="（2）声明并初始化数组"><a href="#（2）声明并初始化数组" class="headerlink" title="（2）声明并初始化数组"></a>（2）声明并初始化数组</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化数组</span></span><br><span class="line">b:= [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// ...即让程序自动读取数组大小</span></span><br><span class="line">c:= [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(b, c)</span><br></pre></td></tr></table></figure><h5 id="（3）声明二维数组"><a href="#（3）声明二维数组" class="headerlink" title="（3）声明二维数组"></a>（3）声明二维数组</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明二维数组</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">    twoD[i][j] = i + j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(twoD)</span><br></pre></td></tr></table></figure><h4 id="2-切片Slice"><a href="#2-切片Slice" class="headerlink" title="2.切片Slice"></a>2.切片Slice</h4><h5 id="（1）切片简介"><a href="#（1）切片简介" class="headerlink" title="（1）切片简介"></a>（1）切片简介</h5><ul><li>切片是 Go 中的一种关键数据类型（引用类型），它为序列提供了比数组更强大的接口</li><li>切片的长度可以改变，因此，切片是一个可变的数组</li><li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制</li></ul><h5 id="（2）切片一般声明"><a href="#（2）切片一般声明" class="headerlink" title="（2）切片一般声明"></a>（2）切片一般声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明切片（让数组长度为空即形成切片）</span></span><br><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(s1, s2)</span><br></pre></td></tr></table></figure><h5 id="（3）make创建"><a href="#（3）make创建" class="headerlink" title="（3）make创建"></a>（3）make创建</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明非0长度的空片，需要用内置的make函数</span></span><br><span class="line"><span class="comment">// make([]type, len, cap):len（长度），cap（容量即为切片最长长度，可选）</span></span><br><span class="line"><span class="comment">// cap可以求出slice最大扩张容量，不能超出数组限制。len(slice) &gt;= len(array)，其中array是slice引用的数组</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(s3)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s3),<span class="built_in">cap</span>(s3))</span><br></pre></td></tr></table></figure><h5 id="（4）切片赋值与追加"><a href="#（4）切片赋值与追加" class="headerlink" title="（4）切片赋值与追加"></a>（4）切片赋值与追加</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片赋值（虽然切片可以自动扩容，但是取索引时不会扩容）</span></span><br><span class="line">s3[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s3[<span class="number">4</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">fmt.Println(s3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向切片中追加元素（必须接受返回值，在追加时可能使切片的容量增大）</span></span><br><span class="line">s3 = <span class="built_in">append</span>(s3, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s3 = <span class="built_in">append</span>(s3, <span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="comment">// 切片可以追加其他切片或数组使用...解压缩</span></span><br><span class="line">s3 = <span class="built_in">append</span>(s3, s3...)</span><br><span class="line">fmt.Println(s3)</span><br></pre></td></tr></table></figure><h5 id="（5）切片复制"><a href="#（5）切片复制" class="headerlink" title="（5）切片复制"></a>（5）切片复制</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片复制</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s3))</span><br><span class="line"><span class="built_in">copy</span>(c, s3)</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure><h5 id="（6）由数组或切片获得切片"><a href="#（6）由数组或切片获得切片" class="headerlink" title="（6）由数组或切片获得切片"></a>（6）由数组或切片获得切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由数组或切片获得切片</span></span><br><span class="line"><span class="comment">// 获得s3的5，6元素</span></span><br><span class="line">l := s3[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line">fmt.Println(l)</span><br><span class="line"><span class="comment">// 去掉切片最后一个元素</span></span><br><span class="line">l = s3[:<span class="built_in">len</span>(s3)<span class="number">-1</span>]</span><br><span class="line">fmt.Println(l)</span><br></pre></td></tr></table></figure><h4 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h4><h5 id="（1）map的创建"><a href="#（1）map的创建" class="headerlink" title="（1）map的创建"></a>（1）map的创建</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空地图（键类型为string，值类型为int）</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><h5 id="（2）map初始化"><a href="#（2）map初始化" class="headerlink" title="（2）map初始化"></a>（2）map初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map初始化</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;foo&quot;</span>:<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;bar&quot;</span>:<span class="string">&quot;str2&quot;</span>&#125;</span><br><span class="line">fmt.Println(n)</span><br></pre></td></tr></table></figure><h5 id="（3）map赋值与取值"><a href="#（3）map赋值与取值" class="headerlink" title="（3）map赋值与取值"></a>（3）map赋值与取值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map键值对赋值</span></span><br><span class="line">m[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">&quot;k2&quot;</span>] = <span class="number">10</span></span><br><span class="line"><span class="comment">// map的键为整型时区别于数组</span></span><br><span class="line">m1[<span class="number">1</span>] = <span class="string">&quot;test1&quot;</span></span><br><span class="line">m1[<span class="number">10</span>] = <span class="string">&quot;test2&quot;</span></span><br><span class="line">fmt.Println(m)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">v1 := m[<span class="string">&quot;k1&quot;</span>]</span><br><span class="line">fmt.Println(v1)</span><br></pre></td></tr></table></figure><p>不存在取值的返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在的键值默认返回为0，加上_,返回fasle（下划线用来忽略结果，也可以理解为那个位置本应赋给某个值，但是咱们不需要这个值）</span></span><br><span class="line">prs := m[<span class="string">&quot;k2&quot;</span>]</span><br><span class="line">_,prs2 := m[<span class="string">&quot;k2&quot;</span>]</span><br><span class="line">fmt.Println(prs, prs2)</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109070940900.png" alt="image-20210907094003976"></p><h5 id="（4）map删除操作"><a href="#（4）map删除操作" class="headerlink" title="（4）map删除操作"></a>（4）map删除操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除（map限定，不存在的键自动略过不报错）</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;k2&quot;</span>)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure><h3 id="基本流程控制"><a href="#基本流程控制" class="headerlink" title="基本流程控制"></a>基本流程控制</h3><h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">If</span><span class="params">(str <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if语句</span></span><br><span class="line"><span class="keyword">if</span> str==<span class="string">&quot;IfA&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a条件&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;其他条件&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明可以先于条件</span></span><br><span class="line"><span class="keyword">if</span> str = <span class="string">&quot;IfA&quot;</span>; str==<span class="string">&quot;IfA&quot;</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a条件满足&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2.switch语句"></a>2.switch语句</h4><h5 id="（1）使用变量作为判定条件"><a href="#（1）使用变量作为判定条件" class="headerlink" title="（1）使用变量作为判定条件"></a>（1）使用变量作为判定条件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch基本案例,使用变量作为判定条件</span></span><br><span class="line">i := <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;write&quot;</span>, i, <span class="string">&quot;as&quot;</span>)</span><br><span class="line">    <span class="keyword">switch</span> i &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（2）使用函数返回的变量值作为expression"><a href="#（2）使用函数返回的变量值作为expression" class="headerlink" title="（2）使用函数返回的变量值作为expression"></a>（2）使用函数返回的变量值作为expression</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数返回的变量值作为expression</span></span><br><span class="line"><span class="comment">// Weekday返回周数（weekday类型）</span></span><br><span class="line"><span class="keyword">switch</span> time.Now().Weekday()&#123;</span><br><span class="line">    <span class="keyword">case</span> time.Saturday, time.Sunday:</span><br><span class="line">    fmt.Println(<span class="string">&quot;weekend&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;weekday&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）使用函数返回值的变量作为constant-expression"><a href="#（3）使用函数返回值的变量作为constant-expression" class="headerlink" title="（3）使用函数返回值的变量作为constant-expression"></a>（3）使用函数返回值的变量作为constant-expression</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数返回值的变量作为constant-expression</span></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> t.Hour() &gt;= <span class="number">6</span> &amp;&amp; t.Hour() &lt; <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;清晨&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &gt;= <span class="number">8</span> &amp;&amp; t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;早上&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;其他时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-for语句"><a href="#3-for语句" class="headerlink" title="3.for语句"></a>3.for语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">For</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要i小于等于3就一直执行循环</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span>&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经典for语句初始/条件/后循环</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt;= <span class="number">9</span>; j++&#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件for循环等待break终止</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n:= <span class="number">0</span>; n &lt;= <span class="number">5</span>; n++&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复数进入下个循环</span></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Range语句"><a href="#4-Range语句" class="headerlink" title="4.Range语句"></a>4.Range语句</h4><h5 id="（1）Range简介"><a href="#（1）Range简介" class="headerlink" title="（1）Range简介"></a>（1）Range简介</h5><ul><li>range类似迭代器操作，返回 (索引, 值) 或 (键, 值)</li><li>range 格式可以对 slice、map、数组、字符串等进行迭代循环</li></ul><h5 id="（2）数组遍历"><a href="#（2）数组遍历" class="headerlink" title="（2）数组遍历"></a>（2）数组遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="comment">//range会提供索引和值，这里我们不需要索引所以用占位符代替</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums&#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure><h5 id="（3）map遍历"><a href="#（3）map遍历" class="headerlink" title="（3）map遍历"></a>（3）map遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="string">&quot;Ava&quot;</span>, <span class="string">&quot;b&quot;</span>:<span class="string">&quot;Bella&quot;</span>, <span class="string">&quot;c&quot;</span>:<span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;d&quot;</span>:<span class="string">&quot;Diana&quot;</span>, <span class="string">&quot;e&quot;</span>:<span class="string">&quot;Eileen&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s : %s\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kvs&#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> kvs&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="1-多参数"><a href="#1-多参数" class="headerlink" title="1.多参数"></a>1.多参数</h4><h5 id="（1）两参数"><a href="#（1）两参数" class="headerlink" title="（1）两参数"></a>（1）两参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数接受两个int参数，返回值为int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）同类型多参数"><a href="#（2）同类型多参数" class="headerlink" title="（2）同类型多参数"></a>（2）同类型多参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受多个同类型参数时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusPlus</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="comment">// 使用strconv包将整型转换成字符串（强制类型转换会出现乱码）</span></span><br><span class="line">a1 := strconv.Itoa(a)</span><br><span class="line">b1 := strconv.Itoa(b)</span><br><span class="line">c1 := strconv.Itoa(c)</span><br><span class="line"><span class="keyword">return</span> a1 + b1 + c1</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）可变参数"><a href="#（3）可变参数" class="headerlink" title="（3）可变参数"></a>（3）可变参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变参数（不定数量参数）,只能作为最后的参数项</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(str <span class="keyword">string</span>, nums ...<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(str, nums)</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,num := <span class="keyword">range</span> nums&#123;</span><br><span class="line">total += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-多返回值"><a href="#2-多返回值" class="headerlink" title="2.多返回值"></a>2.多返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">add := a + b</span><br><span class="line">sub := a - b</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-闭包函数"><a href="#3-闭包函数" class="headerlink" title="3.闭包函数"></a>3.闭包函数</h4><h5 id="（1）声明"><a href="#（1）声明" class="headerlink" title="（1）声明"></a>（1）声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数形成闭包</span></span><br><span class="line"><span class="comment">// 匿名函数常用于赋给变量，像普通变量一样传递操作</span></span><br><span class="line"><span class="comment">// 闭包最终效果就是将闭包赋予变量后，通过调用变量调用闭包函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）调用"><a href="#（2）调用" class="headerlink" title="（2）调用"></a>（2）调用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量赋予闭包，变量可以作为函数使用</span></span><br><span class="line">nextInt := intSeq()</span><br><span class="line"><span class="comment">// intSeq()输出的是原对象指针</span></span><br><span class="line">fmt.Println(intSeq())</span><br><span class="line">fmt.Println(nextInt())</span><br><span class="line">fmt.Println(nextInt())</span><br><span class="line">nextInt2 := intSeq()</span><br><span class="line">fmt.Println(nextInt2())</span><br></pre></td></tr></table></figure><h5 id="（3）结果"><a href="#（3）结果" class="headerlink" title="（3）结果"></a>（3）结果</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071006085.png" alt="image-20210907100638778"></p><h4 id="4-递归函数"><a href="#4-递归函数" class="headerlink" title="4.递归函数"></a>4.递归函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归计算阶乘</span></span><br><span class="line"><span class="comment">// 递归函数特征</span></span><br><span class="line"><span class="comment">// 1.子问题须与原始问题为同样的事，且更为简单。</span></span><br><span class="line"><span class="comment">// 2.不能无限制地调用本身，须有个出口，化简为非递归状况处理。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="1-函数中的指针参数"><a href="#1-函数中的指针参数" class="headerlink" title="1.函数中的指针参数"></a>1.函数中的指针参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通参数是将值传递给函数，相当于复制了副本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroval</span><span class="params">(ival <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">ival = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指针作为参数，函数直接操作参数的内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(iptr *<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(iptr)</span><br><span class="line"><span class="comment">// 引用当前地址的值并修改</span></span><br><span class="line">*iptr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-调用与运行结果"><a href="#2-调用与运行结果" class="headerlink" title="2.调用与运行结果"></a>2.调用与运行结果</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">zeroval(i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取变量地址作为参数</span></span><br><span class="line">zeroptr(&amp;i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Println(&amp;i)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071015209.png" alt="image-20210907101514269"></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="1-结构体简介"><a href="#1-结构体简介" class="headerlink" title="1.结构体简介"></a>1.结构体简介</h4><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性</p><h4 id="2-结构体实例化"><a href="#2-结构体实例化" class="headerlink" title="2.结构体实例化"></a>2.结构体实例化</h4><h5 id="（1）声明结构体"><a href="#（1）声明结构体" class="headerlink" title="（1）声明结构体"></a>（1）声明结构体</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体是字段的类型化集合，它们可以将数据组合在一起形成记录</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）结构体实例化"><a href="#（2）结构体实例化" class="headerlink" title="（2）结构体实例化"></a>（2）结构体实例化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体实例化方法</span></span><br><span class="line">fmt.Println(person&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;)</span><br><span class="line">s := person&#123;name: <span class="string">&quot;Sean&quot;</span>, age: <span class="number">50</span>&#125;</span><br><span class="line">fmt.Println(s.name)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071025874.png" alt="image-20210907102546338"></p><h5 id="（3）结构体地址"><a href="#（3）结构体地址" class="headerlink" title="（3）结构体地址"></a>（3）结构体地址</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体地址</span></span><br><span class="line">fmt.Println(&amp;person&#123;name: <span class="string">&quot;Ava&quot;</span>&#125;)</span><br><span class="line">sp := &amp;s</span><br><span class="line">fmt.Println(sp)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071034851.png" alt="image-20210907103421612"></p><h4 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h4><h5 id="（1）构造方法"><a href="#（1）构造方法" class="headerlink" title="（1）构造方法"></a>（1）构造方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newPerson给定的名称一个新的person结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明新的结构体并赋值</span></span><br><span class="line">p := person&#123;name:name&#125;</span><br><span class="line">p.age = <span class="number">42</span></span><br><span class="line"><span class="comment">// 返回新结构体的位置</span></span><br><span class="line"><span class="keyword">return</span> &amp;p</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）调用与结果"><a href="#（2）调用与结果" class="headerlink" title="（2）调用与结果"></a>（2）调用与结果</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(newPerson(<span class="string">&quot;Bella&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071039908.png" alt="image-20210907103904793"></p><h4 id="4-结构体方法"><a href="#4-结构体方法" class="headerlink" title="4.结构体方法"></a>4.结构体方法</h4><ul><li>对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然</li><li>对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法</li><li>为了减少内存开销，一般用指针类型作为接收者，用指针变量调用方法</li></ul><h5 id="（1）定义结构体"><a href="#（1）定义结构体" class="headerlink" title="（1）定义结构体"></a>（1）定义结构体</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体的方法</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）指针接收类型方法"><a href="#（2）指针接收类型方法" class="headerlink" title="（2）指针接收类型方法"></a>（2）指针接收类型方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针接收器类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值类型调用方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;area&quot;</span>, r.area())</span><br><span class="line"><span class="comment">// 指针类型调用方法</span></span><br><span class="line">rp := &amp;r</span><br><span class="line">fmt.Println(<span class="string">&quot;area&quot;</span>, rp.area())</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071105125.png" alt="image-20210907110512031"></p><h5 id="（3）值接收类型方法"><a href="#（3）值接收类型方法" class="headerlink" title="（3）值接收类型方法"></a>（3）值接收类型方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值接收器类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * r.width + <span class="number">2</span> * r.height</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值类型调用方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;perim&quot;</span>, r.perim())</span><br><span class="line"><span class="comment">// 指针类型调用方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;perim&quot;</span>, rp.perim())</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109071108661.png" alt="image-20210907110638342"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="1-接口简介"><a href="#1-接口简介" class="headerlink" title="1.接口简介"></a>1.接口简介</h4><ul><li>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节</li><li>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则）</li></ul><h4 id="2-接口的实现"><a href="#2-接口的实现" class="headerlink" title="2.接口的实现"></a>2.接口的实现</h4><h5 id="（1）定义接口"><a href="#（1）定义接口" class="headerlink" title="（1）定义接口"></a>（1）定义接口</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go语言提倡面向接口编程</span></span><br><span class="line"><span class="comment">// 接口是一种抽象类型，定义对象的行为规范</span></span><br><span class="line"><span class="keyword">type</span> Gemoetry <span class="keyword">interface</span> &#123;</span><br><span class="line">area() <span class="keyword">float64</span></span><br><span class="line">perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）构建结构体（用于生成对象）"><a href="#（2）构建结构体（用于生成对象）" class="headerlink" title="（2）构建结构体（用于生成对象）"></a>（2）构建结构体（用于生成对象）</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建结构体</span></span><br><span class="line"><span class="keyword">type</span> rect2 <span class="keyword">struct</span> &#123;</span><br><span class="line">width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）结构体的方法实现接口"><a href="#（3）结构体的方法实现接口" class="headerlink" title="（3）结构体的方法实现接口"></a>（3）结构体的方法实现接口</h5><p>只要对象实现了接口中所有的方法，就是实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要对象实现了接口中所有的方法，就是实现了这个接口（不需要显性声明）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect2)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect2)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）-结构体实例化生成对象"><a href="#（4）-结构体实例化生成对象" class="headerlink" title="（4） 结构体实例化生成对象"></a>（4） 结构体实例化生成对象</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现接口后，接口类型变量可以存储所有实现该接口的实例</span></span><br><span class="line"><span class="keyword">var</span> x Gemoetry</span><br><span class="line"></span><br><span class="line">x = rect2&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(x.area())</span><br><span class="line">fmt.Println(x.perim())</span><br><span class="line"></span><br><span class="line">x = circle&#123;radius:<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(x.area())</span><br><span class="line">fmt.Println(x.perim())</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>go语言通过显式的返回值传递错误</p><h4 id="1-内置接口返回错误信息"><a href="#1-内置接口返回错误信息" class="headerlink" title="1.内置接口返回错误信息"></a>1.内置接口返回错误信息</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数arg，返回值类型int，error</span></span><br><span class="line"><span class="comment">// 使用内置接口返回错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>, error)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arg == <span class="number">42</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">&quot;can&#x27;t work&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-自定义结构体"><a href="#2-自定义结构体" class="headerlink" title="2.自定义结构体"></a>2.自定义结构体</h4><h5 id="（1）定义结构体-1"><a href="#（1）定义结构体-1" class="headerlink" title="（1）定义结构体"></a>（1）定义结构体</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义结构体实现 Error ()方法，可以显示表示错误</span></span><br><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span>&#123;</span><br><span class="line">arg <span class="keyword">int</span></span><br><span class="line">prob <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）定义结构体方法"><a href="#（2）定义结构体方法" class="headerlink" title="（2）定义结构体方法"></a>（2）定义结构体方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d - %s&quot;</span>, e.arg, e.prob)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）异常测试方法"><a href="#（3）异常测试方法" class="headerlink" title="（3）异常测试方法"></a>（3）异常测试方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数arg，返回值类型int，error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arg == <span class="number">42</span>&#123;</span><br><span class="line"><span class="comment">// 实例化argError返回指针error（执行函数Error）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, &amp;argError&#123;arg, <span class="string">&quot;cam&#x27;t work with it&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）测试用例"><a href="#（4）测试用例" class="headerlink" title="（4）测试用例"></a>（4）测试用例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r,e = f2(<span class="number">42</span>)</span><br><span class="line">fmt.Println(r, e)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109072134201.png" alt="image-20210907213437028"></p><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="1-Goroutines（协程）"><a href="#1-Goroutines（协程）" class="headerlink" title="1.Goroutines（协程）"></a>1.Goroutines（协程）</h4><h5 id="（1）协程简介"><a href="#（1）协程简介" class="headerlink" title="（1）协程简介"></a>（1）协程简介</h5><ul><li><code>go func()</code>这种形式即可实现创建一个新的协程执行函数</li><li>一般函数调用是阻塞主线程的，即为同步；而使用协程调用函数，则会与主线程，其他协程一起运行，则是一个异步的过程</li><li>在并发编程中，不能用顺序执行语句的同步思维。在多个程序同时运行时，要考虑到各个协程开始的时间和结束的时间决定的运行结果，各个协程对同一数据的同时操作，各个协程任务同步，以及主线程结束后会关闭其他协程（不管其任务是否执行完毕）的问题</li></ul><h5 id="（2）运行案例"><a href="#（2）运行案例" class="headerlink" title="（2）运行案例"></a>（2）运行案例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goroutines</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般调用同步运行</span></span><br><span class="line">f(<span class="string">&quot;direct&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数放到goroutine运行（Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU）</span></span><br><span class="line"><span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为匿名函数启动一个goroutine（最后完成调用）</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;(<span class="string">&quot;going&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须设置等待，使主线程阻塞，否则main()执行完后goroutine也一同结束了</span></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080742743.png" alt="image-20210908074235644"></p><h4 id="2-Channels（通道）"><a href="#2-Channels（通道）" class="headerlink" title="2.Channels（通道）"></a>2.Channels（通道）</h4><h5 id="（1）通道简介"><a href="#（1）通道简介" class="headerlink" title="（1）通道简介"></a>（1）通道简介</h5><ul><li>通过goroutines可以实现函数并发运行，而这些并发执行的函数可以通过channels交换数据</li><li>默认情况下，通道是无缓冲的（阻塞通道），无缓冲的通道必须有接收才能发送</li><li>使用make函数初始化通道的时候为其指定通道的容量即可生成有缓冲通道</li></ul><h5 id="（2）通道的发送与接收"><a href="#（2）通道的发送与接收" class="headerlink" title="（2）通道的发送与接收"></a>（2）通道的发送与接收</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel是一种类型，一种引用类型</span></span><br><span class="line"><span class="comment">// 声明并初始化channel（声明的通道后需要使用make函数初始化之后才能使用）</span></span><br><span class="line">messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">fmt.Println(reflect.TypeOf(messages), messages)</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutines中函数将信息发送到messages通道</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;messages &lt;- <span class="string">&quot;ping&quot;</span>&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收信息</span></span><br><span class="line">msg := &lt;-messages</span><br><span class="line">fmt.Println(reflect.TypeOf(msg), msg)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080812902.png" alt="image-20210908081215613"></p><h5 id="（3）无缓冲通道"><a href="#（3）无缓冲通道" class="headerlink" title="（3）无缓冲通道"></a>（3）无缓冲通道</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况下，通道是无缓冲的（阻塞通道），无缓冲的通道必须有接收才能发送</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080814350.png" alt="image-20210908081412049"></p><p>无缓冲通道原理图：</p><p>无缓冲相当于小区没有快递点，快递员必须亲自把这个物品送到你的手上</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080815152.png" alt="img"></p><h5 id="（4）有缓冲通道"><a href="#（4）有缓冲通道" class="headerlink" title="（4）有缓冲通道"></a>（4）有缓冲通道</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用make函数初始化通道的时候为其指定通道的容量即可生成有缓冲通道</span></span><br><span class="line"><span class="comment">// 有缓冲通道（相当于设置了快递点）</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">ch &lt;- <span class="number">20</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br></pre></td></tr></table></figure><p>有缓冲通道原理图：</p><p>有缓冲通道相当于小区有个菜鸟驿站（非广告）或代收点帮你存快递，需要时再去取快递</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080819934.png" alt="img"></p><h5 id="（5）信道同步"><a href="#（5）信道同步" class="headerlink" title="（5）信道同步"></a>（5）信道同步</h5><p>在协程中存在着主线程结束后不管子协程有没有完成任务仍然让其强制下班的问题</p><p>虽然可以通过时间延迟让主线程嗯等，但是这种硬性处理方式浪费资源</p><p>通过信道，我们可以让主线程等待子协程发送任务完成的信号再结束自己的生命</p><p>子协程任务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信道同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;working&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="comment">// 发送任务完成的信号到通道</span></span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信道同步</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(done)</span><br><span class="line"><span class="comment">// 阻塞接收，等待goroutine完成</span></span><br><span class="line">&lt;- done</span><br></pre></td></tr></table></figure><h5 id="（6）单向通道"><a href="#（6）单向通道" class="headerlink" title="（6）单向通道"></a>（6）单向通道</h5><p>将通道作为参数在多个任务函数间传递时，限制通道在函数中只能发送或只能接收</p><p>单向通道通信方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送通道 chan &lt;- int 接收通道 &lt;- chan int</span></span><br><span class="line"><span class="comment">// 发送信息到pings通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span>&lt;-<span class="keyword">string</span>, msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收pings通道的信息， 发送到pongs通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, pongs <span class="keyword">chan</span>&lt;-<span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">msg := &lt;-pings</span><br><span class="line">pongs &lt;- msg</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单向通道的使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向信道</span></span><br><span class="line">pings := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">pongs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 发送信息到pings通道</span></span><br><span class="line">ping(pings, <span class="string">&quot;passed message&quot;</span>)</span><br><span class="line"><span class="comment">// 接收pings通道的信息， 发送到pongs通道</span></span><br><span class="line">pong(pings, pongs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收pongs信道信息并发送</span></span><br><span class="line">fmt.Println(&lt;-pongs)</span><br></pre></td></tr></table></figure><h4 id="3-通道操作"><a href="#3-通道操作" class="headerlink" title="3.通道操作"></a>3.通道操作</h4><h5 id="（1）通道关闭"><a href="#（1）通道关闭" class="headerlink" title="（1）通道关闭"></a>（1）通道关闭</h5><p>通道关闭这个信息也可以被接收到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作协程接收来自Close协程的信息，当接受完毕后关闭jobs通道</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 接受到more为fasle说明通道被关闭了，发送信息的任务已经结束</span></span><br><span class="line">j, more := &lt;-jobs</span><br><span class="line"><span class="keyword">if</span> more &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line"><span class="comment">// 完成全部任务后通知close协程</span></span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向jobs通道发送信息</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++&#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line">fmt.Println(<span class="string">&quot;sent all job&quot;</span>)</span><br><span class="line"><span class="comment">// close协程接收到完成的信号关闭close协程</span></span><br><span class="line"><span class="comment">// 使得主协程能随工作协程同步结束,可以防止主协程运行完成了,工作协程未完成接收就一起随主协程关闭的情况</span></span><br><span class="line">&lt;-done</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081521451.png" alt="image-20210908152110310"></p><h5 id="（2）通道数据遍历"><a href="#（2）通道数据遍历" class="headerlink" title="（2）通道数据遍历"></a>（2）通道数据遍历</h5><p>通过range语句也可以遍历通道的数据，但是要先关闭掉通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChannelsRange</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道数据遍历</span></span><br><span class="line">queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">queue &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">queue &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">// 遍历前要先关闭通道(让循环的迭代在2后结束)</span></span><br><span class="line"><span class="built_in">close</span>(queue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道关闭后仍然可以接收到信息(无法发送信息)</span></span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> queue&#123;</span><br><span class="line">fmt.Println(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-select"><a href="#4-select" class="headerlink" title="4.select"></a>4.select</h4><h5 id="（1）同时响应多个通道的操作"><a href="#（1）同时响应多个通道的操作" class="headerlink" title="（1）同时响应多个通道的操作"></a>（1）同时响应多个通道的操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启任务1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启任务2</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用select可以同时响应多个通道的操作，从而实现从多个通道接收数据（本质也是对各个通道扫描）</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;- c1:</span><br><span class="line">fmt.Println(msg1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;- c2:</span><br><span class="line">fmt.Println(msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080853240.png" alt="image-20210908085306965"></p><h5 id="（2）非阻塞发送接收"><a href="#（2）非阻塞发送接收" class="headerlink" title="（2）非阻塞发送接收"></a>（2）非阻塞发送接收</h5><p>这里所谓的非阻塞是指通过select的default让主线程进入默认分支</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用select实现通道非阻塞发送接收</span></span><br><span class="line">messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">signals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞接收</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="comment">// 成功读到数据到msg</span></span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(<span class="string">&quot;received message&quot;</span>, msg)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;no message received&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="comment">// 非阻塞发送</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="comment">// 成功发送数据到messages</span></span><br><span class="line"><span class="keyword">case</span> messages &lt;- msg:</span><br><span class="line">fmt.Println(<span class="string">&quot;sent message&quot;</span>, msg)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;no message sent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> msg := &lt;- messages:</span><br><span class="line">fmt.Println(<span class="string">&quot;received message&quot;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> sig := &lt;- signals:</span><br><span class="line">fmt.Println(<span class="string">&quot;received signal&quot;</span>, sig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;no activity&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109080905553.png" alt="image-20210908090500412"></p><h5 id="（3）超时操作"><a href="#（3）超时操作" class="headerlink" title="（3）超时操作"></a>（3）超时操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超时对于一个需要连接外部资源，或者有耗时较长的操作的程序而言是很重要的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timeouts</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c1 &lt;- <span class="string">&quot;res 1&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 等待结果</span></span><br><span class="line"><span class="keyword">case</span> res := &lt;- c1:</span><br><span class="line">fmt.Println(res)</span><br><span class="line"><span class="comment">// 等待超时后发送的值</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-定时器"><a href="#5-定时器" class="headerlink" title="5.定时器"></a>5.定时器</h4><h5 id="（1）定时器Timer"><a href="#（1）定时器Timer" class="headerlink" title="（1）定时器Timer"></a>（1）定时器Timer</h5><p>定时器的作用与time.Sleep类似，不同的是time.Sleep硬性规定等待一定时间才能继续进程,而定时器可以在触发前取消掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timer</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 定时器表示在未来某一时刻的独立事件</span></span><br><span class="line">time1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞直到定时器的通道C发送定时器失效的值</span></span><br><span class="line">&lt;- time1.C</span><br><span class="line">fmt.Println(<span class="string">&quot;Timer 1 fired&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定时器与time.Sleep不同之处在于:</span></span><br><span class="line"><span class="comment">// time.Sleep硬性规定等待一定时间才能继续进程,而定时器可以在触发前取消掉</span></span><br><span class="line">time2 := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;- time2.C</span><br><span class="line">fmt.Println(<span class="string">&quot;Time 2 fired&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line">stop2 := time2.Stop()</span><br><span class="line"><span class="keyword">if</span> stop2 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Timer 2 stopped&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081529584.png" alt="image-20210908152938454"></p><h5 id="（2）打点器Ticker"><a href="#（2）打点器Ticker" class="headerlink" title="（2）打点器Ticker"></a>（2）打点器Ticker</h5><p>定时器用于执行一次时使用,而打点器用于在固定时间间隔重复执行而准备</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ticker</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义打点器</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 不断运行,直到从主协程接收到done</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> t := &lt;- ticker.C:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打点器一共运行2000ms,每一次500ms,可以粗略算出运行4次</span></span><br><span class="line">time.Sleep(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line"><span class="comment">// 停止打点器并结束子协程</span></span><br><span class="line">ticker.Stop()</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Ticker stopped&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081532259.png" alt="image-20210908153237860"></p><h5 id="（3）速率限制"><a href="#（3）速率限制" class="headerlink" title="（3）速率限制"></a>（3）速率限制</h5><p>速率限制是控制服务资源利用和质量的重要机制。 基于协程、通道和打点器，Go 优雅的支持速率限制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RateLimiting</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">requests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++&#123;</span><br><span class="line">requests &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(requests)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 速率限制调度器设置</span></span><br><span class="line">    <span class="comment">// tick是NewTicker的封装，只提供对Ticker的通道的访问</span></span><br><span class="line">limiter := time.Tick(<span class="number">200</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> requests&#123;</span><br><span class="line"><span class="comment">// 让请求每200ms执行一次</span></span><br><span class="line">&lt;-limiter</span><br><span class="line">fmt.Println(<span class="string">&quot;request&quot;</span>, req, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 速率限制方案允许短暂的并发请求，并同时保留总体速率限制</span></span><br><span class="line"><span class="comment">// 填充通道表示允许的爆发</span></span><br><span class="line">burstyLimiter := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每200ms新的值到burstyLimiter中，直到达到 3 个的限制。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">burstyLimiter &lt;- time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(<span class="number">200</span> * time.Millisecond)&#123;</span><br><span class="line">burstyLimiter &lt;- t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟5个传入请求</span></span><br><span class="line">busstyRequests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++&#123;</span><br><span class="line">busstyRequests &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(busstyRequests)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 受益于burstyLimiter 的爆发（bursts）能力，前 3 个请求可以快速完成</span></span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> busstyRequests&#123;</span><br><span class="line">&lt;- burstyLimiter</span><br><span class="line">fmt.Println(<span class="string">&quot;request&quot;</span>, req, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-Goroutine池"><a href="#6-Goroutine池" class="headerlink" title="6.Goroutine池"></a>6.Goroutine池</h4><p>工作池实质上时生产者消费者模型，其可以有效控制gorouine的数量</p><p>工作池中有工人（处理工作的协程），有两条流水线（传递工作的通道与传递结果的通道）</p><h5 id="（1）创建工作池"><a href="#（1）创建工作池" class="headerlink" title="（1）创建工作池"></a>（1）创建工作池</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：任务编号id，从通道接收工作jobs，发送结果到res通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workers</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, res <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> )</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> jobs&#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;started job&quot;</span>, j)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;finnished job&quot;</span>, j)</span><br><span class="line">res &lt;- j * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）使用工作池"><a href="#（2）使用工作池" class="headerlink" title="（2）使用工作池"></a>（2）使用工作池</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WorkerPools</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> numJob = <span class="number">5</span></span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, numJob)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, numJob)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个worker任务（初始时阻塞的，因为还没有传递任务）</span></span><br><span class="line"><span class="comment">// 三个workers任务并行执行（即工作池有三位工具人，两条流水线）</span></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++&#123;</span><br><span class="line"><span class="keyword">go</span> workers(w, jobs, results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信息到jobs</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= numJob; j++&#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭通道，表示发送完毕</span></span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集worker的返回值，确保所有worker协程都已经完成</span></span><br><span class="line"><span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= numJob; a++&#123;</span><br><span class="line">&lt;-results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081546666.png" alt="image-20210908154642399"></p><h4 id="7-Sync"><a href="#7-Sync" class="headerlink" title="7.Sync"></a>7.Sync</h4><h5 id="（1）WaitGroup"><a href="#（1）WaitGroup" class="headerlink" title="（1）WaitGroup"></a>（1）WaitGroup</h5><p>在前面的例子中</p><ul><li>为了同步子协程与主线程我们通过传递done来让主线程等等子协程</li><li>为了让主线程等待工作池内的子协程完成任务我们通过收集返回结果来实现同步</li><li>这次我们用 sync.WaitGroup来实现并发任务的同步，其内部维护着一个计数器（每个计数器对应一个并发任务）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync.WaitGroup来实现并发任务的同步，其内部维护着一个计数器（每个计数器对应一个并发任务）</span></span><br><span class="line"><span class="comment">// WaitGroup 必须通过指针传递给函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerA</span><span class="params">(id <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟调用wg的Done方法（相当于直到return后才执行），计数器减1（当计数器为0，表明所有的并发任务完成）</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, id)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitGroup</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// WaitGroup 用于等待该函数启动的所有协程</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 递增wg计数器</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 启动多个协程任务，并传递其wg计数器</span></span><br><span class="line"><span class="keyword">go</span> workerA(i, &amp;wg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞（主协程）至计数器变为0（所有并发协程已完成）结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081630685.png" alt="image-20210908163034514"></p><h4 id="8-并发安全"><a href="#8-并发安全" class="headerlink" title="8.并发安全"></a>8.并发安全</h4><p>在工作池中我们使用通道之间的通信管理状态，下面我们使用atomic原子技术和互斥锁技术管理状态保证并发安全</p><p>这里以多协程并发访问同一变量作为并发安全问题的案例</p><h5 id="（1）互斥锁"><a href="#（1）互斥锁" class="headerlink" title="（1）互斥锁"></a>（1）互斥锁</h5><p>在一个协程操作对资源上锁，其他协程无法访问到该资源，保证了</p><p>只有一个协程可以访问共享资源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mutexes</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 访问对象</span></span><br><span class="line"><span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutex同步对state的访问</span></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追踪读写操作的数量</span></span><br><span class="line"><span class="keyword">var</span> readOps <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">var</span> writeOps <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++&#123;</span><br><span class="line"><span class="comment">// 启动100个协程做读取操作，每个协程以每 1ms 一次的频率来重复读取 state</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">// 生成键对map进行访问（生成在5之间的随机数）</span></span><br><span class="line">key := rand.Intn(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 互斥锁保证该协程对map独占访问</span></span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="comment">// 读取选定键的值</span></span><br><span class="line">total += state[key]</span><br><span class="line"><span class="comment">// 解开互斥锁</span></span><br><span class="line">mutex.Unlock()</span><br><span class="line"><span class="comment">// 读操作增加1</span></span><br><span class="line">atomic.AddUint64(&amp;readOps, <span class="number">1</span>)</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++&#123;</span><br><span class="line"><span class="comment">// 启动10个协程模拟写入操作</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 与读取的协程类似</span></span><br><span class="line">key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">val := rand.Intn(<span class="number">100</span>)</span><br><span class="line">mutex.Lock()</span><br><span class="line">state[key] = val</span><br><span class="line">mutex.Unlock()</span><br><span class="line"><span class="comment">// 写操作增加1</span></span><br><span class="line">atomic.AddUint64(&amp;writeOps, <span class="number">1</span>)</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让这 10 个协程对 state 和 mutex 的操作持续 1 s（主进程阻塞）</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示最终操作数</span></span><br><span class="line">readOpsFinal := atomic.LoadUint64(&amp;readOps)</span><br><span class="line">fmt.Println(<span class="string">&quot;readOps:&quot;</span>, readOpsFinal)</span><br><span class="line">writeOpsFianl := atomic.LoadUint64(&amp;writeOps)</span><br><span class="line">fmt.Println(<span class="string">&quot;writeOps:&quot;</span>, writeOpsFianl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭对state的操作，展示最后结束时的state</span></span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Println(<span class="string">&quot;state:&quot;</span>, state)</span><br><span class="line">mutex.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081711312.png" alt="image-20210908171059061"></p><h5 id="（2）atomic（原子操作）"><a href="#（2）atomic（原子操作）" class="headerlink" title="（2）atomic（原子操作）"></a>（2）atomic（原子操作）</h5><p>加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atomic</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置原子计数器</span></span><br><span class="line"><span class="keyword">var</span> ops <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">// 设置非原子计数器</span></span><br><span class="line"><span class="keyword">var</span> opn <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waitgroup等待协程完成工作</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++&#123;</span><br><span class="line"><span class="comment">// 增加协程计数器</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启协程进行原子操作</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++&#123;</span><br><span class="line"><span class="comment">// 原子操作增加计数器数值，各协程操作同一数据时之间不会互相干扰</span></span><br><span class="line">atomic.AddUint64(&amp;ops, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 非原子计数，各协程相互干扰</span></span><br><span class="line">opn++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加操作结束后，协程计数器-1</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待直到所有协程完成</span></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全访问ops（此时无协程写入内容）</span></span><br><span class="line"><span class="comment">// 此外atomic.LoadUint64 之类的函数，在原子更新的同时安全地读取它们</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ops&quot;</span>, ops)</span><br><span class="line">fmt.Println(<span class="string">&quot;opn&quot;</span>, opn)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081652041.png" alt="image-20210908165217871"></p><h5 id="（3）状态协程"><a href="#（3）状态协程" class="headerlink" title="（3）状态协程"></a>（3）状态协程</h5><p>互斥锁中通过锁定让state跨多个go协程同步访问<br>这里我们通过内建协程和通道同步的特性来实现同样的效果<br>通过通信使每个数据仅被单个协程所拥有，即通过通信实现共享内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体封装写入与读取的请求</span></span><br><span class="line"><span class="keyword">type</span> readOp <span class="keyword">struct</span> &#123;</span><br><span class="line">key <span class="keyword">int</span></span><br><span class="line">resp <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writeOp <span class="keyword">struct</span> &#123;</span><br><span class="line">key <span class="keyword">int</span></span><br><span class="line">value <span class="keyword">int</span></span><br><span class="line">resp <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SatefulGoroutines</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readOps <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">var</span> writeOps <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建readOp，writeOp类型的通道</span></span><br><span class="line"><span class="comment">// 其他协程将通过 reads 和 writes 通道来发布 读 和 写 请求</span></span><br><span class="line">reads := <span class="built_in">make</span>(<span class="keyword">chan</span> readOp)</span><br><span class="line">writes := <span class="built_in">make</span>(<span class="keyword">chan</span> writeOp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有state的协程（私有），其可以不断接收读写通道的信息</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// state为该协程私有，其他协程（包括主协程都不能访问）</span></span><br><span class="line"><span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="comment">// 其他协程进行读操作，返回map键对应的值</span></span><br><span class="line"><span class="keyword">case</span> read := &lt;-reads:</span><br><span class="line">read.resp &lt;- state[read.key]</span><br><span class="line"><span class="comment">// 其他协程进行写操作，返回成功</span></span><br><span class="line"><span class="keyword">case</span> write := &lt;-writes:</span><br><span class="line">state[write.key] = write.value</span><br><span class="line">write.resp &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动100个协程通过reads通道发起读请求</span></span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">// 构造read请求</span></span><br><span class="line">read := readOp&#123;</span><br><span class="line">key: rand.Intn(<span class="number">5</span>),</span><br><span class="line">resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read请求发送reads通道中进行读操作</span></span><br><span class="line">reads &lt;- read</span><br><span class="line"><span class="comment">// 通过给定的resp通道接收结果</span></span><br><span class="line">&lt;- read.resp</span><br><span class="line">atomic.AddUint64(&amp;readOps, <span class="number">1</span>)</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以相同方法启动10个写操作</span></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">write := writeOp&#123;</span><br><span class="line">key: rand.Intn(<span class="number">5</span>),</span><br><span class="line">value: rand.Intn(<span class="number">100</span>),</span><br><span class="line">resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writes &lt;- write</span><br><span class="line">&lt;- write.resp</span><br><span class="line">atomic.AddUint64(&amp;writeOps, <span class="number">1</span>)</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让协程们跑1s（阻塞主协程）</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">readOpsFinal := atomic.LoadUint64(&amp;readOps)</span><br><span class="line">fmt.Println(<span class="string">&quot;readOps&quot;</span>, readOpsFinal)</span><br><span class="line">writeOpsFinal := atomic.LoadUint64(&amp;writeOps)</span><br><span class="line">fmt.Println(<span class="string">&quot;writeOps&quot;</span>, writeOpsFinal)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081719227.png" alt="image-20210908171921079"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="1-自定义排序"><a href="#1-自定义排序" class="headerlink" title="1.自定义排序"></a>1.自定义排序</h4><p>这里自定义按字符串长度排序</p><p>同过实现go提供的sort.Interface接口来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数实现自定义排序</span></span><br><span class="line"><span class="keyword">type</span> byLength []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现byLength结构体的对象是实现了sort.Interface接口的所有方法</span></span><br><span class="line"><span class="comment">// 这样我们就可以使用 sort 包的通用 Sort 方法了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span>  <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// less方法控制实际的自定义排序逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 按长度排序字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sorting</span><span class="params">()</span></span>  &#123;</span><br><span class="line">asoul := []<span class="keyword">string</span>&#123;<span class="string">&quot;Ava&quot;</span>, <span class="string">&quot;Bella&quot;</span>, <span class="string">&quot;Eileen&quot;</span>,<span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;Diana&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 将asoul强转换为byLength类型</span></span><br><span class="line"><span class="comment">// Sort调用实现结构的对象</span></span><br><span class="line">sort.Sort(byLength(asoul))</span><br><span class="line">fmt.Println(asoul)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081723322.png" alt="image-20210908172335154"></p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>JSON的编码解码即序列化与反序列化</p><p>我们常用byte和string作为数据和json表示形式的中介</p><p>编码过程：go的其他数据类型 -&gt; byte（字节数组） -&gt; json</p><p> 解码过程：json -&gt; byte（字节数组） -&gt; go的其他数据类型（map[string]interface{} / 自定义类型）</p><h4 id="2-构造结构体"><a href="#2-构造结构体" class="headerlink" title="2.构造结构体"></a>2.构造结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造json类型的结构体</span></span><br><span class="line"><span class="comment">// 必须以大写字母开头的字段才是可导出的。</span></span><br><span class="line"><span class="keyword">type</span> res <span class="keyword">struct</span> &#123;</span><br><span class="line">Page <span class="keyword">int</span></span><br><span class="line">Fruits []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h4><p>将Go的数据转换为JSON，go的数据在编码后是byte[]类型，所以要转换成string类型才能打印出字符串</p><h5 id="（1）map类型编码"><a href="#（1）map类型编码" class="headerlink" title="（1）map类型编码"></a>（1）map类型编码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map类型json编码</span></span><br><span class="line">mapD := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;apple&quot;</span>:<span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span>:<span class="number">7</span>&#125;</span><br><span class="line">mapB, _ := json.Marshal(mapD)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(mapB))</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081736704.png" alt="image-20210908173628386"></p><h5 id="（2）自定义类型编码"><a href="#（2）自定义类型编码" class="headerlink" title="（2）自定义类型编码"></a>（2）自定义类型编码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体实例化</span></span><br><span class="line"><span class="comment">// 结构体实例化赋值时，可以赋予地址也可以赋予值（得到一样的结果）</span></span><br><span class="line"><span class="comment">// 但是赋予地址可以减少系统开销</span></span><br><span class="line">res1D := &amp;res&#123;</span><br><span class="line">Page: <span class="number">1</span>,</span><br><span class="line">Fruits: []<span class="keyword">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json可自动编码自定义类型，编码的输出只有可导出的字段</span></span><br><span class="line">res1B, _ := json.Marshal(res1D)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(res1B))</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081734771.png" alt="image-20210908173448648"></p><h4 id="4-解码"><a href="#4-解码" class="headerlink" title="4.解码"></a>4.解码</h4><p>将JSON转换为Go语言可以读取的数据类型，</p><h5 id="（1）map类型接收"><a href="#（1）map类型接收" class="headerlink" title="（1）map类型接收"></a>（1）map类型接收</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码过程</span></span><br><span class="line"><span class="comment">// 构造json</span></span><br><span class="line">byt := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;num&quot;:6.13, &quot;strs&quot;:[&quot;a&quot;, &quot;b&quot;]&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供Json包存放解码数据的变量（键为string，值为任意的map）</span></span><br><span class="line"><span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数据进行解码</span></span><br><span class="line"><span class="comment">// if语句进行错误检查</span></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出解码后的dat</span></span><br><span class="line">fmt.Println(dat)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了使用map中的值，我们需要进行恰当的类型转换</span></span><br><span class="line">num := dat[<span class="string">&quot;num&quot;</span>].(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Println(num)</span><br><span class="line"><span class="comment">// 访问嵌套的值</span></span><br><span class="line">strs := dat[<span class="string">&quot;strs&quot;</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">str1 := strs[<span class="number">1</span>].(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(str1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081743780.png" alt="image-20210908174316707"></p><h5 id="（2）自定义数据类型接收"><a href="#（2）自定义数据类型接收" class="headerlink" title="（2）自定义数据类型接收"></a>（2）自定义数据类型接收</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将json解码为自定义数据类型（增加类型安全性）,推荐的解码方式</span></span><br><span class="line"><span class="comment">// ``可以定义字符串，且其内可以有双引号&quot;&quot;</span></span><br><span class="line">str := <span class="string">`&#123;&quot;page&quot;: 1, &quot;fruits&quot;: [&quot;apple&quot;, &quot;peach&quot;]&#125;`</span></span><br><span class="line">fmt.Println(reflect.TypeOf(str))</span><br><span class="line"></span><br><span class="line">res := res&#123;&#125;</span><br><span class="line"><span class="comment">// 将str转换为byte数组类型，后将其解码放在res类型的结构体中</span></span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;res)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">fmt.Println(res.Fruits[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081744858.png" alt="image-20210908174428706"></p><h5 id="（3）Encode接收"><a href="#（3）Encode接收" class="headerlink" title="（3）Encode接收"></a>（3）Encode接收</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们还可以将os.Stdout 一样直接将 JSON 编码流传输到 os.Writer 甚至 HTTP 响应体</span></span><br><span class="line"><span class="comment">// 创建一个将数据写入*Encoder（可以接收信息）</span></span><br><span class="line">enc := json.NewEncoder(os.Stdout)</span><br><span class="line">d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="comment">// 将json编码写入输出流输出</span></span><br><span class="line">enc.Encode(d)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081745019.png" alt="image-20210908174505894"></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="1-单元测试命名规则"><a href="#1-单元测试命名规则" class="headerlink" title="1.单元测试命名规则"></a>1.单元测试命名规则</h4><ul><li>文件名必须以xx_test.go命名</li><li>方法必须是Test开头</li><li>方法参数必须 t *testing.T</li><li>测试例与被测试对象要放在一个包中</li><li>使用go test执行单元测试（idea可以直接运行测试例）</li></ul><h4 id="2-被测对象"><a href="#2-被测对象" class="headerlink" title="2.被测对象"></a>2.被测对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntMin 主程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntMin</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b&#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-一般测试例"><a href="#3-一般测试例" class="headerlink" title="3.一般测试例"></a>3.一般测试例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestIntMinBasic 测试程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIntMinBasic</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">ans := IntMin(<span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="keyword">if</span> ans != <span class="number">-2</span>&#123;</span><br><span class="line"><span class="comment">// t.Error*会报告测试失败的信息，然后立即终止测试</span></span><br><span class="line"><span class="comment">// t.Fail*会报告测试失败的信息，然后立即终止测试</span></span><br><span class="line">t.Errorf(<span class="string">&quot;IntMin(2, -2) = %d; want -2&quot;</span>, ans)</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(ans)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-表驱动测试例"><a href="#4-表驱动测试例" class="headerlink" title="4.表驱动测试例"></a>4.表驱动测试例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestIntMinTableDriven 单元测试可以重复，所以会经常使用表驱动风格编写单元测试</span></span><br><span class="line"><span class="comment">// 表中列出了输入数据，预期输出，使用循环，遍历并执行测试逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIntMinTableDriven</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">a, b <span class="keyword">int</span></span><br><span class="line">want <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line"></span><br><span class="line">testname := fmt.Sprintf(<span class="string">&quot;%d, %d&quot;</span>, tt.a, tt.b)</span><br><span class="line"><span class="comment">// t.Run运行一个子测试，每一个子测试对应表中一行数据</span></span><br><span class="line">t.Run(testname, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">ans := IntMin(tt.a, tt.b)</span><br><span class="line"><span class="keyword">if</span> ans != tt.want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got %d, want %d&quot;</span>, ans, tt.want)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><h4 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go向服务端发送GET请求</span></span><br><span class="line"></span><br><span class="line">resp1, err := http.Get(<span class="string">&quot;https://search.bilibili.com/&quot;</span>)</span><br><span class="line"><span class="comment">// 捕捉错误</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟关闭请求服务</span></span><br><span class="line"><span class="keyword">defer</span> resp1.Body.Close()</span><br><span class="line"></span><br><span class="line">fmt.Println(resp1)</span><br><span class="line"><span class="comment">// 打印返回的请求状态</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Response status&quot;</span>, resp1.Status)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印响应的内容</span></span><br><span class="line"><span class="comment">// 使用ioutil读取数据（读取返回的是字节数组）</span></span><br><span class="line">body, err := ioutil.ReadAll(resp1.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure><h4 id="2-带参数GET请求"><a href="#2-带参数GET请求" class="headerlink" title="2.带参数GET请求"></a>2.带参数GET请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go向服务端发送带参数GET请求</span></span><br><span class="line">apiurl := <span class="string">&quot;https://search.bilibili.com/all&quot;</span></span><br><span class="line"><span class="comment">// 构造get请求表单</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">&quot;keyword&quot;</span>, <span class="string">&quot;Autovy&quot;</span>)</span><br><span class="line">data.Set(<span class="string">&quot;from_source&quot;</span>, <span class="string">&quot;webtop_search&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合参数构造请求结构体</span></span><br><span class="line">u, err := url.ParseRequestURI(apiurl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url编码</span></span><br><span class="line">u.RawQuery = data.Encode()</span><br><span class="line"><span class="comment">// 生成带参数url</span></span><br><span class="line">fmt.Println(u.String())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行http请求（下面的步骤与一般的get请求一致）</span></span><br><span class="line"><span class="comment">// 其实也可以把带参数的url直接进行请求😅</span></span><br><span class="line">resp2, err := http.Get(u.String())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;post failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp2.Body.Close()</span><br><span class="line"></span><br><span class="line">b, err := ioutil.ReadAll(resp2.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;get resp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br></pre></td></tr></table></figure><h4 id="3-POST请求"><a href="#3-POST请求" class="headerlink" title="3.POST请求"></a>3.POST请求</h4><h5 id="（1）发送from-data"><a href="#（1）发送from-data" class="headerlink" title="（1）发送from-data"></a>（1）发送from-data</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造表单</span></span><br><span class="line">data2 := url.Values&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>:       &#123;<span class="string">&quot;Autovy&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;occupation&quot;</span>: &#123;<span class="string">&quot;programmar&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送表单</span></span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;https://httpbin.org/post&quot;</span>, data2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕捉异常</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码返回的信息</span></span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.NewDecoder(resp.Body).Decode(&amp;res)</span><br><span class="line">fmt.Println(res[<span class="string">&quot;form&quot;</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109082013606.png" alt="image-20210908201313448"></p><h5 id="（2）发送json"><a href="#（2）发送json" class="headerlink" title="（2）发送json"></a>（2）发送json</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造json数据</span></span><br><span class="line">values := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Ava&quot;</span>, <span class="string">&quot;occupation&quot;</span>: <span class="string">&quot;Gamer&quot;</span>&#125;</span><br><span class="line">json_data, err := json.Marshal(values)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// post发送json数据</span></span><br><span class="line">resp3, err := http.Post(<span class="string">&quot;https://httpbin.org/post&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewBuffer(json_data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码返回信息</span></span><br><span class="line"><span class="keyword">var</span> res2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.NewDecoder(resp3.Body).Decode(&amp;res2)</span><br><span class="line">fmt.Println(res2[<span class="string">&quot;json&quot;</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109082013186.png" alt="image-20210908201329065"></p><h3 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h3><p>服务端构造处理请求的函数handler</p><p>handler 函数有两个参数，http.ResponseWriter 和 http.Request</p><h4 id="1-普通服务"><a href="#1-普通服务" class="headerlink" title="1.普通服务"></a>1.普通服务</h4><h5 id="（1）处理http请求"><a href="#（1）处理http请求" class="headerlink" title="（1）处理http请求"></a>（1）处理http请求</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  我们需要读取的 HTTP 请求 header 中的所有内容，并将他们输出至 response body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headers</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, headers := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line"><span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%v: %v\n&quot;</span>, name, h)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）函数注册到路由"><a href="#（2）函数注册到路由" class="headerlink" title="（2）函数注册到路由"></a>（2）函数注册到路由</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/headers&quot;</span>, headers)</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们调用 ListenAndServe 并带上端口和 handler。nil表示使用我们刚刚设置的默认路由器</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081934116.png" alt="image-20210908193457887"></p><h4 id="2-接受GET请求参数"><a href="#2-接受GET请求参数" class="headerlink" title="2.接受GET请求参数"></a>2.接受GET请求参数</h4><h5 id="（1）处理get请求"><a href="#（1）处理get请求" class="headerlink" title="（1）处理get请求"></a>（1）处理get请求</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理带参数的get请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 延迟关闭响应</span></span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"><span class="comment">// 接受url的参数</span></span><br><span class="line">data := r.URL.Query()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出内容到页面</span></span><br><span class="line">answer := <span class="string">`&#123;&quot;status&quot; : &quot;ok&quot;&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求链接中的参数</span></span><br><span class="line">fmt.Fprintln( w ,data.Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">fmt.Fprintln( w ,data.Get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）函数注册到路由-1"><a href="#（2）函数注册到路由-1" class="headerlink" title="（2）函数注册到路由"></a>（2）函数注册到路由</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/get&quot;</span>, getHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们调用 ListenAndServe 并带上端口和 handler。nil表示使用我们刚刚设置的默认路由器</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109081941217.png" alt="image-20210908194148189"></p><h4 id="3-接受POST请求参数"><a href="#3-接受POST请求参数" class="headerlink" title="3.接受POST请求参数"></a>3.接受POST请求参数</h4><h5 id="（1）处理post请求函数"><a href="#（1）处理post请求函数" class="headerlink" title="（1）处理post请求函数"></a>（1）处理post请求函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"><span class="comment">// 请求类型为application/x-www-form-urlencoded时解析form数据</span></span><br><span class="line">r.ParseForm()</span><br><span class="line"><span class="comment">// 打印form数据</span></span><br><span class="line">fmt.Println(r.PostForm)</span><br><span class="line">fmt.Println(r.PostForm.Get(<span class="string">&quot;name&quot;</span>), r.PostForm.Get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 请求类型是application/json时从r.Body读取数据</span></span><br><span class="line">b, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Fprintln(w, <span class="keyword">string</span>(b))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）函数注册到路由-2"><a href="#（2）函数注册到路由-2" class="headerlink" title="（2）函数注册到路由"></a>（2）函数注册到路由</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们调用 ListenAndServe 并带上端口和 handler。nil表示使用我们刚刚设置的默认路由器</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h5 id="（3）请求类型为application-x-www-form-urlencoded"><a href="#（3）请求类型为application-x-www-form-urlencoded" class="headerlink" title="（3）请求类型为application/x-www-form-urlencoded"></a>（3）请求类型为application/x-www-form-urlencoded</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109070739852.png" alt="image-20210907073940923"></p><p>运行结果：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109070740152.png" alt="image-20210907074031817"></p><h5 id="（3）请求类型为application-json"><a href="#（3）请求类型为application-json" class="headerlink" title="（3）请求类型为application/json"></a>（3）请求类型为application/json</h5><p>服务端可以进行反序列化操作得到json内的数据</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109070744119.png" alt="image-20210907074448963"></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109082024169.jpg" alt="cute"></p><p>快乐生活，快乐工作，快乐学习</p><p><code>os.Exit(1)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109070837021.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;Go的吉祥物Gopher也太可爱了叭！！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://autovy.github.io/categories/Go/"/>
    
    
      <category term="入门教程" scheme="https://autovy.github.io/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Go" scheme="https://autovy.github.io/tags/Go/"/>
    
      <category term="面向接口" scheme="https://autovy.github.io/tags/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="并发编程" scheme="https://autovy.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>PHP|课题申报系统开发(Vue+TP)</title>
    <link href="https://autovy.github.io/2021/07/15/PHP/PHP-%E8%AF%BE%E9%A2%98%E7%94%B3%E6%8A%A5%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91(Vue+TP)/"/>
    <id>https://autovy.github.io/2021/07/15/PHP/PHP-%E8%AF%BE%E9%A2%98%E7%94%B3%E6%8A%A5%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91(Vue+TP)/</id>
    <published>2021-07-15T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.202Z</updated>
    
    <content type="html"><![CDATA[<img src="https://raw.staticdn.net/Autovy/Image/master/img/202109042317087.png" alt="image-20210904231657416" style="zoom:150%;"><p>支持国产😇</p><span id="more"></span><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="1-项目启动"><a href="#1-项目启动" class="headerlink" title="1.项目启动"></a>1.项目启动</h4><h5 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h5><p>Vue的依赖文件是package.json，其分为两部分</p><ul><li><p>全部安装（一般用这个）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>只安装dependencies里的内容（生产环境依赖）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --dependencies</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>只安装devDependencies（开发环境依赖）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --devDependencies</span><br></pre></td></tr></table></figure></li></ul><h5 id="删除全部依赖"><a href="#删除全部依赖" class="headerlink" title="删除全部依赖"></a>删除全部依赖</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall</span><br></pre></td></tr></table></figure><h5 id="生成依赖文件package-json"><a href="#生成依赖文件package-json" class="headerlink" title="生成依赖文件package.json"></a>生成依赖文件package.json</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><h5 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h5><p>启动项目的命令需要看package.json文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041953941.png" alt="image-20210904195358015"></p><p>所以要用<code>npm run dev</code>启动项目</p><h4 id="2-登录页面解析"><a href="#2-登录页面解析" class="headerlink" title="2.登录页面解析"></a>2.登录页面解析</h4><h5 id="ref访问子组件实例与元素"><a href="#ref访问子组件实例与元素" class="headerlink" title="ref访问子组件实例与元素"></a>ref访问子组件实例与元素</h5><p>vue的ref有类似于html的id的功能，可以用来给js访问子组件实例或元素</p><p><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">&quot;usernameInput&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Vue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$refs.usernameInput </span><br></pre></td></tr></table></figure><p>这样即可访问到输入框的内容</p><h5 id="组件的属性和方法"><a href="#组件的属性和方法" class="headerlink" title="组件的属性和方法"></a>组件的属性和方法</h5><p><strong>html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&quot;loginForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;form&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">prop</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Input</span> <span class="attr">v-model</span>=<span class="string">&quot;form.user_name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;prepend&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">&quot;16&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Icon</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Vue</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> data () &#123;</span><br><span class="line">           form: &#123;</span><br><span class="line">               user_name: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">               password: <span class="string">&#x27;&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>:model=&quot;form&quot;</code>的双向绑定，相当于视图上的数据与Vue对象上的数据是同步变化的</p><h4 id="3-http请求"><a href="#3-http请求" class="headerlink" title="3.http请求"></a>3.http请求</h4><p>参考：<a href="https://stackoverflow.com/questions/54955426/how-to-use-async-await-in-vue-js">How to use async/await in Vue.js?</a></p><h5 id="Vue异步更新"><a href="#Vue异步更新" class="headerlink" title="Vue异步更新"></a>Vue异步更新</h5><p>异步即几个程序同时开始，不会出现阻塞的现象，Vue进行网络请求时会出现异步现象导致函数执行不同</p><p><strong>同步（按序执行，阻塞现象）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">created ()&#123;</span><br><span class="line">    <span class="built_in">this</span>.getA()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">this</span>.getB() </span><br><span class="line">&#125;,</span><br><span class="line">methods : &#123;</span><br><span class="line">    getA ()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    getB ()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>异步（多个函数同时开始，结束时间决定出现顺序）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">created ()&#123;</span><br><span class="line">    <span class="built_in">this</span>.getA()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">this</span>.getB() </span><br><span class="line">&#125;,</span><br><span class="line">methods : &#123;</span><br><span class="line">    getA ()&#123;</span><br><span class="line">        $axios.post(<span class="string">`/getA`</span>,params)&#123;</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getB ()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="让程序同步"><a href="#让程序同步" class="headerlink" title="让程序同步"></a>让程序同步</h5><p>可以通过then或async/await使函数同步</p><p><strong>then</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    <span class="built_in">this</span>.getA().then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">this</span>.getB()</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods : &#123;</span><br><span class="line">    getA () &#123;</span><br><span class="line">        <span class="keyword">return</span> $axios.post(<span class="string">`/getA`</span>,params);</span><br><span class="line">    &#125;,</span><br><span class="line">    getB ()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>async/await</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> created ()&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.getA()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">this</span>.getB() </span><br><span class="line">&#125;,</span><br><span class="line">methods : &#123;</span><br><span class="line">    getA : <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> $axios.post(<span class="string">`/getA`</span>,params);</span><br><span class="line">    &#125;,</span><br><span class="line">    getB : <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="created"><a href="#created" class="headerlink" title="created()"></a>created()</h5><p>不需要让运行同步，只需要保证最后结束的函数（网络请求函数）正确赋值即可</p><p>采用异步的函数先通过created（相当于js页面加载即执行）执行完axios，赋值给data中的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.getLists();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getLists</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">this</span>.$base.url.ExpertFinishGetLists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cookie获取用户跳转到多少页</span></span><br><span class="line">    <span class="keyword">let</span> page = <span class="built_in">parseInt</span>(Cookies.get(<span class="string">&#x27;page&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">      <span class="built_in">this</span>.params.page = page</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.$post(url,<span class="built_in">this</span>.params).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.data = res.data;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//获取权限树</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ThinkPHP5"><a href="#ThinkPHP5" class="headerlink" title="ThinkPHP5"></a>ThinkPHP5</h3><p>参考文章：<a href="https://www.soolco.com/post/62551_1_1.html">https://www.soolco.com/post/62551_1_1.html</a></p><h4 id="1-路由配置"><a href="#1-路由配置" class="headerlink" title="1.路由配置"></a>1.路由配置</h4><p>配置为在thinkphp/public文件</p><h5 id="phpstudy设置根目录"><a href="#phpstudy设置根目录" class="headerlink" title="phpstudy设置根目录"></a>phpstudy设置根目录</h5><p>一般设为www文件（web服务器上的nginx配置也只会指向这个文件）</p><p>其入口是public文件</p><h5 id="配置伪静态"><a href="#配置伪静态" class="headerlink" title="配置伪静态"></a>配置伪静态</h5><p>访问PHP文件要去掉thinkphp路径中的index.php要配置伪静态</p><p><strong>apache伪静态规则</strong></p><p>修改apache配置文件httpd.conf</p><p>取消掉该行的注释</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule rewrite_module modules/mod_rewrite.so</span><br></pre></td></tr></table></figure><p>将将 <code>AllowOverride None</code>  修改为： <code>AllowOverride All</code></p><p>以开启</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Directory</span> /&gt;</span></span><br><span class="line">    Options +Indexes +FollowSymLinks +ExecCGI</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow from all</span><br><span class="line">    Require all granted</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在thinkphp/public入口文件添加 <code>.htaccess</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_rewrite.c</span>&gt;</span></span><br><span class="line">  Options +FollowSymlinks -Multiviews</span><br><span class="line">  RewriteEngine On</span><br><span class="line"></span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">  RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在phpstudy的网站设置中添加伪静态设置以对应.htaccess文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109042256334.png" alt="image-20210904225150721"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_rewrite.c</span>&gt;</span></span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line">RewriteRule ^index\.php$ - [L]</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">RewriteRule . /index.php [L]</span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Nginx伪静态规则</strong></p><p>在thinkphp/public入口文件添加 <code>nginx.htaccess</code> 文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check if a file exists, or route it to index.php.</span></span><br><span class="line"><span class="attribute">try_files</span> $uri $uri/ /exploit/index.php?$query_string;</span><br><span class="line"><span class="attribute">if</span> (!-e $request_filename) &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> <span class="regexp"> ^(.*)$</span>  /index.php?s=<span class="variable">$1</span>  <span class="literal">last</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置文件</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109042256152.png" alt="image-20210904225437200"></p><p>在 location中增加if语句最终为</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="attribute">index</span> index.php index.html;</span><br><span class="line">           <span class="attribute">if</span> (!-e $request_filename) &#123;</span><br><span class="line">              <span class="attribute">rewrite</span> <span class="regexp"> ^(.*)$</span>  /index.php?s=/<span class="variable">$1</span>  <span class="literal">last</span>;</span><br><span class="line">              break;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">400</span> /error/<span class="number">400</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">403</span> /error/<span class="number">403</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">404</span> /error/<span class="number">404</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">500</span> /error/<span class="number">500</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">501</span> /error/<span class="number">501</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">502</span> /error/<span class="number">502</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">503</span> /error/<span class="number">503</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">504</span> /error/<span class="number">504</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">505</span> /error/<span class="number">505</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">506</span> /error/<span class="number">506</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">507</span> /error/<span class="number">507</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">509</span> /error/<span class="number">509</span>.html;</span><br><span class="line">           <span class="attribute">error_page</span> <span class="number">510</span> /error/<span class="number">510</span>.html;</span><br><span class="line">           <span class="attribute">include</span> D:/phpstudy_pro/WWW/ktsb/public/nginx.htaccess;</span><br><span class="line">           <span class="attribute">autoindex</span>  <span class="literal">off</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="2-数据库导入"><a href="#2-数据库导入" class="headerlink" title="2.数据库导入"></a>2.数据库导入</h4><h5 id="navicat执行sql文件错误"><a href="#navicat执行sql文件错误" class="headerlink" title="navicat执行sql文件错误"></a>navicat执行sql文件错误</h5><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109042258221.png" alt="image-20210904225833897"></p><p>可以关闭以上两个选项查看执行错误</p><h5 id="数据库严格模式与非严格模式"><a href="#数据库严格模式与非严格模式" class="headerlink" title="数据库严格模式与非严格模式"></a>数据库严格模式与非严格模式</h5><p>严格模式下</p><ul><li>不支持对not null字段插入null值</li><li>不支持对自增长字段插入”值</li><li>不支持text字段有默认值</li><li>在严格模式下timestamp类型的字段不允许 ‘0000-00-00’ 作为有效日期</li></ul><h5 id="数据库模式修改"><a href="#数据库模式修改" class="headerlink" title="数据库模式修改"></a>数据库模式修改</h5><p>运行命令查看模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;sql_mode&#x27;</span></span><br></pre></td></tr></table></figure><p>显示出模式的项</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109042306119.png" alt="image-20210904230558730"></p><p>所以需要移除<code>NO_ZERO_IN_DATE,NO_ZERO_DATE</code>，最终变为</p><p><code>STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p><p>可以在root权限下运行命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;</span>;</span><br></pre></td></tr></table></figure><p>也可以在phpstudy环境下修改为非严格模式</p><p>​        <img src="https://raw.staticdn.net/Autovy/Image/master/img/202109042309767.png" alt="image-20210716155625246"></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109042317087.png&quot; alt=&quot;image-20210904231657416&quot; style=&quot;zoom:150%;&quot;&gt;

&lt;p&gt;支持国产😇&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="https://autovy.github.io/categories/php/"/>
    
    
      <category term="开发实战" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="框架学习" scheme="https://autovy.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="前端" scheme="https://autovy.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="thinkphp" scheme="https://autovy.github.io/tags/thinkphp/"/>
    
      <category term="Vue" scheme="https://autovy.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java|基于SSM评论管理系统开发</title>
    <link href="https://autovy.github.io/2021/06/30/Java/Java-%E5%9F%BA%E4%BA%8ESSM%E8%AF%84%E8%AE%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    <id>https://autovy.github.io/2021/06/30/Java/Java-%E5%9F%BA%E4%BA%8ESSM%E8%AF%84%E8%AE%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/</id>
    <published>2021-06-30T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.177Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041811913.png" alt="img"></p><span id="more"></span><h3 id="Maven导入依赖"><a href="#Maven导入依赖" class="headerlink" title="Maven导入依赖"></a>Maven导入依赖</h3><h4 id="1-解决依赖标红问题"><a href="#1-解决依赖标红问题" class="headerlink" title="1.解决依赖标红问题"></a>1.解决依赖标红问题</h4><p><code>java.lang.ClassNotFoundException: Cannot find class: XXX</code></p><ul><li>在Maven仓库查找是否有对应版本</li><li>可以删除标红的版本粗暴解决</li><li>如果仍无法解决可以手动下载导入该jar</li></ul><h4 id="2-解决程序文件包引用问题"><a href="#2-解决程序文件包引用问题" class="headerlink" title="2.解决程序文件包引用问题"></a>2.解决程序文件包引用问题</h4><ul><li><p>通过重写构建项目查看导入的错误</p></li><li><p>参看外部库的包与Maven添加的包是否有重复冲突</p></li><li><p>使用idea修复，将Maven对应的包添加到类路径</p></li></ul><p>3.SSM常用依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Spring--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- jsp --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- json --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1.整体架构"></a>1.整体架构</h4><h4 id="2-主程序分层"><a href="#2-主程序分层" class="headerlink" title="2.主程序分层"></a>2.主程序分层</h4><p>业务逻辑：</p><p> <strong>Controller–&gt;service接口–&gt;serviceImpl–&gt;dao接口–&gt;daoImpl–&gt;mapper–&gt;db</strong></p><p>执行流程：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041811913.png" alt="img"></p><p>而<code>bean/pojo</code>则是实体类作为各层次处理传递的对象：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041811687.png" alt="image-20210629104056016"></p><h3 id="相关配置文件"><a href="#相关配置文件" class="headerlink" title="相关配置文件"></a>相关配置文件</h3><h4 id="1-web-xml"><a href="#1-web-xml" class="headerlink" title="1.web.xml"></a>1.web.xml</h4><p>一般放在web文件夹的WEB-INF文件下，用于配置SSM整体的框架配置，以下是常用的配置项</p><p>1.启动Spring容器</p><p>指向applicationContext.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.springmvc的前端控制器，拦截所有请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring mvc核心：分发servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring mvc的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.字符编码过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3、字符编码过滤器，一定要放在所有过滤器之前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.Rest API配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 4、使用Rest风格的URI，将页面普通的post请求转为指定的delete或者put请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.数据包解析配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--HttpPutFormContentFilter：将请求体中的数据解析包装成一个map --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-applicationContext-xml"><a href="#2-applicationContext-xml" class="headerlink" title="2.applicationContext.xml"></a>2.applicationContext.xml</h4><p>整合spring和mybatis配置，一般用于配置数据库连接和数据库实体类，mapper实体类（可用于自动装配）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库配置信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描XML配置文件：数据库连接对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对应实体类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pojo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 查找映射配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描Mapper类：映射方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.comments.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-springmvc-xml"><a href="#3-springmvc-xml" class="headerlink" title="3.springmvc.xml"></a>3.springmvc.xml</h4><p>主要用于管理映射关系和视图的定位</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描Controller注解，并纳入Spring管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.app.controller&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注解驱动，使访问路径与方法比配通过注解配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置静态页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图定位 --&gt;</span></span><br><span class="line">    &lt;bean</span><br><span class="line">            class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-配置文件处理流程"><a href="#4-配置文件处理流程" class="headerlink" title="4.配置文件处理流程"></a>4.配置文件处理流程</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041811953.png" alt="SSM框架的整合与使用——实现简单的转账系统"></p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041812536.png" alt="image-20210904181218197"></p><h3 id="Bean层"><a href="#Bean层" class="headerlink" title="Bean层"></a>Bean层</h3><p>首先创建实体层，实体层是各层次用于输入输出处理的数据对象可以参照数据库设计所需的对象与属性</p><h4 id="1-Java-Bean概念"><a href="#1-Java-Bean概念" class="headerlink" title="1.Java Bean概念"></a>1.Java Bean概念</h4><p>JavaBeans是Java一种特殊的类，既可以是单独的类型，也可以将多个对象封装到一个类中。</p><p>在系统设计中，其常常对应数据库的字段抽象</p><p>区别于其他的类，Bean一定会有提供getter和setter方法访问对象的每一个私有属性</p><h4 id="2-Java-Bean构造方法"><a href="#2-Java-Bean构造方法" class="headerlink" title="2.Java Bean构造方法"></a>2.Java Bean构造方法</h4><h5 id="手动编码"><a href="#手动编码" class="headerlink" title="手动编码"></a>手动编码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h5><p>Idea可以通过数据库工具生成Bean实体类</p><p>连接好数据库（注意某些版本的mysql需要填写时区，一般我会填为GMT）</p><p>依据数据表生成Bean</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041650556.png" alt="image-20210904165034192"></p><h5 id="Lombok插件补全"><a href="#Lombok插件补全" class="headerlink" title="Lombok插件补全"></a>Lombok插件补全</h5><p>通过lombok工具，我们只需要在Bean属性添加相关注解，idea会自动为我们生成getter和setter方法</p><ul><li>idea中安装插件Lombok（最新版idea已捆绑）</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041657535.png" alt="image-20210904165746685"></p><ul><li>maven中引入lombok包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写Bean与注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">private long id;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">private String content;</span><br></pre></td></tr></table></figure><ul><li><p>自动生成方法</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041703886.png" alt="image-20210904170341335"></p></li></ul><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><h4 id="1-构建SQL"><a href="#1-构建SQL" class="headerlink" title="1.构建SQL"></a>1.构建SQL</h4><ul><li>1.xml映射文件法</li></ul><p>Dao层（即Mapper层）内有两个文件，Mapper文件创建方法对应到xml文件映射sql语句处理实体类</p><p><strong>xml文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里namespace指向CategoryMapper即可将sql语句与Mapper中的方法绑定 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单独使用xml映射sql语句时，指向是实体类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.app.mapper.CategoryMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span> &gt;</span></span><br><span class="line">        insert into category_ ( name ) values (#&#123;name&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span> &gt;</span></span><br><span class="line">        delete from category_ where id= #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;get&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;_int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.app.pojo.Category&quot;</span>&gt;</span></span><br><span class="line">        select * from   category_  where id= #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span> &gt;</span></span><br><span class="line">        update category_ set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.app.pojo.Category&quot;</span>&gt;</span></span><br><span class="line">        select * from   category_</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Mapper文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.app.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.app.pojo.Category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql方法映射（可以用注解，也可以与映射到Category.xml文件）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>2.注解法</p><p>直接通过注解将方法映射到sql语句（简单项目推荐这个）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射动态的sql语句</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法内填写的是CategoryDynaSqlProvider类中定义的动态sql</span></span><br><span class="line">    <span class="meta">@InsertProvider(type = CategoryDynaSqlProvider.class, method = &quot;add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteProvider(type = CategoryDynaSqlProvider.class, method = &quot;delete&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SelectProvider(type = CategoryDynaSqlProvider.class, method = &quot;get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateProvider(type = CategoryDynaSqlProvider.class, method = &quot;update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SelectProvider(type =  CategoryDynaSqlProvider.class, method = &quot;list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.动态sql法</li></ul><p>用Java表示sql语句，达到sql语句动态化效果</p><p><strong>SqlProvider文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列出所有用户数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">            .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .FROM(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得指定id用户数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">            .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .FROM(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">            .WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得指定名字用户数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">            .SELECT(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .FROM(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">            .WHERE(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">            .INSERT_INTO(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">            .VALUES(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;#&#123;name&#125;&quot;</span>)</span><br><span class="line">            .VALUES(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;#&#123;password&#125;&quot;</span>)</span><br><span class="line">            .VALUES(<span class="string">&quot;role&quot;</span>,<span class="string">&quot;#&#123;role&#125;&quot;</span>)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">            .UPDATE(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">            .SET(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>)</span><br><span class="line">            .SET(<span class="string">&quot;password=#&#123;password&#125;&quot;</span>)</span><br><span class="line">            .SET(<span class="string">&quot;role=#&#123;role&#125;&quot;</span>)</span><br><span class="line">            .WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">            .DELETE_FROM(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">            .WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>)</span><br><span class="line">            .toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Mapper文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库User表操作</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户</span></span><br><span class="line">    <span class="meta">@InsertProvider(type=UsersSqlProvider.class,method=&quot;add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Users users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="meta">@DeleteProvider(type=UsersSqlProvider.class,method=&quot;delete&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找用户</span></span><br><span class="line">    <span class="meta">@SelectProvider(type=UsersSqlProvider.class,method=&quot;get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Users <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找用户(按名字)</span></span><br><span class="line">    <span class="meta">@SelectProvider(type=UsersSqlProvider.class,method=&quot;getname&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Users <span class="title">getname</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户</span></span><br><span class="line">    <span class="meta">@UpdateProvider(type=UsersSqlProvider.class,method=&quot;update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Users users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出所有用户</span></span><br><span class="line">    <span class="meta">@SelectProvider(type=UsersSqlProvider.class,method=&quot;list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Users&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Mapper的自动装配"><a href="#2-Mapper的自动装配" class="headerlink" title="2.Mapper的自动装配"></a>2.Mapper的自动装配</h4><p>applicationContext配置扫描Mpaper类，Spring自动装配Mapper类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 扫描XML配置文件：数据库连接对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对应实体类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pojo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 查找映射配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/comments/mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 扫描Mapper类：映射方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.comments.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-Mapper测试"><a href="#3-Mapper测试" class="headerlink" title="3.Mapper测试"></a>3.Mapper测试</h4><p>mapper层测试方法：其用与serivce层的实现类一样的方法对mapper层进行调用，从而实现对mapper层的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 加载配置文件进行测试</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:springMVC.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解装配要测试的Mapper类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出用户测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Users&gt; user = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span>(Users u :user)&#123;</span><br><span class="line">            System.out.println(u.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Users user = <span class="keyword">new</span> Users();</span><br><span class="line">        user.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setRole(<span class="string">&quot;vistor&quot;</span>);</span><br><span class="line">        userMapper.add(user);</span><br><span class="line">        testList();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serivce层"><a href="#Serivce层" class="headerlink" title="Serivce层"></a>Serivce层</h3><p>服务层有serivce接口和serivceimlmpl实现两个文件，该层主要用于调用dao层与数据库交互并为controller层提供服务</p><h4 id="1-serivce接口"><a href="#1-serivce接口" class="headerlink" title="1.serivce接口"></a>1.serivce接口</h4><ul><li>其函数构成与mapper文件类似（都是一些增删改查的方法），serivce内的函数可以以一些需要用户填写的字段作为参数</li><li>但是mapper是面向dao层使用的（与数据库联系）</li><li>而serivce是面向controller层使用的（与用户端联系）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Users服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UsersService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出所有用户</span></span><br><span class="line">    <span class="function">List&lt;Users&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(String name, String password, String role)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找用户</span></span><br><span class="line">    <span class="function">Users <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找用户(按名字)</span></span><br><span class="line">   <span class="function">Users <span class="title">getname</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id ,String name, String password)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-serivceimlmpl实现类"><a href="#2-serivceimlmpl实现类" class="headerlink" title="2.serivceimlmpl实现类"></a>2.serivceimlmpl实现类</h4><ul><li>serivce接口的具体实现</li><li>注解Service（类似于@Component，@Controller）</li><li>将类自动注册到Spring容器，而不需要定义bean</li><li>控制类可以直接通过接口调用到其实现类中的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersServiceImpl</span> <span class="keyword">implements</span> <span class="title">UsersService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出所有用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Users&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Users&gt; user = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span>(Users u :user)&#123;</span><br><span class="line">            System.out.println(u.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(String name, String password, String role)</span></span>&#123;</span><br><span class="line">            Users users =  <span class="keyword">new</span> Users();</span><br><span class="line">            users.setName(name);</span><br><span class="line">            users.setPassword(password);</span><br><span class="line">            users.setRole(role);</span><br><span class="line">            userMapper.add(users);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        userMapper.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Users <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">       Users user = userMapper.get(id);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找用户(按名字)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Users <span class="title">getname</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Users user =  userMapper.getname(name);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id ,String name, String password)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Users users =  userMapper.get(id);</span><br><span class="line">        users.setName(name);</span><br><span class="line">        users.setPassword(password);</span><br><span class="line">        userMapper.update(users);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Serivce的自动装配"><a href="#3-Serivce的自动装配" class="headerlink" title="3.Serivce的自动装配"></a>3.Serivce的自动装配</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描Controller注解，并纳入Spring管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.comments.controller&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 扫描service --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.comments.service&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-Serivce层测试"><a href="#4-Serivce层测试" class="headerlink" title="4.Serivce层测试"></a>4.Serivce层测试</h4><p>加载配置文件，并装配服务对象进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service层测试方法</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 加载配置文件进行测试</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:springMVC.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersServiceImplTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UsersService usersService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        usersService.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = usersService.add(<span class="string">&quot;精灵&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;vistor&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testGet1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Users user = usersService.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testGet2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">         Users user = usersService.getname(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testupdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = usersService.update(<span class="number">2</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Json消息体"><a href="#Json消息体" class="headerlink" title="Json消息体"></a>Json消息体</h3><h4 id="1-自定义Json消息体"><a href="#1-自定义Json消息体" class="headerlink" title="1.自定义Json消息体"></a>1.自定义Json消息体</h4><p>建立util文件放入JsonMsg类，用于设置Json返回对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">jsonmsg</span><span class="params">(String staut, String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    jsonObject.put(staut, msg);</span><br><span class="line">    <span class="keyword">return</span> jsonObject.toJSONString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Fastjson"><a href="#2-Fastjson" class="headerlink" title="2.Fastjson"></a>2.Fastjson</h4><p>Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象</p><ul><li>添加maven依赖</li><li>使用注解获得相应的JSONField / 创建JSON对象输出</li></ul><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>负责调用服务层的方法，并映射路径提供给客户端使用</p><h4 id="1-请求映射"><a href="#1-请求映射" class="headerlink" title="1.请求映射"></a>1.请求映射</h4><ul><li>路径映射</li><li>请求方式</li><li>Controller默认以返回值去寻找资源，如果配置了jsp则会寻找对应jsp，加上@ResponseBody注解则直接输出返回的内容（如json）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得指定用户</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/list/&#123;id&#125;&quot;, method = RequestMethod.GET, produces = &quot;application/json; charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getuser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Users res = usersService.get(id);</span><br><span class="line">    <span class="keyword">return</span> JSONObject.toJSONString(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-请求数据获取"><a href="#2-请求数据获取" class="headerlink" title="2.请求数据获取"></a>2.请求数据获取</h4><ul><li><p>数据过滤判断</p></li><li><p>请求415问题的解决</p><p>Java后端不能对POST或PUT发来的form-data,x-www-form-urlencoded的数据进行处理而出现的问题</p><p>@RequestBody只能处理通过json发送的请求</p></li><li><p>POST请求获得数据类型与方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增用户</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/insert&quot;, method = RequestMethod.POST, produces = &quot;application/json; charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insert</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,String&gt; params)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// json消息</span></span><br><span class="line">    JsonMsg json = <span class="keyword">new</span> JsonMsg();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获得要更新用户请求数据</span></span><br><span class="line">    String name = params.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String password = params.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String role = params.get(<span class="string">&quot;role&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 数据库查询名称</span></span><br><span class="line">    Users users =  usersService.getname(name);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(users == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数齐全判断</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; role != <span class="keyword">null</span>) &#123;</span><br><span class="line">            usersService.add(name, password, role);</span><br><span class="line">            <span class="keyword">return</span> json.jsonmsg(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;新增用户成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> json.jsonmsg(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;参数不齐全&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json.jsonmsg(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;用户名已重复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-中文乱码问题"><a href="#3-中文乱码问题" class="headerlink" title="3.中文乱码问题"></a>3.中文乱码问题</h4><ul><li><p>参考文章：<a href="https://blog.csdn.net/kalision/article/details/46441081">彻底解决Spring MVC 中文乱码</a></p></li><li><p>过滤器</p><p>在web.xml设置编码过滤器解决编码问题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编码过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceEncoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><ul><li>produces属性</li></ul><p>@RequestMapping注解可以设置发送和接收数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/delete/&#123;id&#125;&quot;, method = RequestMethod.DELETE, produces = &quot;application/json; charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="4-Controller自动装配"><a href="#4-Controller自动装配" class="headerlink" title="4.Controller自动装配"></a>4.Controller自动装配</h4><p>如果仅仅是返回json可以配置驱动，如果有jsp页面则需要配置静态页面并且视图定位</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注解驱动，使访问路径与方法匹配通过注解配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置静态页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图定位 --&gt;</span></span><br><span class="line">&lt;bean</span><br><span class="line">        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-Controller层测试"><a href="#5-Controller层测试" class="headerlink" title="5.Controller层测试"></a>5.Controller层测试</h4><ul><li>使用mock模拟用户进行测试（比较复杂，一般不建议使用）</li><li>运行tomcat服务器后，使用浏览器+postman进行测试</li><li><code>System.out.println</code>控制台输出</li></ul><h3 id="Web服务器添加"><a href="#Web服务器添加" class="headerlink" title="Web服务器添加"></a>Web服务器添加</h3><h4 id="1-添加WEB工件"><a href="#1-添加WEB工件" class="headerlink" title="1.添加WEB工件"></a>1.添加WEB工件</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041759524.png" alt="image-20210904175428011"></p><h4 id="2-配置tomcat服务器"><a href="#2-配置tomcat服务器" class="headerlink" title="2.配置tomcat服务器"></a>2.配置tomcat服务器</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041759825.png" alt="image-20210904175840362"></p><p>添加刚才创建的工件（注意修改上下文，这里影响访问的url）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041819887.png" alt="image-20210904180030909"></p><h4 id="3-测试服务器"><a href="#3-测试服务器" class="headerlink" title="3.测试服务器"></a>3.测试服务器</h4><p>出现端口冲突，可以修改http端口和JMX端口，但要注意修改tomcat的server.xml文件为对应的http端口</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041819682.png" alt="image-20210904180518251"></p><p>也可以找到正在运行的端口，然后关闭其进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr 8080</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill -f -pid 进程编号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109041811913.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://autovy.github.io/categories/Java/"/>
    
    
      <category term="开发实战" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
      <category term="Java" scheme="https://autovy.github.io/tags/Java/"/>
    
      <category term="框架学习" scheme="https://autovy.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="后端" scheme="https://autovy.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SSM" scheme="https://autovy.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>开发工具|Linux学习手册</title>
    <link href="https://autovy.github.io/2021/06/27/Tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Linux%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>https://autovy.github.io/2021/06/27/Tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Linux%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</id>
    <published>2021-06-27T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040952867.png" alt="image-20210904095248687"></p><span id="more"></span><h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><h4 id="1-Linux发行版"><a href="#1-Linux发行版" class="headerlink" title="1.Linux发行版"></a>1.Linux发行版</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949495.jpeg" alt="img"></p><p>Linux发行版 = Liunx核心 +应用软件</p><h4 id="2-Liunx内核架构"><a href="#2-Liunx内核架构" class="headerlink" title="2.Liunx内核架构"></a>2.Liunx内核架构</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949098.jpeg" alt="img"></p><p>Liunx内核有5个子系统：</p><ul><li>Process Scheduler，进程管理、进程调度。负责管理 CPU 资源，以便让各个进程可以以尽量公平的方式访问 CPU。</li><li>Memory Manager，内存管理。负责管理 Memory（内存）资源，以便让各个进程可以安全的共享机器的内存资源。</li><li>VFS（Virtual File System），虚拟文件系统。Linux 内核将不同功能的外部设备抽象为可以通过统一的文件操作接口（open、close、read、write 等）来访问。这就是 Linux系统“一切皆是文件”的体现</li><li>设备驱动，负责管理第三方设备接入/终端</li><li>Network，网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准</li></ul><h3 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h3><h4 id="1-开机关机"><a href="#1-开机关机" class="headerlink" title="1.开机关机"></a>1.开机关机</h4><p>开启会启动许多程序，在windows叫做“服务“（service），在Linux叫做“守护进程”（daemon）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949420.png" alt="Linux开机启动脚本 - 转1"></p><p>同步数据命令：sync（常常用于强制关机前）</p><p>关机命令：shutdown</p><p>重启命令：reboot</p><h4 id="2-基本目录结构"><a href="#2-基本目录结构" class="headerlink" title="2.基本目录结构"></a>2.基本目录结构</h4><p>基本知识：</p><ul><li>Liunx一切皆文件</li><li>根目录/，所有文件都挂载在这个节点下</li><li>ls 查看当前目录下所有文件</li></ul><p>Liunx目录结构：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949471.png" alt="img"></p><p>比较常用的如下：</p><ul><li>/etc ： 该目录可用来存放所有系统管理需要的配置文件和子目录</li><li>/home：用户主目录（在liunx，每个用户都有一个自己的目录）</li><li>/opt : 主机额外安装软件存放的位置</li><li>/root : 系统管理员用户主目录</li><li>/usr：用户的应用程序和文件都放在这个目录，类似于Windows的program files目录</li><li>/tmp ：存放临时文件，用完即丢的文件如安装包</li><li>/var : 存放不断扩充的东西，习惯于放那些经常被修改的目录</li></ul><h3 id="Liunx目录管理"><a href="#Liunx目录管理" class="headerlink" title="Liunx目录管理"></a>Liunx目录管理</h3><h4 id="1-文件管理基本命令"><a href="#1-文件管理基本命令" class="headerlink" title="1.文件管理基本命令"></a>1.文件管理基本命令</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949194.png" alt="img"></p><p>比较常用的如下：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp：复制文件或目录</li><li>rm：移除文件或目录</li><li>mv：移动文件与目录，或修改文件与目录的名称</li><li>touch：创建文件</li></ul><h4 id="2-ls命令"><a href="#2-ls命令" class="headerlink" title="2.ls命令"></a>2.ls命令</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949481.png" alt="这里写图片描述"></p><h4 id="3-mkdir命令"><a href="#3-mkdir命令" class="headerlink" title="3.mkdir命令"></a>3.mkdir命令</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949299.png" alt="img"></p><h4 id="4-rm命令"><a href="#4-rm命令" class="headerlink" title="4.rm命令"></a>4.rm命令</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949353.png" alt="img"></p><h3 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h3><h4 id="1-文件属性"><a href="#1-文件属性" class="headerlink" title="1.文件属性"></a>1.文件属性</h4><p>文件属性字符串:<br><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949841.png" alt="img"></p><p>文件权限字符串：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949192.png" alt="363003_1227493859FdXT"></p><p>文件类型：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949930.png" alt="linux文件类型和权限- xd_xumaomao - 博客园"></p><p>常用的如下：</p><ul><li><code>-</code>：普通文件</li><li><code>d</code>：目录文件</li><li><code>l</code>：连接文件（相当于Windows的快捷方式）</li></ul><p>文件权限：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949379.png" alt="img"></p><p>在文件属性中每组权限按<code>rwx</code>这样的顺序显示，而<code>-</code>表示没有该权限</p><h4 id="2-chgrp-amp-chown命令"><a href="#2-chgrp-amp-chown命令" class="headerlink" title="2.chgrp&amp;chown命令"></a>2.chgrp&amp;chown命令</h4><p>更改文件属组（文件所属用户组）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">charg -R 属组名 文件名</span><br></pre></td></tr></table></figure><p>更改文件属主（文件所有者）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 属主名 文件名</span><br></pre></td></tr></table></figure><p>同时修改文件的属组和属主</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 属主名:属组名 文件名</span><br></pre></td></tr></table></figure><h4 id="3-chmod命令"><a href="#3-chmod命令" class="headerlink" title="3.chmod命令"></a>3.chmod命令</h4><p>chmod可以设置文件访问权限，有两种设置方法：数字（常用）和符号</p><p>Linux文件的基本权限有9个，分别是owner/group/others 三种身份分别的rwx权限（9个权限三个三个为一组）</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949807.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用格式</span></span><br><span class="line">chmod 权限数字组 文件名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">开放所有权限给所有人</span></span><br><span class="line">chmod 777 root</span><br></pre></td></tr></table></figure><h4 id="4-文件内容查看"><a href="#4-文件内容查看" class="headerlink" title="4.文件内容查看"></a>4.文件内容查看</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949445.png" alt="夺命雷公狗---linux NO:11 linux的文本文件查看命令- 夺命雷公狗- 博客园"></p><ul><li>nl：显示文件中的时候标注行号</li><li>less与more类似，有分页的功能，但是可以往前翻页（空格下翻页，pageDown，pageUp代表翻动页面）</li><li>在less查看模式下：q命令退出，<code>/</code>命令向下查询字符串，<code>?</code>向下查询字符串，<code>n</code>继续搜寻下一个，<code>N</code>向上寻找</li></ul><h3 id="Linux链接"><a href="#Linux链接" class="headerlink" title="Linux链接"></a>Linux链接</h3><h4 id="1-链接类型"><a href="#1-链接类型" class="headerlink" title="1.链接类型"></a>1.链接类型</h4><p>Linux的链接分为两种：  </p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949118.png" alt="linux之软连接硬链接- osc_3uvms8cw的个人空间- OSCHINA - 中文开源技术交流社区"></p><ul><li>软链接：类似与windows下的快捷方式，删除了源文件，快捷方式也访问不了</li><li>硬链接：允许一个文件有多个路径，用户可以通过这种机制建立硬链接到一些重要文件上，防止误删</li></ul><h4 id="2-创建链接"><a href="#2-创建链接" class="headerlink" title="2.创建链接"></a>2.创建链接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为f1文件创建一个硬链接f2</span></span><br><span class="line">ln f1 f2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为f1文件创建一个软链接（符号链接）f3</span></span><br><span class="line">ln -s f1 f3</span><br></pre></td></tr></table></figure><h4 id="3-链接相关测试"><a href="#3-链接相关测试" class="headerlink" title="3.链接相关测试"></a>3.链接相关测试</h4><p>文件内容修改：</p><p>原文件的内容，其硬链接的内容，其软连接访问的内容都是保持一致的，修改其中之一其他两项访问的内容也会相应变化</p><p>文件删除：</p><p>删除原文件后，硬链接依旧可以访问，而软链接无法打开（快捷方式失效）</p><h3 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h3><h4 id="1-Vim简介"><a href="#1-Vim简介" class="headerlink" title="1.Vim简介"></a>1.Vim简介</h4><ul><li>Vim是一种文本编辑器，有代码补全，编译及错误跳转等方便编程的功能</li><li>Vim可以通过参加实现IDE一样的功能</li><li>Vim基本使用：查看内容，编辑内容，保存内容</li></ul><h4 id="2-Vim三模式"><a href="#2-Vim三模式" class="headerlink" title="2.Vim三模式"></a>2.Vim三模式</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040949256.jpeg" alt="Linux 之Vim 命令使用（详细总结） - 知乎"></p><ul><li>命令模式只能查看文本，可以通过键盘输入切换到输入模式和底部命令行模式</li><li>输入模式可以编辑文件</li><li>末行模式即命令行模式可以执行退出，保存文件等操作</li></ul><h4 id="3-命令模式"><a href="#3-命令模式" class="headerlink" title="3.命令模式"></a>3.命令模式</h4><ul><li><code>数字+空格</code> ：横向移动光标，向右移动n个字</li><li><code>数字+回车</code>：纵向移动光标，向下移动n行</li><li><code>/word</code>：向光标下寻找名为word的字符串</li><li><code>?word</code>：向光标下寻找名为word的字符串</li><li><code>n/N</code>:进行下翻页和下翻页（n表示重复上一个搜寻动作，N则是反向于上一个搜寻动作）</li><li><code>u</code>：重复上一个操作</li></ul><h4 id="4-输入模式"><a href="#4-输入模式" class="headerlink" title="4.输入模式"></a>4.输入模式</h4><p>输入模式常用按键：</p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202271721696.png" alt="image-20220227172148042" style="zoom: 67%;"><h4 id="5-命令行模式"><a href="#5-命令行模式" class="headerlink" title="5.命令行模式"></a>5.命令行模式</h4><p>常用命令：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202202271722004.png" alt="image-20220227172248760"></p><p><code>:ZZ</code>：不存储直接离开（ctrl + z）</p><p><code>:set nu</code>：设置行号，打开文本每一行都显示行号</p><p>注意如果输入的命令不存在会返回127错误，而且会回到vim界面</p><h3 id="Linux账号管理"><a href="#Linux账号管理" class="headerlink" title="Linux账号管理"></a>Linux账号管理</h3><p>账号管理实质是对<code>/etc/passwd</code>文件的更新</p><h4 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1.添加用户"></a>1.添加用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -选项 用户名</span><br></pre></td></tr></table></figure><p>useradd 相关选项：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950318.png" alt="op"></p><p>常用<code>-m</code>自动为用户在home下创建目录</p><p>可以在/etc/passwd文件夹下查看用户相关的配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><h4 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2.删除用户"></a>2.删除用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -选项 用户名</span><br></pre></td></tr></table></figure><p>常用<code>-r</code>选项自动删除用户在home下的用户目录</p><h4 id="3-修改用户"><a href="#3-修改用户" class="headerlink" title="3.修改用户"></a>3.修改用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -选项 修改内容 用户名</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950615.png" alt="选项"></p><h4 id="4-切换用户"><a href="#4-切换用户" class="headerlink" title="4.切换用户"></a>4.切换用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su + 用户名</span><br></pre></td></tr></table></figure><p>切换到root用户：<code>sudo su</code></p><p>修改主机名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname 修改的名称</span><br></pre></td></tr></table></figure><h4 id="5-用户口令管理命令"><a href="#5-用户口令管理命令" class="headerlink" title="5.用户口令管理命令"></a>5.用户口令管理命令</h4><p>创建/修改用户的密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950354.png" alt="选项"></p><h3 id="Linux用户组管理"><a href="#Linux用户组管理" class="headerlink" title="Linux用户组管理"></a>Linux用户组管理</h3><p>组的增加，删除和修改实际上就是对<code>/etc/group</code>文件的更新</p><h4 id="1-创建用户组"><a href="#1-创建用户组" class="headerlink" title="1.创建用户组"></a>1.创建用户组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用户组组的id自增1</span></span><br><span class="line">groupadd 组名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定id创建用户组</span></span><br><span class="line">groupadd -g 233 组名</span><br></pre></td></tr></table></figure><h4 id="2-删除用户组"><a href="#2-删除用户组" class="headerlink" title="2.删除用户组"></a>2.删除用户组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除用户组</span></span><br><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><h4 id="3-修改用户组"><a href="#3-修改用户组" class="headerlink" title="3.修改用户组"></a>3.修改用户组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本样式</span></span><br><span class="line">groupmod 选项 修改内容 组名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 案例</span></span><br><span class="line">groupmod -g 666 -n newname 组名</span><br></pre></td></tr></table></figure><h4 id="4-切换用户组"><a href="#4-切换用户组" class="headerlink" title="4.切换用户组"></a>4.切换用户组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录的当前用户切换到root组</span></span><br><span class="line">newgrp root</span><br></pre></td></tr></table></figure><h4 id="5-用户管理相关文件"><a href="#5-用户管理相关文件" class="headerlink" title="5.用户管理相关文件"></a>5.用户管理相关文件</h4><p><code>/etc/passwd</code>文件：</p><p><strong>具体格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令（不可见一般显示为x）:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950861.jpeg" alt="详解Linux中/etc/passwd文件详解Linux中/etc/passwd文件"></p><p>该文件的每一行都代表一个用户，可以查看用户主目录位置，并查看属于哪一个组</p><p><code>/etc/shadow</code>文件：</p><p>用户密码加密后存放在/etc/shadow文件，与passwd文件一一对应</p><p><strong>具体格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950761.jpeg" alt="img"></p><p><code>/etc/group</code>文件：</p><p><strong>具体格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组ID:组内用户列表</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950338.jpeg" alt="img"></p><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="1-df命令"><a href="#1-df命令" class="headerlink" title="1.df命令"></a>1.df命令</h4><p>列出文件系统整体的磁盘使用量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 普通查看</span></span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内存转换为M</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041103972.png" alt="img"></p><h4 id="2-du命令"><a href="#2-du命令" class="headerlink" title="2.du命令"></a>2.du命令</h4><p>检查磁盘空间使用量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录内存占用</span></span><br><span class="line">du </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查根目录每个目录所占用的容量</span></span><br><span class="line">du -sm /*</span><br></pre></td></tr></table></figure><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950313.png" alt="img"></p><h4 id="3-mount-amp-umount命令"><a href="#3-mount-amp-umount命令" class="headerlink" title="3.mount&amp;umount命令"></a>3.mount&amp;umount命令</h4><p>可类比于U盘的使用</p><p>mount：挂载设备</p><p>umount：卸载设备</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="1-进程介绍"><a href="#1-进程介绍" class="headerlink" title="1.进程介绍"></a>1.进程介绍</h4><ul><li>在Liunx中，每个程序都是有自己的一个进程，每一个进程都有一个id号</li><li>每一个进程都有一个父进程</li><li>进程有两种存在方式：前台运行（程序），后台运行（服务）</li></ul><h4 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h4><ul><li>进程就是应用程序的启动实例，而线程从属于进程，是程序的实际执行者</li><li>一个进程至少包含一个主线程，也可以有更多的子线程</li><li>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950452.webp" alt="img"></p><h4 id="3-任务执行方式"><a href="#3-任务执行方式" class="headerlink" title="3.任务执行方式"></a>3.任务执行方式</h4><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950096.png" alt="img"></p><ul><li>串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个</li><li>并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件</li><li>并发是指两个或多个事件在同一时间间隔内发生，常用于多线程编程中</li></ul><h4 id="4-同步异步阻塞"><a href="#4-同步异步阻塞" class="headerlink" title="4.同步异步阻塞"></a>4.同步异步阻塞</h4><p>同步与异步关注的是<strong>消息通信机制</strong>：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950691.png" alt="img"></p><ul><li>由调用方盲目主动问询的方式是同步调用</li><li>由被调用方主动通知调用方任务已完成的方式是异步调用</li><li>同步异步是对系统内核而言（是否主动通知应用层）</li></ul><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果</strong>时的状态：</p><p><img src="https://pic3.zhimg.com/80/v2-6507ab3517814b1b84fbff9a3eb31842_720w.png" alt="img"></p><ul><li>被挂起无法执行其他操作的则是阻塞型</li><li>被立即「抽离」去完成其他「任务」的则是非阻塞型的</li><li>阻塞和非阻塞对应用层而言（应用是否去做其他事情）</li></ul><h4 id="5-ps命令"><a href="#5-ps命令" class="headerlink" title="5.ps命令"></a>5.ps命令</h4><p><code>ps</code>查看当前系统中正在执行的各种进程</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109040950813.png" alt="Linux学习之路(三) —— Linux高级系统管理命令"></p><p>常用案例：</p><p>查看mysql的所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux|grep mysql</span><br></pre></td></tr></table></figure><ul><li><code>ps -aux</code> ：查看所有进程信息</li><li><code>|</code> ：Linux管道符，过滤上一条命令输出的信息</li><li><code>grep</code> ：查找文件中符合条件的字符串</li></ul><p>查看父进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep mysql</span><br></pre></td></tr></table></figure><p>显示进程树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p显示父id，-u显示用户组</span></span><br><span class="line">pstree -pu</span><br></pre></td></tr></table></figure><h4 id="6-kill命令"><a href="#6-kill命令" class="headerlink" title="6.kill命令"></a>6.kill命令</h4><p>强制结束该进程，类似与windows结束任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109040952867.png&quot; alt=&quot;image-20210904095248687&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="https://autovy.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="入门教程" scheme="https://autovy.github.io/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="开发工具" scheme="https://autovy.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="https://autovy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>硬件开发|stm32使用案例</title>
    <link href="https://autovy.github.io/2021/06/18/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-stm32%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>https://autovy.github.io/2021/06/18/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-stm32%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2021-06-18T06:30:00.000Z</published>
    <updated>2022-08-30T08:07:45.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109041048103.png" alt="image-20210904104854742"></p><span id="more"></span><h3 id="GPIO库导入"><a href="#GPIO库导入" class="headerlink" title="GPIO库导入"></a>GPIO库导入</h3><p>添加<code>USE_STDPERIPH_DRIVER</code>到C/C++配置中</p><h3 id="点亮LED"><a href="#点亮LED" class="headerlink" title="点亮LED"></a>点亮LED</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stm32f10x.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个GPIO信息结构体（静态变量）</span></span><br><span class="line"><span class="keyword">static</span> GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.打开GPIOB组的时钟（降低功耗）选择对应外设 */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置开启端口号</span></span><br><span class="line"><span class="comment">/* 2.配置为输出推挽（多个IO使用位或添加） */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//引脚选择</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//端口输出速率（功耗）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//端口模式：推挽输出</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择外设并控制端口号输出信号</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_0);<span class="comment">// PB1低电平</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>定义GPIO_InitTypeDef类型结构体，可修改其端口配置</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109051306282.png" alt="image-20210618200840443"></p></li><li><p>GPIO_Init函数选择输出外设，并指向端口配置</p></li><li><p>GPIO_ResetBits选择外设与端口，并输出低电平</p></li><li><p>GPIO_setBits选择外设与端口，并输出高电平</p></li></ul><h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stm32f10x.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个GPIO信息结构体（静态变量）</span></span><br><span class="line"><span class="keyword">static</span> GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5000000</span>;</span><br><span class="line"><span class="keyword">while</span>(i--);<span class="comment">// 没有任何意义，只是为了消耗时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 蜂鸣器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BEEP_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 1.打开GPIOB组的时钟（降低功耗）选择对应外设 */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.配置为输出推挽（多个IO使用位或添加） */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;<span class="comment">//引脚选择</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//端口输出速率（功耗）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//端口模式：推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.给蜂鸣器初始化电平（不响）</span></span><br><span class="line">GPIO_SetBits(GPIOA, GPIO_Pin_1);<span class="comment">// 不响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BEEP_Init();<span class="comment">// 初始化蜂鸣器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">delay();<span class="comment">// 延时一段时间</span></span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">delay();<span class="comment">// 延时一段时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切换外设为A则可以选择到蜂鸣器（以开发板手册为准）</li></ul><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stm32f10x.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个GPIO信息结构体（静态变量）</span></span><br><span class="line"><span class="keyword">static</span> GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_ALL GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5000000</span>;</span><br><span class="line"><span class="keyword">while</span>(i--);<span class="comment">// 没有任何意义，只是为了消耗时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LED初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 1.打开GPIOB组的时钟（降低功耗） */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.关闭JTAG引脚映射（PA13/14/15 PB3/4）  */</span></span><br><span class="line">    GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.配置为输出推挽（多个IO使用位或添加） */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = LED_ALL;<span class="comment">//引脚选择</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//端口输出速率（功耗）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//端口模式：推挽输出</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.初始化电平（不亮）</span></span><br><span class="line">GPIO_SetBits(GPIOB, LED_ALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按键初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 1.打开GPIO组的时钟（降低功耗） */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.配置为输入（多个IO使用位或添加） */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;<span class="comment">//引脚选择</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<span class="comment">// 按钮开关使用浮空输入模式</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LED_Init();<span class="comment">// 初始化LED</span></span><br><span class="line">KEY_Init();<span class="comment">// 初始化按键</span></span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_7)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>浮空输入_IN_FLOATING ——浮空输入，IO的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空的情况下，读取该端口的电平是不确定的；</li><li>带上拉输入IPU——IO内部上拉电阻输入  ==悬空时，处于高电平状态</li><li>带下拉输入<em>IPD—— IO内部下拉电阻输入 ==悬空时，处于低电平状态</em></li><li>模拟输入AIN ——应用ADC模拟输入，或者低功耗下省电</li></ul><h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><h4 id="（1）串口通信电路连接"><a href="#（1）串口通信电路连接" class="headerlink" title="（1）串口通信电路连接"></a>（1）串口通信电路连接</h4><p>串口通信电路连接：</p><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109051307840.png" alt="image-20210622112304168"></p><ul><li>12，78 为蓝牙串口（手机app）</li><li>34为串口调试</li><li>56 stm32芯片</li></ul><p>通讯对象将两边引脚短接即可</p><h4 id="（2）重写printf函数"><a href="#（2）重写printf函数" class="headerlink" title="（2）重写printf函数"></a>（2）重写printf函数</h4><p>重写printf函数使其可以将文本输出到串口</p><p>输出字符串到串口：</p><ul><li>配置相关库：</li></ul><p><img src="https://raw.staticdn.net/Autovy/Image/master/img/202109051307778.png" alt="image-20210622114338205"></p><ul><li>重新定义fputc函数，让printf输出数据到串口1<img src="https://raw.staticdn.net/Autovy/Image/master/img/202109051307727.png" alt="image-20210622114454922"></li></ul><h4 id="（3）串口单字符发送"><a href="#（3）串口单字符发送" class="headerlink" title="（3）串口单字符发送"></a>（3）串口单字符发送</h4><p>（芯片与串口通信）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO信息结构体初始化</span></span><br><span class="line"><span class="comment">// 配置IO口结构体</span></span><br><span class="line">GPIO_InitTypeDef   GPIO_InitStructure;</span><br><span class="line"><span class="comment">// 配置中断结构体</span></span><br><span class="line">EXTI_InitTypeDef   EXTI_InitStructure;</span><br><span class="line"><span class="comment">// 配置中断优先级结构体</span></span><br><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line"><span class="comment">// 配置串口结构题</span></span><br><span class="line">USART_InitTypeDef USART_InitStructure; </span><br><span class="line"></span><br><span class="line"><span class="comment">//设置串口1--&gt;PA9+PA10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usart1_init</span><span class="params">(u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使能GPIO外设、IO复用时钟、USART2时钟 PA9 和PA10</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.配置GPIO + 初始化GPIO</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//  PA2   TX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; <span class="comment">//  PA3   RX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  <span class="comment">//浮空输入   PA10  RX</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置USART1 + 初始化USART1</span></span><br><span class="line">USART_InitStructure.USART_BaudRate = bound;<span class="comment">//波特率</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位8位</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位1位</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶检验</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure);<span class="comment">//把配置信息加载到串口2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.配置NVIC + 初始化NVIC </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//选择串口2的中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;<span class="comment">//设置抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>; <span class="comment">//设置响应优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能串口2的中断</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//把配置信息加载到中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.使能串口中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//接收到数据触发中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.使能串口</span></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单字符发送到串口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 配置串口比特率</span></span><br><span class="line">usart1_init(<span class="number">9600</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（4）使用printf发送字符串到串口"><a href="#（4）使用printf发送字符串到串口" class="headerlink" title="（4）使用printf发送字符串到串口"></a>（4）使用printf发送字符串到串口</h4><p>（芯片与串口通信）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO信息结构体初始化</span></span><br><span class="line"><span class="comment">// 配置IO口结构体</span></span><br><span class="line">GPIO_InitTypeDef   GPIO_InitStructure;</span><br><span class="line"><span class="comment">// 配置中断结构体</span></span><br><span class="line">EXTI_InitTypeDef   EXTI_InitStructure;</span><br><span class="line"><span class="comment">// 配置中断优先级结构体</span></span><br><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line"><span class="comment">// 配置串口结构题</span></span><br><span class="line">USART_InitTypeDef USART_InitStructure; </span><br><span class="line"></span><br><span class="line"><span class="comment">//重定义fputc函数---》每次发送一个字符到</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,ch);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置串口1--&gt;PA9+PA10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usart1_init</span><span class="params">(u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使能GPIO外设、IO复用时钟、USART2时钟 PA9 和PA10</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.配置GPIO + 初始化GPIO</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//  PA2   TX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; <span class="comment">//  PA3   RX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  <span class="comment">//浮空输入   PA10  RX</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置USART1 + 初始化USART1</span></span><br><span class="line">USART_InitStructure.USART_BaudRate = bound;<span class="comment">//波特率</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位8位</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位1位</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶检验</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure);<span class="comment">//把配置信息加载到串口2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.配置NVIC + 初始化NVIC </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//选择串口2的中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;<span class="comment">//设置抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>; <span class="comment">//设置响应优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能串口2的中断</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//把配置信息加载到中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.使能串口中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//接收到数据触发中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.使能串口</span></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printf发送字符串到串口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">usart1_init(<span class="number">9600</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good\r\n&quot;</span>);</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（5）手机蓝牙与芯片通信"><a href="#（5）手机蓝牙与芯片通信" class="headerlink" title="（5）手机蓝牙与芯片通信"></a>（5）手机蓝牙与芯片通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO信息结构体体初始化</span></span><br><span class="line">GPIO_InitTypeDef   GPIO_InitStructure;</span><br><span class="line">EXTI_InitTypeDef   EXTI_InitStructure;</span><br><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line">USART_InitTypeDef USART_InitStructure; <span class="comment">//串口配置的信息结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//led-》GPIO信息结构体初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//关闭引脚JTAG复用功能--&gt;PA13、PA14、PA15、PB3、PB4</span></span><br><span class="line">RCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIOB Periph clock enable */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure PD0 and PD2 in output pushpull mode */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = <span class="number">0xff</span> ;<span class="comment">//GPIO_Pin_0~GPIO_Pin_7</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//设置运行频率50MHz</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//设置推挽输出</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOB, <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置串口1--&gt;PA9+PA10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usart1_init</span><span class="params">(u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使能GPIO外设、IO复用时钟、USART2时钟 PA9 和PA10</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.配置GPIO + 初始化GPIO</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//  PA2   TX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; <span class="comment">//  PA3   RX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  <span class="comment">//浮空输入   PA10  RX</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置USART1 + 初始化USART1</span></span><br><span class="line">USART_InitStructure.USART_BaudRate = bound;<span class="comment">//波特率</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位8位</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位1位</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶检验</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure);<span class="comment">//把配置信息加载到串口2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.配置NVIC + 初始化NVIC </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//选择串口2的中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;<span class="comment">//设置抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>; <span class="comment">//设置响应优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能串口2的中断</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//把配置信息加载到中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.使能串口中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//接收到数据触发中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.使能串口</span></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">usart1_init(<span class="number">9600</span>);</span><br><span class="line">led_init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay();</span><br><span class="line">        <span class="comment">// data接收来自蓝牙通信的数据（手机app）</span></span><br><span class="line"><span class="keyword">if</span>(data == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(data == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口1中断服务函数（可以让主函数中断其他事物回来处理串口1，从而接收到蓝牙发送的数据data）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断中断是否产生</span></span><br><span class="line"><span class="keyword">if</span>( USART_GetITStatus(USART1,USART_IT_RXNE) == SET )<span class="comment">//如果接收到数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">data = USART_ReceiveData(USART1);<span class="comment">//接收从USART2发送过来的中断，每次接收1个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line"><span class="comment">//USART_SendData(USART1,n);</span></span><br><span class="line"><span class="comment">//while(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空中断标志位</span></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="液晶屏显示"><a href="#液晶屏显示" class="headerlink" title="液晶屏显示"></a>液晶屏显示</h3><h4 id="（1）工具函数与文件"><a href="#（1）工具函数与文件" class="headerlink" title="（1）工具函数与文件"></a>（1）工具函数与文件</h4><h5 id="液晶显示工具包"><a href="#液晶显示工具包" class="headerlink" title="液晶显示工具包"></a>液晶显示工具包</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* oled.c文件实现液晶屏文字显示 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oledfont.h&quot;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SysTick.h&quot;</span></span></span><br><span class="line">     </span><br><span class="line">u8 OLED_GRAM[<span class="number">128</span>][<span class="number">8</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//更新显存到LCD </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Refresh_Gram</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 i,n;    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA); </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向SSD1306写入一个字节。</span></span><br><span class="line"><span class="comment">//dat:要写入的数据/命令</span></span><br><span class="line"><span class="comment">//cmd:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 i;  </span><br><span class="line">OLED_RS=cmd; <span class="comment">//写命令 </span></span><br><span class="line">OLED_CS=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;  </span><br><span class="line">OLED_SCLK=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)OLED_SDIN=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> OLED_SDIN=<span class="number">0</span>;</span><br><span class="line">OLED_SCLK=<span class="number">1</span>;</span><br><span class="line">dat&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">&#125; </span><br><span class="line">OLED_CS=<span class="number">1</span>;  </span><br><span class="line">OLED_RS=<span class="number">1</span>;     </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Display_On</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Display_Off</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Clear</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 i,n;  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_GRAM[n][i]=<span class="number">0X00</span>;  </span><br><span class="line">OLED_Refresh_Gram();<span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画点 </span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//t:1 填充 0,清空   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_DrawPoint</span><span class="params">(u8 x,u8 y,u8 t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 pos,bx,temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">127</span>||y&gt;<span class="number">63</span>)<span class="keyword">return</span>;<span class="comment">//超出范围了.</span></span><br><span class="line">pos=<span class="number">7</span>-y/<span class="number">8</span>;</span><br><span class="line">bx=y%<span class="number">8</span>;</span><br><span class="line">temp=<span class="number">1</span>&lt;&lt;(<span class="number">7</span>-bx);</span><br><span class="line"><span class="keyword">if</span>(t)OLED_GRAM[x][pos]|=temp;</span><br><span class="line"><span class="keyword">else</span> OLED_GRAM[x][pos]&amp;=~temp;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x1,y1,x2,y2 填充区域的对角坐标</span></span><br><span class="line"><span class="comment">//确保x1&lt;=x2;y1&lt;=y2 0&lt;=x1&lt;=127 0&lt;=y1&lt;=63  </span></span><br><span class="line"><span class="comment">//dot:0,清空;1,填充  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Fill</span><span class="params">(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 x,y;  </span><br><span class="line"><span class="keyword">for</span>(x=x1;x&lt;=x2;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(y=y1;y&lt;=y2;y++)OLED_DrawPoint(x,y,dot);</span><br><span class="line">&#125;    </span><br><span class="line">OLED_Refresh_Gram();<span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 size,u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">u8 temp,t,t1;</span><br><span class="line">u8 y0=y;</span><br><span class="line">u8 csize=(size/<span class="number">8</span>+((size%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*(size/<span class="number">2</span>);<span class="comment">//得到字体一个字符对应点阵集所占的字节数</span></span><br><span class="line">chr=chr-<span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值 </span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;csize;t++)</span><br><span class="line">    &#123;   </span><br><span class="line"><span class="keyword">if</span>(size==<span class="number">12</span>)temp=asc2_1206[chr][t];  <span class="comment">//调用1206字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">16</span>)temp=asc2_1608[chr][t];<span class="comment">//调用1608字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">24</span>)temp=asc2_2412[chr][t];<span class="comment">//调用2412字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;<span class="comment">//没有的字库</span></span><br><span class="line">        <span class="keyword">for</span>(t1=<span class="number">0</span>;t1&lt;<span class="number">8</span>;t1++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;<span class="number">0x80</span>)OLED_DrawPoint(x,y,mode);</span><br><span class="line"><span class="keyword">else</span> OLED_DrawPoint(x,y,!mode);</span><br><span class="line">temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">y++;</span><br><span class="line"><span class="keyword">if</span>((y-y0)==size)</span><br><span class="line">&#123;</span><br><span class="line">y=y0;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line"><span class="function">u32 <span class="title">mypow</span><span class="params">(u8 m,u8 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 result=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//显示2个数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标 </span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//size:字体大小</span></span><br><span class="line"><span class="comment">//mode:模式0,填充模式;1,叠加模式</span></span><br><span class="line"><span class="comment">//num:数值(0~4294967295);   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size)</span></span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=<span class="number">0</span>;   </span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/mypow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowChar(x+(size/<span class="number">2</span>)*t,y,<span class="string">&#x27; &#x27;</span>,size,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> OLED_ShowChar(x+(size/<span class="number">2</span>)*t,y,temp+<span class="string">&#x27;0&#x27;</span>,size,<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//显示字符串</span></span><br><span class="line"><span class="comment">//x,y:起点坐标  </span></span><br><span class="line"><span class="comment">//size:字体大小 </span></span><br><span class="line"><span class="comment">//*p:字符串起始地址 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowString</span><span class="params">(u8 x,u8 y,<span class="keyword">const</span> u8 *p,u8 size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((*p&lt;=<span class="string">&#x27;~&#x27;</span>)&amp;&amp;(*p&gt;=<span class="string">&#x27; &#x27;</span>))<span class="comment">//判断是不是非法字符!</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">if</span>(x&gt;(<span class="number">128</span>-(size/<span class="number">2</span>)))&#123;x=<span class="number">0</span>;y+=size;&#125;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;(<span class="number">64</span>-size))&#123;y=x=<span class="number">0</span>;OLED_Clear();&#125;</span><br><span class="line">        OLED_ShowChar(x,y,*p,size,<span class="number">1</span>); </span><br><span class="line">        x+=size/<span class="number">2</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化SSD1306    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">    </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE );</span><br><span class="line">  </span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);     </span><br><span class="line"> GPIO_SetBits(GPIOA,GPIO_Pin_4|GPIO_Pin_6|GPIO_Pin_3);<span class="comment">//拉高电平</span></span><br><span class="line">  </span><br><span class="line">OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD); <span class="comment">//关闭显示</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD5</span>,OLED_CMD); <span class="comment">//设置时钟分频因子,震荡频率</span></span><br><span class="line">OLED_WR_Byte(<span class="number">80</span>,OLED_CMD);   <span class="comment">//[3:0],分频因子;[7:4],震荡频率</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD); <span class="comment">//设置驱动路数</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X3F</span>,OLED_CMD); <span class="comment">//默认0X3F(1/64) </span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD); <span class="comment">//设置显示偏移</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X00</span>,OLED_CMD); <span class="comment">//默认为0</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD); <span class="comment">//设置显示开始行 [5:0],行数.</span></span><br><span class="line">    </span><br><span class="line">OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD); <span class="comment">//电荷泵设置</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD); <span class="comment">//bit2，开启/关闭</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x20</span>,OLED_CMD); <span class="comment">//设置内存地址模式</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x02</span>,OLED_CMD); <span class="comment">//[1:0],00，列地址模式;01，行地址模式;10,页地址模式;默认10;</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD); <span class="comment">//段重定义设置,bit0:0,0-&gt;0;1,0-&gt;127;</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xC0</span>,OLED_CMD); <span class="comment">//设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]-&gt;COM0;N:驱动路数</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD); <span class="comment">//设置COM硬件引脚配置</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD); <span class="comment">//[5:4]配置</span></span><br><span class="line"> </span><br><span class="line">OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD); <span class="comment">//对比度设置</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xEF</span>,OLED_CMD); <span class="comment">//1~255;默认0X7F (亮度设置,越大越亮)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD); <span class="comment">//设置预充电周期</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xf1</span>,OLED_CMD); <span class="comment">//[3:0],PHASE 1;[7:4],PHASE 2;</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD); <span class="comment">//设置VCOMH 电压倍率</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x30</span>,OLED_CMD); <span class="comment">//[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA4</span>,OLED_CMD); <span class="comment">//全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD); <span class="comment">//设置显示方式;bit0:1,反相显示;0,正常显示       </span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD); <span class="comment">//开启显示 </span></span><br><span class="line">OLED_Clear();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="精准延时工具包"><a href="#精准延时工具包" class="headerlink" title="精准延时工具包"></a>精准延时工具包</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*SysTick.c文件实现精准延时函数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SysTick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8  fac_us=<span class="number">0</span>;<span class="comment">//us延时倍乘数   </span></span><br><span class="line"><span class="keyword">static</span> u16 fac_ms=<span class="number">0</span>;<span class="comment">//ms延时倍乘数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化延迟函数</span></span><br><span class="line"><span class="comment">//SYSTICK的时钟固定为AHB时钟的1/8</span></span><br><span class="line"><span class="comment">//SYSCLK:系统时钟频率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Init</span><span class="params">(u8 SYSCLK)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); </span><br><span class="line">fac_us=SYSCLK/<span class="number">8</span>;</span><br><span class="line">fac_ms=(u16)fac_us*<span class="number">1000</span>;   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_us</span><span class="params">(u32 nus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 temp;     </span><br><span class="line">SysTick-&gt;LOAD=nus*fac_us; <span class="comment">//时间加载   </span></span><br><span class="line">SysTick-&gt;VAL=<span class="number">0x00</span>;        <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;          <span class="comment">//开始倒数 </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">temp=SysTick-&gt;CTRL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(temp&amp;<span class="number">0x01</span>&amp;&amp;!(temp&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达   </span></span><br><span class="line">SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;       <span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时nms</span></span><br><span class="line"><span class="comment">//注意nms的范围</span></span><br><span class="line"><span class="comment">//SysTick-&gt;LOAD为24位寄存器,所以,最大延时为:</span></span><br><span class="line"><span class="comment">//nms&lt;=0xffffff*8*1000/SYSCLK</span></span><br><span class="line"><span class="comment">//SYSCLK单位为Hz,nms单位为ms</span></span><br><span class="line"><span class="comment">//对72M条件下,nms&lt;=1864 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(u16 nms)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">u32 temp;   </span><br><span class="line">SysTick-&gt;LOAD=(u32)nms*fac_ms;<span class="comment">//时间加载(SysTick-&gt;LOAD为24bit)</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0x00</span>;           <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;          <span class="comment">//开始倒数  </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">temp=SysTick-&gt;CTRL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(temp&amp;<span class="number">0x01</span>&amp;&amp;!(temp&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达   </span></span><br><span class="line">SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;       <span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器      </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（2）数字与字母显示"><a href="#（2）数字与字母显示" class="headerlink" title="（2）数字与字母显示"></a>（2）数字与字母显示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SysTick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oled.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line">u8 buf[<span class="number">10</span>] = <span class="string">&quot;ZhangSan&quot;</span>;</span><br><span class="line"></span><br><span class="line">SysTick_Init(<span class="number">72</span>);<span class="comment">// 初始化延时（72MHz芯片主频）</span></span><br><span class="line">OLED_Init();<span class="comment">//  初始化OLED</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">0</span>,<span class="number">0</span>,num,<span class="number">4</span>,<span class="number">16</span>);<span class="comment">//显示数字 </span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">16</span>,buf,<span class="number">16</span>); </span><br><span class="line">OLED_ShowChar(<span class="number">50</span>,<span class="number">0</span>,<span class="string">&#x27;S&#x27;</span>, <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">OLED_Refresh_Gram();    <span class="comment">//更新数据到OLED  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>调用SysTick_Init()函数延时规定的时间</p></li><li><p>调用oled.c定义的OLED_ShowNum等方法</p></li><li><p>相关参数可以查看oled.c内的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x,y :起点坐标</span></span><br><span class="line"><span class="comment">// num or char : 要显示的数据内容或地址</span></span><br><span class="line"><span class="comment">// len字长（一般填16）</span></span><br><span class="line"><span class="comment">// size：字体大小（一般填16）</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）汉字显示"><a href="#（3）汉字显示" class="headerlink" title="（3）汉字显示"></a>（3）汉字显示</h4><h5 id="延时工具包"><a href="#延时工具包" class="headerlink" title="延时工具包"></a>延时工具包</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////  </span></span><br><span class="line"><span class="comment">//如果使用ucos,则包括下面的头文件即可.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_UCOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;includes.h&quot;</span><span class="comment">//ucos 使用  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8  fac_us=<span class="number">0</span>;<span class="comment">//us延时倍乘数</span></span><br><span class="line"><span class="keyword">static</span> u16 fac_ms=<span class="number">0</span>;<span class="comment">//ms延时倍乘数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_CRITICAL_METHOD <span class="comment">//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.</span></span></span><br><span class="line"><span class="comment">//systick中断服务函数,使用ucos时用到</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">OSIntEnter();<span class="comment">//进入中断</span></span><br><span class="line">    OSTimeTick();       <span class="comment">//调用ucos的时钟服务程序               </span></span><br><span class="line">    OSIntExit();        <span class="comment">//触发任务切换软中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化延迟函数</span></span><br><span class="line"><span class="comment">//当使用ucos的时候,此函数会初始化ucos的时钟节拍</span></span><br><span class="line"><span class="comment">//SYSTICK的时钟固定为HCLK时钟的1/8</span></span><br><span class="line"><span class="comment">//SYSCLK:系统时钟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_CRITICAL_METHOD <span class="comment">//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.</span></span></span><br><span class="line">u32 reload;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);<span class="comment">//选择外部时钟  HCLK/8</span></span><br><span class="line">fac_us=SystemCoreClock/<span class="number">8000000</span>;<span class="comment">//为系统时钟的1/8  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_CRITICAL_METHOD <span class="comment">//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.</span></span></span><br><span class="line">reload=SystemCoreClock/<span class="number">8000000</span>;<span class="comment">//每秒钟的计数次数 单位为K   </span></span><br><span class="line">reload*=<span class="number">1000000</span>/OS_TICKS_PER_SEC;<span class="comment">//根据OS_TICKS_PER_SEC设定溢出时间</span></span><br><span class="line"><span class="comment">//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右</span></span><br><span class="line">fac_ms=<span class="number">1000</span>/OS_TICKS_PER_SEC;<span class="comment">//代表ucos可以延时的最少单位   </span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_TICKINT_Msk;   <span class="comment">//开启SYSTICK中断</span></span><br><span class="line">SysTick-&gt;LOAD=reload; <span class="comment">//每1/OS_TICKS_PER_SEC秒中断一次</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk;   <span class="comment">//开启SYSTICK    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">fac_ms=(u16)fac_us*<span class="number">1000</span>;<span class="comment">//非ucos下,代表每个ms需要的systick时钟数   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_CRITICAL_METHOD<span class="comment">//使用了ucos</span></span></span><br><span class="line"><span class="comment">//延时nus</span></span><br><span class="line"><span class="comment">//nus为要延时的us数.       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_us</span><span class="params">(u32 nus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 ticks;</span><br><span class="line">u32 told,tnow,tcnt=<span class="number">0</span>;</span><br><span class="line">u32 reload=SysTick-&gt;LOAD;<span class="comment">//LOAD的值     </span></span><br><span class="line">ticks=nus*fac_us; <span class="comment">//需要的节拍数   </span></span><br><span class="line">tcnt=<span class="number">0</span>;</span><br><span class="line">told=SysTick-&gt;VAL;        <span class="comment">//刚进入时的计数器值</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">tnow=SysTick-&gt;VAL;</span><br><span class="line"><span class="keyword">if</span>(tnow!=told)</span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">if</span>(tnow&lt;told)tcnt+=told-tnow;<span class="comment">//这里注意一下SYSTICK是一个递减的计数器就可以了.</span></span><br><span class="line"><span class="keyword">else</span> tcnt+=reload-tnow+told;    </span><br><span class="line">told=tnow;</span><br><span class="line"><span class="keyword">if</span>(tcnt&gt;=ticks)<span class="keyword">break</span>;<span class="comment">//时间超过/等于要延迟的时间,则退出.</span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时nms</span></span><br><span class="line"><span class="comment">//nms:要延时的ms数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(u16 nms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(OSRunning==TRUE)<span class="comment">//如果os已经在跑了    </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">if</span>(nms&gt;=fac_ms)<span class="comment">//延时的时间大于ucos的最少时间周期 </span></span><br><span class="line">&#123;</span><br><span class="line">   OSTimeDly(nms/fac_ms);<span class="comment">//ucos延时</span></span><br><span class="line">&#125;</span><br><span class="line">nms%=fac_ms;<span class="comment">//ucos已经无法提供这么小的延时了,采用普通方式延时    </span></span><br><span class="line">&#125;</span><br><span class="line">delay_us((u32)(nms*<span class="number">1000</span>));<span class="comment">//普通方式延时,此时ucos无法启动调度.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//不用ucos时</span></span></span><br><span class="line"><span class="comment">//延时nus</span></span><br><span class="line"><span class="comment">//nus为要延时的us数.       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_us</span><span class="params">(u32 nus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 temp;     </span><br><span class="line">SysTick-&gt;LOAD=nus*fac_us; <span class="comment">//时间加载   </span></span><br><span class="line">SysTick-&gt;VAL=<span class="number">0x00</span>;        <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;          <span class="comment">//开始倒数 </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">temp=SysTick-&gt;CTRL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(temp&amp;<span class="number">0x01</span>&amp;&amp;!(temp&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达   </span></span><br><span class="line">SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;       <span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时nms</span></span><br><span class="line"><span class="comment">//注意nms的范围</span></span><br><span class="line"><span class="comment">//SysTick-&gt;LOAD为24位寄存器,所以,最大延时为:</span></span><br><span class="line"><span class="comment">//nms&lt;=0xffffff*8*1000/SYSCLK</span></span><br><span class="line"><span class="comment">//SYSCLK单位为Hz,nms单位为ms</span></span><br><span class="line"><span class="comment">//对72M条件下,nms&lt;=1864 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(u16 nms)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">u32 temp;   </span><br><span class="line">SysTick-&gt;LOAD=(u32)nms*fac_ms;<span class="comment">//时间加载(SysTick-&gt;LOAD为24bit)</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0x00</span>;           <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;          <span class="comment">//开始倒数  </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">temp=SysTick-&gt;CTRL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(temp&amp;<span class="number">0x01</span>&amp;&amp;!(temp&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达   </span></span><br><span class="line">SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;       <span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器      </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="液晶显示工具包-1"><a href="#液晶显示工具包-1" class="headerlink" title="液晶显示工具包"></a>液晶显示工具包</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oledfont.h&quot;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="comment">//OLED的显存</span></span><br><span class="line"><span class="comment">//存放格式如下.</span></span><br><span class="line"><span class="comment">//[0]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[1]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[2]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[3]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[4]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[5]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[6]0 1 2 3 ... 127</span></span><br><span class="line"><span class="comment">//[7]0 1 2 3 ... 127    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OLED_MODE==1</span></span><br><span class="line"><span class="comment">//向SSD1106写入一个字节。</span></span><br><span class="line"><span class="comment">//dat:要写入的数据/命令</span></span><br><span class="line"><span class="comment">//cmd:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DATAOUT(dat);    </span><br><span class="line"><span class="keyword">if</span>(cmd)</span><br><span class="line">  OLED_DC_Set();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  OLED_DC_Clr();   </span><br><span class="line">OLED_CS_Clr();</span><br><span class="line">OLED_WR_Clr(); </span><br><span class="line">OLED_WR_Set();</span><br><span class="line">OLED_CS_Set();  </span><br><span class="line">OLED_DC_Set(); </span><br><span class="line">&#125;         </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//向SSD1106写入一个字节。</span></span><br><span class="line"><span class="comment">//dat:要写入的数据/命令</span></span><br><span class="line"><span class="comment">//cmd:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 i;  </span><br><span class="line"><span class="keyword">if</span>(cmd)</span><br><span class="line">  OLED_DC_Set();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  OLED_DC_Clr();  </span><br><span class="line">OLED_CS_Clr();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;  </span><br><span class="line">OLED_SCLK_Clr();</span><br><span class="line"><span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)</span><br><span class="line">   OLED_SDIN_Set();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   OLED_SDIN_Clr();</span><br><span class="line">OLED_SCLK_Set();</span><br><span class="line">dat&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">&#125;   </span><br><span class="line">OLED_CS_Set();</span><br><span class="line">OLED_DC_Set();     </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Set_Pos</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> x, <span class="keyword">unsigned</span> <span class="keyword">char</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">OLED_WR_Byte(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">OLED_WR_Byte((x&amp;<span class="number">0x0f</span>)|<span class="number">0x01</span>,OLED_CMD); </span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Display_On</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Display_Off</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Clear</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 i,n;    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">0</span>,OLED_DATA); </span><br><span class="line">&#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr)</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">c=chr-<span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;Max_Column<span class="number">-1</span>)&#123;x=<span class="number">0</span>;y=y+<span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(SIZE ==<span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i],OLED_DATA);</span><br><span class="line">OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i+<span class="number">8</span>],OLED_DATA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">OLED_WR_Byte(F6x8[c][i],OLED_DATA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line"><span class="function">u32 <span class="title">oled_pow</span><span class="params">(u8 m,u8 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 result=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//显示2个数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标 </span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//size:字体大小</span></span><br><span class="line"><span class="comment">//mode:模式0,填充模式;1,叠加模式</span></span><br><span class="line"><span class="comment">//num:数值(0~4294967295);   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size)</span></span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=<span class="number">0</span>;   </span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/oled_pow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowChar(x+(size/<span class="number">2</span>)*t,y,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> OLED_ShowChar(x+(size/<span class="number">2</span>)*t,y,temp+<span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;OLED_ShowChar(x,y,chr[j]);</span><br><span class="line">x+=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">120</span>)&#123;x=<span class="number">0</span>;y+=<span class="number">2</span>;&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示汉字--no表示行数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span></span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">u8 t,adder=<span class="number">0</span>;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(Hzk[<span class="number">2</span>*no][t],OLED_DATA);</span><br><span class="line">adder+=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(Hzk[<span class="number">2</span>*no+<span class="number">1</span>][t],OLED_DATA);</span><br><span class="line">adder+=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_DrawBMP</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> x0, <span class="keyword">unsigned</span> <span class="keyword">char</span> y0,<span class="keyword">unsigned</span> <span class="keyword">char</span> x1, <span class="keyword">unsigned</span> <span class="keyword">char</span> y1,<span class="keyword">unsigned</span> <span class="keyword">char</span> BMP[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> x,y;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(y1%<span class="number">8</span>==<span class="number">0</span>) y=y1/<span class="number">8</span>;      </span><br><span class="line">  <span class="keyword">else</span> y=y1/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(y=y0;y&lt;y1;y++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_Set_Pos(x0,y);</span><br><span class="line">    <span class="keyword">for</span>(x=x0;x&lt;x1;x++)</span><br><span class="line">    &#123;      </span><br><span class="line">    OLED_WR_Byte(BMP[j++],OLED_DATA);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SSD1306    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"> </span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); <span class="comment">//使能A端口时钟</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_6| GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_7; </span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//速度50MHz</span></span><br><span class="line"> GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOD3,6</span></span><br><span class="line"> GPIO_SetBits(GPIOA,GPIO_Pin_5|GPIO_Pin_7|GPIO_Pin_4);</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); <span class="comment">//使能A端口时钟</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; </span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//速度50MHz</span></span><br><span class="line"> GPIO_Init(GPIOB, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOD3,6</span></span><br><span class="line"></span><br><span class="line"> GPIO_SetBits(GPIOB,GPIO_Pin_8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  OLED_RST_Set();</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_RST_Clr();</span><br><span class="line">delay_ms(<span class="number">200</span>);</span><br><span class="line">OLED_RST_Set(); </span><br><span class="line">  </span><br><span class="line">OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD);<span class="comment">//--turn off oled panel</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//---set low column address</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//---set high column address</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD);<span class="comment">//--set contrast control register</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xCF</span>,OLED_CMD); <span class="comment">// Set SEG Output Current Brightness</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);<span class="comment">//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//--set normal display</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//--1/64 duty</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD);<span class="comment">//-set display offsetShift Mapping RAM Counter (0x00~0x3F)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//-not offset</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//--set display clock divide ratio/oscillator frequency</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//--set divide ratio, Set Clock as 100 Frames/Sec</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD);<span class="comment">//--set pre-charge period</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xF1</span>,OLED_CMD);<span class="comment">//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD);<span class="comment">//--set com pins hardware configuration</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD);<span class="comment">//--set vcomh</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//Set VCOM Deselect Level</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x20</span>,OLED_CMD);<span class="comment">//-Set Page Addressing Mode (0x00/0x01/0x02)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x02</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD);<span class="comment">//--set Charge Pump enable/disable</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//--set(0x10) disable</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA4</span>,OLED_CMD);<span class="comment">// Disable Entire Display On (0xa4/0xa5)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">// Disable Inverse Display On (0xa6/a7) </span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD);<span class="comment">//--turn on oled panel</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD); <span class="comment">/*display ON*/</span> </span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_Set_Pos(<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="中断优先工具包"><a href="#中断优先工具包" class="headerlink" title="中断优先工具包"></a>中断优先工具包</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Configuration</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>串口通信配置工具包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加入以下代码,支持printf函数,而不需要选择use MicroLIB  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> import(__use_no_semihosting)             </span></span><br><span class="line"><span class="comment">//标准库需要的支持函数                 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> handle; </span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">FILE __stdout;       </span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式    </span></span><br><span class="line">_sys_exit(<span class="keyword">int</span> x) </span><br><span class="line">&#123; </span><br><span class="line">x = x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//重定义fputc函数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line"><span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕   </span></span><br><span class="line">    USART1-&gt;DR = (u8) ch;      </span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用microLib的方法*/</span></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">USART_SendData(USART1, (uint8_t) ch);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) &#123;&#125;</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">    return ch;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int GetKey (void)  &#123; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while (!(USART1-&gt;SR &amp; USART_FLAG_RXNE));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return ((int)(USART1-&gt;DR &amp; 0x1FF));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> EN_USART1_RX   <span class="comment">//如果使能了接收</span></span></span><br><span class="line"><span class="comment">//串口1中断服务程序</span></span><br><span class="line"><span class="comment">//注意,读取USARTx-&gt;SR能避免莫名其妙的错误   </span></span><br><span class="line">u8 USART_RX_BUF[USART_REC_LEN];     <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.</span></span><br><span class="line"><span class="comment">//接收状态</span></span><br><span class="line"><span class="comment">//bit15，接收完成标志</span></span><br><span class="line"><span class="comment">//bit14，接收到0x0d</span></span><br><span class="line"><span class="comment">//bit13~0，接收到的有效字节数目</span></span><br><span class="line">u16 USART_RX_STA=<span class="number">0</span>;       <span class="comment">//接收状态标记  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>&#123;</span><br><span class="line">    <span class="comment">//GPIO端口设置</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"> </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//使能USART1，GPIOA时钟以及复用功能时钟</span></span><br><span class="line">     <span class="comment">//USART1_TX   PA.9</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//PA.9</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//USART1_RX  PA.10</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<span class="comment">//浮空输入</span></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//Usart1 NVIC 配置</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">3</span> ;<span class="comment">//抢占优先级3</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;<span class="comment">//子优先级3</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//根据指定的参数初始化VIC寄存器</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//USART 初始化设置</span></span><br><span class="line"></span><br><span class="line">USART_InitStructure.USART_BaudRate = bound;<span class="comment">//一般设置为9600;</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//字长为8位数据格式</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//一个停止位</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶校验位</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line"></span><br><span class="line">    USART_Init(USART1, &amp;USART_InitStructure); <span class="comment">//初始化串口</span></span><br><span class="line">    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<span class="comment">//开启中断</span></span><br><span class="line">    USART_Cmd(USART1, ENABLE);                    <span class="comment">//使能串口 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>                <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 Res;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_TICKS_PER_SEC <span class="comment">//如果时钟节拍数定义了,说明要使用ucosII了.</span></span></span><br><span class="line">OSIntEnter();    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">&#123;</span><br><span class="line">Res =USART_ReceiveData(USART1);<span class="comment">//(USART1-&gt;DR);//读取接收到的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((USART_RX_STA&amp;<span class="number">0x8000</span>)==<span class="number">0</span>)<span class="comment">//接收未完成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x4000</span>)<span class="comment">//接收到了0x0d</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Res!=<span class="number">0x0a</span>)USART_RX_STA=<span class="number">0</span>;<span class="comment">//接收错误,重新开始</span></span><br><span class="line"><span class="keyword">else</span> USART_RX_STA|=<span class="number">0x8000</span>;<span class="comment">//接收完成了 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//还没收到0X0D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Res==<span class="number">0x0d</span>)USART_RX_STA|=<span class="number">0x4000</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">USART_RX_BUF[USART_RX_STA&amp;<span class="number">0X3FFF</span>]=Res ;</span><br><span class="line">USART_RX_STA++;</span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&gt;(USART_REC_LEN<span class="number">-1</span>))USART_RX_STA=<span class="number">0</span>;<span class="comment">//接收数据错误,重新开始接收  </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">     &#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_TICKS_PER_SEC <span class="comment">//如果时钟节拍数定义了,说明要使用ucosII了.</span></span></span><br><span class="line">OSIntExit();   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>支持中断处理串口通信</li><li>支持printf输出内容到串口</li></ul><h5 id="文字取模添加"><a href="#文字取模添加" class="headerlink" title="文字取模添加"></a>文字取模添加</h5><p>在oledfont.h可以看到字符串的16进制对应，我们也可以取模然后添加汉字</p><h5 id="汉字显示"><a href="#汉字显示" class="headerlink" title="汉字显示"></a>汉字显示</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bmp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 t;</span><br><span class="line">delay_init();     <span class="comment">//延时函数初始化  </span></span><br><span class="line">NVIC_Configuration();  <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级 LED_Init(); </span></span><br><span class="line">    <span class="comment">//LED端口初始化</span></span><br><span class="line">OLED_Init();<span class="comment">//初始化OLED  </span></span><br><span class="line">OLED_Clear()  ; </span><br><span class="line">t=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">OLED_Clear();</span><br><span class="line"><span class="comment">//LED_ON;</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//中</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//景</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//园</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//电</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>);<span class="comment">//子</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//科</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>);<span class="comment">//技</span></span><br><span class="line"></span><br><span class="line">OLED_ShowCHinese(<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>);<span class="comment">//佛</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">18</span>,<span class="number">6</span>,<span class="number">8</span>);<span class="comment">//科</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">3</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="string">&quot;1.3&#x27; OLED TEST&quot;</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="温度测量"><a href="#温度测量" class="headerlink" title="温度测量"></a>温度测量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO信息结构体体初始化</span></span><br><span class="line">GPIO_InitTypeDef   GPIO_InitStructure;</span><br><span class="line">EXTI_InitTypeDef   EXTI_InitStructure;</span><br><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line">USART_InitTypeDef USART_InitStructure; <span class="comment">//串口配置的信息结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> dht11_data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定义fputc函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//发送字符到串口1</span></span><br><span class="line">USART_SendData(USART1,ch);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延时100ms ，计数72000000次时间过了1s  , 计数72000次时间过了1ms,计数72次表示时间过了1us</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SysTick-&gt;LOAD = <span class="number">72000</span>*x; <span class="comment">//把计数值加载到LOAD寄存器 ---&gt;每次计数100ms</span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0</span>; <span class="comment">//清空VAL寄存器的计数值</span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL |= <span class="number">0x1</span>&lt;&lt;<span class="number">0</span>; <span class="comment">//开始计时,打开定时器把CTRL的第0位置1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">0</span> == (SysTick-&gt;CTRL &amp; (<span class="number">0x1</span>&lt;&lt;<span class="number">16</span>)) ); <span class="comment">//判断CTRL是否为1，如果为1表示计时时间到了</span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL &amp;= ~(<span class="number">0x1</span>&lt;&lt;<span class="number">0</span>); <span class="comment">//关闭定时器，把CTRL的第0位清零</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//微妙级别延时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_us</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SysTick-&gt;LOAD = <span class="number">72</span>*x; <span class="comment">//把计数值加载到LOAD寄存器 ---&gt;每次计数100ms</span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0</span>; <span class="comment">//清空VAL寄存器的计数值</span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL |= <span class="number">0x1</span>&lt;&lt;<span class="number">0</span>; <span class="comment">//开始计时,打开定时器把CTRL的第0位置1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">0</span> == (SysTick-&gt;CTRL &amp; (<span class="number">0x1</span>&lt;&lt;<span class="number">16</span>)) ); <span class="comment">//判断CTRL是否为1，如果为1表示计时时间到了</span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL &amp;= ~(<span class="number">0x1</span>&lt;&lt;<span class="number">0</span>); <span class="comment">//关闭定时器，把CTRL的第0位清零</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//led-》GPIO信息结构体初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//关闭引脚JTAG复用功能--&gt;PA13、PA14、PA15、PB3、PB4</span></span><br><span class="line">RCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIOB Periph clock enable */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure PD0 and PD2 in output pushpull mode */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = <span class="number">0xff</span> ;<span class="comment">//GPIO_Pin_0~GPIO_Pin_7</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//设置运行频率50MHz</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//设置推挽输出</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOB, <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置串口1--&gt;PA9+PA10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usart1_init</span><span class="params">(u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使能GPIO外设、IO复用时钟、USART2时钟 PA9 和PA10</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.配置GPIO + 初始化GPIO</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//  PA2   TX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; <span class="comment">//  PA3   RX</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  <span class="comment">//浮空输入   PA10  RX</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置USART1 + 初始化USART1</span></span><br><span class="line">USART_InitStructure.USART_BaudRate = bound;<span class="comment">//波特率</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位8位</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位1位</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶检验</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure);<span class="comment">//把配置信息加载到串口2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.配置NVIC + 初始化NVIC </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//选择串口2的中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;<span class="comment">//设置抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>; <span class="comment">//设置响应优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能串口2的中断</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//把配置信息加载到中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.使能串口中断</span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//接收到数据触发中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.使能串口</span></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把PB15设置为输出模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_PA15_outputmode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* GPIOB Peripheral clock enable 使能对应GPIO组的硬件时钟，使能第B组的硬件时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure PB15 in output pushpull mode */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;<span class="comment">//选择15号引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//选择输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//设置运行速度为100MHz</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把PB15设置为输入模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_PA15_inputmode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIOB Periph clock enable */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure PD0 and PD2 in output pushpull mode */</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15; </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//设置运行频率50MHz</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//设置推挽输出</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MCU请求dht11发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_dht11_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//请求dht11发送数据</span></span><br><span class="line">set_PA15_outputmode(); <span class="comment">//--》设置为输出模式</span></span><br><span class="line">GPIO_ResetBits(GPIOA,  GPIO_Pin_15);</span><br><span class="line">delay_ms(<span class="number">20</span>);</span><br><span class="line">GPIO_SetBits(GPIOA, GPIO_Pin_15);</span><br><span class="line"></span><br><span class="line">delay_us(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断dht11是否有回应--》在一定的时间内没有回应，就要重新请求数据</span></span><br><span class="line">set_PA15_inputmode();</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时控制--》设置100us</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//如果超时，就结束函数</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;= <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//检测低电平持续时间--》也要设置超时控制</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//如果超时，就结束函数</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;= <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次读取一个字节数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">read_dht11_data_1byte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//等待高电平时间持续结束</span></span><br><span class="line"><span class="comment">//while(1 == PAin(15));</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span> ==  GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15));</span><br><span class="line"><span class="comment">//读取8bit数据--》合成一个unsigned char 数据</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是1还是0--&gt;等待低电平时间持续结束</span></span><br><span class="line"><span class="keyword">while</span>( <span class="number">0</span> == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15));</span><br><span class="line">delay_us(<span class="number">40</span>);</span><br><span class="line"><span class="comment">//40us后，仍然是高电平，该bit则为1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15))</span><br><span class="line">&#123;</span><br><span class="line">data |=  <span class="number">1</span>&lt;&lt; (<span class="number">7</span>-i); <span class="comment">//先读到是高位</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//等待高电平时间持续结束</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span> == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取全部数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_dht11_all_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//不断请求dht11发送数据</span></span><br><span class="line"><span class="keyword">while</span>( <span class="number">-1</span> == ask_dht11_data());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">dht11_data[i]= read_dht11_data_1byte();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断校验和</span></span><br><span class="line"><span class="keyword">if</span>(dht11_data[<span class="number">4</span>] == dht11_data[<span class="number">0</span>]+dht11_data[<span class="number">1</span>]+dht11_data[<span class="number">2</span>]+dht11_data[<span class="number">3</span>])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化系统定时器时钟--》时钟频率为72MHz</span></span><br><span class="line">SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);</span><br><span class="line">led_init();</span><br><span class="line"></span><br><span class="line">usart1_init(<span class="number">9600</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delay();</span><br><span class="line"><span class="comment">//if(data == &#x27;D&#x27;)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//读取温湿度数据 成功</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == read_dht11_all_data())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H:%d.%d T:%d.%d\r\n&quot;</span>, dht11_data[<span class="number">0</span>],dht11_data[<span class="number">1</span>], dht11_data[<span class="number">2</span>],dht11_data[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口1中断服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断中断是否产生</span></span><br><span class="line"><span class="keyword">if</span>( USART_GetITStatus(USART1,USART_IT_RXNE) == SET )<span class="comment">//如果接收到数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">data = USART_ReceiveData(USART1);<span class="comment">//接收从USART2发送过来的中断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空中断标志位</span></span><br><span class="line">USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.staticdn.net/Autovy/Image/master/img/202109041048103.png&quot; alt=&quot;image-20210904104854742&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件开发" scheme="https://autovy.github.io/categories/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="入门教程" scheme="https://autovy.github.io/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="stm32" scheme="https://autovy.github.io/tags/stm32/"/>
    
      <category term="硬件" scheme="https://autovy.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
</feed>
