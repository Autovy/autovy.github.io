<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/gear48.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gear32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="true"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"autovy.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="开发原理|深入理解TCP&#x2F;IP">
<meta property="og:url" content="https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/index.html">
<meta property="og:site_name" content="Autovy&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222123110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172102110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172153405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091935607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172209140.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090832758.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131208230.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131209573.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090836254.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091957945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181640784.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181640604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130593.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092029731.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181742784.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130170.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092031256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110261926809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111221558394.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130712.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130175.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130600.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111551532.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222021036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271337578.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232154413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222117832.webp">
<meta property="article:published_time" content="2021-12-22T15:45:00.000Z">
<meta property="article:modified_time" content="2022-10-25T08:48:30.252Z">
<meta property="article:author" content="Autovy">
<meta property="article:tag" content="开发原理">
<meta property="article:tag" content="深度系列">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="IP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222123110.png">

<link rel="canonical" href="https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>开发原理|深入理解TCP/IP | Autovy's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Autovy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Autovy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Just For Interest</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">58</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">51</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2.png">
      <meta itemprop="name" content="Autovy">
      <meta itemprop="description" content="新时代农民工的数字农田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Autovy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          开发原理|深入理解TCP/IP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021/12/22 23:45:00" itemprop="dateCreated datePublished" datetime="2021-12-22T23:45:00+08:00">2021/12/22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">开发原理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv_test" style="display: inline;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222123110.png" alt="Packets incoming "></p>
<span id="more"></span>

<h3 id="深入TCP连接"><a href="#深入TCP连接" class="headerlink" title="深入TCP连接"></a>深入TCP连接</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg</a></p>
<h4 id="1-TCP基本认识"><a href="#1-TCP基本认识" class="headerlink" title="1.TCP基本认识"></a>1.TCP基本认识</h4><h5 id="（1）TCP头部结构"><a href="#（1）TCP头部结构" class="headerlink" title="（1）TCP头部结构"></a>（1）TCP头部结构</h5><p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172102110.png" alt="image-20211117210224727"></p>
<p>下面介绍其中较为重要的部分：</p>
<ul>
<li><strong>序列号</strong>：建立连接时计算生成的随机数作为其初始值，通过SYN包传给接收端主机。每发送一次数据就会<strong>累加</strong>一次该<strong>数据字节数</strong>的大小，所以可以用来<strong>解决网络包乱序</strong>的问题</li>
<li><strong>确认应答号</strong>：即下一次<strong>期望</strong>收到的数据序列号，发送端接收到这个确认应答就可以认为这个序号之前的数据已被正常接收，用以解决<strong>不丢包的问题</strong></li>
<li><strong>控制位（状态位）</strong>：该字段中的每个比特分别表示以下通信控制含义<ul>
<li>ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></li>
<li>RST：<strong>强制断开</strong>连接，用于异常中断的情况</li>
<li>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作</li>
<li>FIN：表示<strong>断开</strong>连接</li>
</ul>
</li>
<li><strong>窗口大小</strong>：接收方告知发送方窗口大小（窗口大小即缓存大小，标识当前处理能力，用于<strong>流量控制</strong>，<strong>拥塞控制</strong>）</li>
</ul>
<h5 id="（2）TCP基本定义"><a href="#（2）TCP基本定义" class="headerlink" title="（2）TCP基本定义"></a>（2）TCP基本定义</h5><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的</strong></p>
<p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p>
<ul>
<li>面向连接：十分专一，只支持一对一连接</li>
<li>可靠的：不管网络链路出现怎样的链路变化，TCP都可以保证一个报文一定能到达中断</li>
<li>字节流：消息无论多大都可以传输，而且一定是<strong>有序的</strong>，<strong>顺序不对</strong>的，<strong>重复</strong>的报文会被自动丢弃</li>
</ul>
<p>TCP连接即<strong>用于保证可靠性和流量控制维护</strong>的某些状态信息包括：</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
<p>TCP四元组可以唯一确定一个连接：</p>
<ul>
<li><p>源地址</p>
</li>
<li><p>源端口</p>
</li>
<li><p>目标地址</p>
</li>
<li><p>目标端口</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172153405.png" alt="img"></p>
<p>地址储存在IP头部中，作用是通过IP协议发送报文给对方主机</p>
<p>端口存储在TCP头部，作用是告诉TCP协议应该把报文发给哪个进程</p>
<p>服务器通常固定在某个本地端口监听（如80，443等），等待客户端的连接请求</p>
<p>TCP理论上的最大连接数与客户端的IP数和客户端的端口数有关<br>$$<br>最大TCP连接数 = 客户端的IP数 × 客户端的端口数<br>$$<br>当实际上服务端最大TCP连接还会受到<strong>文件描述符</strong>和<strong>内存</strong>限制</p>
<h5 id="（3）TCP与UDP的区别"><a href="#（3）TCP与UDP的区别" class="headerlink" title="（3）TCP与UDP的区别"></a>（3）TCP与UDP的区别</h5><p>TCP与UDP的结构对比：</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091935607.png" alt="img" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111172209140.png" alt="image-20211117220850428" style="zoom: 67%;"></p>
<ul>
<li>首部长度：TCP有首部长度，UDP则没有。因为TCP有可变长的<strong>选项</strong>字段，所以需要首部长度来记录；UDP的头部长度是不会变化的，所以需要去记录首部长度</li>
</ul>
<ul>
<li>包长度：UDP有首部长度，UDP则没有。TCP和UDP的数据长度都可以通过下面公式计算出来，所以包长度是不需要的，这里的UDP可能纯属是补全UDP的首部长度为4字节<br>$$<br>TCP/UDP数据长度 = IP总长度 - IP首部长度 - TCP/UDP首部长度<br>$$</li>
</ul>
<p>TCP和UDP协议的应用：</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090832758.jpeg" alt="TCP/UDP常见应用"></p>
<p>TCP/UDP比较：</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131208230.webp" alt="TCP/UDP比较"></p>
<p>咳咳，正经详细的比较如下：</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110131209573.png" alt="image-20211013120922107"></p>
<p>TCP/UDP编程模型对比：</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110090836254.jpeg" alt="TCP/UDP编程模型"></p>
<h4 id="2-TCP连接建立"><a href="#2-TCP连接建立" class="headerlink" title="2.TCP连接建立"></a>2.TCP连接建立</h4><h5 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h5><p>TCP三次握手其实就是<strong>建立一个TCP连接</strong>，客户端和服务器之间需要<strong>3个数据包</strong>，握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110091957945.png" alt="img"></p>
<p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong></p>
<ul>
<li>初始状态下，客户端和服务端都处在<strong>CLOSED</strong>状态，先是服务端主动监听某个端口，处于<strong>LISTEN</strong>状态</li>
</ul>
<ul>
<li>第一次握手：客户端发送<strong>SYN</strong>报文，并进入<strong>SYN-SENT</strong>状态，等待服务器确认</li>
</ul>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181640784.png" alt="img" style="zoom: 67%;">





<ul>
<li>第二次握手：服务器收到<strong>SYN</strong>报文后，需要向客户端发送<strong>ACK</strong>确认<strong>收到</strong>的报文；同时服务端也向客户端发送一个<strong>SYN报文</strong>（也就是说服务端向客户端发送了<strong>SYN+ACK</strong>报文），然后服务端进入<strong>SYN_RCVD</strong>状态</li>
</ul>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181640604.png" alt="img" style="zoom: 67%;">





<ul>
<li><p>第三次握手：客户端收到<strong>SYN+ACK</strong>报文后，向服务端发送<strong>ACK</strong>确认<strong>收到</strong>的报文，客户端进入<strong>ESTABLISHED</strong>状态； 服务端收到客户端的<strong>ACK</strong>包后也会进入<strong>ESTABLISHED</strong>状态，完成三次握手</p>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130593.png" alt="img" style="zoom: 67%;">



</li>
</ul>
<p><strong>第三次握手是可以携带数据的，前面两次握手是不可以携带数据的</strong>，完成三次握手后，双方都处于<strong>ESTABLISHED</strong>状态，至此连接就已经建立完成了</p>
<p>在Linux系统可以通过<code>netstat -napt</code>命令查看TCP连接状态</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092029731.png" alt="img"></p>
<h5 id="（2）需要三次握手的原因"><a href="#（2）需要三次握手的原因" class="headerlink" title="（2）需要三次握手的原因"></a>（2）需要三次握手的原因</h5><p>我们需要三次握手才能初始化Socket，序列号和窗口大小并建立TCP连接，才能保证双方具有接收和发送的能力</p>
<p>需要三次握手的原因如下：</p>
<ul>
<li>三次握手才能阻止历史重复连接的初始化</li>
<li>三次握手才能同步双方的初始序列化</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p><strong>避免历史连接</strong>：防止旧的重复连接初始化造成混乱</p>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130449.png" alt="img" style="zoom: 67%;">



<p>网络环境错综复杂，在网络拥堵的情况下，一个「旧 SYN 报文」可能会比「最新的 SYN 」 报文早到达了服务端</p>
<p>第三次握手可以用来判断是否收到了自己期望的ACK：</p>
<ul>
<li>如果是历史连接（序列号过期或超时）就发送<strong>RST报文</strong>中止历史连接</li>
<li>如果不是历史连接则第三次发送的报文是<strong>ACK报文</strong>，通信双方就会成功建立连接</li>
</ul>
<p>如果是两次握手将无法判断出历史连接</p>
<p><strong>同步双方初始序列号</strong>：TCP协议通信双方，都必须维护一个序列号，只有客户端和服务端之间通过<strong>SYN和ACK</strong>一来一回的确认，才能确保双方的初始化序列号能被可靠的同步</p>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111181742784.png" alt="img" style="zoom:67%;">



<p>如果是两次握手只能保证一方的初始序列号可以被对方接收，没办法保证双方的初始序列号都能被确认接受</p>
<p><strong>避免资源浪费</strong>：二次握手会建立多个冗杂的无效的连接，造成不必要的资源浪费</p>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130170.png" alt="img" style="zoom:67%;">



<p>两次握手会造成消息滞留的情况，服务器接收到无用的SYN报文，因为没有ACK确认信号，服务器就会造成重复的资源分配</p>
<h5 id="（3）初始化序列号ISN"><a href="#（3）初始化序列号ISN" class="headerlink" title="（3）初始化序列号ISN"></a>（3）初始化序列号ISN</h5><p>客户端和服务端的初始序列号ISN是不相同的，因为网络的<strong>报文会延迟，会复制重发，也可能丢失</strong>。为了避免相互影响，客户端和服务端的初始序列号是随机且不同的</p>
<p>初始序列号ISN的随机生成算法是基于时钟的，如下<br>$$<br>ISN = M + F (localhost, localport, remotehost, remoteport)<br>$$</p>
<ul>
<li><code>M</code> 是一个<strong>计时器</strong>，这个计时器每隔 4 毫秒加 1</li>
<li><code>F</code> 是一个 Hash 算法，根据<strong>源 IP、目的 IP、源端口、目的端口生成一个随机数值</strong>。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择</li>
</ul>
<h5 id="（4）MTU与MSS"><a href="#（4）MTU与MSS" class="headerlink" title="（4）MTU与MSS"></a>（4）MTU与MSS</h5><p>IP层分片的大小为MTU，TCP层分段的大小为MSS</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110092031256.png" alt="image-20211009203103835"></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
<p>既然IP层可以将大于MTU数据进行分片，为什么还需要TCP层将大于MSS的数据分段呢？</p>
<p>因为IP层本身并没有超时重传机制，如果一个IP分片丢失了，那么整个IP报文的<strong>所有分片都要进行重传</strong></p>
<p>所有为了达到最佳的传输效能，TCP协议在<strong>建立连接时通常要协商双方的MSS值</strong>，当TCP发现数据超过MSS时就会对数据进行分段，这样它生成的IP包长度就不会大于MTU了，当然也不需要IP层进行分片。</p>
<p>如果一个TCP分片丢失，就可以以MSS为单位重发数据</p>
<h5 id="（5）TCP接收队列"><a href="#（5）TCP接收队列" class="headerlink" title="（5）TCP接收队列"></a>（5）TCP接收队列</h5><p>​    在TCP三次握手中，我们如何分辨：哪些连接是半连接，哪些连接是全连接呢？</p>
<p>​    Linux通过维护两个队列来解决问题：</p>
<ul>
<li>半连接队列（SYN队列）</li>
<li>全连接队列（accepet队列）</li>
</ul>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110261926809.png" alt="img" style="zoom:80%;">



<ul>
<li>服务端收到客户端发起的<strong>SYN</strong>后，内核会将连接存储到<strong>半连接队列</strong></li>
<li>服务端向客户端发送<strong>SYN+ACK</strong></li>
<li>客户端收到<strong>SYN+ACK</strong>后，发送<strong>ACK</strong>到服务端</li>
<li>服务端收到客户端的<strong>ACK</strong>后，内核会把连接从<strong>半连接队列</strong>移除，将其添加到<strong>全连接队列</strong>，等待进程调用<strong>accept函数</strong>时把连接取出来</li>
<li>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接<strong>丢弃</strong>，或<strong>返回 RST 包</strong></li>
</ul>
<h5 id="（6）SYN攻击与避免方式"><a href="#（6）SYN攻击与避免方式" class="headerlink" title="（6）SYN攻击与避免方式"></a>（6）SYN攻击与避免方式</h5><p>SYN攻击实际上就是对服务端一直发送SYN包，但是不回第三次握手ACK，这样会使服务端有大量的处于 <code>SYN_RECV</code> 状态的 TCP 连接（即<strong>半连接状态</strong>），久而久之就会导致<strong>TCP半连接队列溢出</strong></p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111221558394.jpeg" alt="img"></p>
<p><strong>避免SYN方法</strong>如下</p>
<p>方法一：调整Linux相关参数</p>
<p>通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</p>
<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog</span><br></pre></td></tr></table></figure>



<ul>
<li>SYN_RCVD 状态连接的最大个数：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure>



<ul>
<li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_abort_on_overflow</span><br></pre></td></tr></table></figure>





<p>方法二：<strong>开启tcp_syncookies</strong></p>
<p>当syncookies=1时，服务端开启 syncookies 功能，其可以在不使用 SYN 半连接队列的情况下成功建立连接（默认配置）</p>
<p>SYN队列即半连接队列        Accept队列即全连接队列</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130712.png" alt="img" style="zoom: 50%;">                                <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130242.png" alt="img" style="zoom: 50%;"></p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130175.png" alt="img" style="zoom:50%;">                                <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130600.png" alt="img" style="zoom: 50%;"> </p>
<p>syncookies的运行原理：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功。其处理流程如下：</p>
<ul>
<li>「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」</li>
<li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」</li>
<li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接</li>
</ul>
<h4 id="3-TCP连接断开"><a href="#3-TCP连接断开" class="headerlink" title="3.TCP连接断开"></a>3.TCP连接断开</h4><h5 id="（1）四次挥手"><a href="#（1）四次挥手" class="headerlink" title="（1）四次挥手"></a>（1）四次挥手</h5><p>当我们的应用不再需要数据通信，就会发起断开TCP连接，建立一个连接需要<strong>三次握手</strong>，而终止一个连接需要经过<strong>四次挥手</strong></p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110111551532.png" alt="img"></p>
<p>SYN：发送方和接收方相互确认序号，表示<strong>连接</strong>操作；    ACK：表示接收数据序号字段有效，一般表示数据已被接收方<strong>收到</strong>；    FIN：表示<strong>断开</strong>连接</p>
<ul>
<li>第一次挥手：客户端发起<strong>FIN</strong>包，客户端进入<strong>FIN_WAIT_1</strong>状态（虽然FIN包不携带数据，也需要消耗一个序号u）</li>
<li>第二次挥手：服务端收到<strong>FIN</strong>包，发出确认包<strong>ACK</strong>（ack=u+1），并带上自己的序号seq=v，服务端进入<strong>CLOSE_WAIT</strong>状态（这个时候客户端仍需要接收服务器发送的数据）；客户端接收到服务端发送的<strong>ACK</strong>后，进入<strong>FIN_WAIT_2</strong>状态</li>
<li>第三次挥手：服务端数据发送完毕后，向客户端发送<strong>FIN</strong>包（seq=w，ack=u+1），<strong>半连接状态</strong>下服务器可能又发送一些数据，服务端此时进入<strong>LAST_ACK</strong>状态</li>
<li>第四次挥手：客户端收到服务端的<strong>FIN</strong>包后，发出确认包ACK（ACK=1， ack=w+1），此时客户端进入<strong>TIME_WAIT</strong>状态；服务端收到客户端确认包后进入<strong>CLOSED</strong>状态，而客户端需要等待2MSL后才进入<strong>CLOSED</strong>状态</li>
</ul>
<p>四次挥手的本质是——客户端和服务器通过<strong>两对FIN-ACK报文</strong>通知对方自己要关闭了</p>
<p>三次握手中，在第二次握手时，接收端将一个<strong>ACK</strong>包和一个<strong>SYN</strong>包合并一起发送，所以减少了一次包的发送</p>
<p>四次挥手中，在主动关闭方（客户端）发送FIN包后，接收方（服务端）可能还要发送数据，不能立即关闭数据通道，所以服务端要先确认ACK，然后等到自己把数据发无可发后再发送<strong>FIN</strong>包</p>
<h5 id="（2）需要四次挥手的原因"><a href="#（2）需要四次挥手的原因" class="headerlink" title="（2）需要四次挥手的原因"></a>（2）需要四次挥手的原因</h5><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据</li>
<li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能<strong>还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接</li>
</ul>
<p>服务端的<strong>ACK</strong>和<strong>FIN</strong>需要分开发送，是因为通常需要等待完成数据的发送和处理，所以会比三次握手多一次</p>
<h5 id="（3）TIME-WAIT状态功能"><a href="#（3）TIME-WAIT状态功能" class="headerlink" title="（3）TIME_WAIT状态功能"></a>（3）TIME_WAIT状态功能</h5><p>为什么客户端在关闭连接时需要一个TIME_WAIT的状态呢？</p>
<p>其主要有以下两个原因：</p>
<ul>
<li>防止旧连接的数据包</li>
<li>保证「被动关闭连接」的一方能被正确的关闭</li>
</ul>
<p><strong>防止旧连接的数据包</strong>：</p>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222021036.png" alt="img" style="zoom:67%;">



<p>如果没有TIME_WAIT或TIME_WAIT的时间过短，那么图中被延迟的过期的数据包可能会被客户端正常接收</p>
<p>而经过TIME_WAIT的<code>2MSL</code> 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</p>
<p><strong>保证连接正确关闭</strong>：</p>
<img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222130617.png" alt="img" style="zoom:67%;">

<p>TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</p>
<p>一旦客户端最后的ACK报文在网络丢失，如果没有TIME_WAIT或TIME_WAIT的时间过短，客户端很快就会进入了则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。这时如果客户端要发起新的连接，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止</p>
<p>如果 TIME-WAIT 等待足够长时，一旦服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文</p>
<h5 id="（4）TIME-WAIT深入讲解"><a href="#（4）TIME-WAIT深入讲解" class="headerlink" title="（4）TIME_WAIT深入讲解"></a>（4）TIME_WAIT深入讲解</h5><p><strong>为什么TIME_WAIT等待的时间是两秒</strong>？</p>
<p>MSL：<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p>
<p>TTL： <strong>IP 数据报可以经过的最大路由数</strong>，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机</p>
<p>如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， <strong>一来一去正好 2 MSL</strong></p>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong></p>
<p><strong>TIME_WAIT 过多有什么危害？</strong></p>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是内存资源占用；</li>
<li>第二是对端口资源的占用，如果<strong>TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接</strong></li>
</ul>
<p><strong>TIME_WAIT 优化</strong></p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项：可以复用<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>，引入时间戳后，重复的数据包会因为时间戳过期而被自然丢弃，同时<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong></li>
<li>net.ipv4.tcp_max_tw_buckets：这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置</strong></li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭（也是一个危险行为，不推荐使用）</li>
</ul>
<h5 id="（5）TCP保活机制"><a href="#（5）TCP保活机制" class="headerlink" title="（5）TCP保活机制"></a>（5）TCP保活机制</h5><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
<p>这时候就要提到TCP的<strong>保活机制</strong>了</p>
<p>在一个<strong>规定的时间段</strong>（tcp_keepalive_time：保活时间）内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<strong>每隔一个时间间隔</strong>（tcp_keepalive_intvl：每次检测间隔），发送一个「探测报文」，该探测报文包含的数据非常少，如果<strong>连续几个探测报文</strong>（tcp_keepalive_probes：检测次数）都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p>
<p>  相关参数如下：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure>

<p>  <img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110271337578.png" alt="image-20211023214647732">    </p>
<p>按照系统默认的设置来计算在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接</p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202110232154413.png" alt="img"></p>
<p>开启了TCP保活可以考虑以下三种情况：</p>
<ul>
<li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来</li>
<li>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置</li>
<li>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong></li>
</ul>
<p><strong>前方施工中。。。</strong></p>
<p><img src="https://raw.githubusercontent.com/Autovy/Image/master/img/202111222117832.webp" alt></p>
<h3 id="深入TCP机制"><a href="#深入TCP机制" class="headerlink" title="深入TCP机制"></a>深入TCP机制</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA">https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA</a></p>
<h4 id="1-重传机制"><a href="#1-重传机制" class="headerlink" title="1.重传机制"></a>1.重传机制</h4><h4 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2.滑动窗口"></a>2.滑动窗口</h4><h4 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3.流量控制"></a>3.流量控制</h4><h4 id="4-拥堵控制"><a href="#4-拥堵控制" class="headerlink" title="4.拥堵控制"></a>4.拥堵控制</h4><h3 id="TCP关键参数与优化"><a href="#TCP关键参数与优化" class="headerlink" title="TCP关键参数与优化"></a>TCP关键参数与优化</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw">https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw</a></p>
<h4 id="1-TCP三次握手参数"><a href="#1-TCP三次握手参数" class="headerlink" title="1.TCP三次握手参数"></a>1.TCP三次握手参数</h4><h4 id="2-TCP四次挥手参数"><a href="#2-TCP四次挥手参数" class="headerlink" title="2.TCP四次挥手参数"></a>2.TCP四次挥手参数</h4><h4 id="3-TCP数据传输参数"><a href="#3-TCP数据传输参数" class="headerlink" title="3.TCP数据传输参数"></a>3.TCP数据传输参数</h4><h3 id="IP基本知识"><a href="#IP基本知识" class="headerlink" title="IP基本知识"></a>IP基本知识</h3><h3 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h3><h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><h3 id="Ping工作原理"><a href="#Ping工作原理" class="headerlink" title="Ping工作原理"></a>Ping工作原理</h3><h3 id="Ping工作原理-1"><a href="#Ping工作原理-1" class="headerlink" title="Ping工作原理"></a>Ping工作原理</h3>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Autovy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://autovy.github.io/2021/12/22/DevPrinciple/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TCP/" title="开发原理|深入理解TCP&#x2F;IP">https://autovy.github.io/2021/12/22/DevPrinciple/深入了解TCP/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 开发原理</a>
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 深度系列</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 计算机网络</a>
              <a href="/tags/TCP/" rel="tag"><i class="fa fa-tag"></i> TCP</a>
              <a href="/tags/IP/" rel="tag"><i class="fa fa-tag"></i> IP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/16/Tool/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" rel="prev" title="开发工具|Git的使用与工作原理">
      <i class="fa fa-chevron-left"></i> 开发工具|Git的使用与工作原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/20/Java/Java-Socket%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/" rel="next" title="Java|Socket编程指南">
      Java|Socket编程指南 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>



  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5TCP%E8%BF%9E%E6%8E%A5"><span class="nav-text">深入TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-TCP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="nav-text">1.TCP基本认识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89TCP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">（1）TCP头部结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89TCP%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）TCP基本定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">（3）TCP与UDP的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="nav-text">2.TCP连接建立</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">（1）三次握手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">（2）需要三次握手的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%8F%E5%88%97%E5%8F%B7ISN"><span class="nav-text">（3）初始化序列号ISN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89MTU%E4%B8%8EMSS"><span class="nav-text">（4）MTU与MSS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%885%EF%BC%89TCP%E6%8E%A5%E6%94%B6%E9%98%9F%E5%88%97"><span class="nav-text">（5）TCP接收队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%886%EF%BC%89SYN%E6%94%BB%E5%87%BB%E4%B8%8E%E9%81%BF%E5%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">（6）SYN攻击与避免方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-TCP%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80"><span class="nav-text">3.TCP连接断开</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text">（1）四次挥手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">（2）需要四次挥手的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89TIME-WAIT%E7%8A%B6%E6%80%81%E5%8A%9F%E8%83%BD"><span class="nav-text">（3）TIME_WAIT状态功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89TIME-WAIT%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3"><span class="nav-text">（4）TIME_WAIT深入讲解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%885%EF%BC%89TCP%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="nav-text">（5）TCP保活机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5TCP%E6%9C%BA%E5%88%B6"><span class="nav-text">深入TCP机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-text">1.重传机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">2.滑动窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">3.流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%8B%A5%E5%A0%B5%E6%8E%A7%E5%88%B6"><span class="nav-text">4.拥堵控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-text">TCP关键参数与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%82%E6%95%B0"><span class="nav-text">1.TCP三次握手参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%8F%82%E6%95%B0"><span class="nav-text">2.TCP四次挥手参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-TCP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8F%82%E6%95%B0"><span class="nav-text">3.TCP数据传输参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-text">IP基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">IP地址基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="nav-text">IP协议相关技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ping%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">Ping工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ping%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-text">Ping工作原理</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a href="/">  <img class="site-author-image" itemprop="image" alt="Autovy"
      src="/images/2.png">  </a>
  <p class="site-author-name" itemprop="name">Autovy</p>
  <div class="site-description" itemprop="description">新时代农民工的数字农田</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Autovy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">648k</span>
</div>

<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
    本站已有
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    位访客
    <i class="fa fa-user"></i>
    </span>
  
<span> | </span>

  
    <span class="site-pv" title="总访问量">
   
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    次阅读
    <i class="fa fa-eye"></i>
    </span>
  
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RVJRabsBhxWXvhMcG8CH5wbc-gzGzoHsz',
      appKey     : 'JSGLk7guOagDPMFN9wbASkEh',
      placeholder: "说点什么吧",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
  <script src="/js/bloom.js" type="text/javascript"></script>