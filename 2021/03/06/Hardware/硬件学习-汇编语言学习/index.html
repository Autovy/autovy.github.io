<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/gear48.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gear32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="true"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"autovy.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="汇编|汇编语言学习">
<meta property="og:url" content="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Autovy&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041134246.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041130473.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041237607.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041130721.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131528.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131369.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131824.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131863.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131208.png">
<meta property="og:image" content="c:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210307191351945.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131386.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131210.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131248.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131898.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131672.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131032.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131639.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131793.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131479.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131296.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131432.png">
<meta property="og:image" content="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C:%5CUsers%5Clinghao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210307200924999.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131569.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131272.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131656.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131464.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131008.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131551.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131137.png">
<meta property="og:image" content="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C:%5CUsers%5Clinghao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210310200637543.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131648.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131193.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131423.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131921.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131463.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131473.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132991.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132336.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132272.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132432.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132063.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132720.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132992.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132824.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132975.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132665.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132892.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132122.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132657.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132997.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132648.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132490.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132608.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132987.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132783.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132340.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132531.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132289.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132474.png">
<meta property="og:image" content="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210317192816740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133833.png">
<meta property="og:image" content="c:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210322195732483.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133674.png">
<meta property="og:image" content="c:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210326155529547.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133329.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133817.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133267.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133199.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133793.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133283.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133001.png">
<meta property="article:published_time" content="2021-03-06T06:30:00.000Z">
<meta property="article:modified_time" content="2021-09-04T10:16:59.388Z">
<meta property="article:author" content="Autovy">
<meta property="article:tag" content="入门教程">
<meta property="article:tag" content="汇编语言">
<meta property="article:tag" content="底层原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041134246.jpeg">

<link rel="canonical" href="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>汇编|汇编语言学习 | Autovy's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Autovy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Autovy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Just For Interest</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">51</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">43</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2.png">
      <meta itemprop="name" content="Autovy">
      <meta itemprop="description" content="新时代农民工的数字农田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Autovy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          汇编|汇编语言学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021/03/06 14:30:00" itemprop="dateCreated datePublished" datetime="2021-03-06T14:30:00+08:00">2021/03/06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">硬件开发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv_test" style="display: inline;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041134246.jpeg" alt="img"></p>
<span id="more"></span>



<h2 id="汇编基础知识"><a href="#汇编基础知识" class="headerlink" title="汇编基础知识"></a>汇编基础知识</h2><h3 id="1-CPU对存储器的读写"><a href="#1-CPU对存储器的读写" class="headerlink" title="1.CPU对存储器的读写"></a>1.CPU对存储器的读写</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041130473.png" alt="image-20210307172937120"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041237607.png" alt="image-20210307173115319"></p>
<h3 id="2-地址总线"><a href="#2-地址总线" class="headerlink" title="2.地址总线"></a>2.地址总线</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041130721.png" alt="image-20210307173818234"></p>
<h3 id="3-数据总线"><a href="#3-数据总线" class="headerlink" title="3.数据总线"></a>3.数据总线</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131528.png" alt="image-20210307174352688"></p>
<h3 id="4-PC中各类存储器的逻辑连接"><a href="#4-PC中各类存储器的逻辑连接" class="headerlink" title="4.PC中各类存储器的逻辑连接"></a>4.PC中各类存储器的逻辑连接</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131369.png" alt="image-20210307175417668"></p>
<h2 id="CPU工作原理"><a href="#CPU工作原理" class="headerlink" title="CPU工作原理"></a>CPU工作原理</h2><h3 id="1-寄存器概述"><a href="#1-寄存器概述" class="headerlink" title="1.寄存器概述"></a>1.寄存器概述</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131138.png" alt="image-20210307190658768"></p>
<h3 id="2-通用寄存器"><a href="#2-通用寄存器" class="headerlink" title="2.通用寄存器"></a>2.通用寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131824.png" alt="image-20210307190849268"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131863.png" alt="image-20210307190909058"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131208.png" alt="image-20210307191017012"></p>
<p><img src="C:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210307191351945.png" alt="image-20210307191351945"> </p>
<h3 id="3-基础汇编指令"><a href="#3-基础汇编指令" class="headerlink" title="3.基础汇编指令"></a>3.基础汇编指令</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131386.png" alt="image-20210307191802493"></p>
<ul>
<li>但寄存器超过了4位数（十六进制），只会保留4位的内容</li>
<li>ax寄存器也可以拆成al，ah两块存储</li>
</ul>
<h3 id="4-CPU内部逻辑结构"><a href="#4-CPU内部逻辑结构" class="headerlink" title="4.CPU内部逻辑结构"></a>4.CPU内部逻辑结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131210.png" alt="image-20210307193135190"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131248.png" alt="image-20210307193654830"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131898.png" alt="image-20210307193826865"></p>
<p><strong>地址加法器工作原理：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131672.png" alt="image-20210307194023535"></p>
<h3 id="5-16位结构的CPU"><a href="#5-16位结构的CPU" class="headerlink" title="5.16位结构的CPU"></a>5.16位结构的CPU</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131032.png" alt="image-20210307193239847"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131408.png" alt="image-20210307195014762"></p>
<h3 id="6-段寄存器"><a href="#6-段寄存器" class="headerlink" title="6.段寄存器"></a>6.段寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131639.png" alt="image-20210307195535155"></p>
<p><strong>CPU工作流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131793.png" alt="image-20210307195700302"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131479.png" alt="image-20210307195911736"></p>
<p><strong>修改CS，IP指令：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131296.png" alt="image-20210307200416031"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131432.png" alt="image-20210307200445852"></p>
<h3 id="7-代码段"><a href="#7-代码段" class="headerlink" title="7.代码段"></a>7.代码段</h3><p><img src="/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C:%5CUsers%5Clinghao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210307200924999.png" alt="image-20210307200924999"></p>
<h2 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h2><h3 id="1-内存中字的存储"><a href="#1-内存中字的存储" class="headerlink" title="1.内存中字的存储"></a>1.内存中字的存储</h3><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节</p>
<p>字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131569.png" alt="image-20210308205927102"></p>
<p>0号是低地址单元，1号是高地址单元</p>
<p>（1）0地址单元中存放的字节型数据是多少？    20H</p>
<p>（2）0地址字单元中存放的字型数据是多少？    4E20H</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131272.png" alt="image-20210308210201087"></p>
<h3 id="2-DS寄存器与地址"><a href="#2-DS寄存器与地址" class="headerlink" title="2.DS寄存器与地址"></a>2.DS寄存器与地址</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131656.png" alt="image-20210308211025318"></p>
<p>读取内存单元数据到寄存器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 以下三条指令将1000H（1000:0）地址中的数据读到al</span><br><span class="line"># 先将目标地址放入通用寄存器 </span><br><span class="line">mov bx, 1000H</span><br><span class="line"># 经过通用寄存器将地址信息传送给ds（8086CPU不支持将数据直接送入段寄存器）</span><br><span class="line">mov ds, bx</span><br><span class="line"># 后面的代码可以自动索引到目标段地址是1000H（ds相当于栈的指针）</span><br><span class="line"># [0]指偏移地址是0，直接读取到1000H的数据（传送8位数据）</span><br><span class="line">mov al,[0]  </span><br><span class="line"></span><br><span class="line"># 下面这样则是将数据从寄存器送入内存单元（传送16位数据）</span><br><span class="line">mov [0],cx</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131464.png" alt="image-20210308212241728"></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="1-mov"><a href="#1-mov" class="headerlink" title="1.mov"></a>1.mov</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131008.png" alt="image-20210309215735409"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 将数据b放入ax寄存器中</span><br><span class="line">mov ax, b</span><br><span class="line"># ax寄存器中的内容放入bx寄存器中</span><br><span class="line">mov bx, ax</span><br><span class="line"># 内存单元里的内容存入ax寄存器中（内存单元的地址是根据ds + 偏移地址得到）</span><br><span class="line">mov ax, [0]</span><br><span class="line"># ax的内容存入内存单元中</span><br><span class="line">mov [0], ax</span><br><span class="line"># ax中存入的地址传入ds中</span><br><span class="line">mov ds ax</span><br></pre></td></tr></table></figure>



<h3 id="2-add与sub"><a href="#2-add与sub" class="headerlink" title="2.add与sub"></a>2.add与sub</h3><p>add，sub指令同mov一样，都有两个操作对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131551.png" alt="image-20210310192221575"></p>
<p>注意add和sub的对象不能有段寄存器</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><h3 id="1-数据段概念"><a href="#1-数据段概念" class="headerlink" title="1.数据段概念"></a>1.数据段概念</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131137.png" alt="image-20210310192835140"></p>
<h3 id="2-读取数据段"><a href="#2-读取数据段" class="headerlink" title="2.读取数据段"></a>2.读取数据段</h3><p>（1）读取数据段中前三个单元中的字节数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 123BH</span><br><span class="line"># 将123BH送入ds，作为数据段的段地址</span><br><span class="line">mov ds, ax</span><br><span class="line"># al存放累加的结果</span><br><span class="line">mov al, 0</span><br><span class="line"># 利用偏移地址读取数据段的单元</span><br><span class="line">add al, [0]</span><br><span class="line">add al, [1]</span><br><span class="line">add al, [2]</span><br></pre></td></tr></table></figure>



<p>（2）累加数据段中前三个单元中的字型数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 123BH</span><br><span class="line"># 将123BH送入ds，作为数据段的段地址</span><br><span class="line">mov ds, ax</span><br><span class="line"># ax存放累加的结果</span><br><span class="line">mov ax, 0</span><br><span class="line"># 利用偏移地址读取数据段的单元</span><br><span class="line">add ax, [0] </span><br><span class="line">add ax, [2]</span><br><span class="line">add ax, [4]</span><br></pre></td></tr></table></figure>

<p>注意：一个字型数据占两个单元，所以偏移地址是0，2，4</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p><img src="/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C:%5CUsers%5Clinghao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210310200637543.png" alt="image-20210310200637543"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131648.png" alt="image-20210310200840950"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="1-CPU提供的栈机制"><a href="#1-CPU提供的栈机制" class="headerlink" title="1.CPU提供的栈机制"></a>1.CPU提供的栈机制</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131193.png" alt="image-20210310201357424"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131423.png" alt="image-20210310201518098"></p>
<h3 id="2-push指令执行过程"><a href="#2-push指令执行过程" class="headerlink" title="2.push指令执行过程"></a>2.push指令执行过程</h3><p>先移动指针再放入数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131921.png" alt="image-20210310202248384"></p>
<p>任何时刻ss:sp指向栈顶元素，如果栈的最低部字单元地址位1000:000E，当栈为空时，SP=0100H</p>
<h3 id="3-pop指令执行过程"><a href="#3-pop指令执行过程" class="headerlink" title="3.pop指令执行过程"></a>3.pop指令执行过程</h3><p>先弹出数据再移动指针 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131463.png" alt="image-20210310203836597"></p>
<h3 id="4-栈顶超界问题"><a href="#4-栈顶超界问题" class="headerlink" title="4.栈顶超界问题"></a>4.栈顶超界问题</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041131473.png" alt="image-20210310205502760"></p>
<h3 id="5-push和pop指令"><a href="#5-push和pop指令" class="headerlink" title="5.push和pop指令"></a>5.push和pop指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 通用寄存器</span><br><span class="line"># 将寄存器中的数据入栈</span><br><span class="line">push ax</span><br><span class="line"># 用一个寄存器接受出栈的数据</span><br><span class="line">pop bx</span><br><span class="line"></span><br><span class="line"># 段寄存器</span><br><span class="line"># 将一个段寄存器中的数据入栈</span><br><span class="line">push ds</span><br><span class="line"># 用一个段寄存器接受出栈数据</span><br><span class="line">pop es</span><br><span class="line"></span><br><span class="line"># 内存单元（栈操作都是以字为单位，cpu会从ds中取出段地址加上指令中的偏移地址</span><br><span class="line"># 将一个内存单元的字入栈</span><br><span class="line">push [0]</span><br><span class="line"># 用一个内存字单元接收栈的数据</span><br><span class="line">pop [2]</span><br></pre></td></tr></table></figure>



<h3 id="6-栈的实例"><a href="#6-栈的实例" class="headerlink" title="6.栈的实例"></a>6.栈的实例</h3><p>将10000H~1000FH这段空间当作栈，初始状态为空，将AX，BX，DS的数据入栈</p>
<p>栈中的空间地址为ss:sp（即ss段地址*10加上sp偏移地址）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设置栈</span><br><span class="line"># 我们要用ss来定义一个栈，因为ss是段寄存器，所以要使用ax进行中转</span><br><span class="line"># 分析储存空间的地址，sp指向第一个字单元时为000EH，则栈的初始段地址为1000H</span><br><span class="line">mov ax, 1000H</span><br><span class="line">mov ss, ax</span><br><span class="line"># 设置栈顶指针，因为栈为空，所以初始化位置要向下移动一位，sp + 2（向下移动加，向上移动减）</span><br><span class="line">mov sp, 0010H</span><br><span class="line"># 填入数据，sp自动减2</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure>

<p>   <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132991.png" alt="image-20210310221157701"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132336.png" alt="image-20210310221459106"></p>
<h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>数据段：ds ，代码段：cs， 栈段：ss（这些仅仅是我们编程时的一种安排）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132272.png" alt="image-20210311092016168"></p>
<h2 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h2><h3 id="1-指令"><a href="#1-指令" class="headerlink" title="1.指令"></a>1.指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line"></span><br><span class="line">abc segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	add ax, ax</span><br><span class="line">	add ax, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00H</span><br><span class="line">	int 21H</span><br><span class="line">	</span><br><span class="line">abc ends</span><br><span class="line"></span><br><span class="line">end	</span><br></pre></td></tr></table></figure>

<ul>
<li><p>汇编指令：有对应的机器码的指令，可以被编译成机器指令，最终为CPU所执行</p>
</li>
<li><p>伪指令：没有对应的机器码的指令，最终不被CPU所执行，伪指令是由编译器来执行的指令 </p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132241.png" alt="image-20210314085001805"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132432.png" alt="image-20210314085047189"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132063.png" alt="image-20210314085131609"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132321.png" alt="image-20210314085229218"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132720.png" alt="image-20210314085411000"></p>
</li>
</ul>
<h3 id="2-程序"><a href="#2-程序" class="headerlink" title="2.程序"></a>2.程序</h3><p>程序：源代码中最终由计算机执行，处理的指令或数据</p>
<p>程序经编译连接后变成机器码</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132992.png" alt="image-20210314085547911"></p>
<h3 id="3-标号"><a href="#3-标号" class="headerlink" title="3.标号"></a>3.标号</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132602.png" alt="image-20210314085832394"></p>
<h3 id="4-程序返回"><a href="#4-程序返回" class="headerlink" title="4.程序返回"></a>4.程序返回</h3><p>（1）原理</p>
<p>DOS是一个单任务操作系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132824.png" alt="image-20210314090132826"></p>
<p>（2）实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132975.png" alt="image-20210314090243007"></p>
<p>（3）总结</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132665.png" alt="image-20210314090331563"></p>
<h3 id="5-汇编程序流程图"><a href="#5-汇编程序流程图" class="headerlink" title="5.汇编程序流程图"></a>5.汇编程序流程图</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132892.png" alt="image-20210314094246362"></p>
<h3 id="6-程序执行过程的跟踪"><a href="#6-程序执行过程的跟踪" class="headerlink" title="6.程序执行过程的跟踪"></a>6.程序执行过程的跟踪</h3><p>（1）exe文件程序加载过程</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132122.png" alt="image-20210314100412638"></p>
<p>（2）跟踪方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132657.png" alt="image-20210314101510698"></p>
<p>（3）总结</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132997.png" alt="image-20210314101055085"></p>
<h2 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h2><h3 id="1-bx"><a href="#1-bx" class="headerlink" title="1.[bx]"></a>1.[bx]</h3><p>（1）编译器环境下的偏移地址</p>
<p>在debug模式下可以用[0]表示偏移地址，编译器是无法读取[0]的，而是把它当作数值，所以我们需要用[bx]来表示偏移地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132648.png" alt="image-20210314170113276"></p>
<p>  在编译器中无法识别<code>mov ax, [0]</code>，但是可以加上段地址从而获得准确地址<code>mov ax, ds:[0]</code></p>
<p>（2）指令案例</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132137.png" alt="image-20210314170739068"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132490.png" alt="image-20210314170845019"></p>
<p>（3）案例分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">; 建立段寄存器寻址，保证编译器可以找到存放代码的段：codesg</span><br><span class="line">assume cs:codesg</span><br><span class="line">; 定义codesg段,里面存放代码</span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">; 定义程序</span><br><span class="line">demo: </span><br><span class="line">	; 为ds赋值为2000H</span><br><span class="line">	mov ax, 2000H</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov bx, 1000H</span><br><span class="line">	; 将地址2000:1000处的值赋给ax</span><br><span class="line">	mov ax, [bx]</span><br><span class="line">	; bx自增1</span><br><span class="line">	inc bx</span><br><span class="line">	inc bx</span><br><span class="line">	; 将ax的值存到2000:1002</span><br><span class="line">	mov [bx], ax</span><br><span class="line">	inc bx</span><br><span class="line">	inc bx</span><br><span class="line">	mov [bx], ax</span><br><span class="line">	inc bx</span><br><span class="line">	; 将ax中的低字节al存入内存单元</span><br><span class="line">	mov [bx], al</span><br><span class="line">	inc bx</span><br><span class="line">	mov [bx], al</span><br><span class="line">	</span><br><span class="line">	; 程序返回</span><br><span class="line">	mov ax, 4C00H</span><br><span class="line">	int 21H</span><br><span class="line"></span><br><span class="line">; 结束段	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">; 结束程序</span><br><span class="line">end demo; 	</span><br></pre></td></tr></table></figure>



<h3 id="2-loop指令"><a href="#2-loop指令" class="headerlink" title="2.loop指令"></a>2.loop指令</h3><p>  （1）基础知识</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132608.png" alt="image-20210314190421088"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132987.png" alt="image-20210314211437586"></p>
<p>（2）实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	mov cx, 11</span><br><span class="line">	</span><br><span class="line">s: add ax, ax</span><br><span class="line">	; 跳到地址s处</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax，4C00H</span><br><span class="line">	int 21H</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end	</span><br></pre></td></tr></table></figure>

<ul>
<li><p>标号</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132783.png" alt="image-20210314191625503"></p>
</li>
<li><p>loop s</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132340.png" alt="image-20210314191714300"></p>
</li>
</ul>
<p>（3）循环调试方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	</span><br><span class="line">	; 汇编语言的源程序中数值不能以字母开头，所以要在前面加个0</span><br><span class="line">	mov ax, 0ffffH</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov bx, 6</span><br><span class="line">	mov ax, [bx]</span><br><span class="line">	</span><br><span class="line">	mov dx, 0</span><br><span class="line">	</span><br><span class="line">	mov cx, 3</span><br><span class="line">	</span><br><span class="line">s:	add dx, ax</span><br><span class="line">	loop s	</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00H</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;相关命令</span><br><span class="line">-r ;查看寄存器中所存内容</span><br><span class="line">-u 076c:0 ;读取指定地址块的代码（翻译成汇编指令）</span><br><span class="line">-d 076c:0 ;读取指定地址块的16进制数</span><br><span class="line">-t ;执行一条指令，地址为CS:0000</span><br><span class="line">-g 0014 ;执行到某条指令（地址为cs:0014），可以执行到循环结束后的指令</span><br><span class="line">-p ;直接执行完循环</span><br></pre></td></tr></table></figure>



<h3 id="3-loop和-bx-的联合应用"><a href="#3-loop和-bx-的联合应用" class="headerlink" title="3.loop和[bx]的联合应用"></a>3.loop和[bx]的联合应用</h3><p><strong>要求：</strong></p>
<p>计算ffff:0 ~ ffff:b 单元中的数据的和，结果存储在dx中</p>
<p><strong>分析：</strong></p>
<p>（1）存储大小分析</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132531.png" alt="image-20210317192256653"></p>
<p>（2）存储位置分析</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132055.png" alt="image-20210317192341116"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132289.png" alt="image-20210317192452107"></p>
<p>（3）做法总结</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041132474.png" alt="image-20210317192606076"></p>
<img src="/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Users\linghao\AppData\Roaming\Typora\typora-user-images\image-20210317192816740.png" alt="image-20210317192816740" style="zoom:200%;">



<p>（4）程序案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	; 设置段地址</span><br><span class="line">	mov ax, 0ffffh</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov bx, 0</span><br><span class="line">	</span><br><span class="line">	; 设置最终存放寄存器dx</span><br><span class="line">	mov dx, 0</span><br><span class="line">	; 循环次数的寄存器cx</span><br><span class="line">	mov cx, 12</span><br><span class="line">	</span><br><span class="line">	; 循环过程中的al（8位寄存器）充当搬运工</span><br><span class="line">s:	mov al [bx]</span><br><span class="line">	mov ah, 0</span><br><span class="line">	add dx, ax</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end	</span><br></pre></td></tr></table></figure>



<h2 id="多段程序"><a href="#多段程序" class="headerlink" title="多段程序"></a>多段程序</h2><h3 id="1-在代码段中使用数据"><a href="#1-在代码段中使用数据" class="headerlink" title="1.在代码段中使用数据"></a>1.在代码段中使用数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	; dw定义一段连续的数据</span><br><span class="line">	dw 0123H, 0456H, 0789H, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">	; cpu会从start标记出开始存储代码并执行</span><br><span class="line">start:</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov ax, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line"> s: add ax, cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end	start</span><br></pre></td></tr></table></figure>

<p> dw定义一段连续的数据</p>
<p>但是cpu会从start标记出开始存储代码并执行</p>
<h3 id="2-在代码段中使用栈"><a href="#2-在代码段中使用栈" class="headerlink" title="2.在代码段中使用栈"></a>2.在代码段中使用栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; 利用栈将程序中定义的数据逆序存放</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	; dw定义一个字单元，在cs:0~cs:15中存放</span><br><span class="line">	dw 0123h, 0456H, 0789h,0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">	; dw定义8个字型数据，把这段空间当作栈来使用</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">	</span><br><span class="line">	start: 	mov ax, cs</span><br><span class="line">		mov ss, ax</span><br><span class="line">		; 栈顶ss:sp 指向 cs:32</span><br><span class="line">		mov sp, 32</span><br><span class="line">		; 初始化偏移地址，设置循环次数</span><br><span class="line">		mov bx, 0</span><br><span class="line">		mov cx, 8</span><br><span class="line">	</span><br><span class="line">	; 循环将数据入栈 </span><br><span class="line">	s:	push cs:[bx]</span><br><span class="line">		add bx, 2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">	</span><br><span class="line">	; 循环将数据出栈，顺序变换</span><br><span class="line">		s0:	pop cs:[bx]</span><br><span class="line">		add bx, 2</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>



<h3 id="3-将数据，代码，栈放入不同的段"><a href="#3-将数据，代码，栈放入不同的段" class="headerlink" title="3.将数据，代码，栈放入不同的段"></a>3.将数据，代码，栈放入不同的段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">; 分段存储代码，数据，栈</span><br><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">; 数据段存储</span><br><span class="line">data segment</span><br><span class="line">	; dw定义一个字单元，在cs:0~cs:15中存放</span><br><span class="line">	dw 0123h, 0456H, 0789h,0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">data ends	</span><br><span class="line">	</span><br><span class="line">; 栈段存储	</span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 代码段储存</span><br><span class="line">code segment</span><br><span class="line">	; 标记start，cpu就会将code段内容当作指令执行	</span><br><span class="line">	start: 	mov ax, stack</span><br><span class="line">		; 设置ss指向stack，并设置栈顶ss:sp 指向 stack:16</span><br><span class="line">		mov ss, ax</span><br><span class="line">		mov sp, 16</span><br><span class="line">		</span><br><span class="line">		; ds指向data段</span><br><span class="line">		mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; ds：bx 指向data段第一个单元</span><br><span class="line">		mov bx, 0</span><br><span class="line">		mov cx, 8</span><br><span class="line">	</span><br><span class="line">	; 循环将数据入栈 </span><br><span class="line">	s:	push cs:[bx]</span><br><span class="line">		add bx, 2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">	</span><br><span class="line">	; 循环将数据出栈，顺序变换</span><br><span class="line">		s0:	pop cs:[bx]</span><br><span class="line">		add bx, 2</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>



<h3 id="4-编写，调试多段程序"><a href="#4-编写，调试多段程序" class="headerlink" title="4.编写，调试多段程序"></a>4.编写，调试多段程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">; 分段存储代码，数据，栈</span><br><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">; 数据段存储</span><br><span class="line">data segment</span><br><span class="line">	; dw定义一个字单元，在cs:0~cs:15中存放</span><br><span class="line">	dw 0123h, 0456H, 0789h,0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">data ends	</span><br><span class="line">	</span><br><span class="line">; 栈段存储	</span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">			; 将stack链接到ss，确定了栈段的存储空间</span><br><span class="line">start:		mov ax, stack</span><br><span class="line">			mov ss, ax</span><br><span class="line">			; 找到空间后，因为要存16个字节，所以移动栈指针到栈底</span><br><span class="line">			mov sp, 16</span><br><span class="line">			</span><br><span class="line">			; 将data链接到ds，确定了代码段的存储空间</span><br><span class="line">			mov ax, data</span><br><span class="line">			mov ds, ax</span><br><span class="line">			</span><br><span class="line">			; 栈操作，将数据段的数据压入栈</span><br><span class="line">			push ds:[0]</span><br><span class="line">			push ds:[2]</span><br><span class="line">			</span><br><span class="line">			; 弹出栈</span><br><span class="line">			pop ds:[2]</span><br><span class="line">			pop ds:[0]</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">			mov ax, 4c00h</span><br><span class="line">			int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>无论段中要存放多少数据，程序分配的段的空间都是16的倍数（比如我们要在ds中存储2个字，其实际占有空间仍然为16）</li>
<li>程序是从上到下为段编排地址，ss，ds，cs只是人为安排的段地址，程序一视同仁地处理</li>
<li>start可以确定代码段中的指令可以被执行</li>
</ul>
<h2 id="更灵活的定位内存地址"><a href="#更灵活的定位内存地址" class="headerlink" title="更灵活的定位内存地址"></a>更灵活的定位内存地址</h2><h3 id="1-and和or指令"><a href="#1-and和or指令" class="headerlink" title="1.and和or指令"></a>1.and和or指令</h3><p>（1）and（与运算，类乘法）应用</p>
<p>​    使操作对象的相应位设为0</p>
<p>（2）or（或运算，类加法）应用</p>
<p>​    使操作对象的相应位设为0</p>
<h3 id="2-字符数据"><a href="#2-字符数据" class="headerlink" title="2.字符数据"></a>2.字符数据</h3><p>汇编程序中的字符会被编译器转换为相对应的ASCII码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	; dw定义字型数据（可存16位），db定义字节型数据（可存8位，每个字符对应的ASCII码就是8位的）</span><br><span class="line">	db &#39;unIt&#39;</span><br><span class="line">	db &#39;foRK&#39;</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: 	mov al, &#39;a&#39;</span><br><span class="line">		mov bx, &#39;b&#39;</span><br><span class="line"></span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line">end start		</span><br></pre></td></tr></table></figure>

<p>相关规律：</p>
<ul>
<li>大小写字母的转换：小写字母减20H可以转换为其对应的大写字母</li>
<li>小写字母的的ASCII大于61H，我们可以通过61H来判断大小写字母</li>
<li>一个字母，将第5位置置0，它将变为大写字母（and运算）；将第5位置置1，它将变为小写字母（or运算）</li>
</ul>
<h3 id="3-大小写转换"><a href="#3-大小写转换" class="headerlink" title="3.大小写转换"></a>3.大小写转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">; 大小写字母转换</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">; 存储字符串</span><br><span class="line">data segment</span><br><span class="line">	</span><br><span class="line">	db &#39;AutoVY&#39;</span><br><span class="line">	db &#39;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: 	mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		</span><br><span class="line">		; 将&#39;AutoVY&#39;全部转为大写</span><br><span class="line">		; ds:bx, 指向&quot;AutoVY&quot;第一个字母</span><br><span class="line">		mov bx, 0</span><br><span class="line">		; 因为AutoVY有6个字母，所以要循环6次</span><br><span class="line">		mov cx, 6</span><br><span class="line">		</span><br><span class="line">		; 逐个读取字符</span><br><span class="line">		s0: mov al, [bx]</span><br><span class="line">			; 将字符与11011111b做与运算，将第5位置0，转换为大写字母</span><br><span class="line">			and al, 11011111b</span><br><span class="line">			; 将转换后的ASCII码写回原单元</span><br><span class="line">			mov [bx], al</span><br><span class="line">			</span><br><span class="line">			; bx自增1，指向下个字母</span><br><span class="line">			inc bx</span><br><span class="line">			loop s0</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		; 将&#39;HelloWorld&#39;全部转为小写</span><br><span class="line">		; ds:bx, 指向&quot;HelloWorld&quot;第一个字母</span><br><span class="line">		mov bx, 6</span><br><span class="line">		; 因为HelloWorld有10个字母，所以要循环10次</span><br><span class="line">		mov cx, 10</span><br><span class="line">		</span><br><span class="line">		; 逐个读取字符</span><br><span class="line">		s1: mov al, [bx]</span><br><span class="line">			; 将字符与00100000b做或运算，将第5位置1，转换为小写字母</span><br><span class="line">			or al, 11011111b</span><br><span class="line">			; 将转换后的ASCII码写回原单元</span><br><span class="line">			mov [bx], al</span><br><span class="line">			</span><br><span class="line">			; bx自增1，指向下个字母</span><br><span class="line">			inc bx</span><br><span class="line">			loop s1</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="4-bx-idata"><a href="#4-bx-idata" class="headerlink" title="4.[bx+idata]"></a>4.[bx+idata]</h3><p>不改变bx，更加方便获得后续地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; 大小写字母转换</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">; 存储字符串</span><br><span class="line">data segment</span><br><span class="line">	</span><br><span class="line">	db &#39;AutoVY&#39;</span><br><span class="line">	db &#39;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">; 改进程序，以数组的方式处理数据</span><br><span class="line">start: 	mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		mov bx, 0</span><br><span class="line">		</span><br><span class="line">		mov cx, 5</span><br><span class="line">		; 定位第一个字符串字符</span><br><span class="line">	s:  mov al, [bx]</span><br><span class="line">		and al, 11011111b</span><br><span class="line">		mov [bx], al</span><br><span class="line">		</span><br><span class="line">		; 定位第二个字符串的字符</span><br><span class="line">		mov al, [6+bx]</span><br><span class="line">		or al, 00100000b</span><br><span class="line">		mov [6+bx], al</span><br><span class="line">		</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h3 id="5-SI和DI"><a href="#5-SI和DI" class="headerlink" title="5.SI和DI"></a>5.SI和DI</h3><p>SI和DI与bx的功能相似，起到了补充bx的作用，常常用于复制数据的场景</p>
<p>我们用ds:si指向要复制的原始数据，用ds:di指向复制的目的空间</p>
<p><strong>优化前：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">; 利用SI和DI将字符串复制到其后面的数据区</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &#39;hello,world&#39;</span><br><span class="line">	db &#39;...........&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; ds:si指向要复制的原始数据，用ds:di指向复制的目的空间</span><br><span class="line">		mov si, 0</span><br><span class="line">		mov di, 16</span><br><span class="line">		mov cx, 8</span><br><span class="line">		</span><br><span class="line">		; 复制</span><br><span class="line">	s:  mov ax, [si]</span><br><span class="line">		; 粘贴</span><br><span class="line">		mov [di], ax</span><br><span class="line">			</span><br><span class="line">		; 移动偏移地址</span><br><span class="line">		add si, 2</span><br><span class="line">		add di, 2</span><br><span class="line">			</span><br><span class="line">		loop s	</span><br><span class="line">		</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p><strong>优化后：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">; 利用SI和[bx+idata]将字符串复制到其后面的数据区</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &#39;hello,world&#39;</span><br><span class="line">	db &#39;...........&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; ds:si指向要复制的原始数据</span><br><span class="line">		mov si, 0</span><br><span class="line">		mov cx, 8</span><br><span class="line">		</span><br><span class="line">		; 0[si]即[si+0],复制ds:si中的数据</span><br><span class="line">	s:  mov ax, 0[si]</span><br><span class="line">		; 16[si]即[si+16]，将数据粘贴到ds:(si+16)</span><br><span class="line">		mov 16[si], ax</span><br><span class="line">			</span><br><span class="line">		; 移动偏移地址</span><br><span class="line">		add si, 2</span><br><span class="line">			</span><br><span class="line">		loop s	</span><br><span class="line">		</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="6-bx-si-和-bx-di"><a href="#6-bx-si-和-bx-di" class="headerlink" title="6.[bx+si]和[bx+di]"></a>6.[bx+si]和[bx+di]</h3><p> [bx+si]的偏移地址为<code>(bx)+(si)</code>，也可以写成<code>[bx][si]</code></p>
<p>[bx+si+idata]的偏移地址为<code>(bx)+(si)+(idata)</code>，也可以写成<code>idata[bx][si]</code></p>
<h2 id="寻址方式应用"><a href="#寻址方式应用" class="headerlink" title="寻址方式应用"></a>寻址方式应用</h2><h3 id="1-bx-si-应用"><a href="#1-bx-si-应用" class="headerlink" title="1.[bx+si]应用"></a>1.[bx+si]应用</h3><p>双重循环需要共用一个CX，造成在内层的时候覆盖了外层循环的循环计数值</p>
<p>所以我们应该每次开始内层循环时，将外层循环的cx数值保存起来，在执行外层loop前，再恢复</p>
<ul>
<li>当循环内，bx寄存器未被使用，我们可以用bx寄存器临时储存外层循环的cx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; 将数据段中每个单词都改写成大写字母</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">; 共有四行数据，且每一行占了16个字节</span><br><span class="line">data segment</span><br><span class="line">db &#39;ibm             &#39;</span><br><span class="line">db &#39;dec             &#39;</span><br><span class="line">db &#39;vim             &#39;</span><br><span class="line">db &#39;dos             &#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">; 利用[bx+si]双重循环访问数据（类似于二维数组）</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; bx定位行</span><br><span class="line">		mov bx, 0</span><br><span class="line">		</span><br><span class="line">		mov cx, 4</span><br><span class="line">		</span><br><span class="line">		; 用dx临时存放外层循环的值</span><br><span class="line">	s0: mov dx, cx</span><br><span class="line">		; si定位列 </span><br><span class="line">		mov si, 0</span><br><span class="line">		; 覆盖cx的值</span><br><span class="line">		mov cx, 3</span><br><span class="line">		s:	mov al, [bx+si]</span><br><span class="line">			and al, 11011111b</span><br><span class="line">			mov al, [bx+si], al</span><br><span class="line">			</span><br><span class="line">			inc si</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">	add bx, 16</span><br><span class="line">	; 在进行外层循环前恢复外层循环的cx值</span><br><span class="line">	mov cx, dx</span><br><span class="line">	loop s0	</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>



<ul>
<li>cpu的寄存器数量有限容易撞车,我们也可以将暂存的数据放入内容单元中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">; 将数据段中每个单词都改写成大写字母</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">; 共有四行数据，且每一行占了16个字节</span><br><span class="line">data segment</span><br><span class="line">db &#39;ibm             &#39;</span><br><span class="line">db &#39;dec             &#39;</span><br><span class="line">db &#39;vim             &#39;</span><br><span class="line">db &#39;dos             &#39;</span><br><span class="line">; 定义一个字用来保存cx</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">; 利用[bx+si]双重循环访问数据（类似于二维数组）</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; bx定位行</span><br><span class="line">		mov bx, 0</span><br><span class="line">		</span><br><span class="line">		mov cx, 4</span><br><span class="line">		</span><br><span class="line">		; 将外层循环的cx值保存在data:40H的单元中</span><br><span class="line">	s0: mov ds:[40H], cx</span><br><span class="line">		; si定位列 </span><br><span class="line">		mov si, 0</span><br><span class="line">		; 覆盖cx的值</span><br><span class="line">		mov cx, 3</span><br><span class="line">		s:	mov al, [bx+si]</span><br><span class="line">			and al, 11011111b</span><br><span class="line">			mov al, [bx+si], al</span><br><span class="line">			</span><br><span class="line">			inc si</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">	add bx, 16</span><br><span class="line">	; 在进行外层循环前从内存单元中恢复外层循环的cx值</span><br><span class="line">	mov cx, dx</span><br><span class="line">	loop s0	</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>把暂存的数据单个放入内存单元的时候，我们必须要记住数据放到的单元的位置，这样程序会造成混乱；我们能尝试使用栈来存储这些数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">; 将数据段中每个单词都改写成大写字母</span><br><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">; 共有四行数据，且每一行占了16个字节</span><br><span class="line">data segment</span><br><span class="line">db &#39;ibm             &#39;</span><br><span class="line">db &#39;dec             &#39;</span><br><span class="line">db &#39;vim             &#39;</span><br><span class="line">db &#39;dos             &#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">; 定义一个段,用来作为栈段，用来储存一些临时数据</span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line"></span><br><span class="line">stack ends	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 利用[bx+si]双重循环访问数据（类似于二维数组）</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; bx定位行</span><br><span class="line">		mov bx, 0</span><br><span class="line">		</span><br><span class="line">		mov cx, 4</span><br><span class="line">		</span><br><span class="line">		; 外层循环的cx值压入栈中</span><br><span class="line">	s0: push cx</span><br><span class="line">		mov dx, cx</span><br><span class="line">		; si定位列</span><br><span class="line">		mov si, 0</span><br><span class="line">		; 内层循环覆盖cx的值</span><br><span class="line">		mov cx, 3</span><br><span class="line">		s:	mov al, [bx+si]</span><br><span class="line">			and al, 11011111b</span><br><span class="line">			mov al, [bx+si], al</span><br><span class="line">			</span><br><span class="line">			inc si</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">	add bx, 16</span><br><span class="line">	; 在进行外层循环前通过弹出栈中数据恢复外层循环的cx值</span><br><span class="line">	pop cx</span><br><span class="line">	loop s0	</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="1-寻址寄存器"><a href="#1-寻址寄存器" class="headerlink" title="1.寻址寄存器"></a>1.寻址寄存器</h3><ul>
<li>在8086CPU中，只有bx，bp，si，di这四个寄存器可以用于内存单元的寻找</li>
<li>bx，bp，si，di这四个寄存器可以单个出现，或只能以以下四种组合出现：bx和si，bx和di，bp和si，bp和di</li>
<li>bp寄存器，当指令没有显性给出段地址，段地址默认为ss</li>
</ul>
<h3 id="2-数据位置"><a href="#2-数据位置" class="headerlink" title="2.数据位置"></a>2.数据位置</h3><p>（1）数据位置可以在三个位置：cpu内部，内存，端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133833.png" alt="image-20210322162735142"></p>
<p>（2）数据位置的表达</p>
<ul>
<li>立即数（idata）: 如<code>mov ax, 1</code>，执行前在cpu的指令缓存器中</li>
<li>寄存器：如：<code>mov ax, bx</code>执行，数据在寄存器中</li>
<li>段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中</li>
</ul>
<h3 id="3-寻址方式"><a href="#3-寻址方式" class="headerlink" title="3.寻址方式"></a>3.寻址方式</h3><ul>
<li>直接寻址：[idata]</li>
<li>寄存器间接寻址：[bx]</li>
<li>寄存器相对寻址：<code>[bx].idata（用于结构体）</code>；<code>idata[si]（用于数组）</code>；<code>[bx][idata]（用于二维数组）</code></li>
<li>基址变址寻址：<code>[bx][si]（用于二维数组）</code></li>
<li>相对基址变址寻址：<code>idata[bx][si](用于二维数组)</code></li>
</ul>
<p>常用方式（对比C语言）：我们可以用<code>[bx+idata+si]</code>的方式来访问结构体，bx对应整个结构体，idata对应结构体中的某一个数据项，用si定位数据项中的每一个元素</p>
<p>c语言：dec.cp[i] =&gt; 汇编：bx.10h[si]</p>
<h3 id="4-数据长度"><a href="#4-数据长度" class="headerlink" title="4.数据长度"></a>4.数据长度</h3><ul>
<li>通过寄存器指明要处理的数据尺寸，例如：<code>mov ax,1</code>,ax申请了16位的长度</li>
<li>通过操作符<code>x ptr</code>指明内存单元长度，如<code>word ptr</code>，<code>byte ptr</code>，常用于没有寄存器时访问内存单元</li>
<li>指令默认访问数据大小，如<code>push[1000H]</code>，默认处理字单元</li>
</ul>
<h3 id="5-div指令"><a href="#5-div指令" class="headerlink" title="5.div指令"></a>5.div指令</h3><p>（1）基本原则</p>
<p>​    <img src="C:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210322195732483.png" alt="image-20210322195732483"></p>
<p>除数（当除数为8位时，当除数为16位时）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133674.png" alt="image-20210322200100086"></p>
<p>（2）解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; (al)&#x3D;(ax)&#x2F;((ds)*16+0)的商</span><br><span class="line">; (ah)&#x3D;(ax)&#x2F;((ds)*16+0)的余数</span><br><span class="line">div byte ptr ds[0]</span><br><span class="line"></span><br><span class="line">; (ax)&#x3D;[(dx)*10000H+(ax)]&#x2F;((es)*16+0)的商</span><br><span class="line">; (dx)&#x3D;[(dx)*10000H+(ax)]&#x2F;((es)*16+0)的余数</span><br><span class="line">div word ptr es:[0]</span><br><span class="line"></span><br><span class="line">; (al)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的商</span><br><span class="line">; (al)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的余数</span><br><span class="line">div byte ptr [bx+si+8]</span><br></pre></td></tr></table></figure>



<p>（3） 案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; 计算100001&#x2F;100</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	; 被除数100001转换为十六进制为186A1H，超过了16位（ax存不下）</span><br><span class="line">	; 所以我们用dx存储16位溢出的1</span><br><span class="line">	mov dx, 1</span><br><span class="line">	; ax储存16位数据</span><br><span class="line">	mov ax, 86A1H</span><br><span class="line">	</span><br><span class="line">	; 除数100，转换成十六进制为64,虽然8位可以存放</span><br><span class="line">	; 但是按照被除数为32位，除数为16位的规则，我们只能用一整个bx存储</span><br><span class="line">	mov bx,100</span><br><span class="line">	</span><br><span class="line">	; div指令会自动读取被除数(dx)*10000H+(ax)</span><br><span class="line">	; 除以bx</span><br><span class="line">	div bx</span><br><span class="line">	</span><br><span class="line">	; 程序返回</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="6-伪指令dd"><a href="#6-伪指令dd" class="headerlink" title="6.伪指令dd"></a>6.伪指令dd</h3><p>前面我们用db定义字节型数据（8位），dw定义字型数据（16位）</p>
<p>我们用dd定义dword（dobule word 双字，32位）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">; div计算data段中第一个数据除以第二个数据的商放在第三个数据的储存单元中</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">; 定义数据段</span><br><span class="line">data segment</span><br><span class="line">	; 被除数，dword类型（32位），需要用dx和ax存储</span><br><span class="line">	dd 100001</span><br><span class="line">	; 除数</span><br><span class="line">	dw 100</span><br><span class="line">	; 商</span><br><span class="line">	dw 0</span><br><span class="line">data ends	</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		</span><br><span class="line">		; 将ds:0（即第一个数据的低16位）中的数据存入ax中</span><br><span class="line">		mov ax, ds:[0]</span><br><span class="line">		</span><br><span class="line">		; 将ds:2（即第一个数据的高16位）中的数据存入dx中</span><br><span class="line">		mov dx, ds:[2]</span><br><span class="line">		</span><br><span class="line">		; 用dx:ax中的32位数据除以ds:4（即第二个数据，16位）中的字型数据</span><br><span class="line">		div word ptr ds:[4]</span><br><span class="line">		</span><br><span class="line">		; 将商存储在ds:6中</span><br><span class="line">		mov ds:[6],ax</span><br><span class="line"></span><br><span class="line">			; 程序返回</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="7-dup"><a href="#7-dup" class="headerlink" title="7.dup"></a>7.dup</h3><ul>
<li><p>dup是一个操作符</p>
</li>
<li><p>dup会与db，dw，dd等数据定义的伪指令配合使用，用来进行数据的重复</p>
</li>
<li><p>使用案例：<code>db 3 dup(0)</code>定义了三个字节，且值都为0,相当于<code>db 0,0,0</code></p>
</li>
</ul>
<h2 id="转移指令原理"><a href="#转移指令原理" class="headerlink" title="转移指令原理"></a>转移指令原理</h2><p>8086CPU的转移指令有以下几类</p>
<ul>
<li><p>无条件转移指令（jmp）</p>
</li>
<li><p>条件转移指令</p>
</li>
<li><p>循环指令（loop）</p>
</li>
<li><p>过程（相当于高级语言的函数）</p>
</li>
<li><p>中断</p>
</li>
</ul>
<h3 id="1-操作offset"><a href="#1-操作offset" class="headerlink" title="1.操作offset"></a>1.操作offset</h3><p>offset为伪指令，offset取得标号的偏移地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">; 将s的一条指令复制到s0</span><br><span class="line">; ---------------------------</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">; 复制对象</span><br><span class="line">;-------------------------</span><br><span class="line">s:	mov ax, bx</span><br><span class="line">	; 获得s指令的偏移地址存在si中</span><br><span class="line">	mov si, offset s</span><br><span class="line">	; 获得s0指令的偏移地址存在di中</span><br><span class="line">	mov di, offset s0</span><br><span class="line">	</span><br><span class="line">	; 从cs:[si]中复制出指令内容</span><br><span class="line">	mov ax, cs:[si]</span><br><span class="line">	; 粘贴给cs:[di]</span><br><span class="line">	mov cs:[di], ax</span><br><span class="line"></span><br><span class="line">; 粘贴对象	</span><br><span class="line">;----------------------	</span><br><span class="line">; nop是空指令，一个可占一个字节（因为要复制的指令是两字节的，所以这里要两个nop）</span><br><span class="line">s0: nop</span><br><span class="line">	nop</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure>



<h3 id="2-jmp指令"><a href="#2-jmp指令" class="headerlink" title="2.jmp指令"></a>2.jmp指令</h3><p>jmp可以无条件转移，可以只修改IP，也可以同时修改CS和IP</p>
<p>jmp指令参数：</p>
<ul>
<li>转移目标地址</li>
<li>转移的距离</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax, 0</span><br><span class="line">		; jmp转移到标记s处</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax, 1</span><br><span class="line">		add ax, ax</span><br><span class="line">        </span><br><span class="line">		s:inc ax</span><br><span class="line">code ends</span><br><span class="line">end start		</span><br><span class="line">		</span><br></pre></td></tr></table></figure>



<p>（1）<strong>jmp short 标号</strong></p>
<ul>
<li>功能为（IP）= （IP） +  8位位移</li>
<li>8位位移= 标号处地址 - jmp指令后第一个字节地址</li>
<li>short表示位移为8位位移</li>
<li>8位位移的范围位-128~127</li>
</ul>
<p>（2）<strong>jmp near ptr 标号</strong></p>
<ul>
<li>(IP) = (IP) + 16</li>
<li>16位位移= 标号处地址 - jmp指令后第一个字节地址</li>
<li>段内近转移</li>
</ul>
<p>（3）<strong>jmp far ptr 标号</strong></p>
<ul>
<li>段间转移，又称远转移</li>
</ul>
<p>（4）jmp 16位寄存器</p>
<p>（5）jmp word ptr 内存单元地址</p>
<ul>
<li>读取内存单元存放的偏移地址，并跳转</li>
<li>段内转移</li>
</ul>
<p>（6）jmp dword ptr 内存单元地址</p>
<ul>
<li><p>内存单元存放两个字，高地址处的字存放目的段地址，低地址处是转移的目标地址</p>
</li>
<li><p>段间转移</p>
</li>
</ul>
<h3 id="3-jcxz指令"><a href="#3-jcxz指令" class="headerlink" title="3.jcxz指令"></a>3.jcxz指令</h3><p>有条件跳转指令，所有有条件跳转指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址</p>
<p> （1）jcxz指令操作</p>
<ul>
<li>当(cx) = 0 时， （IP）= （IP） +  8位位移</li>
<li>当（cx）!= 0 时，程序向下执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; 在内存2000H段查找第一个值为0的字节，找到后将其偏移地址存储在dx中</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax, 2000H</span><br><span class="line">		mov ds, ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		</span><br><span class="line">; 循环查找内存</span><br><span class="line">; ----------------------------</span><br><span class="line">	; cx存放16位（字），但是要求按8位（字节）处理，所以要分高低位分别存储</span><br><span class="line">	s:  mov ch, 0</span><br><span class="line">		mov cl, [bx]</span><br><span class="line">		; jcxz 放在cx寄存器后，一旦cx&#x3D;0，即跳转到ok段</span><br><span class="line">		jcxz ok</span><br><span class="line">		; 不符合条件，bx自增找到下一个单元，利用jmp形成循环</span><br><span class="line">		inc bx</span><br><span class="line">		jmp short s</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">; 查找到后运行</span><br><span class="line">; ------------------	</span><br><span class="line">	ok: mov dx, bx</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start		</span><br></pre></td></tr></table></figure>



<h3 id="4-loop指令"><a href="#4-loop指令" class="headerlink" title="4.loop指令"></a>4.loop指令</h3><p>loop指令也是有条件跳转指令</p>
<p>loop指令操作</p>
<ul>
<li>(cx) = (cx) - 1</li>
<li>当(cx) != 0 ，（IP）= （IP） +  8位位移</li>
<li>当(cx) = 0 时，程序向下运行</li>
</ul>
<h2 id="函数相关指令"><a href="#函数相关指令" class="headerlink" title="函数相关指令"></a>函数相关指令</h2><p>call，ret指令都是转移指令，他们都同时修改IP或同时修改CS和IP</p>
<h3 id="1-ret和retf"><a href="#1-ret和retf" class="headerlink" title="1.ret和retf"></a>1.ret和retf</h3><p>（1）ret指令</p>
<p>​    ret指令使用栈中的数据，修改IP内容，实现近转移</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">; 申请栈的空间</span><br><span class="line">stack segment</span><br><span class="line">	</span><br><span class="line">	db 16 dup (0)</span><br><span class="line"></span><br><span class="line">stack ends	</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	; 定位栈段位置</span><br><span class="line">	mov ax, stack</span><br><span class="line">	mov ss, ax</span><br><span class="line">	; 确定栈顶指针</span><br><span class="line">	mov sp, 16</span><br><span class="line">	mov ax, 0</span><br><span class="line">	; 将ax值放入供ret使用</span><br><span class="line">	push ax</span><br><span class="line">	; 这一句好像没什么用</span><br><span class="line">	mov bx, 0</span><br><span class="line">	; 利用栈中的数据，IP修改为0</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>（2）retf指令</p>
<p>​    retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	</span><br><span class="line">	db 16 dup (0)</span><br><span class="line"></span><br><span class="line">stack ends	</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">start:</span><br><span class="line">	mov ax, stack</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	</span><br><span class="line">	mov ax, 0</span><br><span class="line">	; 这里的栈需要cs，和IP两个参数</span><br><span class="line">	push cs</span><br><span class="line">	push ax</span><br><span class="line">	</span><br><span class="line">	mov bx, 0</span><br><span class="line">	; 利用栈中的值取出cs:ip并跳转</span><br><span class="line">	retf</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="2-call指令"><a href="#2-call指令" class="headerlink" title="2.call指令"></a>2.call指令</h3><p>call指令操作</p>
<ul>
<li><p>将当前IP或CS和IP压入栈中</p>
</li>
<li><p>jmp转移</p>
</li>
<li><p>16位位移=“标号”处地址 - call指令后的第一个字节的地址</p>
</li>
</ul>
<h3 id="3-call和ret的配合使用"><a href="#3-call和ret的配合使用" class="headerlink" title="3.call和ret的配合使用"></a>3.call和ret的配合使用</h3><p>类似于函数，call调用子程序，执行完后通过ret返回到主程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">		mov ax, 1</span><br><span class="line">		; 确定循环次数</span><br><span class="line">		mov cx, 3</span><br><span class="line">		; 这里的call完成了两个操作</span><br><span class="line">		; 将下一个指令的IP压入栈中</span><br><span class="line">		; 跳转到s标记处</span><br><span class="line">		call s</span><br><span class="line">		mov bx, ax</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21</span><br><span class="line">	</span><br><span class="line">	; 循环3次相加ax</span><br><span class="line">	s:  add ax, ax</span><br><span class="line">		loop s</span><br><span class="line">		; 循环结束后，从栈中读到IP，然后跳转会mov bx, ax 句 </span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>4.mul指令</p>
<p>mul相乘的两个数，要么是8位的，要么都是16位</p>
<ul>
<li>8位：处理对象放在AL中和8位寄存器或内存字节单元中，结果在AX中</li>
<li>16位：处理对象放在AX中和16位寄存器或内存字单元中，结果DX（高位），AX（低位）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 乘法使用案例，计算100*10000</span><br><span class="line">; 因为乘数中的10000大于了255，所以必须做16位乘法</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">		mov ax, 100</span><br><span class="line">		mov bx, 10000</span><br><span class="line">		; mul会自动读取ax中的值作为其中一个乘数</span><br><span class="line">		mul bx	</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="4-批量数据的传递"><a href="#4-批量数据的传递" class="headerlink" title="4.批量数据的传递"></a>4.批量数据的传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; 利用子程序将data段中的字符串转换为大写</span><br><span class="line">assume cs:code</span><br><span class="line">; 利用内存空间传递批量数据作为参数</span><br><span class="line">data segment</span><br><span class="line">	db &#39;TestText&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		mov ax, data</span><br><span class="line">		; ds:si指向字符串（批量数据）所在空间的首地址</span><br><span class="line">		mov ds, ax</span><br><span class="line">		mov si, 0</span><br><span class="line">		</span><br><span class="line">		; 字符串长度决定循环次数</span><br><span class="line">		mov cx, 8</span><br><span class="line">		call change</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">change: </span><br><span class="line">		and byte ptr [si], 11011111b</span><br><span class="line">		inc si</span><br><span class="line">		loop change</span><br><span class="line">		ret	</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面这个利用了内存批量传参，使用栈也可以达到同样效果</p>
<h3 id="5-解决除法溢出问题"><a href="#5-解决除法溢出问题" class="headerlink" title="5.解决除法溢出问题"></a>5.解决除法溢出问题</h3><p><img src="C:/Users/linghao/AppData/Roaming/Typora/typora-user-images/image-20210326155529547.png" alt="image-20210326155529547"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">; 解决除法溢出问题，F4240H&#x2F;0AH</span><br><span class="line">assume cs:code, ss:stack</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		mov ax, stack</span><br><span class="line">		mov ss, ax</span><br><span class="line">		mov sp, 10h</span><br><span class="line">		; 被除数低16位</span><br><span class="line">		mov ax, 4240h</span><br><span class="line">		; 被除数高16位</span><br><span class="line">		mov dx, 0fh</span><br><span class="line">		; 除数</span><br><span class="line">		mov cx, 0ah</span><br><span class="line">		</span><br><span class="line">		call divdw</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">divdw:	; 子程序定义开始</span><br><span class="line"></span><br><span class="line">		; 低16位入栈保存</span><br><span class="line">		push ax</span><br><span class="line">		</span><br><span class="line">		; 高16位放到ax中进行处理</span><br><span class="line">		mov ax, dx</span><br><span class="line">		</span><br><span class="line">		; dx置零</span><br><span class="line">		mov dx, 0</span><br><span class="line">		</span><br><span class="line">		; H&#x2F;N，用高位除以除数</span><br><span class="line">		div cx</span><br><span class="line">		</span><br><span class="line">		; ax,bx的值为H&#x2F;N的商，这时候dx的值为H&#x2F;N的余数</span><br><span class="line">		mov bx, ax</span><br><span class="line">		</span><br><span class="line">		; 从栈中恢复低16位</span><br><span class="line">		pop ax</span><br><span class="line">		</span><br><span class="line">		; L&#x2F;N，dx默认为被除数的高16位，ax为低16位</span><br><span class="line">		div cx</span><br><span class="line">		</span><br><span class="line">		; 将余数放到cx中</span><br><span class="line">		mov cx, dx</span><br><span class="line">		</span><br><span class="line">		; 将结果高16位放到dx中，结果的低16位在ax中</span><br><span class="line">		mov dx, bx</span><br><span class="line">		</span><br><span class="line">		; 子程序结束</span><br><span class="line">		ret</span><br></pre></td></tr></table></figure>



<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>flag寄存器按位起作用，每一位都有专门的含义</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133329.png" alt="image-20210327093649958"></p>
<p>在debug中查看标志寄存器</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133817.png" alt="image-20210327095901036"></p>
<h3 id="1-ZF标志"><a href="#1-ZF标志" class="headerlink" title="1.ZF标志"></a>1.ZF标志</h3><p>ZF为零标志位，记录相关指令执行后的计算结果是否为0</p>
<ul>
<li>结果为0，ZF=1</li>
<li>结果不为0，ZF=0</li>
</ul>
<h3 id="2-PF标志"><a href="#2-PF标志" class="headerlink" title="2.PF标志"></a>2.PF标志</h3><p>PF为奇偶标志位，记录指令执行后，结果的二进制位中1的个数</p>
<ul>
<li>为偶数，PF=1</li>
<li>为奇数，PF=0</li>
</ul>
<h3 id="3-SF标志"><a href="#3-SF标志" class="headerlink" title="3.SF标志"></a>3.SF标志</h3><p>SF为符号标志位，记录相关指令执行后的的结果</p>
<ul>
<li><p>结果为负，SF=1</p>
</li>
<li><p>结果为正，SF=0</p>
</li>
<li><p>SF标志是CPU对有符号数运算结果的一种记录</p>
<p>对同一个二进制数据，计算机可以把它当作无符号数据来运算，也可以当作有符号数据来运算</p>
</li>
</ul>
<p>当CPU在执行add等指令时，实际上就包括了了两层含义（当作有符号处理/当作无符号处理）</p>
<h3 id="4-CF标志"><a href="#4-CF标志" class="headerlink" title="4.CF标志"></a>4.CF标志</h3><p>CF为进位标志位，针对无符号数，记录运算的进位值，也记录借位</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133267.png" alt="image-20210327095644658"></p>
<h3 id="5-OF标志"><a href="#5-OF标志" class="headerlink" title="5.OF标志"></a>5.OF标志</h3><p>OF为溢出标志位，针对有符号数</p>
<ul>
<li>结果溢出则为1</li>
<li>结果不溢出则为0</li>
<li>在进行有符号数的运算时发生了溢出，那么运算的结果是不正确的</li>
</ul>
<h3 id="6-adc指令"><a href="#6-adc指令" class="headerlink" title="6.adc指令"></a>6.adc指令</h3><p>abc为带进位加法指令，利用CF位上的进位值</p>
<p><code>abc ax, bx</code> 实现功能：(ax) = (ax) + (bx) + CF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; adc和add指令相配合可以对更大的数据进行加法运算</span><br><span class="line">; add ax, bx</span><br><span class="line">add al, bl</span><br><span class="line">abc ah, bh</span><br></pre></td></tr></table></figure>



<h3 id="7-sbb指令"><a href="#7-sbb指令" class="headerlink" title="7.sbb指令"></a>7.sbb指令</h3><p>sbb为带借位减法指令，利用CF上的借位值</p>
<p><code>sbb ax, bx</code>实现的功能：(ax) = (ax) - (bx) - CF</p>
<h3 id="8-cmp指令"><a href="#8-cmp指令" class="headerlink" title="8.cmp指令"></a>8.cmp指令</h3><p>cmp指令为比较指令，对标志寄存器产生影响。<code>cmp ax, ax</code>实现的功能：做(ax)-(ax)运算，运算结果不保存，仅对flag的相关位产生影响</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133199.png" alt="image-20210327103947535"></p>
<h3 id="9-检测比较结果的条件转移指令"><a href="#9-检测比较结果的条件转移指令" class="headerlink" title="9.检测比较结果的条件转移指令"></a>9.检测比较结果的条件转移指令</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133793.png" alt="image-20210327152053172"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133283.png" alt="image-20210327152141824"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">; 比较条件语句(cmp和je配合使用)</span><br><span class="line">; (ah)&#x3D;(bh)则(ah)&#x3D;(ah)+(ah),否则(ah)&#x3D;(ah)+(bh)</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		; cmp 比较ah和bh</span><br><span class="line">		cmp ah, bh</span><br><span class="line">		; je做相等检测（相当于&#x3D;&#x3D;）,如果符合则跳转到s处</span><br><span class="line">		je s</span><br><span class="line">		; 无跳转正常向下执行</span><br><span class="line">		add ah, bh</span><br><span class="line">		; 跳转以绕开符合条件执行的语句</span><br><span class="line">		jmp short ok</span><br><span class="line">	; 条件符合后执行	</span><br><span class="line">	s:	add ah, ah</span><br><span class="line">	; 跳回到第一句，反复循环</span><br><span class="line">	ok: ret	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">; 统计data段中数值为8的字节的个数，用ax保存统计结果</span><br><span class="line">assume ds:data, cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">		</span><br><span class="line">		db 8,11,8,1,8,5,63,38</span><br><span class="line">		</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">		mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; ds:bx指向数据段第一个字节</span><br><span class="line">		mov bx, 0</span><br><span class="line">		</span><br><span class="line">		; 初始化累加器</span><br><span class="line">		mov ax, 0</span><br><span class="line">		; 由多少个数据决定循环次数</span><br><span class="line">		mov cx, 8</span><br><span class="line">	</span><br><span class="line">	    </span><br><span class="line">	s: 	; 和8进行比较</span><br><span class="line">		cmp byte ptr [bx], 8</span><br><span class="line">		; 不相等直接到下一个循环</span><br><span class="line">		jne next</span><br><span class="line">		; 相等ax计数</span><br><span class="line">		inc ax</span><br><span class="line">	</span><br><span class="line">   next:</span><br><span class="line">		; 移动地址，并进行下一次的比较</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends		</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="10-DF标志和串传送指令"><a href="#10-DF标志和串传送指令" class="headerlink" title="10.DF标志和串传送指令"></a>10.DF标志和串传送指令</h3><p>DF为方向标志位</p>
<ul>
<li><p>DF为0，每次操作后si，di递增</p>
</li>
<li><p>DF为1，每次操作后si，di递减</p>
</li>
</ul>
<p>（1）movsb</p>
<p>以字节为单位传送，将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减</p>
<p>（2）movsw</p>
<p>以字为单位传送，将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减2</p>
<p>（3）rep movsb</p>
<p>​    rep根据cx的值，重复执行后面的串传送指令</p>
<p>（4）DF设置指令</p>
<p>​    cld指令：将DF置0</p>
<p>​    std指令：将DF置1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">; 利用串传输指令，将data段中的第一个字符复制到它后面的空间</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	</span><br><span class="line">	db &#39;Welcome to masm!&#39;</span><br><span class="line">	db 16 dup (0)</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		mov ax, data</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; 设置ds:si指向data:0，读取位置</span><br><span class="line">		mov si, 0</span><br><span class="line">		mov es, ax</span><br><span class="line">		; 设置es:di指向data:16，存储位置</span><br><span class="line">		mov di, 16</span><br><span class="line">		; 设置rep循环16次(总共有16个字符，一个字符一字节)</span><br><span class="line">		mov cx, 16</span><br><span class="line">		</span><br><span class="line">		; 设置DF&#x3D;0，正向传送</span><br><span class="line">		cld</span><br><span class="line">		; 以字节为单位传送，将ds:si指向的内存单元中的字节送入es:di中</span><br><span class="line">		; 并且si，di自增1</span><br><span class="line">		rep movsb</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start	</span><br></pre></td></tr></table></figure>



<h3 id="11-pushf和popf"><a href="#11-pushf和popf" class="headerlink" title="11.pushf和popf"></a>11.pushf和popf</h3><p>pushf：将标志寄存器的值压栈</p>
<p>popf：从栈中弹出数据，送入标志寄存器中</p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><h3 id="1-中断基础知识"><a href="#1-中断基础知识" class="headerlink" title="1.中断基础知识"></a>1.中断基础知识</h3><p><strong>中断分类：</strong></p>
<p>外部中断，内部中断，软件中断</p>
<p><strong>中断向量表：</strong></p>
<p>存放着256个中断源所对应的中断处理程序的入口</p>
<p><strong>中断过程：</strong></p>
<ul>
<li>获得中断类型码N</li>
<li>标志寄存器的值入栈（保护标志位）：pushf</li>
<li>设置标志寄存器的TF和IF位为0 ：TF=0，IF=0</li>
<li>CS内容入栈：push CS</li>
<li>IP内容入栈： push IP</li>
<li>从内存地址为中断类型码<em>4和中断类型码\</em>4+2的两个字单元中读取中断程序入口地址设置IP和CS：(IP)=(N*4)，(CS)=(N*4+2)</li>
</ul>
<h3 id="2-中断处理程序"><a href="#2-中断处理程序" class="headerlink" title="2.中断处理程序"></a>2.中断处理程序</h3><p>处理步骤：</p>
<ul>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回（恢复保存起来的IP，CS和标志位寄存器）</li>
</ul>
<p>当发生除法溢出时，默认产生0号中断信息，从而引发中断过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109041133001.png" alt="image-20210327173957758"></p>
<p>修改默认的中断，令中断表的0号指向200:0处，中断程序就变为了200:0处存储的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line">mov word ptr es:[0*4], 200h</span><br><span class="line">mov word ptr es:[0*4+2], 0</span><br></pre></td></tr></table></figure>



<h3 id="3-单步中断"><a href="#3-单步中断" class="headerlink" title="3.单步中断"></a>3.单步中断</h3><p>单步中断的中断类型码为1，则它引发的中断过程如下：</p>
<ul>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF，IF设置为0</li>
<li>CS，IP入栈</li>
<li>(IP)=(1*4)，(CS)=(1*4+2)</li>
</ul>
<p>debug使用T命令时，将TF设置为1，引发单步中断</p>
<h2 id="int中断"><a href="#int中断" class="headerlink" title="int中断"></a>int中断</h2><p>CPU执行int n 指令，相当于调用一个n号中断的中断过程</p>
<h3 id="1-基本案例"><a href="#1-基本案例" class="headerlink" title="1.基本案例"></a>1.基本案例</h3><p>（1）安装程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">; 安装中断7ch的中断例程</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">; 通过串传送，将程序安装（复制）到安全的内存中（0:200）</span><br><span class="line">; -----------------------------		</span><br><span class="line">		mov ax,cs</span><br><span class="line">		mov ds, ax</span><br><span class="line">		; 设置ds:si指向源地址</span><br><span class="line">		mov si, offset sqs</span><br><span class="line">		</span><br><span class="line">		mov ax, 0</span><br><span class="line">		mov es, ax</span><br><span class="line">		; 设置es:di指向目的地址</span><br><span class="line">		mov di, 200h</span><br><span class="line">		; 计算出传输长度（循环次数）</span><br><span class="line">		mov cx, offset sqrend - offset sqr</span><br><span class="line">		; 设置传输方向为正</span><br><span class="line">		cld</span><br><span class="line">		; 传输</span><br><span class="line">		rep movsb</span><br><span class="line"></span><br><span class="line">; 设置中断向量表</span><br><span class="line">;-----------------------------------		</span><br><span class="line">		mov ax, 0</span><br><span class="line">		mov es, ax</span><br><span class="line">		mov word ptr es:[7ch*4], 200h</span><br><span class="line">		mov word ptr es:[7ch*4+2], 0</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	; 中断后运行的程序（这里是求a的平方）	</span><br><span class="line">	sqr:</span><br><span class="line">		mul ax</span><br><span class="line">		; 用iret指令返回（恢复保存起来的IP，CS和标志位寄存器），保证中断结束后继续执行原来的主程序</span><br><span class="line">		iret</span><br><span class="line">	</span><br><span class="line">	; 设置一个空指令，方便计算上面程序的长度 		</span><br><span class="line">	sqrend: </span><br><span class="line">		nop</span><br><span class="line">        </span><br><span class="line">code ends</span><br><span class="line">end start        </span><br></pre></td></tr></table></figure>



<p>（2）调用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; 调用中断例程,求2*3256^2</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		mov ax, 3456</span><br><span class="line">		; 调用中断7ch的中断例程，计算出ax数据的平方</span><br><span class="line">		int 7ch</span><br><span class="line">		</span><br><span class="line">		; 存放结果，结果乘以2</span><br><span class="line">		add ax, ax</span><br><span class="line">		adc dx, dx</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>CPU可以直接读写3个地方的数据：</p>
<ul>
<li><p>CPU内部寄存器</p>
</li>
<li><p>内存单元</p>
</li>
<li><p>端口</p>
</li>
</ul>
<h3 id="1-端口的读写"><a href="#1-端口的读写" class="headerlink" title="1.端口的读写"></a>1.端口的读写</h3><p>对0-255以内的端口进行读写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al, 20h 		;从20h端口读入一个字节</span><br><span class="line">out 20h, al		;从20h端口写入一个字节</span><br></pre></td></tr></table></figure>



<p>对255-65535位的端口进行读写，端口号放在dx中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 3f8h</span><br><span class="line">in ax, dx		; 读入一个字</span><br><span class="line">out dx, ax		; 写入一个字</span><br></pre></td></tr></table></figure>



<h3 id="2-shl和shr指令"><a href="#2-shl和shr指令" class="headerlink" title="2.shl和shr指令"></a>2.shl和shr指令</h3><p>（1）shl左移指令</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左移位</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
<li>如果移动的位数大于1，必须将移动位数放在cl中：<code>shl al, cl</code></li>
<li>将X逻辑左移一位，相当于执行：X=X*2</li>
</ul>
<p>（2）shr右移指令</p>
<ul>
<li>将一个寄存器或内存单元中的数据向右移位</li>
<li>将最后移出的一位写入CF中</li>
<li>最高位用0补充</li>
<li>如果移动的位数大于1，必须将移动位数放在cl中：<code>shr al, cl</code></li>
<li>将X逻辑左移一位，相当于执行：X=X/2</li>
</ul>
<h3 id="3-读取RAM芯片数据"><a href="#3-读取RAM芯片数据" class="headerlink" title="3.读取RAM芯片数据"></a>3.读取RAM芯片数据</h3><p>（1）CMOS RAM芯片与端口</p>
<ul>
<li><p>70h为地址端口，存放要访问的CMOS RAM单元的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 在70h写入要访问单元的地址</span><br><span class="line">mov al, 8</span><br><span class="line">out 70h, al</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或者写入到其中的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 在71h读取指定单元中的数据</span><br><span class="line">in al, 71h</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>CPU通过端口和外部设备进行联系</p>
<h3 id="1-外中断信息"><a href="#1-外中断信息" class="headerlink" title="1.外中断信息"></a>1.外中断信息</h3><p>（1）外中断源有两类：</p>
<ul>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ul>
<p>（2）当CPU检测到可屏蔽中断信息时</p>
<ul>
<li>如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程</li>
<li>如果IF=0，则不响应可屏蔽中断</li>
</ul>
<p>（3）设置IF指令</p>
<ul>
<li>sti，用于设置IF=1</li>
<li>cli，用于设置IF=0</li>
</ul>
<h3 id="2-键盘处理过程"><a href="#2-键盘处理过程" class="headerlink" title="2.键盘处理过程"></a>2.键盘处理过程</h3><p>（1）键盘触发中断原理</p>
<ul>
<li>一般按下一个键时产生的扫描码为通码，松开一个键产生的扫描码为断码（扫描码会送入60H）</li>
<li>扫描码长度为一个字节，通码第7位为0，断码第7位为1</li>
<li>断码 = 通码 + 80H</li>
<li>如果是字符键的扫描码，将该扫描码和其对应的字符码送入键盘缓冲区</li>
</ul>
<p>（2）键盘输入的处理过程</p>
<ul>
<li>键盘产生扫描码</li>
<li>扫描码送入60h端口</li>
<li>一旦侦测到60h端口有动静，引发9号中断</li>
<li>CPU执行int 9 中断例程处理键盘输入</li>
</ul>
<h2 id="直接定值表"><a href="#直接定值表" class="headerlink" title="直接定值表"></a>直接定值表</h2><h3 id="1-描述了单位长度的标号"><a href="#1-描述了单位长度的标号" class="headerlink" title="1.描述了单位长度的标号"></a>1.描述了单位长度的标号</h3><p>（1）地址标号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; a,b这里代表地址</span><br><span class="line">a: db 1, 2, 3, 4</span><br><span class="line">b: dw 0</span><br><span class="line"></span><br><span class="line">; a，b的使用，获得偏移地址</span><br><span class="line">mov si, offset a</span><br><span class="line">mov bx, offset b</span><br></pre></td></tr></table></figure>



<p>（2）地址+长度标号（数据标号）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; a描述了地址code:0，并描述了从这个地址开始，以后的内存单元都是字节单元</span><br><span class="line">a db 1, 2, 3, 4</span><br><span class="line">b dw 0</span><br><span class="line"></span><br><span class="line">; a，b可以代表段中的内存单元</span><br><span class="line">; 相当于mov ax, cs:[4]</span><br><span class="line">mov ax, b</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Autovy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://autovy.github.io/2021/03/06/Hardware/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="汇编|汇编语言学习">https://autovy.github.io/2021/03/06/Hardware/硬件学习-汇编语言学习/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 入门教程</a>
              <a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> 汇编语言</a>
              <a href="/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 底层原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/03/CLanguage/C%E8%AF%AD%E8%A8%80-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" rel="prev" title="C语言|算法入门指南">
      <i class="fa fa-chevron-left"></i> C语言|算法入门指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/10/CLanguage/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" rel="next" title="C语言|数据结构入门指南">
      C语言|数据结构入门指南 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>



  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">汇编基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CPU%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">1.CPU对存储器的读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF"><span class="nav-text">2.地址总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF"><span class="nav-text">3.数据总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-PC%E4%B8%AD%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%9E%E6%8E%A5"><span class="nav-text">4.PC中各类存储器的逻辑连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">CPU工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">1.寄存器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2.通用寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="nav-text">3.基础汇编指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-CPU%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">4.CPU内部逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-16%E4%BD%8D%E7%BB%93%E6%9E%84%E7%9A%84CPU"><span class="nav-text">5.16位结构的CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">6.段寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="nav-text">7.代码段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="nav-text">内存访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">1.内存中字的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-DS%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%9C%B0%E5%9D%80"><span class="nav-text">2.DS寄存器与地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-text">指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-mov"><span class="nav-text">1.mov</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-add%E4%B8%8Esub"><span class="nav-text">2.add与sub</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="nav-text">数据段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%A6%82%E5%BF%B5"><span class="nav-text">1.数据段概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="nav-text">2.读取数据段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-text">3.总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="nav-text">1.CPU提供的栈机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-push%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">2.push指令执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-pop%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">3.pop指令执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%88%E9%A1%B6%E8%B6%85%E7%95%8C%E9%97%AE%E9%A2%98"><span class="nav-text">4.栈顶超界问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-push%E5%92%8Cpop%E6%8C%87%E4%BB%A4"><span class="nav-text">5.push和pop指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A0%88%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-text">6.栈的实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E6%AE%B5"><span class="nav-text">栈段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="nav-text">汇编程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8C%87%E4%BB%A4"><span class="nav-text">1.指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A0%87%E5%8F%B7"><span class="nav-text">3.标号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="nav-text">4.程序返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">5.汇编程序流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B7%9F%E8%B8%AA"><span class="nav-text">6.程序执行过程的跟踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="nav-text">[BX]和loop指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-bx"><span class="nav-text">1.[bx]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-loop%E6%8C%87%E4%BB%A4"><span class="nav-text">2.loop指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-loop%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88%E5%BA%94%E7%94%A8"><span class="nav-text">3.loop和[bx]的联合应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F"><span class="nav-text">多段程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="nav-text">1.在代码段中使用数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="nav-text">2.在代码段中使用栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B0%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="nav-text">3.将数据，代码，栈放入不同的段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BC%96%E5%86%99%EF%BC%8C%E8%B0%83%E8%AF%95%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F"><span class="nav-text">4.编写，调试多段程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="nav-text">更灵活的定位内存地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-and%E5%92%8Cor%E6%8C%87%E4%BB%A4"><span class="nav-text">1.and和or指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE"><span class="nav-text">2.字符数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.大小写转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-bx-idata"><span class="nav-text">4.[bx+idata]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-SI%E5%92%8CDI"><span class="nav-text">5.SI和DI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-bx-si-%E5%92%8C-bx-di"><span class="nav-text">6.[bx+si]和[bx+di]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="nav-text">寻址方式应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-bx-si-%E5%BA%94%E7%94%A8"><span class="nav-text">1.[bx+si]应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-text">数据处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AF%BB%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">1.寻址寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="nav-text">2.数据位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">3.寻址方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6"><span class="nav-text">4.数据长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-div%E6%8C%87%E4%BB%A4"><span class="nav-text">5.div指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BC%AA%E6%8C%87%E4%BB%A4dd"><span class="nav-text">6.伪指令dd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-dup"><span class="nav-text">7.dup</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E5%8E%9F%E7%90%86"><span class="nav-text">转移指令原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%93%8D%E4%BD%9Coffset"><span class="nav-text">1.操作offset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-jmp%E6%8C%87%E4%BB%A4"><span class="nav-text">2.jmp指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-jcxz%E6%8C%87%E4%BB%A4"><span class="nav-text">3.jcxz指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-loop%E6%8C%87%E4%BB%A4"><span class="nav-text">4.loop指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">函数相关指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ret%E5%92%8Cretf"><span class="nav-text">1.ret和retf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-call%E6%8C%87%E4%BB%A4"><span class="nav-text">2.call指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-call%E5%92%8Cret%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-text">3.call和ret的配合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-text">4.批量数据的传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%A7%A3%E5%86%B3%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-text">5.解决除法溢出问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">标志寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ZF%E6%A0%87%E5%BF%97"><span class="nav-text">1.ZF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-PF%E6%A0%87%E5%BF%97"><span class="nav-text">2.PF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SF%E6%A0%87%E5%BF%97"><span class="nav-text">3.SF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-CF%E6%A0%87%E5%BF%97"><span class="nav-text">4.CF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-OF%E6%A0%87%E5%BF%97"><span class="nav-text">5.OF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-adc%E6%8C%87%E4%BB%A4"><span class="nav-text">6.adc指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-sbb%E6%8C%87%E4%BB%A4"><span class="nav-text">7.sbb指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-cmp%E6%8C%87%E4%BB%A4"><span class="nav-text">8.cmp指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">9.检测比较结果的条件转移指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">10.DF标志和串传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-pushf%E5%92%8Cpopf"><span class="nav-text">11.pushf和popf</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD"><span class="nav-text">内中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">1.中断基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%95%E6%AD%A5%E4%B8%AD%E6%96%AD"><span class="nav-text">3.单步中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int%E4%B8%AD%E6%96%AD"><span class="nav-text">int中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A1%88%E4%BE%8B"><span class="nav-text">1.基本案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3"><span class="nav-text">端口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">1.端口的读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-shl%E5%92%8Cshr%E6%8C%87%E4%BB%A4"><span class="nav-text">2.shl和shr指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AF%BB%E5%8F%96RAM%E8%8A%AF%E7%89%87%E6%95%B0%E6%8D%AE"><span class="nav-text">3.读取RAM芯片数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="nav-text">外中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%96%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="nav-text">1.外中断信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%94%AE%E7%9B%98%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">2.键盘处理过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%80%BC%E8%A1%A8"><span class="nav-text">直接定值表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%8F%E8%BF%B0%E4%BA%86%E5%8D%95%E4%BD%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%A0%87%E5%8F%B7"><span class="nav-text">1.描述了单位长度的标号</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a href="/">  <img class="site-author-image" itemprop="image" alt="Autovy"
      src="/images/2.png">  </a>
  <p class="site-author-name" itemprop="name">Autovy</p>
  <div class="site-description" itemprop="description">新时代农民工的数字农田</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Autovy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">499k</span>
</div>

<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
    本站已有
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    位访客
    <i class="fa fa-user"></i>
    </span>
  
<span> | </span>

  
    <span class="site-pv" title="总访问量">
   
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    次阅读
    <i class="fa fa-eye"></i>
    </span>
  
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RVJRabsBhxWXvhMcG8CH5wbc-gzGzoHsz',
      appKey     : 'JSGLk7guOagDPMFN9wbASkEh',
      placeholder: "说点什么吧",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
  <script src="/js/bloom.js" type="text/javascript"></script>