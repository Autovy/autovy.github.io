<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/gear48.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gear32.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="true"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"autovy.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Java|知识框架">
<meta property="og:url" content="https://autovy.github.io/2021/04/11/Java-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Autovy&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040947723.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944597.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944324.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944267.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944489.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944251.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944665.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945274.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945714.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945201.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945850.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945892.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945760.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945099.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945354.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945866.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945369.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945603.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945557.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945002.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945770.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945212.png">
<meta property="article:published_time" content="2021-04-11T06:30:00.000Z">
<meta property="article:modified_time" content="2021-09-04T02:05:10.473Z">
<meta property="article:author" content="Autovy">
<meta property="article:tag" content="入门教程">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040947723.png">

<link rel="canonical" href="https://autovy.github.io/2021/04/11/Java-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Java|知识框架 | Autovy's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Autovy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Autovy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Just For Interest</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">22</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://autovy.github.io/2021/04/11/Java-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2.png">
      <meta itemprop="name" content="Autovy">
      <meta itemprop="description" content="某编外人员的个人小站，新时代农民工的数字农田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Autovy's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java|知识框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021/04/11 14:30:00" itemprop="dateCreated datePublished" datetime="2021-04-11T14:30:00+08:00">2021/04/11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/11/Java-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/11/Java-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040947723.png" alt="image-20210904094723369"></p>
<span id="more"></span>

<h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><h3 id="计算机硬件介绍"><a href="#计算机硬件介绍" class="headerlink" title="计算机硬件介绍"></a>计算机硬件介绍</h3><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h4><p>中央处理器从内存获取指令，然后执行这些指令</p>
<p>每台计算机都有一个内部时钟，以固定速度发射电子脉冲，时钟速度越快，在给定的时间段内可以执行更多的指令（计量单位为HZ）</p>
<h4 id="2-计算机发展规律"><a href="#2-计算机发展规律" class="headerlink" title="2.计算机发展规律"></a>2.计算机发展规律</h4><ul>
<li>摩尔定律</li>
<li>安迪-比尔定律</li>
<li>反摩尔定律</li>
</ul>
<h4 id="3-存储设备"><a href="#3-存储设备" class="headerlink" title="3.存储设备"></a>3.存储设备</h4><p>内存中的信息在断电后丢失，所有我们要将程序和数据永久保存在存储设备上</p>
<p>存储设备有下面三种</p>
<ul>
<li><p>磁盘驱动器</p>
</li>
<li><p>光盘驱动器</p>
</li>
<li><p>USB闪存驱动器</p>
</li>
</ul>
<h4 id="4-内存"><a href="#4-内存" class="headerlink" title="4.内存"></a>4.内存</h4><p>计算机最基本的存储单元是字节（byte），每个字节有8个比特（bit）构成</p>
<p>内存（RAM）用于存储程序及程序所需要的数据</p>
<p>一个程序和它的数据在被CPU执行前必须移到计算机内存中</p>
<h4 id="5-通信设备"><a href="#5-通信设备" class="headerlink" title="5.通信设备"></a>5.通信设备</h4><p>电脑可以通过通信设备</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统是运行在计算机上最重要的程序，管理和控制计算机的活动</p>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>万维网即world wide web，简称web</p>
<p>web客户端可以访问浏览web服务器上的页面</p>
<p>web通过一个全局统一资源标识符（URL）标识</p>
<p>web通过超文本传输协议（http）传输给用户</p>
<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><h3 id="Java语言应用场景"><a href="#Java语言应用场景" class="headerlink" title="Java语言应用场景"></a>Java语言应用场景</h3><h4 id="1-JavaEE（spring）"><a href="#1-JavaEE（spring）" class="headerlink" title="1.JavaEE（spring）"></a>1.JavaEE（spring）</h4><h4 id="2-大数据（spark）"><a href="#2-大数据（spark）" class="headerlink" title="2.大数据（spark）"></a>2.大数据（spark）</h4><h4 id="3-安卓开发"><a href="#3-安卓开发" class="headerlink" title="3.安卓开发"></a>3.安卓开发</h4><h3 id="Java开发介绍"><a href="#Java开发介绍" class="headerlink" title="Java开发介绍"></a>Java开发介绍</h3><h4 id="1-软件开发介绍"><a href="#1-软件开发介绍" class="headerlink" title="1.软件开发介绍"></a>1.软件开发介绍</h4><p>（1）软件开发</p>
<p>软件集一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分</p>
<p>（2）人机交互方式</p>
<ul>
<li>图形化界面：GUI</li>
<li>命令行方式：CLI</li>
</ul>
<h4 id="2-Java技术体系平台"><a href="#2-Java技术体系平台" class="headerlink" title="2.Java技术体系平台"></a>2.Java技术体系平台</h4><ul>
<li>Java SE：面向桌面级应用的Java平台</li>
<li>Java EE：面向web应用程序</li>
<li>Java ME：面向移动终端</li>
</ul>
<h4 id="3-Java语言特点"><a href="#3-Java语言特点" class="headerlink" title="3.Java语言特点"></a>3.Java语言特点</h4><ul>
<li>面向对象：类与对象</li>
<li>健壮性：提供一个相对安全的内存管理和访问机制</li>
<li>跨平台性：java语言编写的应用程序可以运行在不同的系统平台上（通过jvm实现）</li>
</ul>
<h4 id="4-Java两种核心机制"><a href="#4-Java两种核心机制" class="headerlink" title="4.Java两种核心机制"></a>4.Java两种核心机制</h4><ul>
<li>Java虚拟机（JVM）：JVM是一个虚拟计算机，具有指令集使用不同的存储区域，负责执行指令，管理数据，内存，寄存器（屏蔽底层运行平台的差别，实现“”一次编译，处处运行“）</li>
<li>垃圾收集机制：java系统级线性跟踪存储空间的分配情况，并在JVM空闲时，检测并释放可被释放的存储空间</li>
</ul>
<h4 id="5-Java环境"><a href="#5-Java环境" class="headerlink" title="5.Java环境"></a>5.Java环境</h4><ul>
<li>JDK：Java开发工具包，其中包含了JRE，其中包含了编译工具（javac）和打包工具（jar）</li>
<li>JRE：java运行环境，包括了JVM和java的核心类库</li>
<li>使用JDK开发java程序，交给JRE运行</li>
<li>JDK &gt; JRE &gt; JVM</li>
</ul>
<h2 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h2><h3 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h3><h4 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h4><p>定义：在java语言中用作专门用途的字符串（单词）</p>
<p>特点：关键字所有字母为小写</p>
<p>功能：定影数据类型，定义流程控制，定义访问权限修饰，定义类函数变量修饰符，定义类与类之间关系，定义建立引用判断实例，异常处理，包</p>
<h4 id="2-保留字"><a href="#2-保留字" class="headerlink" title="2.保留字"></a>2.保留字</h4><p>现有Java版本尚未使用，但后续版本可能作为关键字使用，命名标识符时避免使用这些保留字</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>对变量，方法和类的命名使用的字符序列，称为标识符</p>
<p>合法标识符规则，命名规范</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量即内存中一个存储区域，该区域的数据可以在同一类型范围内不断变化</p>
<p>变量时程序最基础的存储单元，包含变量类型，变量名和存储的值</p>
<p>Java的每个变量必须先声明后使用</p>
<ul>
<li></li>
</ul>
<h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><p>（1）基本数据类型</p>
<ul>
<li><p>数值型：整数类型（byte,short,int,long），浮点类型（float,double）</p>
</li>
<li><p>字符型（char）</p>
</li>
<li><p>布尔型（boolean）</p>
</li>
</ul>
<p>（2）引用数据类型</p>
<ul>
<li><p>类（class）（字符串变量的声明就是用类来声明）</p>
</li>
<li><p>接口（interface）</p>
</li>
<li><p>数组（array）</p>
</li>
</ul>
<p>（3）声明位置分类变量</p>
<ul>
<li>成员变量：方法体外，类体内声明的变量</li>
<li>局部变量：方法体内部声明的变量</li>
</ul>
<h4 id="2-整型类型"><a href="#2-整型类型" class="headerlink" title="2.整型类型"></a>2.整型类型</h4><p>整型默认使用int型，当遇到不足以表达较大的数，才使用long，声明long类型常量，需要后加”L”</p>
<h4 id="3-浮点数类型"><a href="#3-浮点数类型" class="headerlink" title="3.浮点数类型"></a>3.浮点数类型</h4><p>浮点数类型常量默认使用double型，声明float型常量，需要后加”F”</p>
<h4 id="4-基本数据类型转换"><a href="#4-基本数据类型转换" class="headerlink" title="4.基本数据类型转换"></a>4.基本数据类型转换</h4><ul>
<li>自动转换类型：容量小的类型自动转换为容量大的数据类型</li>
<li>byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double</li>
<li>在多种类型数据混合运算时，系统首先自动间=将所有数据转换成容量最大的数据类型，然后进行计算</li>
<li>强类型转换：自动类型转换的逆过程，可以将容量大的数据类型转换成容量小的数据类型（如将字符串转换为int类）</li>
</ul>
<h4 id="5-引用数据类型"><a href="#5-引用数据类型" class="headerlink" title="5.引用数据类型"></a>5.引用数据类型</h4><p>引用数据类型包括：类（如String类）,接口，数组</p>
<p>​    String类：</p>
<ul>
<li>String属于引用数据类型</li>
<li>声明String类型变量使用一对””</li>
<li>String可以和8种基本数据类型做运行（字符串连接运算）</li>
</ul>
<h4 id="6-变量赋值"><a href="#6-变量赋值" class="headerlink" title="6.变量赋值"></a>6.变量赋值</h4><ul>
<li>如果变量是基本数据类型，此时赋值的变量是所保存的数据值</li>
<li>如果变量是引用数据类型，此时赋值的变量所保存的数据的地址值</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h4><p>加减乘除，取余，自增，自减，字符串连接</p>
<h4 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h4><ul>
<li>当”=“号两侧数据类型不一致时，可以使用自动类型转换或者使用强制类型转换原则进行处理</li>
<li>支持连续赋值</li>
<li>可以使用扩展赋值运算符：+=，-=，*=，/=，%=</li>
</ul>
<h4 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3.比较运算符"></a>3.比较运算符</h4><ul>
<li><p>比较运算符的结果都是Boolean型</p>
</li>
<li><p>Java有个特殊的比较运算符：instanceof，可以检查是否为类的对象</p>
</li>
</ul>
<h4 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h4><ul>
<li>与或非等等</li>
<li>逻辑运算符操作的都是boolean类型的变量</li>
</ul>
<h4 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5.位运算符"></a>5.位运算符</h4><p>类型：</p>
<ul>
<li>左移右移</li>
<li>与运算</li>
<li>或运算</li>
<li>取反</li>
</ul>
<p>交换两数的方法：</p>
<ul>
<li>定义临时变量法</li>
<li>相加法</li>
<li>位运算符法</li>
</ul>
<h4 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="6.三元运算符"></a>6.三元运算符</h4><ul>
<li>结构：(条件表达式)? 表达式1 : 表达式2</li>
<li>返回结果为Boolean类型</li>
<li>凡是可以使用三元运算符的地方，都可以转换为if-else，但是优先使用三元运算符</li>
</ul>
<h3 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h3><h4 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h4><p>程序从上到下逐条执行，中间没有任何判断和跳转</p>
<h4 id="2-分支结构"><a href="#2-分支结构" class="headerlink" title="2.分支结构"></a>2.分支结构</h4><p>（1）根据条件，选择性执行某段代码</p>
<ul>
<li>if-elseif-else</li>
<li>switch-case</li>
<li>switch-case可以转换为if-elseif-else</li>
</ul>
<p>，优先使用switch-case</p>
<p>（2）switch-case-default:</p>
<ul>
<li>根据switch表达式中的值，依次匹配各个case中的常量，一旦匹配成功跳转到相应的case语句中</li>
<li>一旦执行到break，跳出switch-case结构</li>
<li>switch的表达式中，只能是如下的6种数据类型之一：byte，short，char，int，String类型</li>
</ul>
<h4 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h4><p>（1）根据循环条件，重复性执行某段代码</p>
<ul>
<li>for循环</li>
<li>while循环</li>
<li>do-while循环</li>
</ul>
<p>（2）循环语句四个组成部分：</p>
<ul>
<li>初始化部分</li>
<li>循环条件部分</li>
<li>循环体部分</li>
<li>迭代部分</li>
</ul>
<p>​    执行过程:初始化 -&gt;  循环条件 -&gt; 循环体 -&gt; 迭代 -&gt;  循环-&gt;条件 -&gt; 循环体 -&gt; 迭代 -&gt; …… -&gt;  循环条件</p>
<p>（3）for循环结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(初始化; 循环条件; 迭代) &#123;循环体&#125;</span><br></pre></td></tr></table></figure>

<p>​    不在循环条件内限制次数的结构：for( ; ; )</p>
<p>（4）while循环结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line">while(循环条件)&#123;循环体;迭代&#125;</span><br></pre></td></tr></table></figure>

<p>​    不在循环条件内限制次数的结构：while(true)</p>
<p>（5）do-while循环结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line">do&#123; 循环体;迭代;&#125;while(循环条件)</span><br></pre></td></tr></table></figure>



<p>​    do-while的执行过程与for，while不同，会至少执行一次循环体</p>
<p>​    执行过程: 初始化 -&gt;  循环体 -&gt; 迭代-&gt;  循环条件-&gt;  循环体 -&gt; 迭代-&gt;  ……</p>
<p>（6）结束循环方式</p>
<ul>
<li>循环条件中返回false</li>
<li>循环体中执行break：结束当前循环</li>
<li>循环体中执行continue：结束当次循环</li>
<li>break和coninue在多重循环中，可以通过指定标识结束循环（默认跳出包裹关键字的最近一层循环）</li>
</ul>
<h4 id="4-Scanner输入"><a href="#4-Scanner输入" class="headerlink" title="4.Scanner输入"></a>4.Scanner输入</h4><p>从用户输入处获得不同类型的变量，需要用到Scanner类</p>
<ul>
<li>导入Scanner的包</li>
<li>Scanner实例化</li>
<li>调用Scanner类相关方法来获取指定类型的变量</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1.数组概述"></a>1.数组概述</h4><p>（1）数组是多个相同类型数据按照一定顺序排列的集合，并使用一个名字命名，通过编号的方式对数据进行统一管理</p>
<p>（2）数组相关概念：数组名，元素，索引，数组长度</p>
<p>（3）数组特点：</p>
<ul>
<li>数组本身是引用数据类型，数组中的元素可以是任意数据类型</li>
<li>创建数据对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址</li>
<li>数组的长度一旦确定，就不能修改</li>
</ul>
<h4 id="2-一维数组的使用"><a href="#2-一维数组的使用" class="headerlink" title="2.一维数组的使用"></a>2.一维数组的使用</h4><p>（1）数组的声明与初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">int</span> [] ids</span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>&#125;</span><br><span class="line"><span class="comment">// 动态初始化：初始化与赋值分离</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>（2）调用数组指定位置元素</p>
<p>（3）获取数组长度</p>
<p>（4）数组遍历</p>
<p>（5）数组元素默认初始化值</p>
<p>（6）数组的内存解析</p>
<p>​    内存结构：</p>
<ul>
<li>栈（局部变量）</li>
<li>堆（对象，数组）</li>
<li>方法区（常量池，静态域）</li>
</ul>
<h4 id="3-多维数据的使用"><a href="#3-多维数据的使用" class="headerlink" title="3.多维数据的使用"></a>3.多维数据的使用</h4><p>Java语言里提供多维数组的语法</p>
<p>从数组底层运行机制来看，其实没有多维数组</p>
<p>（1）二维数组的声明与初始化</p>
<p>（2）调用数组指定位置的元素</p>
<p>（3）获取数组长度</p>
<p>（4）遍历二维数组</p>
<p>（5）数组元素默认初始化</p>
<p>​    外层数组初始化为地址值</p>
<p>​    内存元素初始化与一维数组初始化情况相同</p>
<p>（6）二维数组内存解析</p>
<h4 id="4-数组算法"><a href="#4-数组算法" class="headerlink" title="4.数组算法"></a>4.数组算法</h4><p>（1）数组元素赋值</p>
<p>​    二维数组打印杨辉三角</p>
<p>（2）数组元素计算</p>
<ul>
<li>求最值</li>
<li>求和</li>
<li>求平均值</li>
</ul>
<p>（3）数组复制，反转，查找</p>
<ul>
<li>​    java的数组间可以直接赋值，相当于把原数组地址备份了。这两个数组地址值相同，都指向了堆空间唯一的数组实体，这样不能称作数组的复制</li>
<li>数组的赋值，备份数组应当申请出与原数组相同大小的空间后，一一赋值</li>
<li>数组反转，使正数n的数与倒数n的数交换</li>
<li>查找：线性查找，二分查找（必须有序）</li>
</ul>
<p>（4）数组排序</p>
<p>​    排序算法分类：</p>
<ul>
<li>内部排序：排序过程都在内存中完成</li>
<li>外部排序：数据量巨大，必须借助外部存储器完成排序</li>
</ul>
<h4 id="5-数组工具类"><a href="#5-数组工具类" class="headerlink" title="5.数组工具类"></a>5.数组工具类</h4><p>Arrays即操作数组的工具类，包含了用来操作数组的各种方法</p>
<ul>
<li>判断数组相等</li>
<li>输出数组</li>
<li>指定值填充到数组中</li>
<li>对数组进行排序</li>
<li>二分查找数组</li>
</ul>
<h4 id="6-数组常见异常"><a href="#6-数组常见异常" class="headerlink" title="6.数组常见异常"></a>6.数组常见异常</h4><ul>
<li>数组角标越界异常</li>
<li>空指针异常</li>
</ul>
<h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><p>Java面向对象学习的三条主线：</p>
<ul>
<li>Java类及类的成员：属性，方法，构造器，代码块，内部类</li>
<li>面向对象三大特征：封装性，继承性，多态性（抽象性）</li>
<li>关键字</li>
</ul>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><h4 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h4><p>面向过程：强调功能行为以函数为最小单位，考虑怎么做</p>
<p>面向对象：将功能封装到对象中，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</p>
<p>面向过程中为执行者，面向对象中为指挥者</p>
<h4 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2.类与对象"></a>2.类与对象</h4><p>（1）概念</p>
<ul>
<li>类是对一类事物的描述，是抽象的，概念上的定义</li>
<li>对象是事情存在的该类事物的个体，因而被称为实例(instance)</li>
</ul>
<p>（2）类的设计</p>
<p>​    设计类其实就是设计类的成员</p>
<p>​    类的基本成员：</p>
<ul>
<li>属性（field）：对应类中成语变量</li>
<li>行为（method）：对应类中的成员方法</li>
<li>除了上面两个常用的外，还有构造器，代码块，内部类</li>
</ul>
<p>（3）对象</p>
<ul>
<li>创建类的对象即类的实例化（new）</li>
<li>调用对象的属性，方法( 对象.属性 对象.方法 )</li>
<li>一个类的多个对象，每个对象都独立拥有一套类的属性。</li>
<li>将对象赋值给另一个对象，它们存有相同的对象地址值指向堆空间同一对象实体</li>
</ul>
<p>（4）对象内存解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944597.png" alt="image-20210418093314518"></p>
<ul>
<li>堆：存放对象实例</li>
<li>栈：指虚拟机栈，用于储存局部变量</li>
<li>方法区：用于存储已被虚拟机加载的类的信息，常量，静态变量（即编译器编译后的代码等数据）</li>
</ul>
<p>（5）成员变量与局部变量</p>
<ul>
<li><p>成员变量（属性）定义在类中</p>
</li>
<li><p>局部变量是声明在方法内，方法形参，代码块内，构造器形参，构造器内部的变量</p>
</li>
<li><p>成员变量（属性）可以在声明时使用权限修饰符指明其权限（封装性）</p>
</li>
<li><p>局部变量不可以使用权限修饰符</p>
</li>
<li><p>成员变量（属性）根据其类型都有默认初始化值</p>
</li>
<li><p>局部变量没有初始化值，所以在调用之前，一定要显式赋值</p>
</li>
<li><p>成员变量（属性）加载到堆空间（非static时）</p>
</li>
<li><p>局部变量加载到栈空间</p>
</li>
</ul>
<p>（6）对象数组（数组中存储对象的地址）</p>
<p>（7）匿名对象的使用</p>
<ul>
<li>创建的对象，没有显式赋给一个变量名，即为匿名对象</li>
<li>特征：匿名对象只能使用一次</li>
<li>使用：可以把一个对象当作一个对象方法的形参，从而达到对象的匿名</li>
</ul>
<p>​    </p>
<h4 id="3-类与方法"><a href="#3-类与方法" class="headerlink" title="3.类与方法"></a>3.类与方法</h4><p>（1）方法：描述类应该有的功能（java内部类中提供了很多方法）</p>
<p>（2）方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限修饰符 返回值类型 方法名(形参列表)&#123;方法体&#125;</span></span><br></pre></td></tr></table></figure>

<p>（3）权限修饰符</p>
<p>（4）返回值类型：return后返回指定的数据类型</p>
<p>（5）形参列表：方法可以申请多个形参</p>
<p>（6）方法的使用中，可以调用当前类的属性和方法，也可以实现递归调用</p>
<h4 id="4-方法进阶"><a href="#4-方法进阶" class="headerlink" title="4.方法进阶"></a>4.方法进阶</h4><p>（1）方法重载</p>
<ul>
<li>重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或参数类型不同即可</li>
<li>重载的特定：与返回值类型无关，只看参数列表</li>
<li>两同一不同：1.同一个类，相同方法名 2.参数列表个数不同，参数类型不同</li>
<li>可变个数形参：允许直接定义和多个实参相匹配的形参，使用格式：<code>数据类型... 变量名</code>，形参会以数组的形式传入</li>
<li>可变个数形参必须声明在末尾，而且只能声明一个 </li>
</ul>
<p>（2）方法参数的值的传递机制</p>
<p>​    形参：方法定义时，声明的小括号内的参数</p>
<p>​    实参：方法调用时，实际传递给形参的数据</p>
<p>​    值传递机制：</p>
<ul>
<li>参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值（实参和形参都在栈中，都是数据本身）</li>
<li>参数是引用数据类型，此时实参赋给形参的是变量所保存数据的地址值（实参和形参都在栈中，存储的是数据的地址，数据在堆中）</li>
</ul>
<p>（3）递归方法</p>
<p>递归方法：一个方法体内调用它自身</p>
<ul>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制</li>
<li>递归一定要向已知方向递归，否则会变成无穷递归，类似于死循环</li>
</ul>
<h4 id="5-封装与隐藏"><a href="#5-封装与隐藏" class="headerlink" title="5.封装与隐藏"></a>5.封装与隐藏</h4><p>（1）封装的引出</p>
<p>程序设计追求：“高内聚，低耦合”：</p>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉（相同方法高度集中在一个类中）</p>
<p>低耦合：仅对外暴露少量方法用于使用（类与类之间的依赖关系降低）</p>
<p>（2）封装设计思想</p>
<p>​    隐藏该隐藏的，暴露该暴露的</p>
<ul>
<li>对于类内某个属性使用private修改符，类外对该属性的操作，只能通过类内设置的方法（隐藏私有属性，暴露公共方法）</li>
<li>不对外暴露私有方法，单例模式</li>
</ul>
<p>（3）访问权限修饰符</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944324.png" alt="image-20210418131340405"></p>
<p>以上四种权限都可以用来修饰类的内部结构，属性，方法，构造器，内部类</p>
<p>修饰类只能使用：缺省，public</p>
<h4 id="6-构造器"><a href="#6-构造器" class="headerlink" title="6.构造器"></a>6.构造器</h4><p>构造器（constructor）又称构造方法</p>
<p>（1）构造器作用</p>
<ul>
<li>创建对象</li>
<li>初始化对象信息（属性方法）</li>
</ul>
<p>（2）构造器说明</p>
<ul>
<li>如果没有显示定义的构造器，系统默认提供一个空参构造器。一旦定义了构造器，系统不再提供空参构造器</li>
<li>定义构造器格式：权限修饰符 类名(形参列表){}，无返回值</li>
<li>一个类中定义多个构造器，彼此构成重载</li>
<li>一个类中，至少会有一个构造器</li>
</ul>
<h4 id="7-JavaBean"><a href="#7-JavaBean" class="headerlink" title="7.JavaBean"></a>7.JavaBean</h4><p>JavaBean是可重用组件：</p>
<ul>
<li><p>类是公共的</p>
</li>
<li><p>有个无参的公共构造器</p>
</li>
<li><p>有属性，且有对应的get，set方法</p>
</li>
</ul>
<h4 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h4><p>this表示当前对象，可以调用类的属性，方法，构造器</p>
<p>（1）this含义</p>
<ul>
<li>this在方法内部使用，即这个方法所属对象的引用</li>
<li>this在构造器内部使用，表示该构造器正在初始化的对象</li>
</ul>
<p>（2）this修饰属性和方法</p>
<ul>
<li>照类的方法中，可以使用this调用当前对象属性或方法</li>
<li>可以用this来区分局部变量和属性</li>
</ul>
<p>（3）this调用构造器</p>
<ul>
<li>在类的构造器中，可以显式使用<code>this(形参列表)</code>的方式，调用本类中指定的其他构造器</li>
<li>构造器不能调用自己</li>
</ul>
<h4 id="9-package与import的使用"><a href="#9-package与import的使用" class="headerlink" title="9.package与import的使用"></a>9.package与import的使用</h4><p>（1）package</p>
<ul>
<li>为了更好实现项目中类的管理，提供包的概念</li>
<li>使用packae声明类或接口所属的包，声明在源文件的首行</li>
<li>同一个包下，不能命名同名接口和类</li>
<li>JDK提供了包，其中包含常用的类和接口</li>
</ul>
<p>（2）MVC设计模式 </p>
<ul>
<li><p>模型层model：主要用于处理数据</p>
</li>
<li><p>控制层controller：处理业务逻辑</p>
</li>
<li><p>视图层view：显示数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944267.png" alt="image-20210418190748964"></p>
</li>
</ul>
<p>（3）import关键字</p>
<ul>
<li>在源文件中使用import可以导入指定包下的类，接口</li>
<li>声明在包声明和类声明之间</li>
<li>如果类和接口是在java.lang或本包下定义的，则可以省略import结构</li>
</ul>
<p>​    </p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><h4 id="1-继承性概念"><a href="#1-继承性概念" class="headerlink" title="1.继承性概念"></a>1.继承性概念</h4><p>（1）继承性的优点：</p>
<ul>
<li>减少代码冗余，提高代码复用性</li>
<li>便于功能扩展</li>
<li>是多态性的继承</li>
</ul>
<p>（2）继承性格式  class A extends B {}：</p>
<ul>
<li><p>A：子类，派生类</p>
</li>
<li><p>B：父类，基类</p>
</li>
<li><p>子类继承父类后，就可以获得父类中声明的结构，属性，方法</p>
</li>
<li><p>子类可以在父类的基础上声明自己的属性或方法，实现功能的拓展</p>
</li>
</ul>
<p>（3）继承规则</p>
<ul>
<li>子类继承父类后，仍然获得了父类中私有的属性和方法，但是由于封装性，子类不能直接调用父类的结构</li>
<li>子类对象“拥有”父类对象的私有属性，但无法直接操作，不属于“继承“</li>
<li>支持单继承和多继承：一个子类只要一个父类，一个父类可以派生多个子类</li>
<li>子父类是相对的概念</li>
<li>如果没有显式声明一个类的父类，则此类继承于java.lang.Object类</li>
</ul>
<h4 id="2-方法的重写"><a href="#2-方法的重写" class="headerlink" title="2.方法的重写"></a>2.方法的重写</h4><p>子类根据要求对父类中继承来的方法进行改造，子类方法覆盖父类方法这个过程称为方法的重写</p>
<p>（1）重写：子类继承父类后，可以对父类中同名同参数的方法，进行覆盖操作</p>
<p>（2）重载与重写的区别</p>
<p>（3）重写规则</p>
<ul>
<li><p>方法的声明：权限修饰符 返回值类型 方法名(形参列表){方法体}</p>
</li>
<li><p>子类重写的方法的方法名和形参列表要与父类被重写的方法相同</p>
</li>
<li><p>子类重写的方法的权限修饰符要不小于父类被重写的方法修饰符</p>
</li>
<li><p>子类不能重写父类中声明为private权限的方法</p>
</li>
<li><p>子类重写的方法返回值要与父类被重写的返回值相同</p>
</li>
</ul>
<h4 id="3-spuer"><a href="#3-spuer" class="headerlink" title="3.spuer"></a>3.spuer</h4><p>与super对应的是this，this代指本对象，super则代指本对象的父类</p>
<p>super的使用：</p>
<ul>
<li>super理解为：父类的</li>
<li>super可以调用：属性，方法，构造器</li>
<li>在子类的方法或构造器中，可以通过super调用父类中声明的属性或方法</li>
<li>super调用构造器，必须在子类构造器首行进行声明</li>
<li>在类的构造器中，this和super只能二选一（默认情况下调用的是父类中的空参构造器，即super()）</li>
</ul>
<h4 id="4-子类对象实例化过程"><a href="#4-子类对象实例化过程" class="headerlink" title="4.子类对象实例化过程"></a>4.子类对象实例化过程</h4><ul>
<li>创建子类对象，在堆空间，就会加载所有父类中声明的属性</li>
<li>通过子类构造器构造子类对象时，就会直接或间接调用了其父类的构造器，直至调用到java.lang.Object的空参构造器</li>
<li>虽然创建子类对象时调用了父类的构造器，但是自始至终就创建了一个对象，即new出来的子类实例</li>
</ul>
<h4 id="5-多态性"><a href="#5-多态性" class="headerlink" title="5.多态性"></a>5.多态性</h4><p>对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类引用），可以直接应用到抽象类和接口上。方便传参时，可根据new的对象的不同传入不同的对象</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作</p>
<p>（1）多态的使用</p>
<ul>
<li>有了对象多太性以后，我们在编译期，只能调用父类中的声明的方法，但在运行期，我们实际执行了子类重写父类的方法</li>
<li>编译看左（父类），运行看右（子类）</li>
<li>多态性使用前提：类的继承关系，方法重写</li>
<li>多态性主要用于方法，不适用于属性</li>
</ul>
<p>（2）虚拟方法的调用</p>
<ul>
<li>​    在多态的情况下，子类定义了父类同名同参数的方法，此时父类的方法被称为虚拟方法。</li>
<li>父类根据赋给它的不同子类对象，动态调用属于子类的该方法</li>
<li>这样的方法时无法在编译期确定的，只有到方法调用那一刻，解释运行器才会确定所要调用的具体方法（”动态绑定“）</li>
</ul>
<h4 id="6-向下转型"><a href="#6-向下转型" class="headerlink" title="6.向下转型"></a>6.向下转型</h4><p>​    在多态中可知，虽然内存加载了子类的方法，但是由于类型是父类，所以编译时无法调用子类的属性和方法，只能调用父类中声明的属性和方法</p>
<p>为了调用子类特有的属性和方法，我们需要用到强制类型转换符，向下转型</p>
<p>（1）instanceof操作符</p>
<ul>
<li>检验对象是否为某类的对象，返回值为Boolean</li>
<li>为了避免在向下转型时出现ClassCastException的异常，在向下转型前进行instanceof判断，为true才能进行向下转型  </li>
</ul>
<p>（2）向下转型规则</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944489.png" alt="image-20210419073037475"></p>
<h3 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h3><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944251.png" alt="image-20210419073502990"></p>
<h4 id="1-和equals的区别"><a href="#1-和equals的区别" class="headerlink" title="1.==和equals的区别"></a>1.==和equals的区别</h4><p>（1）==运算符</p>
<ul>
<li>可以使用在基本数据类型和引用数据类型中</li>
<li>如果比较的是基本数据类型，比较两个变量保存的数据是否相等（不一定类型相同）</li>
<li>如果比较的是引用数据类型，比较两个对象的地址值是否相同（两个引用是否指向同一个对象实体）</li>
</ul>
<p>（2）equals()方法</p>
<ul>
<li>是一个方法而非运算符</li>
<li>只适用于引用数据类型</li>
<li>Object类中定义的equals()和==的作用是一样的，即比较比较两个对象的地址值是否相同</li>
<li>但是String，Date，File等类重写了Object类中的equals()方法，重写以后就是比较两个对象的“实体内容”是否相同了</li>
</ul>
<h4 id="2-toString-方法"><a href="#2-toString-方法" class="headerlink" title="2.toString()方法"></a>2.toString()方法</h4><ul>
<li>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</li>
<li>String，Date，File等类重写了Object类中的toString()方法。使得在调用对象的toString时，返回“实体内容”信息</li>
</ul>
<h3 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h3><h4 id="1-包装类介绍"><a href="#1-包装类介绍" class="headerlink" title="1.包装类介绍"></a>1.包装类介绍</h4><p>针对八种基本数据类型有相应的引用类型——包装类（封装类）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040944665.png" alt="image-20210419081234938"></p>
<p>基本数据类型，包装类，String三者的相互转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945274.png" alt="image-20210419082428442"></p>
<h4 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2.数据类型转换"></a>2.数据类型转换</h4><ul>
<li>基本数据类型 &gt; 包装类：调用包装类的构造器</li>
<li>包装类 &gt; 基本数据类型：调用包装类的xxxValue()</li>
<li>基本数据类型，包装类 &gt; String类型：1.使用字符串的连接运算 2.调用String的ValueOf()方法</li>
<li>String类型 &gt; 基本数据类型，包装类 ：调用包装类的parseXxx(String s)方法</li>
<li>在JDK5.0后，基本数据类型和包装类已经可以实现自动拆箱与自动装箱</li>
</ul>
<h3 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h3><p>static让类的实例共享一个属性或方法，无论新建多少个对象都会有这个静态的属性或方法</p>
<h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h4><ul>
<li>static:静态的</li>
<li>static可以用来修饰：属性，方法，代码块，内部类</li>
</ul>
<h4 id="2-修饰属性"><a href="#2-修饰属性" class="headerlink" title="2.修饰属性"></a>2.修饰属性</h4><ul>
<li><p>实例变量：每个对象都独立拥有一套类中的非静态属性，当修改其中一个对象的非静态属性时，不会导致其他对象相同属性值修改</p>
</li>
<li><p>静态变量：多个对象共享同一个静态变量，，当修改其中一个对象的静态属性时，其他对象的静态变量也随之改变</p>
</li>
<li><p>静态变量随着类的加载而加载，静态变量的加载要早于对象的创建</p>
</li>
<li><p>因为类只会加载一次，所以静态变量在内存中只会存在一份（方法区的静态域中）</p>
</li>
<li><p>实例变量与类变量的内存解析</p>
</li>
</ul>
<h4 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><ul>
<li>静态方法，只能调用静态的方法或属性；非静态方法既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li>
<li>静态方法随着类的加载而加载</li>
</ul>
<h4 id="4-静态的使用"><a href="#4-静态的使用" class="headerlink" title="4.静态的使用"></a>4.静态的使用</h4><ul>
<li>确定一个属性用静态：属性可以被多个对象共享，不会随对象不同而不同</li>
<li>确定一个方法用静态：1.操作静态属性的方法用静态 2.工具类的方法，习惯上声明为静态</li>
<li>单例设计模式：对某个类只能存在一个对象实例（使用静态让其可以永久驻留内存），减少了系统性能开销</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="1-代码块概念"><a href="#1-代码块概念" class="headerlink" title="1.代码块概念"></a>1.代码块概念</h4><ul>
<li>代码块的作用：用来初始化类，对象</li>
<li>代码块只能用static修饰</li>
</ul>
<h4 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2.静态代码块"></a>2.静态代码块</h4><ul>
<li>内部可以有输出语句</li>
<li>随着类的加载而执行，而且只执行一次</li>
<li>作用：初始化类的信息</li>
<li>一个类可以定义多个静态代码块，而且按声明先后顺序执行</li>
<li>静态代码块的执行要优先于非静态  </li>
<li>静态代码块内只能调用静态的属性，静态的方法，不能调用非静态结构</li>
</ul>
<h4 id="3-非静态代码块"><a href="#3-非静态代码块" class="headerlink" title="3.非静态代码块"></a>3.非静态代码块</h4><ul>
<li>内部可以有输出语句 </li>
<li>随着对象的创建而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象属性等进行初始化</li>
<li>一个类可以定义多个非静态代码块，而且按声明先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性，静态的方法或非静态的属性，非静态的方法</li>
</ul>
<h4 id="2-属性赋值总结"><a href="#2-属性赋值总结" class="headerlink" title="2.属性赋值总结"></a>2.属性赋值总结</h4><ul>
<li>默认初始化</li>
<li>显式初始化</li>
<li>在代码块中赋值</li>
<li>构造器初始化</li>
<li>通过<code>对象.属性</code>的方式赋值</li>
</ul>
<p>按照由上到下的顺序先后执行</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="1-final概念"><a href="#1-final概念" class="headerlink" title="1.final概念"></a>1.final概念</h4><ul>
<li><p>final意为最终的，可以禁止对修饰对象进一步的更改修饰</p>
</li>
<li><p>final可以用来修饰类，方法，变量</p>
</li>
</ul>
<h4 id="2-final修饰"><a href="#2-final修饰" class="headerlink" title="2.final修饰"></a>2.final修饰</h4><ul>
<li>被修饰的类不能被其他类所继承</li>
<li>被修饰的方法不能被重写</li>
<li>被修饰的变量被称为常量</li>
<li>被修饰的变量为属性：其可以被赋值的位置有：显式初始化，代码块中初始化，构造器中初始化</li>
<li>被修饰的变量为局部变量：尤其是修饰形参时，表名此时形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值</li>
<li>static final 修饰属性：全局常量</li>
</ul>
<h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><p>父类在设计中要求更一般，更通用。但一个父类设计得非常抽象时，以至于它没有任何具体实例，这样得类称为抽象类</p>
<h4 id="1-abstract的使用"><a href="#1-abstract的使用" class="headerlink" title="1.abstract的使用"></a>1.abstract的使用</h4><ul>
<li>abstract意为抽象的</li>
<li>abstract可以修饰的结构：类，方法</li>
<li>abstract不能修饰私有方法，静态方法，final的方法，final的类</li>
</ul>
<h4 id="2-抽象类特点"><a href="#2-抽象类特点" class="headerlink" title="2.抽象类特点"></a>2.抽象类特点</h4><ul>
<li>abstract修饰的类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作</li>
<li>抽象类的匿名子类</li>
</ul>
<h4 id="3-抽象方法特点"><a href="#3-抽象方法特点" class="headerlink" title="3.抽象方法特点"></a>3.抽象方法特点</h4><ul>
<li>抽象方法只有方法声明，没有方法体</li>
<li>包含抽象方法的类，一定是一个抽象类</li>
<li>只有子类重写了父类所有的抽象方法后，此子类才能实例化（否则子类也是个抽象类）</li>
</ul>
<h4 id="4-抽象类应用"><a href="#4-抽象类应用" class="headerlink" title="4.抽象类应用"></a>4.抽象类应用</h4><ul>
<li>模板方法设计模式：抽象类作为多个子类的通用模板，子类在抽象类基础上进行拓展，改造</li>
<li>模板方法设计可以让固定通用的步骤在父类中写好，然后将易变的部分抽象出来，供不同的子类实现</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="1-接口概述"><a href="#1-接口概述" class="headerlink" title="1.接口概述"></a>1.接口概述</h4><ul>
<li>有时必须从几个类中派生出一个子类，让子类继承它们所以的属性和方法，但是Java是不支持多重继承的（继承中子类只能有一个父类），这时候就需要用到接口</li>
<li>有时必须从几个类中抽取一些共同的行为特征。，而它们之间不存在继承关系，这时候也要用到接口</li>
<li>继承是一个“是不是”的关系，而接口则是“能不能”的关系（体现了如果你是/要……则必须能……）</li>
<li>接口的本质是契约，标准，规范</li>
</ul>
<h4 id="2-接口的使用"><a href="#2-接口的使用" class="headerlink" title="2.接口的使用"></a>2.接口的使用</h4><ul>
<li>类和接口时并列的两个结构</li>
<li>接口使用interface来定义</li>
<li>接口中可以定义全局变量，抽象方法，静态方法，默认方法</li>
<li>接口中不能定义构造器，这意味着接口不能实例化</li>
<li>接口中定义的静态方法只能通过接口调用</li>
<li>通过实现类的对象，可以调用接口中的默认方法（而不是像抽象方法那样要先重写抽象类才能实例化，实现类也可以重写接口的默认方法）</li>
<li>接口可以通过让类去实现（implements）的方式来使用，如果实现类覆盖了接口所有抽象方法，则实现类可以实例化，如果没有则仍为一个抽象类</li>
<li>Java可以实现多个接口，弥补了Java单继承性的局限性，格式：<code>class AA extends BB implements CC,DD,EE</code></li>
<li>接口与接口之间也可以继承，而且是多继承</li>
</ul>
<h4 id="3-接口的优点"><a href="#3-接口的优点" class="headerlink" title="3.接口的优点"></a>3.接口的优点</h4><ul>
<li>接口的具体使用，体现多态性  </li>
<li>接口实际上可以看作是一种规范，实现其接口的类必须按步骤（规范）实现相关的方法才能运行</li>
<li>接口的主要用途就是被实现类实现</li>
</ul>
<h4 id="4-接口应用"><a href="#4-接口应用" class="headerlink" title="4.接口应用"></a>4.接口应用</h4><p>（1）代理模式：</p>
<ul>
<li><p>为其他对象提供一种代理以控制对这个对象的访问</p>
</li>
<li><p>安全代理：可以屏蔽真实对象的直接访问</p>
</li>
<li><p>远程代理：通过代理类处理远程方法调用</p>
</li>
<li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实的对象</p>
</li>
</ul>
<p>（2）工厂设计模式</p>
<ul>
<li>实现创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</li>
<li>简单工厂模式：用来生产同一等级结构中任意产品（对于增加新产品，需要修改已有代码）</li>
<li>工厂方法模式：用来生成同一等级结构中的固定产品（支持增加任意产品）</li>
<li>抽象工厂模式：用来生产不同产品族的全部产品（对于增加新的产品，无能为力，支持增加产品族）</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在A类中定义了另一个类B，则A为外部类，B为内部类</p>
<p>内部类有两种：成员内部类和局部内部类（此类在开发中很少被使用）</p>
<h4 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h4><p>（1）作为外部类的成员</p>
<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被4种不同的权限修饰</li>
</ul>
<p>（2）作为一个类</p>
<ul>
<li>可以在类内定义属性，方法，构造器</li>
<li>可以被final修饰，表示此类不能被继承</li>
<li>可以被abstract修饰</li>
</ul>
<p>（3）调用</p>
<ul>
<li>实例化成员内部类的对象：（通过点运算符：<code>Person.Dog dog = new Person.Dog()</code> ）</li>
<li>在成员内部类种区分调用外部类的结构（属性方法）：通过this</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><p>异常：程序执行中发生的不正常情况被称为“异常”（开发过程中的语法错误和逻辑错误不是异常）</p>
<h4 id="1-异常分类"><a href="#1-异常分类" class="headerlink" title="1.异常分类"></a>1.异常分类</h4><p>（1）Error型：Java虚拟机无法解决的严重问题，一般不编写针对性代码进行处理</p>
<ul>
<li>JVM系统内部错误</li>
<li>资源耗尽</li>
</ul>
<p>（2）Exception型：其他因编程原因或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
<p>Exception分类：编译异常，运行异常</p>
<h4 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h4><ul>
<li>遇到错误终止程序运行</li>
<li>编写程序时，错误检测，错误消息的提示，以及错误的处理</li>
<li>捕获异常最理想的是在编译期间，但是有的错误只有在运行时才能发生（Exception分类：编译异常，运行异常）</li>
<li>异常处理中，要在可能出现错误的地方加上检测代码</li>
<li>过多的if-else封装会导致代码臃肿，可读性差，因此采用异常处理机制</li>
<li>在开发中运行异常比较常见，所以我们往往针对编译时的异常编写异常捕捉代码</li>
<li>手动生成一个异常对象，并用throw方法抛出</li>
</ul>
<h4 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h4><p>（1）try-catch-finally</p>
<ul>
<li>try{可能出现异常的代码}catch{异常类型 变量名}finally{一定会执行的代码}</li>
<li>finally是可选的</li>
<li>try中的代码执行过程中一旦出现异常就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常处理，一旦处理完成就跳出当前try-catch结构，有finally则进入finally中</li>
<li>常用的异常对象处理方式（放在catch中）：1.String getMessage()：打印出异常信息   2.printStackTrace()：打印整个错误对象信息（比较常用）</li>
<li>在try中声明的变量，再出了try结构后，就不能再被调用</li>
</ul>
<p>try-catch相当于将一个编译时可能出现的异常，延迟到运行时出现</p>
<p>（2）finally解析</p>
<ul>
<li>finally声明的是一定会被执行的代码，无论有没有捕捉到异常都会执行</li>
<li>先数据库连接，输入输出流，网络编程Socket等资源，JVM是不能自动的回收，所以我们需要手动的进行资源的释放。此时的资源释放就要声明到finally中</li>
</ul>
<p>（3）throws + 异常处理</p>
<ul>
<li>throws + 异常处理写在方法声明处，指明此方法执行时，可能会抛出的异常类型，一旦当方法体执行时，出现异常，仍然会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出</li>
<li>try-catch-finally是真正的将异常处理掉了，throws的方式只是将异常抛出</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>（1）程序与进程</p>
<ul>
<li>程序是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段静态代码，静态对象</li>
<li>进程是程序的一次执行过程，是一个动态的过程：有自身的产生，存在和消亡的过程</li>
<li>程序是静态的，进程是动态的。进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<p>（2）线程与进程</p>
<ul>
<li>进程可以细化为线程，是一个程序内部的一条执行路径</li>
<li>一个Java应用程序至少有三个线程：main()主线程，gc()垃圾回收线程, 异常处理线程</li>
<li>线程作为调度和执行的单位，每个线程都拥有独立的运行栈和程序计数器，线程切换的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间（从同一堆中分配对象，可以访问相同变量和对象），这使线程间通信更加简洁，高效，但是也带来了安全隐患</li>
</ul>
<p>（3）并发与并行</p>
<ul>
<li>并行：多个CPU同时执行多个任务</li>
<li>并发：一个CPU同时执行多个任务</li>
</ul>
<h4 id="2-多线程的应用"><a href="#2-多线程的应用" class="headerlink" title="2.多线程的应用"></a>2.多线程的应用</h4><p>（1）多线程的优点</p>
<ul>
<li>提高应用程序的响应，对图形化界面更有意义</li>
<li>提高计算机相同CPU的利用率</li>
<li>改善程序结构，将长而复杂的进程分为多个线程独立运行，利于理解和修改</li>
</ul>
<p>（2）多线程使用场景</p>
<ul>
<li>程序需要同时执行多个任务</li>
<li>程序需要实现一些需要等待的任务（用户输入，文件读写操作，网络操作，搜索）</li>
<li>需要一些后台运行的程序</li>
</ul>
<h4 id="3-线程的创建与使用"><a href="#3-线程的创建与使用" class="headerlink" title="3.线程的创建与使用"></a>3.线程的创建与使用</h4><p>（1）多线程的创建（继承Thread类）</p>
<ul>
<li><p>创建一个继承于Tread类的子类</p>
</li>
<li><p>重写Thread类的run()：声明此线程执行的操作</p>
</li>
<li><p>创建Thread类的子类对象</p>
</li>
<li><p>通过此对象调用start()：启动当前线程；调用当前线程的run() </p>
</li>
<li><p>不能直接调用run()的方式启动线程</p>
</li>
</ul>
<h4 id="4-线程常用方法"><a href="#4-线程常用方法" class="headerlink" title="4.线程常用方法"></a>4.线程常用方法</h4><ul>
<li><p>start()：启动线程，调用当前线程的run()</p>
</li>
<li><p>run()：线程被调度时执行的操作</p>
<p>getName()：返回线程名称</p>
</li>
<li><p>setName(String name) ：设置线程名称</p>
</li>
<li><p>yield()：释放当前CPU的执行权</p>
</li>
<li><p>join()：在线程a中调用线程b的jion()，线程a进入阻塞状态直到线程b执行完</p>
</li>
<li><p>sleep(long millitime)：让当前线程睡眠，当前线程是阻塞状态</p>
</li>
<li><p>isAlive()：判断当前线程是否存活</p>
</li>
<li><p>stactic Thread currentThread()：返回当前线程</p>
</li>
</ul>
<h4 id="5-线程优先级设置"><a href="#5-线程优先级设置" class="headerlink" title="5.线程优先级设置"></a>5.线程优先级设置</h4><p>（1）线程的调度</p>
<ul>
<li>调度策略：抢占式，高优先级的线程抢占CPU</li>
<li>调度方法：对同优先级线程组成先进先出队列，使用时间片策略; 对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p>（2）线程优先级</p>
<ul>
<li>线程优先级等级：MAX_PRIORITY(10)，MIN_PRIORITY(1)，NORM_PRIORITY(5)</li>
<li>涉及的方法：getPriority()：返回线程优先级；setPriority(int newPriority)：改变线程优先级</li>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是高优先级线程后才被调用</li>
</ul>
<h4 id="6-创建多线程方式"><a href="#6-创建多线程方式" class="headerlink" title="6.创建多线程方式"></a>6.创建多线程方式</h4><p>（1）继承Thread方式</p>
<ul>
<li>多线程时可用静态变量，让每个线程处理的数据都是在同一个地方，而不是又重新创建一个数据对象</li>
</ul>
<p>（2）创建多线程的方式二：实现Runnable接口</p>
<ul>
<li>创建一个实现Runnable接口的类（该实现类定义的变量也是线程公用的）</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ul>
<p>（3）创建多线程的新方法：实现Callable接口</p>
<ul>
<li>call()可以有返回值</li>
<li>call()可以抛出异常，被外面的操作捕获，获得异常的信息</li>
<li>Callable支持泛型</li>
</ul>
<p>（4）创建多线程的新方法：使用线程池</p>
<ul>
<li>经常创建销毁，使用量特别大的资源，对性能影响很大</li>
<li>提前创建多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁，实现重复利用</li>
<li>好处：提高了响应速度; 降低资源消耗; 便于线程管理;</li>
</ul>
<p>  （5）比较两种创建多线程的方式</p>
<ul>
<li>开发中优先现在实现Runnable接口的方式</li>
<li>原因：1.实现方式没有类的单继承性的局限性  2.实现的方式更适合来处理多个线程有共享数据的情况</li>
<li>联系：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中</li>
</ul>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><h4 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1.线程的生命周期"></a>1.线程的生命周期</h4><p>（1）线程状态</p>
<ul>
<li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它具备运行的条件，只是没有分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能</li>
<li>阻塞：线程被人为挂起或执行输入输出操作时，让出CPU并临时中止执行的执行进入阻塞状态</li>
<li>死亡：线程完成了全部工作或线程被提前强制性中止或出现异常导致结束</li>
</ul>
<p>（2）线程状态转换</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945714.png" alt="image-20210423073620432"></p>
<h4 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2.线程同步"></a>2.线程同步</h4><p>（1）多线程存在问题</p>
<ul>
<li><p>多个线程执行的不确定性引起执行结构的不稳定</p>
</li>
<li><p>多个线程对数据的共享，会造成操作的不完整性，会破坏数据</p>
</li>
<li><p>线程的安全问题：（数据重复，数据错误）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945201.png" alt="image-20210423074125257"></p>
</li>
<li><p>线程安全问题出现的原因：当某个线程在操作数据时，尚未完成操作，其他线程就参与进来，也操作了车票</p>
</li>
</ul>
<p>（2）线程安全问题的解决</p>
<ul>
<li><p>当一个线程在操作共享数据时，其他线程不能参与进来，直到该线程完成操作（即时出现了阻塞也不能改变）</p>
</li>
<li><p>通过同步机制解决线程安全问题：1.同步代码块; 2.同步方法；</p>
</li>
<li><p>同步代码块：synchroized(同步监视器){需要同步的代码}，操作共享数据的代码，即为需要同步的代码</p>
</li>
<li><p>同步监视器就是我们所熟悉的锁（任何一个类的对象都可以充当锁），多个线程必须共用一把锁</p>
</li>
<li><p>同步方法：在方法中使用synchroized修饰方法，然后再调用</p>
</li>
<li><p>同步方法：1.同步方法仍涉及到同步监视器，只是不需要显式声明; 2.非静态的同步方法监视器是this; 3.静态的同步方法监视器是当前类本身 </p>
</li>
<li><p>操作同步代码时实质上是单线程过程，效率低（一个线程操作，其他线程等待）</p>
</li>
</ul>
<h4 id="3-线程死锁问题"><a href="#3-线程死锁问题" class="headerlink" title="3.线程死锁问题"></a>3.线程死锁问题</h4><p>（1）死锁原理</p>
<ul>
<li>不同线程分别占用了对方需要的同步资源，都在等待对方放弃自己需要的同步资源，就会形成线程的死锁</li>
<li>出现死锁后，不会出现异常或错误提示，只是所有线程都处在阻塞状态，无法继续</li>
</ul>
<p>（2）解决方法</p>
<ul>
<li>专门的算法，原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
<h4 id="4-Lock-锁"><a href="#4-Lock-锁" class="headerlink" title="4.Lock(锁)"></a>4.Lock(锁)</h4><p>Java提供了更加强大的线程同步机制——通过显式定义同步锁对象来实现同步，其同样可以解决线程安全问题</p>
<p>（1）Lock与synchroized的异同</p>
<ul>
<li>同：两者都可以解决线程问题</li>
<li>异：synchroized执行同步代码后，自动释放同步监视器; Lock需要手动启动同步（lock()），手动结束同步（unlock()）</li>
<li>Lock只有代码块锁，synchroized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并具有更好的扩展性</li>
</ul>
<p>（2）使用顺序</p>
<p>Lock -&gt; 同步代码块-&gt; 同步方法</p>
<h4 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5.线程通信"></a>5.线程通信</h4><p>（1）常用方法</p>
<ul>
<li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li>
<li>notify()：一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的线程</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程</li>
</ul>
<p>以上三个方法必须用在同步代码块或同步方法中</p>
<p>（2）sleep()和wait()的异同</p>
<ul>
<li>同：一旦执行方法，都可以使得当前得线程进入阻塞状态</li>
<li>异：1.声明位置不同   2.调用要求不同 3.是否释放同步监视器</li>
</ul>
<h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="1-String概述"><a href="#1-String概述" class="headerlink" title="1.String概述"></a>1.String概述</h4><ul>
<li>String类代表字符串</li>
<li>Stirng是一个final类（ 不可被继承），代表不可变的字符串序列</li>
<li>字符串是常量，值在创建后不能更改</li>
<li>String对象的字符内容是存储在一个字符数组value[]中的</li>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时字符串声明在字符串常量池中（方法区）</li>
<li>字符串常量池不会存储相同内容的字符串，故栈中不同的局部变量如果赋相同字面量，实际指向方法区同一位置（地址相同）</li>
</ul>
<h4 id="2-String实现接口"><a href="#2-String实现接口" class="headerlink" title="2.String实现接口"></a>2.String实现接口</h4><ul>
<li>Serializable接口：表示字符串支持序列化</li>
<li>Comparable接口：表示字符串可以比较大小</li>
</ul>
<h4 id="3-不可变性体现"><a href="#3-不可变性体现" class="headerlink" title="3.不可变性体现"></a>3.不可变性体现</h4><ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>对现有的字符串进行连接操作、修改操作时，也需要重新指定内存区域赋值</li>
</ul>
<h4 id="4-String实例化"><a href="#4-String实例化" class="headerlink" title="4.String实例化"></a>4.String实例化</h4><p>（1）String实例化方式：</p>
<ul>
<li>通过字面量定义（数据存储在在方法区字符串常量池中，字符串作为常量，各变量共享一个数据空间）：<code>String s1 = &quot;2333&quot;</code></li>
<li>通过new  + 构造器（字符串数据仍然存储在常量池中，但是字符串的引用值存储在堆中，每创建一个字符串都会在堆中开辟新的空间存储字符串的引用值）：<code>String s3  = new String(&quot;javaEE&quot;)</code></li>
</ul>
<p>（2）String s3  = new String(“test”)对象个数</p>
<ul>
<li>两个对象：一个是堆空间中的new结构，另一个char[]对应变量池中的数据</li>
</ul>
<p>（3）字符串的拼接</p>
<ul>
<li><p>常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的变量</p>
</li>
<li><p>只要拼接的两个对象中其中一个为变量，结果位于堆中</p>
</li>
<li><p>拼接结果调用intern方法，返回值就在常量中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945850.png" alt="image-20210423113251323"></p>
</li>
</ul>
<h4 id="5-String常用方法"><a href="#5-String常用方法" class="headerlink" title="5.String常用方法"></a>5.String常用方法</h4><ul>
<li>length()：返回字符串长度</li>
<li>charAt()：返回某索引处的字符</li>
<li>isEmpty()：判断是否为空字符串</li>
<li>toLowerCase()：转换为小写</li>
<li>toUpperCase()：转换为大写</li>
<li>trim()：返回字符串副本，忽略空白处</li>
<li>equals()：比较字符串内容是否相同</li>
<li>concat()：将指定字符串连接到此字符串结尾</li>
<li>compareTo：比较两个字符串大小</li>
<li>substring()：截取出新的字符串</li>
<li>endsWith：测试字符串是否以指定的后缀结束</li>
<li>startsWith：测试此字符串是否以指定的前缀开始</li>
<li>contains：字符串是否包含指定char值序列</li>
<li>indexOf：返回指定子字符串第一次出现处的索引</li>
<li>rplace(): 替换掉字符串中指定的子字符串</li>
<li>replaceAll()：替换掉字符串所匹配正则表达式的子字符串</li>
<li>matches()：判断字符串是否匹配给定的正则表达式</li>
<li>split()：根据给定的正则表达式的匹配拆分此字符串</li>
</ul>
<h4 id="6-String数据类型转换"><a href="#6-String数据类型转换" class="headerlink" title="6.String数据类型转换"></a>6.String数据类型转换</h4><p>（1）String与基本数据类型，包装类的转换</p>
<ul>
<li>String –&gt; 基本数据类型，包装类：调用包装类的静态方法：parseXxx(str)</li>
<li>基本数据类型，包装类 –&gt; String：调用String重载的valueOf(xxx)</li>
</ul>
<p>（2）String与char[]的转换</p>
<ul>
<li>String –&gt; char[]：调用String的toCharArray()</li>
<li>char[] –&gt; String：调用String的构造器</li>
</ul>
<h4 id="7-String，StringBuffer，StringBuilder"><a href="#7-String，StringBuffer，StringBuilder" class="headerlink" title="7.String，StringBuffer，StringBuilder"></a>7.String，StringBuffer，StringBuilder</h4><p>（1）比较</p>
<ul>
<li>String:不可变的字符序列，底层使用char[]存储</li>
<li>StringBuffer：可变的字符序列，线程安全，效率低，底层使用char[]存储</li>
<li>StringBuffer：可变的字符序列，线程不安全，效率高，底层使用char[]存储</li>
<li>执行效率：StringBuilder &gt; StringBuffer &gt; String，开发中推荐使用StringBuffer</li>
</ul>
<p>（2）StringBuffer常用方法</p>
<ul>
<li>append()：提供很多append()方法，用于进行字符串拼接</li>
<li>delete()：删除指定位置的内容</li>
<li>replace()：替换指定索引位置的内容</li>
<li>insert()：在指定位置插入xxx</li>
<li>reverse()：把当前字符序列逆转</li>
</ul>
<h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3><p>Java中的对象，正常情况下只能进行比较：==  或 != ，不能使用 &gt; 或 &lt; 的。但是在开发场景中我们需要对多个对象进行排序，就要用到两个接口：Comparable 或  Comparator</p>
<h4 id="1-Comparable接口"><a href="#1-Comparable接口" class="headerlink" title="1.Comparable接口"></a>1.Comparable接口</h4><p>（1）Comparable接口使用</p>
<ul>
<li>像String，包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出比较两个对象大小的方式</li>
<li>可以重写compareTo(obj)的规则</li>
</ul>
<p>（2）自定义类实现Comparable自然排序</p>
<ul>
<li>对于自定义类，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在其中指明如何排序</li>
<li>可以重写compareTo(obj)的规则：<ol>
<li>​    如果当前对象大于obj,返回正整数</li>
<li>​    如果当前对象小于obj,返回负整数</li>
<li>​    如果当前对象大于obj,返回零</li>
</ol>
</li>
</ul>
<h4 id="2-Comparator接口"><a href="#2-Comparator接口" class="headerlink" title="2.Comparator接口"></a>2.Comparator接口</h4><ul>
<li>重写compare(Object o1，Object o2)方法，比较o1和o2大小<ol>
<li>​    方法返回正整数，则表示o1大于o2</li>
<li>​    返回0，表示相等</li>
<li>​    返回负整数，表示o1小于o2</li>
</ol>
</li>
<li>Comparable接口的实现类的对象在任何位置都可以比较大小</li>
<li>Comparator接口属于临时性的比较</li>
</ul>
<h3 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h3><h4 id="1-时间类"><a href="#1-时间类" class="headerlink" title="1.时间类"></a>1.时间类</h4><h4 id="2-System类"><a href="#2-System类" class="headerlink" title="2.System类"></a>2.System类</h4><h4 id="3-Math类"><a href="#3-Math类" class="headerlink" title="3.Math类"></a>3.Math类</h4><h4 id="4-BigInteger和BigDecimal"><a href="#4-BigInteger和BigDecimal" class="headerlink" title="4.BigInteger和BigDecimal"></a>4.BigInteger和BigDecimal</h4><h2 id="枚举类与注解"><a href="#枚举类与注解" class="headerlink" title="枚举类与注解"></a>枚举类与注解</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><h4 id="1-枚举类的使用"><a href="#1-枚举类的使用" class="headerlink" title="1.枚举类的使用"></a>1.枚举类的使用</h4><ul>
<li>类的对象只能是有限个，确定的，我们称此类为枚举类</li>
<li>当需要定义一组常量时，强烈建议使用枚举类</li>
<li>如果枚举类只有一个对象，则可以作为单例模式实现</li>
</ul>
<h4 id="2-枚举类的定义"><a href="#2-枚举类的定义" class="headerlink" title="2.枚举类的定义"></a>2.枚举类的定义</h4><ul>
<li><p>方式一：jdk5之前，自定义枚举类</p>
<ol>
<li>声明对象属性（private final修饰）</li>
<li>私有化类的构造器</li>
<li>提供当前多个枚举类的多个对象</li>
<li>其他诉求：获得枚举类对象的属性，提供toString()</li>
</ol>
</li>
</ul>
<ul>
<li><p>方式二：jdk5，可以使用enum关键字定义枚举类</p>
<ol>
<li><p>创建当前枚举类的对象，多个对象用“,”隔开，末尾对象”;”结束</p>
</li>
<li><p>声明对象属性（private final修饰）</p>
</li>
<li><p>提供当前多个枚举类的多个对象</p>
</li>
<li><p>其他诉求：获得枚举类对象的属性</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-Enum类中常用方法"><a href="#3-Enum类中常用方法" class="headerlink" title="3.Enum类中常用方法"></a>3.Enum类中常用方法</h4><ul>
<li><p>values：返回枚举类型的对象数组</p>
</li>
<li><p>valueOf(String str)：可以把一个字符串转为对应枚举类对象</p>
</li>
<li><p>toString()：返回当前枚举类对象常量名称</p>
</li>
</ul>
<h4 id="4-枚举类实现接口"><a href="#4-枚举类实现接口" class="headerlink" title="4.枚举类实现接口"></a>4.枚举类实现接口</h4><ul>
<li>实现接口，在enum类中实现抽象方法</li>
<li>让枚举类的对象分别实现接口中的抽象方法</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="1-注解说明"><a href="#1-注解说明" class="headerlink" title="1.注解说明"></a>1.注解说明</h4><ul>
<li>注解是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行响应操作。</li>
<li>利用注解，我们可以在不改变原有逻辑的情况下，在源文件嵌入一些补充信息。框架 = 注解 + 反射 + 设计模式</li>
</ul>
<h4 id="2-注解示例"><a href="#2-注解示例" class="headerlink" title="2.注解示例"></a>2.注解示例</h4><ul>
<li>生成文档的相关注解</li>
<li>在编译时进行格式检查</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
<li>spring框架中关于“事务”的管理</li>
<li>Junit单元测试中也有大量注解的使用</li>
</ul>
<h4 id="3-JDK内置基本注解"><a href="#3-JDK内置基本注解" class="headerlink" title="3.JDK内置基本注解"></a>3.JDK内置基本注解</h4><ul>
<li>@Override：限定重写父类方法，在编译前校验该方法是否是重写父类的</li>
<li>@Deprecated：用于表示所修饰的元素（已过时）。通常是因为所修饰的结构危险或者存在更好的选择</li>
<li>@SuppressWarnings：抑制编译器警告</li>
</ul>
<h4 id="4-自定义注解"><a href="#4-自定义注解" class="headerlink" title="4.自定义注解"></a>4.自定义注解</h4><ul>
<li>注解声明为@interface</li>
<li>内部定义成员，通常用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没有成员，表明是一个标识作用</li>
<li>如果注解有成员，在使用注解时，需要指明成员的类</li>
<li>自定义注解必须配送注解的信息处理流程（使用反射）才用意义</li>
<li>自定义注解通过都非指明两个元注解：Retention，Target</li>
</ul>
<h4 id="5-基本元注解"><a href="#5-基本元注解" class="headerlink" title="5.基本元注解"></a>5.基本元注解</h4><p>元注解：对现有的注解进行解释说明的注解</p>
<ul>
<li>Rentention：指定所修饰的Annotation的生命周期，只有生命为RUNTIME生命周期的注解才能通过反射获取</li>
<li>Target：用于指定被修饰的Annotation能用于修饰哪些程序元素</li>
<li>Documented：表示所修饰的注解被javadoc解析时，保留下来</li>
<li>Inherited：被它修饰的Annotation将具有继承性</li>
</ul>
<p>通过反射可以获取注解信息</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合，数组都是对多个数据进行存储操作的结构，简称Java容器（这里的存储主要是指内存层面的存储。不涉及到持久化的存储）</p>
<p>Java集合就像一种容器，可以动态地把多个对象的引用放入容器中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945892.png" alt="image-20210424101354876"></p>
<h3 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h3><h4 id="1-数组存储缺点"><a href="#1-数组存储缺点" class="headerlink" title="1.数组存储缺点"></a>1.数组存储缺点</h4><ul>
<li>一旦初始化以后，其长度就不可修改了</li>
<li>数组中提供的方法非常有限，对于添加，删除，插入数据等操作，非常不便，效率不高</li>
<li>获取数据实际元素个数没有现成的属性和方法</li>
<li>数组存储数据特点：有序，可重复。对于无序，不可重复的需求，不能满足</li>
</ul>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>单列数据，定义了存储一组对象的方法集合</p>
<h4 id="1-Collection接口继承树"><a href="#1-Collection接口继承树" class="headerlink" title="1.Collection接口继承树"></a>1.Collection接口继承树</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945760.png" alt="image-20210424101922654"></p>
<h4 id="2-Collection接口常用方法"><a href="#2-Collection接口常用方法" class="headerlink" title="2.Collection接口常用方法"></a>2.Collection接口常用方法</h4><ul>
<li>add(Object e)：将元素e添加到集合coll中</li>
<li>size()：获得添加的元素个数</li>
<li>addAll(Collection coll1)：将coll1集合中的元素添加到当前的集合中</li>
<li>isEmpty()：判断当前集合是否为空</li>
<li>clear()：清空集合元素</li>
<li>contains(Object obj)：判断当前集合是否包含obj </li>
<li>containsAll(Collecion coll1)：判断colls中的所有元素是否都存在于当前集合中</li>
<li>remove(Object obj)：从当前集合中移除obj元素</li>
<li>remove(Collecion coll1)：从当前集合中移除coll1中所有元素（移除差集）</li>
<li>retain(Collecion coll1)：获取当前集合与coll1集合的交集，并返回给当前集合</li>
<li>equals(Object obj)：要想返回true，需要当前集合和形参集合的元素都相同</li>
<li>hasCode()：返回当前对象的哈希值</li>
<li>toArray()：集合—-&gt;数组（数组—&gt;集合：调用Araays类的静态方法asList()）</li>
</ul>
<h4 id="3-集合遍历"><a href="#3-集合遍历" class="headerlink" title="3.集合遍历"></a>3.集合遍历</h4><p>（1）迭代器Iterator接口</p>
<ul>
<li>Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合的元素</li>
<li>迭代器模式：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节（迭代器，为容器而生）</li>
<li>迭代器Iterator内部方法：hasNext()和next()</li>
<li>迭代器执行原理：hasNext()判断是否还有下个元素; next()让指针下移</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都集合在第一个元素之前</li>
<li>remove()可以在遍历时，删除集合中的元素（区别于Collection接口的remove方法，这个要先调用next() ）</li>
</ul>
<p>（2）foreach循环遍历集合元素</p>
<ul>
<li>其内部仍然调用了迭代器</li>
<li>for(集合元素的类型 局部变量:集合对象)</li>
<li>foreach可以遍历数组和集合</li>
</ul>
<h4 id="4-List接口"><a href="#4-List接口" class="headerlink" title="4.List接口"></a>4.List接口</h4><p>存储有序的，可重复的数据（“动态”数组）</p>
<p>（1）List三个实现类ArrayList，LinkedList，Vector的异同</p>
<ul>
<li>同：都实现了List接口，存储数据特点相同：存储有序的，可重复的数据</li>
<li>异：<ol>
<li>ArrayList：底层使用Object[] elementData存储；作为List接口主要实现类，线程不安全，效率高；</li>
<li>LinkList：底层使用双向链表存储；对于频繁的插入，删除操作，使用此类效率比ArrayList高；</li>
<li>Vector：List接口古老实现类;线程安全，效率低；底层使用Object[] elementData存储</li>
</ol>
</li>
</ul>
<p>（2）List常用方法</p>
<ul>
<li>增：add(Object obj)</li>
<li>删：remove(int index)</li>
<li>改：set(int index, Object ele)</li>
<li>查：get(int inedx)</li>
<li>插：add(int index, Object ele)</li>
<li>长度：size()</li>
<li>遍历方法：<ol>
<li>Iterator迭代器方法</li>
<li>增强for循环</li>
<li>普通循环</li>
</ol>
</li>
</ul>
<h4 id="5-Set接口"><a href="#5-Set接口" class="headerlink" title="5.Set接口"></a>5.Set接口</h4><p>存储无序的（set的底层也是数组，但是存储的物理顺序是在申请空间的随机位置），不可重复的数据（数学概念的“集合”）</p>
<p>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法</p>
<p>（1）Set接口的实现类</p>
<ul>
<li>HashSet：作为Set接口的主要实现类，线程不安全，可以存储null值</li>
<li>LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加顺序遍历</li>
<li>TreeSet：可以按照添加对象的指定属性进行排序（底层为红黑树）</li>
</ul>
<p>（2）Set解析</p>
<ul>
<li>无序性：不等同于随机性，存储的数据在底层数组中并发按照数组索引的顺序添加，而是根据数据的哈希值决定的</li>
<li>不可重复性：相同的元素只能添加一个</li>
</ul>
<p>（3）HashSet元素插入过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945099.png" alt="image-20210424182729653"></p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>双列数据，保存具有映射关系“key-value”的集合（ y=f(x) ）</p>
<h4 id="1-Map实现"><a href="#1-Map实现" class="headerlink" title="1.Map实现"></a>1.Map实现</h4><p>有两种实现类：HashMap（主要）和Hashtable（古老）</p>
<ul>
<li>HashMap：Map的主要实现类，线程不安全，效率高，可以存储null的key和value（底层为：数组+链表+红黑树）<ol>
<li>LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历（有一对指向前和指向后节点的指针，对频繁的遍历操作，执行效率高于HashMap）</li>
</ol>
</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历（key自然排序或自定义排序，底层为红黑树 ）</li>
<li>Hashtable：作为古老的实现类，线程安全，效率低，不能存储null的key和value<ol>
<li>Properties：常用于处理配置文件，key 和 value都是String类型</li>
</ol>
</li>
</ul>
<h4 id="2-Map接口继承树"><a href="#2-Map接口继承树" class="headerlink" title="2.Map接口继承树"></a>2.Map接口继承树</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945354.png" alt="image-20210424102038816"></p>
<h4 id="3-Map结构理解"><a href="#3-Map结构理解" class="headerlink" title="3.Map结构理解"></a>3.Map结构理解</h4><ul>
<li>Map中的key：无序的，不可重复的，使用Set存储所有的key ———–&gt;key所在的类要重写equals()和hashCode()</li>
<li>Map中的value:无序的，可重复的，使用Collection存储所有的value————&gt; value所在类要重写equals()</li>
<li>一个键值对：key-value构成一个Entry对象</li>
<li>Map中的entry：无序的，不可重复的，使用Set存储所有的entry</li>
</ul>
<h4 id="4-HashMap底层实现原理"><a href="#4-HashMap底层实现原理" class="headerlink" title="4.HashMap底层实现原理"></a>4.HashMap底层实现原理</h4><p>（1）jdk7</p>
<ul>
<li><code>HashMap map = new HashMap()</code>：实例化后，底层创建了长度为16的一维数组Entry[] table</li>
<li><code>map.put(key1,value1)</code>：首先调用key所在；类的hasCode计算key哈希值，得到在Entry数组的存放位置</li>
<li>如果此位置上的数据为空，则添加成功</li>
<li>如果此位置上的数据不为空，比较key和已存在的数据的哈希值<ol>
<li>如果key的哈希值与已存在的数据哈希值都不相同，则添加成功</li>
<li>如果与其中一个数据哈希值相同，继续比较其value值：如果返回false，则添加成功，如果返回true，则使用替换相同key的value值</li>
</ol>
</li>
</ul>
<p>（2）jdk8</p>
<p>数组+链表+红黑树</p>
<h4 id="5-Map常用方法"><a href="#5-Map常用方法" class="headerlink" title="5.Map常用方法"></a>5.Map常用方法</h4><p>（1）添加，删除，修改操作</p>
<ul>
<li>Object put(Object key, Object value)：将指定的key-value添加到当前map对象中</li>
<li>void putAll(Map m)：将m中所有的key-value放到当前map中</li>
<li>Object remove(Object key)：移除指定key-value对，并返回value</li>
<li>void clear()：清空当前map中所有数据</li>
</ul>
<p>（2）元素查询操作</p>
<ul>
<li>Object get(Object key)：获取指定key对应的value</li>
<li>boolean containsKey(Object key)：是否包含指定key</li>
<li>boolean containsValue(Object Value)：是否包含指定Value</li>
<li>int size()：返回map中key-value个数</li>
<li>boolean isEmpty()：判断当前map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li>
</ul>
<p>（3）元视图操作的方法</p>
<ul>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对构成的Set集合</li>
</ul>
<h4 id="6-TreeMap"><a href="#6-TreeMap" class="headerlink" title="6.TreeMap"></a>6.TreeMap</h4><p>用于需要排列的key-value，可以定制排序</p>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>Collections是一个操作Set，List和Map等集合的工具类</p>
<h4 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a>1.常用方法</h4><p>（1）排序操作（抽象方法）</p>
<ul>
<li>reverse(List)：反转List中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</li>
<li>sort(List, Comparator)：根据指定的Comparator产生的顺序对List集合进行排序</li>
<li>swap(List, int i, int j )：将指定list集合的i和j处元素进行交换</li>
</ul>
<p>（2）查找替换</p>
<ul>
<li>Object max(Collection)：根据自然顺序返回最大元素</li>
<li>Object max(Collection, Comparator)：根据Comparator指定顺序，返回最大元素</li>
<li>Object min(Collection)</li>
<li>Object min(Collection, Comparator)</li>
<li>int frequency(Collection, Object)：返回指定集合元素出现次数</li>
<li>void copy(List dest, List src)：将src中的内容复制到dest中</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值</li>
</ul>
<p>（3）同步控制</p>
<p>Collections类提供多个synchromizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发范围集合时的线程安全问题</p>
<p>将线程不安全的集合类型转换为线程安全的类型</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>（1）数据间的逻辑关系：</p>
<ul>
<li>集合</li>
<li>线性关系（对应Java中的顺序表，链表，栈，队列）</li>
<li>树形结构（对应java中的二叉树）</li>
<li>网状结构（对应java中的图）</li>
</ul>
<h4 id="2-真实结构"><a href="#2-真实结构" class="headerlink" title="2.真实结构"></a>2.真实结构</h4><ul>
<li>顺序表（静态数据结构）：Array，ArrayList</li>
<li>链表（动态数据结构）：LinkedList</li>
</ul>
<h4 id="3-抽象结构"><a href="#3-抽象结构" class="headerlink" title="3.抽象结构"></a>3.抽象结构</h4><ul>
<li>栈</li>
<li>队列</li>
<li>树</li>
<li>图</li>
</ul>
<h2 id="泛型与File"><a href="#泛型与File" class="headerlink" title="泛型与File"></a>泛型与File</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="1-泛型概述"><a href="#1-泛型概述" class="headerlink" title="1.泛型概述"></a>1.泛型概述</h4><p>（1）泛型的出现</p>
<ul>
<li>泛型相当于标签，来确定一个容器实际存放什么类型的对象</li>
<li>把元素的类型设计为一个参数，这个类型参数叫做泛型</li>
</ul>
<p>（2）泛型说明</p>
<ul>
<li>泛型允许在定义类，接口时通过一个标识表示类中某个属性的类型或者某个方法的返回值及参数类型</li>
<li>List<String>表明List只能存放字符串类型对象</String></li>
</ul>
<p>（3）泛型相对Object</p>
<ul>
<li>解决元素储存的安全性问题</li>
<li>解决获取数据元素时，需要类型强制转换的问题</li>
</ul>
<h4 id="2-泛型的使用"><a href="#2-泛型的使用" class="headerlink" title="2.泛型的使用"></a>2.泛型的使用</h4><p>（1）在集合中使用泛型</p>
<ul>
<li>ArrayList <Integer> list =  new ArrayList <Integer>()</Integer></Integer></li>
<li>编译时就会进行类型检查，保证数据安全</li>
<li>避免强转操作</li>
</ul>
<p>（2）泛型使用总结</p>
<ul>
<li><p>在实例化集合类时，可以指明具体的泛型类型</p>
</li>
<li><p>指明完以后，在集合类或接口中函数定义类或接口时，内部结构使用到类的泛型的位置，都指定为实例化时的泛型类型</p>
</li>
<li><p>泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置用包装类代替</p>
</li>
</ul>
<h4 id="3-泛型结构"><a href="#3-泛型结构" class="headerlink" title="3.泛型结构"></a>3.泛型结构</h4><p>（1）泛型类</p>
<ul>
<li>类的内部结构就可以使用类的泛型</li>
<li>如果定义了泛型类，实例化时没有指明类的泛型，默认为Object类型</li>
<li>如果定义的类带泛型，建议在实例化时指明类的泛型</li>
<li>子类在继承泛型的父类时指明了泛型类型，则实例子类对象时，不在需要指明泛型</li>
<li>泛型不同的引用不能互相赋值</li>
<li>静态方法中不能使用类的泛型</li>
<li>子类除了指定后保留父类的泛型，也可以增加自己的泛型</li>
</ul>
<p>（2）泛型方法</p>
<ul>
<li>在该方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系（泛型方法所属的类是不是泛型类都没有关系）</li>
<li>泛型方法在调用时，指明泛型参数的类型</li>
<li>泛型方法，可以声明为静态</li>
</ul>
<p>（3）通配符</p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类属于IO流的内容，可以新建，删除，重命名文件和目录，但是File列不能访问文件本身，访问文件内容需要输入\输出流</p>
<h4 id="1-常用方法-1"><a href="#1-常用方法-1" class="headerlink" title="1.常用方法"></a>1.常用方法</h4><p>（1）获取功能</p>
<p>（2）重命名功能</p>
<p>（3）判断功能</p>
<p>（4）创建，删除方法</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="IO流原理与分类"><a href="#IO流原理与分类" class="headerlink" title="IO流原理与分类"></a>IO流原理与分类</h3><h4 id="1-IO原理"><a href="#1-IO原理" class="headerlink" title="1.IO原理"></a>1.IO原理</h4><ul>
<li>I/O技术用于处理设备之间的数据传输，如读写文件，网络通讯</li>
<li>在 Java中，数据的输入输出以流（stream）的方式进行</li>
<li>java.io包下提供各种“流”类和接口，以获得不同种类的数据，并通过标准的方法输入或输出数据</li>
</ul>
<h4 id="2-流的分类"><a href="#2-流的分类" class="headerlink" title="2.流的分类"></a>2.流的分类</h4><ul>
<li><p>操作数据单位分类：字节流（InputStream/OutputStream），字符流（Reader/Writer）</p>
</li>
<li><p>流向分类：输入流，输出流</p>
</li>
<li><p>流的角色分类：节点流，处理流（应用上为缓冲流）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945866.png" alt="image-20210505075809772"></p>
</li>
</ul>
<h3 id="文件流操作"><a href="#文件流操作" class="headerlink" title="文件流操作"></a>文件流操作</h3><h4 id="1-读取文件"><a href="#1-读取文件" class="headerlink" title="1.读取文件"></a>1.读取文件</h4><p>从硬盘文件读入数据到内存</p>
<ul>
<li><p>实例化File类对象，指明操作文件</p>
</li>
<li><p>提供具体流</p>
</li>
<li><p>数据的读入方法与结束判断</p>
<p>​    1. read()：返回读入的一个字符，如果达到文件末尾，返回-1）</p>
<p>​    2. read(char[] cbuf )：read()方法的重载，返回每次读入cbuf数组的字符个数，如果达到文件末尾返回-1</p>
</li>
<li><p>流的关闭（往往要通过异常处理保证流资源一定可以执行关闭操作）</p>
</li>
<li><p>读入的文件一定要存在，否则会报出异常</p>
</li>
</ul>
<h4 id="2-写出文件"><a href="#2-写出文件" class="headerlink" title="2.写出文件"></a>2.写出文件</h4><p>从内存中写出数据到硬盘文件</p>
<ul>
<li>提供File类对象，指明写出到的文件<ol>
<li>如果File对应文件不存在，则自动创建此文件</li>
<li>如果File对应文件存在，则有覆盖和追加两种形式的操作</li>
</ol>
</li>
<li>提供FileWriter的对象，用于数据写出<ol>
<li>流的构造器为：FileWriter(file,false) / FileWriter(file)，则对原有文件进行覆盖</li>
<li>流的构造器为：FileWriter(file, ture),则在源文件上追加内容</li>
</ol>
</li>
<li>写出操作</li>
<li>流资源关闭</li>
</ul>
<h4 id="3-字符流与字节流"><a href="#3-字符流与字节流" class="headerlink" title="3.字符流与字节流"></a>3.字符流与字节流</h4><ul>
<li>操作数据单位分类：字节流（InputStream/OutputStream），字符流（Reader/Writer）</li>
<li>字符流不能处理非文本文件，对于文本文件使用字符流处理</li>
<li>字节流不能处理文本文件，对于非文本文件使用字节流处理</li>
</ul>
<h4 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h4><ul>
<li>缓冲流比于节点流，提供了流的读取，写入的速度</li>
<li>使用缓冲流要比使用节点流，多一步造缓冲流的操作（在节点的基础上制造缓冲流）</li>
<li>资源关闭上，先关闭外层的流，再关闭内层的流（关闭外层流的同时，内层流可以自动关闭，内层流的关闭程序可以省略）</li>
<li>缓冲流可以提高文件读入写出速度，因为内部提供了一个缓冲区</li>
</ul>
<h4 id="5-随机存取文件流"><a href="#5-随机存取文件流" class="headerlink" title="5.随机存取文件流"></a>5.随机存取文件流</h4><ul>
<li>RandomAceessFile类实现了DataInput、DataOutput两个接口，该类既可以读也可以写</li>
<li>RandomAceessFile类支持随机访问的形式，程序可以直接跳到文件任意地方来读写文件</li>
<li>RandomAceessFile对象包含一个记录指针，用于标识当前读写位置</li>
</ul>
<h4 id="6-NIO2中文件读写"><a href="#6-NIO2中文件读写" class="headerlink" title="6.NIO2中文件读写"></a>6.NIO2中文件读写</h4><ul>
<li>NIO2是对Java原有IO流的升级，可以以更加高效的方式进行文件读写操作</li>
<li>Java API提供了两套NIO，一套是针对标准输入输出的NIO，另一套是网络编程NIO</li>
<li>File类访问文件功能比较有限，后来又引入类Path接口对File类进行了升级</li>
<li>在NIO.2中还提供了Files、Paths工具类</li>
</ul>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="1-转换流概述"><a href="#1-转换流概述" class="headerlink" title="1.转换流概述"></a>1.转换流概述</h4><ul>
<li>转换流为处理流的一种，提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ol>
<li>InputStreamReader：将InputStream转换为Reader</li>
<li>OutputStreamWriter：将Writer转换为OutputStream</li>
</ol>
</li>
<li>字节流中的数据都是字符时，转换成字符流操作更高效</li>
<li>转换流常用来处理文件乱码问题，实现编码和解码的功能</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945369.png" alt="image-20210505100444727"></p>
<h4 id="2-转换流的使用"><a href="#2-转换流的使用" class="headerlink" title="2.转换流的使用"></a>2.转换流的使用</h4><ul>
<li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li>
<li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li>
<li>提供了在字节流和字符流之间的转换，用于解码、编码</li>
</ul>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><h4 id="1-对象流概述"><a href="#1-对象流概述" class="headerlink" title="1.对象流概述"></a>1.对象流概述</h4><ul>
<li><p>ObjectinputStream和ObjectOutputSteam</p>
</li>
<li><p>用于存储和读取基本数据类型数据或对象的处理流，可以把Java的对象写入数据源中，也能把对象从数据源中还原回来</p>
</li>
<li><p>序列化：ObjectinputStream保存基本数据类型或对象的机制</p>
</li>
<li><p>反序列化：ObjectOutputSteam读取基本数据类型或对象的机制</p>
</li>
<li><p>ObjectinputStream和ObjectOutputSteam不能序列化static和transient修饰的成员变量</p>
</li>
</ul>
<h4 id="2-对象的序列化"><a href="#2-对象的序列化" class="headerlink" title="2.对象的序列化"></a>2.对象的序列化</h4><ul>
<li>对象序列化机制把内存中的Java对象转换成平台无关的二进制流，从而允许把二进制流保存在磁盘上或通过网络传输</li>
<li>程序获取二进制流，可以反序列化恢复为Java对象</li>
<li>序列化的好处在于可以将任何实现了Serializable接口的对象转换为字节数据，保证其保存和传输时可被还原</li>
</ul>
<h3 id="其他基本流"><a href="#其他基本流" class="headerlink" title="其他基本流"></a>其他基本流</h3><h4 id="1-标准输入输出流"><a href="#1-标准输入输出流" class="headerlink" title="1.标准输入输出流"></a>1.标准输入输出流</h4><ul>
<li>System.in：标准的输入流，默认从键盘输入</li>
<li>System.out：标准的输出流，默认从控制台输出</li>
<li>可以通过setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输出和输入的默认设备</li>
</ul>
<h4 id="2-打印流"><a href="#2-打印流" class="headerlink" title="2.打印流"></a>2.打印流</h4><ul>
<li>实现将基本数据类型转化成字符串输出</li>
<li>打印流PrintStream和PrintWriter</li>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型输出</li>
</ul>
<h4 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3.数据流"></a>3.数据流</h4><ul>
<li><p>方便操作（读取和写出）Java语言的基本类型和 String的数据</p>
</li>
<li><p>DataInputStream 和 DataOutputStream分别套接在InputStream和OutputStream子类的流上</p>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><h4 id="1-网络编程定义"><a href="#1-网络编程定义" class="headerlink" title="1.网络编程定义"></a>1.网络编程定义</h4><ul>
<li>网络编程的目的：直接或间接通过网络协议与其他计算机实现数据交换，进行通讯</li>
<li>定位主机上特定的应用（IP和端口号）</li>
<li>可靠高效数据运输（通过网络通信协议TCP/IP）</li>
</ul>
<h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><h3 id="URL网络编程"><a href="#URL网络编程" class="headerlink" title="URL网络编程"></a>URL网络编程</h3><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="反射机制概述"><a href="#反射机制概述" class="headerlink" title="反射机制概述"></a>反射机制概述</h3><h4 id="1-反射的含义"><a href="#1-反射的含义" class="headerlink" title="1.反射的含义"></a>1.反射的含义</h4><p>（1）含义</p>
<ul>
<li>反射是动态语言的关键，反射机制允许程序在执行期间借助Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</li>
<li>加载完类后，堆内存的方法区中就会产生一个Class类型的对象，通过该对象我们可以看到类的结构信息，则就是反射机制的本质</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945603.png" alt="image-20210505220053207"></p>
<p>（2）动态语言与静态语言</p>
<ul>
<li>动态语言在运行时可以根据条件改变自身结构（PHP，Python）</li>
<li>静态语言运行时结构不可变（Java，C, C++）</li>
<li>Java是准动态语言，我们可以利用反射机制，字节码操作获得类似动态语言的特性，让编程更加灵活</li>
</ul>
<h4 id="2-反射功能"><a href="#2-反射功能" class="headerlink" title="2.反射功能"></a>2.反射功能</h4><p>通过反射可以调用类的私有结构，反射常常用于对象不确定的情况下（反射的动态性）</p>
<ul>
<li>运行时判断任意对象所属类</li>
<li>运行时构造任意一个类的对象</li>
<li>运行时判断一个类所具有的成员变量和方法</li>
<li>运行时获取泛型信息</li>
<li>运行时任意调用对象的成员变量和方法</li>
<li>运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<h4 id="3-反射主要API"><a href="#3-反射主要API" class="headerlink" title="3.反射主要API"></a>3.反射主要API</h4><ul>
<li>java.lang.Class：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
</ul>
<h3 id="Class类的理解"><a href="#Class类的理解" class="headerlink" title="Class类的理解"></a>Class类的理解</h3><h4 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1.类的加载过程"></a>1.类的加载过程</h4><ul>
<li>程序经过javac.exe命令后，会生成一个或多个字节码文件（.class结尾）接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就被称为类的加载</li>
<li>加载到内存中的类，我们称为运行时类，此运行时类就作为Class的一个实例（类是Class的对象）</li>
<li>Class的实例对应着一个运行时类</li>
</ul>
<h4 id="2-获得Class实例的方法"><a href="#2-获得Class实例的方法" class="headerlink" title="2.获得Class实例的方法"></a>2.获得Class实例的方法</h4><ul>
<li><p>调用运行类时的属性：.class</p>
</li>
<li><p>通过运行时类的对象，调用getClass</p>
</li>
<li><p>调用Class静态方法：forName(String classPath)（常用）</p>
</li>
<li><p>使用类的加载器：ClassLoader</p>
</li>
</ul>
<h4 id="3-Class实例对应结构"><a href="#3-Class实例对应结构" class="headerlink" title="3.Class实例对应结构"></a>3.Class实例对应结构</h4><p>有哪些类型有Class对象</p>
<ul>
<li>class：外部类，成员，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h3 id="类的加载的理解"><a href="#类的加载的理解" class="headerlink" title="类的加载的理解"></a>类的加载的理解</h3><h4 id="1-类的加载过程-1"><a href="#1-类的加载过程-1" class="headerlink" title="1.类的加载过程"></a>1.类的加载过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945557.png" alt="image-20210506074346998"></p>
<h4 id="2-ClassLoader的理解"><a href="#2-ClassLoader的理解" class="headerlink" title="2.ClassLoader的理解"></a>2.ClassLoader的理解</h4><p>（1）类的加载器流程位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945002.png" alt="image-20210506074558379"></p>
<p>（2）类的加载器的作用</p>
<ul>
<li>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口</li>
<li>类缓存：一旦某个类被加载到类加载器中，它会维持（缓存）一段时间，不够JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<p>（3）Java定义的类的加载器类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945770.png" alt="image-20210506075638645"></p>
<p>（4）ClassLoader加载配置文件</p>
<p>​    读取配置文件的方法：</p>
<ul>
<li>使用properties集合+IO流读取</li>
<li>使用ClassLoader读取</li>
</ul>
<h3 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h3><p>平常我们一般使用类的构造器（new）创建类的对象，我们也可以通过反射创建对应的运行时类的对象</p>
<h4 id="1-创建流程"><a href="#1-创建流程" class="headerlink" title="1.创建流程"></a>1.创建流程</h4><ul>
<li>调用newInstance()方法，创建对应的运行时类的对象</li>
<li>内部调用了运行时类的空参构造器</li>
</ul>
<h4 id="2-创建要求"><a href="#2-创建要求" class="headerlink" title="2.创建要求"></a>2.创建要求</h4><ul>
<li>运行时类必须提供空参的构造器</li>
<li>空参过的构造器的访问权限通常设置为public</li>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行类时，默认调用super()时，保证父类有此构造器</li>
</ul>
<h3 id="获得运行时类的结构"><a href="#获得运行时类的结构" class="headerlink" title="获得运行时类的结构"></a>获得运行时类的结构</h3><h4 id="1-获得属性结构"><a href="#1-获得属性结构" class="headerlink" title="1.获得属性结构"></a>1.获得属性结构</h4><ul>
<li>getFields()：获取当前运行时类及其父类中声明public访问权限的属性</li>
<li>getDeclaredFields()：获取当前运行时类中声明的所有属性（不包含父类中声明的属性）</li>
</ul>
<h4 id="2-获取方法结构"><a href="#2-获取方法结构" class="headerlink" title="2.获取方法结构"></a>2.获取方法结构</h4><ul>
<li>getMethods()：获取当前运行时类及其所有父类中声明为public权限的方法</li>
<li>getDeclaredMethods()：获取当前运行时类中声明的所有方法（不包含父类中声明的方法）</li>
</ul>
<h4 id="3-获取方法的内部结构"><a href="#3-获取方法的内部结构" class="headerlink" title="3.获取方法的内部结构"></a>3.获取方法的内部结构</h4><ul>
<li>获取方法声明的注解</li>
<li>权限修饰符</li>
<li>返回值类型</li>
<li>方法名</li>
<li>形参列表</li>
</ul>
<h4 id="4-获取构造器结构"><a href="#4-获取构造器结构" class="headerlink" title="4.获取构造器结构"></a>4.获取构造器结构</h4><ul>
<li>getConstructors()：获取当前运行时类中声明为public的构造器</li>
<li>getDeclaredConstructors()：获取当前运行时类中声明的所有构造器</li>
</ul>
<h4 id="5-其他获取内容"><a href="#5-其他获取内容" class="headerlink" title="5.其他获取内容"></a>5.其他获取内容</h4><ul>
<li>获得运行时类的父类及父类泛型</li>
<li>获得运行类的实现的接口，所在包，注解</li>
</ul>
<h3 id="调用运行时类的结构"><a href="#调用运行时类的结构" class="headerlink" title="调用运行时类的结构"></a>调用运行时类的结构</h3><h4 id="1-调用指定属性"><a href="#1-调用指定属性" class="headerlink" title="1.调用指定属性"></a>1.调用指定属性</h4><ul>
<li>创建运行时类的对象</li>
<li>获得指定的属性（通常用getDeclaredFields()，因为可以获得私有属性）</li>
<li>保证当前属性是可访问的（setAccessible方法）</li>
<li>设置当前属性的值（set方法）</li>
<li>获取当前属性的值（get方法）</li>
<li>获取当前属性的值</li>
</ul>
<h4 id="2-调用指定方法"><a href="#2-调用指定方法" class="headerlink" title="2.调用指定方法"></a>2.调用指定方法</h4><ul>
<li>创建运行时类的对象</li>
<li>获取指定的某个方法</li>
<li>保证当前方法是可访问的（setAccessible方法）</li>
<li>调用invoke方法执行</li>
</ul>
<h4 id="3-调用指定构造器"><a href="#3-调用指定构造器" class="headerlink" title="3.调用指定构造器"></a>3.调用指定构造器</h4><ul>
<li>获得指定构造器</li>
<li>保证此构造器可访问</li>
<li>调用此构造器创建运行时类的对象</li>
</ul>
<h3 id="反射应用：动态代理"><a href="#反射应用：动态代理" class="headerlink" title="反射应用：动态代理"></a>反射应用：动态代理</h3><h4 id="1-代理设计模式原理"><a href="#1-代理设计模式原理" class="headerlink" title="1.代理设计模式原理"></a>1.代理设计模式原理</h4><ul>
<li><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象，任何对原始对象的调用都要通过代理</p>
</li>
<li><p>最好可以通过一个代理类完成全部的代理功能</p>
</li>
</ul>
<h4 id="2-动态代理概述"><a href="#2-动态代理概述" class="headerlink" title="2.动态代理概述"></a>2.动态代理概述</h4><ul>
<li><p>动态代理是指用户通过代理类来调用其他对象的方法，并且是在程序运行时更加动态创建 目标类的代理对象</p>
</li>
<li><p>动态代理使用场合：</p>
<ol>
<li>调试</li>
<li>远程方法调用</li>
</ol>
</li>
<li><p>动态代理相比静态代理的优点：抽象角色中接口声明的所有方法都被转移到调用处理器一个集中的方法中处理（可以更加灵活和统一的处理众多的方法）</p>
</li>
</ul>
<h4 id="3-动态代理与AOP"><a href="#3-动态代理与AOP" class="headerlink" title="3.动态代理与AOP"></a>3.动态代理与AOP</h4><p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945546.png" alt="image-20210506141800436"></p>
<h2 id="Java8的其他特性"><a href="#Java8的其他特性" class="headerlink" title="Java8的其他特性"></a>Java8的其他特性</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式是一个 ，可以将其理解为一段可以传递的代码，其本质是作为函数式接口的实例</p>
<h4 id="1-Lambda表达式的使用"><a href="#1-Lambda表达式的使用" class="headerlink" title="1.Lambda表达式的使用"></a>1.Lambda表达式的使用</h4><ul>
<li>-&gt; :lambda操作符或箭头操作符</li>
<li>-&gt; 左边：lambda形参列表（即接口中的抽象方法的形参列表）</li>
<li>-&gt; 右边：lambda体（即重写抽象方法的方法体）</li>
<li>如果lamba形参列表只有一个参数，其一对()也可以省略</li>
<li>lambda体应该使用一对{}包裹，如果lambda只有一条执行语句，可以省略{}和return</li>
</ul>
<h4 id="2-lambda使用分类"><a href="#2-lambda使用分类" class="headerlink" title="2.lambda使用分类"></a>2.lambda使用分类</h4><ul>
<li>无参，无返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = ()-&gt; &#123;System.out.println(<span class="string">&quot;Hello,Lambda&quot;</span>);&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要一个参数，无返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (String str)-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据类型可以省略，可由编译器推断得出（类型推断）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (str)-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>只需要一个参数时，参数的小括号可以省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = str-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要两个或两个以上的参数，多条执行语句，并且可以有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;实现函数式接口方法&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当Lambda只有一条语句时，return与大括号可以省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;Integer.compare(x,y);</span><br></pre></td></tr></table></figure>



<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h4 id="1-函数式接口含义"><a href="#1-函数式接口含义" class="headerlink" title="1.函数式接口含义"></a>1.函数式接口含义</h4><ul>
<li><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口</p>
</li>
<li><p>我们可以通过Lambda表达式创建该接口的对象</p>
</li>
<li><p>使用@Functionallnterface注解，可以检测是否为函数式接口</p>
</li>
</ul>
<h4 id="2-Java内置函数式接口"><a href="#2-Java内置函数式接口" class="headerlink" title="2.Java内置函数式接口"></a>2.Java内置函数式接口</h4><ul>
<li><p>Consumer<T>：消费型接口</T></p>
</li>
<li><p>Supplier<T>：供给型接口</T></p>
</li>
<li><p>Function&lt;T,R&gt;：函数型接口</p>
</li>
<li><p>Predicate<T>：断定型接口</T></p>
<p><img src="https://cdn.jsdelivr.net/gh/Autovy/Image/img/202109040945212.png" alt="image-20210506192031648"></p>
</li>
</ul>
<h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h3><h4 id="1-方法引用介绍"><a href="#1-方法引用介绍" class="headerlink" title="1.方法引用介绍"></a>1.方法引用介绍</h4><ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li>
<li>方法引用就是Lambada表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法</li>
<li>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</li>
<li>有以下三种主要使用情况<ol>
<li>对象::实例方法名</li>
<li>类::静态方法名</li>
<li>类::实例方法名</li>
</ol>
</li>
</ul>
<h4 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2.构造器引用"></a>2.构造器引用</h4><ul>
<li>与方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致</li>
<li>抽象方法的返回值类型即构造器所属的类的类型</li>
</ul>
<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><h4 id="1-Stream概述"><a href="#1-Stream概述" class="headerlink" title="1.Stream概述"></a>1.Stream概述</h4><ul>
<li>Stream是Java中处理集合的关键抽象概念，它可以对集合进行复杂的查找，过滤，映射数据等操作（类似于SQL之于数据库）</li>
<li>NoSQL的数据（MongDB,Radis等）需要在Java层面处理，所有需要Stream API</li>
<li>Stream 与 Collection集合的区别：Collection是一种静态的内存数据结构，其面向内存用于数据存储;Stream有关计算，其面向CPU通过CPU实现计算</li>
</ul>
<h4 id="2-Stream须知事项"><a href="#2-Stream须知事项" class="headerlink" title="2.Stream须知事项"></a>2.Stream须知事项</h4><ul>
<li>Stream自己不会存储元素</li>
<li>Stream不会改变源对象，相反，它们会返回一个持有结果的新Stream</li>
<li>Stream操作时延迟执行的，他们会等到需要结果时才执行</li>
</ul>
<h4 id="3-Stream操作过程"><a href="#3-Stream操作过程" class="headerlink" title="3.Stream操作过程"></a>3.Stream操作过程</h4><ul>
<li><p>创建Stream：一个数据源（如：集合，数组）获取一个流</p>
</li>
<li><p>中间操作：一个中间操作链，对数据源的数据进行处理</p>
</li>
<li><p>终止操作：一旦执行终止操作，就执行中间操作链，并产生结果，后面不会再被使用</p>
</li>
</ul>
<h4 id="4-Stream实例化"><a href="#4-Stream实例化" class="headerlink" title="4.Stream实例化"></a>4.Stream实例化</h4><p>（1）创建Stream</p>
<ul>
<li>通过集合创建</li>
<li>通过数组创建</li>
<li>通过Stream的of()创建</li>
<li>创建无限流</li>
</ul>
<p>（2）中间操作</p>
<ul>
<li>筛选与切片</li>
<li>映射</li>
<li>排序</li>
</ul>
<p>（3）Stream的终止操作</p>
<ul>
<li>匹配与查找</li>
<li>归约</li>
<li>收集</li>
</ul>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><h4 id="1-Optional类概述"><a href="#1-Optional类概述" class="headerlink" title="1.Optional类概述"></a>1.Optional类概述</h4><ul>
<li><p>Optional<T>类是一个容器类，可以保存类型T的值，代表这个值存在（或者仅仅保存null，表示这个值不存在）</T></p>
</li>
<li><p>Optional可以更好表达这个概念，并且可以避免空指针异常</p>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Autovy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://autovy.github.io/2021/04/11/Java-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/" title="Java|知识框架">https://autovy.github.io/2021/04/11/Java-知识框架/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 入门教程</a>
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 后端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/28/PHP-thinkphp5/" rel="prev" title="PHP|Thinkphp学习">
      <i class="fa fa-chevron-left"></i> PHP|Thinkphp学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/26/Java-%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB/" rel="next" title="Java|网络爬虫项目">
      Java|网络爬虫项目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>



  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-text">计算机硬件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-CPU"><span class="nav-text">1.CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E8%A7%84%E5%BE%8B"><span class="nav-text">2.计算机发展规律</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">3.存储设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98"><span class="nav-text">4.内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E9%80%9A%E4%BF%A1%E8%AE%BE%E5%A4%87"><span class="nav-text">5.通信设备</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%87%E7%BB%B4%E7%BD%91"><span class="nav-text">万维网</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-text">Java语言概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">Java语言应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-JavaEE%EF%BC%88spring%EF%BC%89"><span class="nav-text">1.JavaEE（spring）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%88spark%EF%BC%89"><span class="nav-text">2.大数据（spark）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91"><span class="nav-text">3.安卓开发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D"><span class="nav-text">Java开发介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.软件开发介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B9%B3%E5%8F%B0"><span class="nav-text">2.Java技术体系平台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-text">3.Java语言特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java%E4%B8%A4%E7%A7%8D%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-text">4.Java两种核心机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Java%E7%8E%AF%E5%A2%83"><span class="nav-text">5.Java环境</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">Java基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="nav-text">关键字与保留字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">1.关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BF%9D%E7%95%99%E5%AD%97"><span class="nav-text">2.保留字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.整型类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.浮点数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">4.基本数据类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.引用数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="nav-text">6.变量赋值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">1.算术运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2.赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3.比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">4.逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">5.位运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">6.三元运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">程序流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">1.顺序结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-text">2.分支结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">3.循环结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Scanner%E8%BE%93%E5%85%A5"><span class="nav-text">4.Scanner输入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="nav-text">1.数组概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.一维数组的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3.多维数据的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95"><span class="nav-text">4.数组算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">5.数组工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-text">6.数组常见异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">Java面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7"><span class="nav-text">封装性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.面向过程与面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.类与对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-text">3.类与方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6"><span class="nav-text">4.方法进阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="nav-text">5.封装与隐藏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">6.构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-JavaBean"><span class="nav-text">7.JavaBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-this"><span class="nav-text">8.this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-package%E4%B8%8Eimport%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">9.package与import的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="nav-text">继承性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BB%A7%E6%89%BF%E6%80%A7%E6%A6%82%E5%BF%B5"><span class="nav-text">1.继承性概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-text">2.方法的重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-spuer"><span class="nav-text">3.spuer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-text">4.子类对象实例化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-text">5.多态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-text">6.向下转型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">Object类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-toString-%E6%96%B9%E6%B3%95"><span class="nav-text">2.toString()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">包装类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8C%85%E8%A3%85%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.包装类介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.数据类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Static"><span class="nav-text">Static</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">1.使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7"><span class="nav-text">2.修饰属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-text">3.修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%9D%99%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">4.静态的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A6%82%E5%BF%B5"><span class="nav-text">1.代码块概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">2.静态代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">3.非静态代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E6%80%BB%E7%BB%93"><span class="nav-text">2.属性赋值总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-final%E6%A6%82%E5%BF%B5"><span class="nav-text">1.final概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-final%E4%BF%AE%E9%A5%B0"><span class="nav-text">2.final修饰</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">抽象类与抽象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-abstract%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">1.abstract的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="nav-text">2.抽象类特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%89%B9%E7%82%B9"><span class="nav-text">3.抽象方法特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BA%94%E7%94%A8"><span class="nav-text">4.抽象类应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">1.接口概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.接口的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">3.接口的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8"><span class="nav-text">4.接口应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">1.成员内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">异常体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="nav-text">1.异常分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-text">2.解决方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">3.异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">多线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1.基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.多线程的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">3.线程的创建与使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">4.线程常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE"><span class="nav-text">5.线程优先级设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="nav-text">6.创建多线程方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.线程的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">2.线程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-text">3.线程死锁问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Lock-%E9%94%81"><span class="nav-text">4.Lock(锁)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">5.线程通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-text">Java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-text">String类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-String%E6%A6%82%E8%BF%B0"><span class="nav-text">1.String概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-String%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.String实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E4%BD%93%E7%8E%B0"><span class="nav-text">3.不可变性体现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-String%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">4.String实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">5.String常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">6.String数据类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-String%EF%BC%8CStringBuffer%EF%BC%8CStringBuilder"><span class="nav-text">7.String，StringBuffer，StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-text">Java比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Comparable%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.Comparable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Comparator%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.Comparator接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-text">其他常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="nav-text">1.时间类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-System%E7%B1%BB"><span class="nav-text">2.System类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Math%E7%B1%BB"><span class="nav-text">3.Math类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-BigInteger%E5%92%8CBigDecimal"><span class="nav-text">4.BigInteger和BigDecimal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="nav-text">枚举类与注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-text">枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">1.枚举类的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.枚举类的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Enum%E7%B1%BB%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">3.Enum类中常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.枚举类实现接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E"><span class="nav-text">1.注解说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B3%A8%E8%A7%A3%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.注解示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-JDK%E5%86%85%E7%BD%AE%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="nav-text">3.JDK内置基本注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.自定义注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%9F%BA%E6%9C%AC%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">5.基本元注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B"><span class="nav-text">数组简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%BC%BA%E7%82%B9"><span class="nav-text">1.数组存储缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-text">1.Collection接口继承树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Collection%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">2.Collection接口常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86"><span class="nav-text">3.集合遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-List%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.List接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Set%E6%8E%A5%E5%8F%A3"><span class="nav-text">5.Set接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Map%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.Map实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-text">2.Map接口继承树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Map%E7%BB%93%E6%9E%84%E7%90%86%E8%A7%A3"><span class="nav-text">3.Map结构理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">4.HashMap底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">5.Map常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-TreeMap"><span class="nav-text">6.TreeMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">Collections工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">1.常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%9C%9F%E5%AE%9E%E7%BB%93%E6%9E%84"><span class="nav-text">2.真实结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-text">3.抽象结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8EFile"><span class="nav-text">泛型与File</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="nav-text">1.泛型概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.泛型的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="nav-text">3.泛型结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-text">1.常用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-text">IO流原理与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-IO%E5%8E%9F%E7%90%86"><span class="nav-text">1.IO原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">2.流的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="nav-text">文件流操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-text">1.读取文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%86%99%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-text">2.写出文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%8E%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-text">3.字符流与字节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-text">4.缓冲流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-text">5.随机存取文件流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-NIO2%E4%B8%AD%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="nav-text">6.NIO2中文件读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-text">转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BD%AC%E6%8D%A2%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-text">1.转换流概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.转换流的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-text">对象流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AF%B9%E8%B1%A1%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-text">1.对象流概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">2.对象的序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E6%B5%81"><span class="nav-text">其他基本流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-text">1.标准输入输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-text">2.打印流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-text">3.数据流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9"><span class="nav-text">基础内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">1.网络编程定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">TCP网络编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">UDP网络编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">URL网络编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-text">反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">反射机制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">1.反射的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD"><span class="nav-text">2.反射功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8F%8D%E5%B0%84%E4%B8%BB%E8%A6%81API"><span class="nav-text">3.反射主要API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">Class类的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">1.类的加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%8E%B7%E5%BE%97Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">2.获得Class实例的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Class%E5%AE%9E%E4%BE%8B%E5%AF%B9%E5%BA%94%E7%BB%93%E6%9E%84"><span class="nav-text">3.Class实例对应结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">类的加载的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-1"><span class="nav-text">1.类的加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">2.ClassLoader的理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建运行时类的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="nav-text">1.创建流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E8%A6%81%E6%B1%82"><span class="nav-text">2.创建要求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">获得运行时类的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%8E%B7%E5%BE%97%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-text">1.获得属性结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-text">2.获取方法结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.获取方法的内部结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-text">4.获取构造器结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%85%B6%E4%BB%96%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9"><span class="nav-text">5.其他获取内容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">调用运行时类的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7"><span class="nav-text">1.调用指定属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="nav-text">2.调用指定方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">3.调用指定构造器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">反射应用：动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-text">1.代理设计模式原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-text">2.动态代理概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP"><span class="nav-text">3.动态代理与AOP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-text">Java8的其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">1.Lambda表达式的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-lambda%E4%BD%BF%E7%94%A8%E5%88%86%E7%B1%BB"><span class="nav-text">2.lambda使用分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%90%AB%E4%B9%89"><span class="nav-text">1.函数式接口含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Java%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.Java内置函数式接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.方法引用介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-text">2.构造器引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-API"><span class="nav-text">Stream API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Stream%E6%A6%82%E8%BF%B0"><span class="nav-text">1.Stream概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Stream%E9%A1%BB%E7%9F%A5%E4%BA%8B%E9%A1%B9"><span class="nav-text">2.Stream须知事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Stream%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-text">3.Stream操作过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Stream%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">4.Stream实例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional%E7%B1%BB"><span class="nav-text">Optional类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Optional%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="nav-text">1.Optional类概述</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a href="/">  <img class="site-author-image" itemprop="image" alt="Autovy"
      src="/images/2.png">  </a>
  <p class="site-author-name" itemprop="name">Autovy</p>
  <div class="site-description" itemprop="description">某编外人员的个人小站，新时代农民工的数字农田</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Autovy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Autovy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/JohnSmith232" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;JohnSmith232" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Autovy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">268k</span>
</div>

<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>
        







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RVJRabsBhxWXvhMcG8CH5wbc-gzGzoHsz',
      appKey     : 'JSGLk7guOagDPMFN9wbASkEh',
      placeholder: "说点什么吧",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
  <script src="/js/bloom.js" type="text/javascript"></script>